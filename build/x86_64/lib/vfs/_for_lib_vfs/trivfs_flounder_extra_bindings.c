/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: trivfs
 * INTEFACE FILE: ../if/trivfs.if
 * INTERFACE DESCRIPTION: Trivial file system interface
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

/*
 * Generated Stub for RPC
 */

#include <barrelfish/barrelfish.h>
#include <flounder/flounder_support.h>
#include <if/trivfs_rpcclient_defs.h>

/*
 * RPC wrapper functions
 */
static  errval_t trivfs_bulk_init__rpc(struct trivfs_rpc_client *_rpc, struct capref frame, trivfs_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).bulk_init_call)(_rpc->b, NOP_CONT, frame));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct trivfs_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).bulk_init_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t trivfs_getroot__rpc(struct trivfs_rpc_client *_rpc, trivfs_fh_t *rootfh)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).getroot_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct trivfs_binding *_binding = _rpc->b;
    *rootfh = (((_binding->rx_union).getroot_response).rootfh);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t trivfs_readdir__rpc(struct trivfs_rpc_client *_rpc, trivfs_fh_t dir, uint32_t idx, trivfs_errval_t *err, char **name, bool *isdir, trivfs_fsize_t *size)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).readdir_call)(_rpc->b, NOP_CONT, dir, idx));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct trivfs_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).readdir_response).err);
    *name = (((_binding->rx_union).readdir_response).name);
    *isdir = (((_binding->rx_union).readdir_response).isdir);
    *size = (((_binding->rx_union).readdir_response).size);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t trivfs_lookup__rpc(struct trivfs_rpc_client *_rpc, trivfs_fh_t dir, const char *name, trivfs_errval_t *err, trivfs_fh_t *fh, bool *isdir)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).lookup_call)(_rpc->b, NOP_CONT, dir, name));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct trivfs_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).lookup_response).err);
    *fh = (((_binding->rx_union).lookup_response).fh);
    *isdir = (((_binding->rx_union).lookup_response).isdir);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t trivfs_getattr__rpc(struct trivfs_rpc_client *_rpc, trivfs_fh_t fh, trivfs_errval_t *err, bool *isdir, trivfs_fsize_t *size)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).getattr_call)(_rpc->b, NOP_CONT, fh));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct trivfs_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).getattr_response).err);
    *isdir = (((_binding->rx_union).getattr_response).isdir);
    *size = (((_binding->rx_union).getattr_response).size);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t trivfs_read__rpc(struct trivfs_rpc_client *_rpc, trivfs_fh_t file, trivfs_offset_t offset, trivfs_fsize_t maxlen, trivfs_errval_t *err, uint8_t **data, size_t *retlen)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).read_call)(_rpc->b, NOP_CONT, file, offset, maxlen));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct trivfs_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).read_response).err);
    *data = (((_binding->rx_union).read_response).data);
    *retlen = (((_binding->rx_union).read_response).retlen);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t trivfs_write__rpc(struct trivfs_rpc_client *_rpc, trivfs_fh_t file, trivfs_offset_t offset, const uint8_t *data, size_t len, trivfs_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).write_call)(_rpc->b, NOP_CONT, file, offset, data, len));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct trivfs_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).write_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t trivfs_read_bulk__rpc(struct trivfs_rpc_client *_rpc, trivfs_fh_t file, trivfs_offset_t offset, trivfs_fsize_t maxlen, trivfs_bulkid_t bulkid, trivfs_errval_t *err, trivfs_fsize_t *retlen)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).read_bulk_call)(_rpc->b, NOP_CONT, file, offset, maxlen, bulkid));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct trivfs_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).read_bulk_response).err);
    *retlen = (((_binding->rx_union).read_bulk_response).retlen);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t trivfs_write_bulk__rpc(struct trivfs_rpc_client *_rpc, trivfs_fh_t file, trivfs_offset_t offset, trivfs_fsize_t len, trivfs_bulkid_t bulkid, trivfs_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).write_bulk_call)(_rpc->b, NOP_CONT, file, offset, len, bulkid));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct trivfs_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).write_bulk_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t trivfs_truncate__rpc(struct trivfs_rpc_client *_rpc, trivfs_fh_t file, trivfs_fsize_t newsize, trivfs_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).truncate_call)(_rpc->b, NOP_CONT, file, newsize));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct trivfs_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).truncate_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t trivfs_create__rpc(struct trivfs_rpc_client *_rpc, trivfs_fh_t dir, const char *name, trivfs_errval_t *err, trivfs_fh_t *fh)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).create_call)(_rpc->b, NOP_CONT, dir, name));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct trivfs_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).create_response).err);
    *fh = (((_binding->rx_union).create_response).fh);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t trivfs_mkdir__rpc(struct trivfs_rpc_client *_rpc, trivfs_fh_t dir, const char *name, trivfs_errval_t *err, trivfs_fh_t *fh)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).mkdir_call)(_rpc->b, NOP_CONT, dir, name));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct trivfs_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).mkdir_response).err);
    *fh = (((_binding->rx_union).mkdir_response).fh);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t trivfs_delete__rpc(struct trivfs_rpc_client *_rpc, trivfs_fh_t fh, trivfs_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).delete_call)(_rpc->b, NOP_CONT, fh));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct trivfs_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).delete_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}


/*
 * Receive handlers
 */
static  void trivfs_bulk_init__rpc_rx_handler(struct trivfs_binding *_binding, trivfs_errval_t err)
{
    // get RPC client state pointer
    struct trivfs_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).bulk_init_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void trivfs_getroot__rpc_rx_handler(struct trivfs_binding *_binding, trivfs_fh_t rootfh)
{
    // get RPC client state pointer
    struct trivfs_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).getroot_response).rootfh = rootfh;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void trivfs_readdir__rpc_rx_handler(struct trivfs_binding *_binding, trivfs_errval_t err, char *name, bool isdir, trivfs_fsize_t size)
{
    // get RPC client state pointer
    struct trivfs_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).readdir_response).err = err;
    ((_binding->rx_union).readdir_response).name = name;
    ((_binding->rx_union).readdir_response).isdir = isdir;
    ((_binding->rx_union).readdir_response).size = size;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void trivfs_lookup__rpc_rx_handler(struct trivfs_binding *_binding, trivfs_errval_t err, trivfs_fh_t fh, bool isdir)
{
    // get RPC client state pointer
    struct trivfs_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).lookup_response).err = err;
    ((_binding->rx_union).lookup_response).fh = fh;
    ((_binding->rx_union).lookup_response).isdir = isdir;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void trivfs_getattr__rpc_rx_handler(struct trivfs_binding *_binding, trivfs_errval_t err, bool isdir, trivfs_fsize_t size)
{
    // get RPC client state pointer
    struct trivfs_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).getattr_response).err = err;
    ((_binding->rx_union).getattr_response).isdir = isdir;
    ((_binding->rx_union).getattr_response).size = size;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void trivfs_read__rpc_rx_handler(struct trivfs_binding *_binding, trivfs_errval_t err, uint8_t *data, size_t retlen)
{
    // get RPC client state pointer
    struct trivfs_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).read_response).err = err;
    ((_binding->rx_union).read_response).data = data;
    ((_binding->rx_union).read_response).retlen = retlen;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void trivfs_write__rpc_rx_handler(struct trivfs_binding *_binding, trivfs_errval_t err)
{
    // get RPC client state pointer
    struct trivfs_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).write_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void trivfs_read_bulk__rpc_rx_handler(struct trivfs_binding *_binding, trivfs_errval_t err, trivfs_fsize_t retlen)
{
    // get RPC client state pointer
    struct trivfs_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).read_bulk_response).err = err;
    ((_binding->rx_union).read_bulk_response).retlen = retlen;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void trivfs_write_bulk__rpc_rx_handler(struct trivfs_binding *_binding, trivfs_errval_t err)
{
    // get RPC client state pointer
    struct trivfs_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).write_bulk_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void trivfs_truncate__rpc_rx_handler(struct trivfs_binding *_binding, trivfs_errval_t err)
{
    // get RPC client state pointer
    struct trivfs_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).truncate_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void trivfs_create__rpc_rx_handler(struct trivfs_binding *_binding, trivfs_errval_t err, trivfs_fh_t fh)
{
    // get RPC client state pointer
    struct trivfs_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).create_response).err = err;
    ((_binding->rx_union).create_response).fh = fh;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void trivfs_mkdir__rpc_rx_handler(struct trivfs_binding *_binding, trivfs_errval_t err, trivfs_fh_t fh)
{
    // get RPC client state pointer
    struct trivfs_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).mkdir_response).err = err;
    ((_binding->rx_union).mkdir_response).fh = fh;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void trivfs_delete__rpc_rx_handler(struct trivfs_binding *_binding, trivfs_errval_t err)
{
    // get RPC client state pointer
    struct trivfs_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).delete_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}


/*
 * RPC Vtable
 */
static  struct trivfs_rpc_vtbl trivfs_rpc_vtbl = {
    .bulk_init = trivfs_bulk_init__rpc,
    .getroot = trivfs_getroot__rpc,
    .readdir = trivfs_readdir__rpc,
    .lookup = trivfs_lookup__rpc,
    .getattr = trivfs_getattr__rpc,
    .read = trivfs_read__rpc,
    .write = trivfs_write__rpc,
    .read_bulk = trivfs_read_bulk__rpc,
    .write_bulk = trivfs_write_bulk__rpc,
    .truncate = trivfs_truncate__rpc,
    .create = trivfs_create__rpc,
    .mkdir = trivfs_mkdir__rpc,
    .delete = trivfs_delete__rpc,
};

/*
 * Error handler
 */
static  void trivfs_rpc_client_error(struct trivfs_binding *_binding, errval_t _err)
{
    // get RPC client state pointer
    struct trivfs_rpc_client *_rpc = _binding->st;
    
    if (_rpc->rpc_in_progress) {
        assert(err_is_fail(_err));
        _rpc->async_error = _err;
        // kick waitset with dummy event
        flounder_support_register(&(_rpc->rpc_waitset), &(_rpc->dummy_chanstate), dummy_event_closure, true);
    } else {
        USER_PANIC_ERR(_err, "async error in RPC");
    }
}


/*
 * Init function
 */
 errval_t trivfs_rpc_client_init(struct trivfs_rpc_client *rpc, struct trivfs_binding *binding)
{
    errval_t _err;
    
    // Setup state of RPC client object
    rpc->b = binding;
    rpc->reply_present = false;
    rpc->rpc_in_progress = false;
    rpc->async_error = SYS_ERR_OK;
    waitset_init(&(rpc->rpc_waitset));
    flounder_support_waitset_chanstate_init(&(rpc->dummy_chanstate));
    rpc->vtbl = trivfs_rpc_vtbl;
    binding->st = rpc;
    
    // Change waitset on binding
    _err = ((binding->change_waitset)(binding, &(rpc->rpc_waitset)));
    if (err_is_fail(_err)) {
        waitset_destroy(&(rpc->rpc_waitset));
        return(err_push(_err, FLOUNDER_ERR_CHANGE_WAITSET));
    }
    
    // Set RX handlers on binding object for RPCs
    (binding->rx_vtbl).bulk_init_response = trivfs_bulk_init__rpc_rx_handler;
    (binding->rx_vtbl).getroot_response = trivfs_getroot__rpc_rx_handler;
    (binding->rx_vtbl).readdir_response = trivfs_readdir__rpc_rx_handler;
    (binding->rx_vtbl).lookup_response = trivfs_lookup__rpc_rx_handler;
    (binding->rx_vtbl).getattr_response = trivfs_getattr__rpc_rx_handler;
    (binding->rx_vtbl).read_response = trivfs_read__rpc_rx_handler;
    (binding->rx_vtbl).write_response = trivfs_write__rpc_rx_handler;
    (binding->rx_vtbl).read_bulk_response = trivfs_read_bulk__rpc_rx_handler;
    (binding->rx_vtbl).write_bulk_response = trivfs_write_bulk__rpc_rx_handler;
    (binding->rx_vtbl).truncate_response = trivfs_truncate__rpc_rx_handler;
    (binding->rx_vtbl).create_response = trivfs_create__rpc_rx_handler;
    (binding->rx_vtbl).mkdir_response = trivfs_mkdir__rpc_rx_handler;
    (binding->rx_vtbl).delete_response = trivfs_delete__rpc_rx_handler;
    
    // Set error handler on binding object
    binding->error_handler = trivfs_rpc_client_error;
    
    return(SYS_ERR_OK);
}

