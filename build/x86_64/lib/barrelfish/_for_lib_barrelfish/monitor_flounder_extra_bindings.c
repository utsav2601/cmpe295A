/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: monitor
 * INTEFACE FILE: ../if/monitor.if
 * INTERFACE DESCRIPTION: The monitor to client Interface
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

/*
 * Generated Stub for LMP on x86_64
 */

#include <string.h>
#include <barrelfish/barrelfish.h>
#include <flounder/flounder_support.h>
#include <flounder/flounder_support_lmp.h>
#include <if/monitor_defs.h>

/*
 * Send handler functions
 */
static  void monitor_alloc_iref_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_alloc_iref_request__msgnum, ((_binding->tx_union).alloc_iref_request).service_id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_alloc_iref_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_alloc_iref_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, NULL_CAP, monitor_alloc_iref_reply__msgnum | (((uintptr_t )(((_binding->tx_union).alloc_iref_reply).iref)) << 16), ((_binding->tx_union).alloc_iref_reply).service_id, ((_binding->tx_union).alloc_iref_reply).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_alloc_iref_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_boot_core_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, ((_binding->tx_union).boot_core_request).frame, monitor_boot_core_request__msgnum | (((uintptr_t )(((_binding->tx_union).boot_core_request).id)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_boot_core_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_boot_core_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_boot_core_reply__msgnum, ((_binding->tx_union).boot_core_reply).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_boot_core_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_new_monitor_binding_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_new_monitor_binding_request__msgnum, ((_binding->tx_union).new_monitor_binding_request).st);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_new_monitor_binding_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_new_monitor_binding_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, ((_binding->tx_union).new_monitor_binding_reply).ep, monitor_new_monitor_binding_reply__msgnum, ((_binding->tx_union).new_monitor_binding_reply).err, ((_binding->tx_union).new_monitor_binding_reply).st);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_new_monitor_binding_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_bind_lmp_client_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, ((_binding->tx_union).bind_lmp_client_request).ep, monitor_bind_lmp_client_request__msgnum | (((uintptr_t )(((_binding->tx_union).bind_lmp_client_request).iref)) << 16), ((_binding->tx_union).bind_lmp_client_request).conn_id, ((_binding->tx_union).bind_lmp_client_request).buflen);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_bind_lmp_client_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_multiboot_cap_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_multiboot_cap_request__msgnum | (((uintptr_t )(((_binding->tx_union).multiboot_cap_request).slot)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_multiboot_cap_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_multiboot_cap_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, ((_binding->tx_union).multiboot_cap_reply).cap, monitor_multiboot_cap_reply__msgnum, ((_binding->tx_union).multiboot_cap_reply).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_multiboot_cap_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_bind_lmp_service_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send4(&(b->chan), b->flags, ((_binding->tx_union).bind_lmp_service_request).ep, monitor_bind_lmp_service_request__msgnum, ((_binding->tx_union).bind_lmp_service_request).service_id, ((_binding->tx_union).bind_lmp_service_request).mon_id, ((_binding->tx_union).bind_lmp_service_request).buflen);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_bind_lmp_service_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_bind_lmp_reply_monitor__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send4(&(b->chan), b->flags, ((_binding->tx_union).bind_lmp_reply_monitor).ep, monitor_bind_lmp_reply_monitor__msgnum, ((_binding->tx_union).bind_lmp_reply_monitor).err, ((_binding->tx_union).bind_lmp_reply_monitor).mon_id, ((_binding->tx_union).bind_lmp_reply_monitor).conn_id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_bind_lmp_reply_monitor__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_bind_lmp_reply_client__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send4(&(b->chan), b->flags, ((_binding->tx_union).bind_lmp_reply_client).ep, monitor_bind_lmp_reply_client__msgnum, ((_binding->tx_union).bind_lmp_reply_client).err, ((_binding->tx_union).bind_lmp_reply_client).mon_id, ((_binding->tx_union).bind_lmp_reply_client).conn_id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_bind_lmp_reply_client__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_bind_ump_client_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send4(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), ((_binding->tx_union).bind_ump_client_request).frame, monitor_bind_ump_client_request__msgnum | (((uintptr_t )(((_binding->tx_union).bind_ump_client_request).iref)) << 16), ((_binding->tx_union).bind_ump_client_request).conn_id, ((_binding->tx_union).bind_ump_client_request).channel_length_in, ((_binding->tx_union).bind_ump_client_request).channel_length_out);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send0(&(b->chan), b->flags, ((_binding->tx_union).bind_ump_client_request).notify);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_bind_ump_client_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_bind_ump_service_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send5(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), ((_binding->tx_union).bind_ump_service_request).frame, monitor_bind_ump_service_request__msgnum, ((_binding->tx_union).bind_ump_service_request).service_id, ((_binding->tx_union).bind_ump_service_request).mon_id, ((_binding->tx_union).bind_ump_service_request).channel_length_in, ((_binding->tx_union).bind_ump_service_request).channel_length_out);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send0(&(b->chan), b->flags, ((_binding->tx_union).bind_ump_service_request).notify);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_bind_ump_service_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_bind_ump_reply_monitor__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send4(&(b->chan), b->flags, ((_binding->tx_union).bind_ump_reply_monitor).notify, monitor_bind_ump_reply_monitor__msgnum, ((_binding->tx_union).bind_ump_reply_monitor).mon_id, ((_binding->tx_union).bind_ump_reply_monitor).conn_id, ((_binding->tx_union).bind_ump_reply_monitor).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_bind_ump_reply_monitor__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_bind_ump_reply_client__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send4(&(b->chan), b->flags, ((_binding->tx_union).bind_ump_reply_client).notify, monitor_bind_ump_reply_client__msgnum, ((_binding->tx_union).bind_ump_reply_client).mon_id, ((_binding->tx_union).bind_ump_reply_client).conn_id, ((_binding->tx_union).bind_ump_reply_client).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_bind_ump_reply_client__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_ipi_alloc_notify_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, ((_binding->tx_union).ipi_alloc_notify_request).ep, monitor_ipi_alloc_notify_request__msgnum, ((_binding->tx_union).ipi_alloc_notify_request).state);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_ipi_alloc_notify_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_ipi_alloc_notify_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, ((_binding->tx_union).ipi_alloc_notify_reply).notify, monitor_ipi_alloc_notify_reply__msgnum, ((_binding->tx_union).ipi_alloc_notify_reply).state, ((_binding->tx_union).ipi_alloc_notify_reply).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_ipi_alloc_notify_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_get_mem_iref_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_get_mem_iref_request__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_get_mem_iref_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_get_mem_iref_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_get_mem_iref_reply__msgnum | (((uintptr_t )(((_binding->tx_union).get_mem_iref_reply).iref)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_get_mem_iref_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_get_name_iref_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_get_name_iref_request__msgnum, ((_binding->tx_union).get_name_iref_request).st);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_get_name_iref_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_get_name_iref_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_get_name_iref_reply__msgnum | (((uintptr_t )(((_binding->tx_union).get_name_iref_reply).iref)) << 16), ((_binding->tx_union).get_name_iref_reply).st);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_get_name_iref_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_get_ramfs_iref_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_get_ramfs_iref_request__msgnum, ((_binding->tx_union).get_ramfs_iref_request).st);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_get_ramfs_iref_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_get_ramfs_iref_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_get_ramfs_iref_reply__msgnum | (((uintptr_t )(((_binding->tx_union).get_ramfs_iref_reply).iref)) << 16), ((_binding->tx_union).get_ramfs_iref_reply).st);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_get_ramfs_iref_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_set_ramfs_iref_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_set_ramfs_iref_request__msgnum | (((uintptr_t )(((_binding->tx_union).set_ramfs_iref_request).iref)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_set_ramfs_iref_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_set_mem_iref_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_set_mem_iref_request__msgnum | (((uintptr_t )(((_binding->tx_union).set_mem_iref_request).iref)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_set_mem_iref_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_set_name_iref_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_set_name_iref_request__msgnum | (((uintptr_t )(((_binding->tx_union).set_name_iref_request).iref)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_set_name_iref_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_set_name_iref_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_set_name_iref_reply__msgnum, ((_binding->tx_union).set_name_iref_reply).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_set_name_iref_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_get_monitor_rpc_iref_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_get_monitor_rpc_iref_request__msgnum, ((_binding->tx_union).get_monitor_rpc_iref_request).st);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_get_monitor_rpc_iref_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_get_monitor_rpc_iref_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_get_monitor_rpc_iref_reply__msgnum | (((uintptr_t )(((_binding->tx_union).get_monitor_rpc_iref_reply).iref)) << 16), ((_binding->tx_union).get_monitor_rpc_iref_reply).st);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_get_monitor_rpc_iref_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_cap_send_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, ((_binding->tx_union).cap_send_request).cap, monitor_cap_send_request__msgnum | (((uintptr_t )(((_binding->tx_union).cap_send_request).capid)) << 16), ((_binding->tx_union).cap_send_request).mon_id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_cap_send_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_cap_move_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), (b->flags) | LMP_FLAG_GIVEAWAY, ((_binding->tx_union).cap_move_request).cap, monitor_cap_move_request__msgnum | (((uintptr_t )(((_binding->tx_union).cap_move_request).capid)) << 16), ((_binding->tx_union).cap_move_request).mon_id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_cap_move_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_cap_receive_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), (b->flags) | LMP_FLAG_GIVEAWAY, ((_binding->tx_union).cap_receive_request).cap, monitor_cap_receive_request__msgnum | (((uintptr_t )(((_binding->tx_union).cap_receive_request).capid)) << 16), ((_binding->tx_union).cap_receive_request).conn_id, ((_binding->tx_union).cap_receive_request).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_cap_receive_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_span_domain_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), ((_binding->tx_union).span_domain_request).vroot, monitor_span_domain_request__msgnum | (((uintptr_t )(((_binding->tx_union).span_domain_request).core_id)) << 16), ((_binding->tx_union).span_domain_request).domain_id);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send0(&(b->chan), b->flags, ((_binding->tx_union).span_domain_request).disp);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_span_domain_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_span_domain_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, NULL_CAP, monitor_span_domain_reply__msgnum, ((_binding->tx_union).span_domain_reply).err, ((_binding->tx_union).span_domain_reply).domain_id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_span_domain_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_migrate_dispatcher_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), ((_binding->tx_union).migrate_dispatcher_request).vroot, monitor_migrate_dispatcher_request__msgnum | (((uintptr_t )(((_binding->tx_union).migrate_dispatcher_request).core_id)) << 16));
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send0(&(b->chan), b->flags, ((_binding->tx_union).migrate_dispatcher_request).disp);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_migrate_dispatcher_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_multihop_routing_table_new__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_multihop_routing_table_new__msgnum | ((((uintptr_t )(((_binding->tx_union).multihop_routing_table_new).max_coreid)) << 16) | (((uintptr_t )(((_binding->tx_union).multihop_routing_table_new).nentries)) << 24)));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_multihop_routing_table_new__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_multihop_routing_table_set__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, monitor_multihop_routing_table_set__msgnum | (((uintptr_t )(((_binding->tx_union).multihop_routing_table_set).from)) << 16));
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = flounder_stub_lmp_send_buf(&(b->chan), b->flags, ((_binding->tx_union).multihop_routing_table_set).to, ((_binding->tx_union).multihop_routing_table_set).len, &(_binding->tx_str_pos));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_multihop_routing_table_set__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_multihop_bind_client_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_multihop_bind_client_request__msgnum | (((uintptr_t )(((_binding->tx_union).multihop_bind_client_request).iref)) << 16), ((_binding->tx_union).multihop_bind_client_request).sender_vci);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_multihop_bind_client_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_multihop_bind_client_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send4(&(b->chan), b->flags, NULL_CAP, monitor_multihop_bind_client_reply__msgnum, ((_binding->tx_union).multihop_bind_client_reply).receiver_vci, ((_binding->tx_union).multihop_bind_client_reply).sender_vci, ((_binding->tx_union).multihop_bind_client_reply).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_multihop_bind_client_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_multihop_bind_service_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, NULL_CAP, monitor_multihop_bind_service_request__msgnum, ((_binding->tx_union).multihop_bind_service_request).service_id, ((_binding->tx_union).multihop_bind_service_request).sender_vci);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_multihop_bind_service_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_multihop_bind_service_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send4(&(b->chan), b->flags, NULL_CAP, monitor_multihop_bind_service_reply__msgnum, ((_binding->tx_union).multihop_bind_service_reply).receiver_vci, ((_binding->tx_union).multihop_bind_service_reply).sender_vci, ((_binding->tx_union).multihop_bind_service_reply).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_multihop_bind_service_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_multihop_message__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, monitor_multihop_message__msgnum | ((((uintptr_t )(((_binding->tx_union).multihop_message).direction)) << 16) | ((((uintptr_t )(((_binding->tx_union).multihop_message).flags)) << 24) | (((uintptr_t )(((_binding->tx_union).multihop_message).ack)) << 32))), ((_binding->tx_union).multihop_message).vci);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = flounder_stub_lmp_send_buf(&(b->chan), b->flags, ((_binding->tx_union).multihop_message).payload, ((_binding->tx_union).multihop_message).size, &(_binding->tx_str_pos));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_multihop_message__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_multihop_cap_send__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, ((_binding->tx_union).multihop_cap_send).cap, monitor_multihop_cap_send__msgnum | ((((uintptr_t )(((_binding->tx_union).multihop_cap_send).direction)) << 16) | (((uintptr_t )(((_binding->tx_union).multihop_cap_send).capid)) << 24)), ((_binding->tx_union).multihop_cap_send).vci, ((_binding->tx_union).multihop_cap_send).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_multihop_cap_send__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_trace_prepare__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_trace_prepare__msgnum | (((uintptr_t )(((_binding->tx_union).trace_prepare).origin_core)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_trace_prepare__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_trace_prepare_finished__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_trace_prepare_finished__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_trace_prepare_finished__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_bfscope_flush_send__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_bfscope_flush_send__msgnum | (((uintptr_t )(((_binding->tx_union).bfscope_flush_send).iref)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_bfscope_flush_send__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_bfscope_flush_ack__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_bfscope_flush_ack__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_bfscope_flush_ack__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_migrate_dispatcher__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_migrate_dispatcher__msgnum, ((_binding->tx_union).migrate_dispatcher).domain_id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_migrate_dispatcher__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}


/*
 * Message sender functions
 */
static  errval_t monitor_alloc_iref_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t service_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_alloc_iref_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).alloc_iref_request).service_id = service_id;
    FL_DEBUG("lmp TX monitor.alloc_iref_request\n");
    
    // try to send!
    monitor_alloc_iref_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_alloc_iref_reply__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t service_id, iref_t iref, monitor_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_alloc_iref_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).alloc_iref_reply).service_id = service_id;
    ((_binding->tx_union).alloc_iref_reply).iref = iref;
    ((_binding->tx_union).alloc_iref_reply).err = err;
    FL_DEBUG("lmp TX monitor.alloc_iref_reply\n");
    
    // try to send!
    monitor_alloc_iref_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_boot_core_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uint8_t id, struct capref frame)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_boot_core_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).boot_core_request).id = id;
    ((_binding->tx_union).boot_core_request).frame = frame;
    FL_DEBUG("lmp TX monitor.boot_core_request\n");
    
    // try to send!
    monitor_boot_core_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_boot_core_reply__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_boot_core_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).boot_core_reply).err = err;
    FL_DEBUG("lmp TX monitor.boot_core_reply\n");
    
    // try to send!
    monitor_boot_core_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_new_monitor_binding_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t st)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_new_monitor_binding_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).new_monitor_binding_request).st = st;
    FL_DEBUG("lmp TX monitor.new_monitor_binding_request\n");
    
    // try to send!
    monitor_new_monitor_binding_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_new_monitor_binding_reply__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_errval_t err, struct capref ep, uintptr_t st)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_new_monitor_binding_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).new_monitor_binding_reply).err = err;
    ((_binding->tx_union).new_monitor_binding_reply).ep = ep;
    ((_binding->tx_union).new_monitor_binding_reply).st = st;
    FL_DEBUG("lmp TX monitor.new_monitor_binding_reply\n");
    
    // try to send!
    monitor_new_monitor_binding_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bind_lmp_client_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref, uintptr_t conn_id, size_t buflen, struct capref ep)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_bind_lmp_client_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_lmp_client_request).iref = iref;
    ((_binding->tx_union).bind_lmp_client_request).conn_id = conn_id;
    ((_binding->tx_union).bind_lmp_client_request).buflen = buflen;
    ((_binding->tx_union).bind_lmp_client_request).ep = ep;
    FL_DEBUG("lmp TX monitor.bind_lmp_client_request\n");
    
    // try to send!
    monitor_bind_lmp_client_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multiboot_cap_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uint32_t slot)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_multiboot_cap_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multiboot_cap_request).slot = slot;
    FL_DEBUG("lmp TX monitor.multiboot_cap_request\n");
    
    // try to send!
    monitor_multiboot_cap_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multiboot_cap_reply__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, struct capref cap, monitor_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_multiboot_cap_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multiboot_cap_reply).cap = cap;
    ((_binding->tx_union).multiboot_cap_reply).err = err;
    FL_DEBUG("lmp TX monitor.multiboot_cap_reply\n");
    
    // try to send!
    monitor_multiboot_cap_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bind_lmp_service_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t service_id, uintptr_t mon_id, size_t buflen, struct capref ep)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_bind_lmp_service_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_lmp_service_request).service_id = service_id;
    ((_binding->tx_union).bind_lmp_service_request).mon_id = mon_id;
    ((_binding->tx_union).bind_lmp_service_request).buflen = buflen;
    ((_binding->tx_union).bind_lmp_service_request).ep = ep;
    FL_DEBUG("lmp TX monitor.bind_lmp_service_request\n");
    
    // try to send!
    monitor_bind_lmp_service_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bind_lmp_reply_monitor__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_errval_t err, uintptr_t mon_id, uintptr_t conn_id, struct capref ep)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_bind_lmp_reply_monitor__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_lmp_reply_monitor).err = err;
    ((_binding->tx_union).bind_lmp_reply_monitor).mon_id = mon_id;
    ((_binding->tx_union).bind_lmp_reply_monitor).conn_id = conn_id;
    ((_binding->tx_union).bind_lmp_reply_monitor).ep = ep;
    FL_DEBUG("lmp TX monitor.bind_lmp_reply_monitor\n");
    
    // try to send!
    monitor_bind_lmp_reply_monitor__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bind_lmp_reply_client__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_errval_t err, uintptr_t mon_id, uintptr_t conn_id, struct capref ep)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_bind_lmp_reply_client__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_lmp_reply_client).err = err;
    ((_binding->tx_union).bind_lmp_reply_client).mon_id = mon_id;
    ((_binding->tx_union).bind_lmp_reply_client).conn_id = conn_id;
    ((_binding->tx_union).bind_lmp_reply_client).ep = ep;
    FL_DEBUG("lmp TX monitor.bind_lmp_reply_client\n");
    
    // try to send!
    monitor_bind_lmp_reply_client__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bind_ump_client_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref, uintptr_t conn_id, struct capref frame, size_t channel_length_in, size_t channel_length_out, struct capref notify)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_bind_ump_client_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_ump_client_request).iref = iref;
    ((_binding->tx_union).bind_ump_client_request).conn_id = conn_id;
    ((_binding->tx_union).bind_ump_client_request).frame = frame;
    ((_binding->tx_union).bind_ump_client_request).channel_length_in = channel_length_in;
    ((_binding->tx_union).bind_ump_client_request).channel_length_out = channel_length_out;
    ((_binding->tx_union).bind_ump_client_request).notify = notify;
    FL_DEBUG("lmp TX monitor.bind_ump_client_request\n");
    
    // try to send!
    monitor_bind_ump_client_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bind_ump_service_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t service_id, uintptr_t mon_id, struct capref frame, size_t channel_length_in, size_t channel_length_out, struct capref notify)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_bind_ump_service_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_ump_service_request).service_id = service_id;
    ((_binding->tx_union).bind_ump_service_request).mon_id = mon_id;
    ((_binding->tx_union).bind_ump_service_request).frame = frame;
    ((_binding->tx_union).bind_ump_service_request).channel_length_in = channel_length_in;
    ((_binding->tx_union).bind_ump_service_request).channel_length_out = channel_length_out;
    ((_binding->tx_union).bind_ump_service_request).notify = notify;
    FL_DEBUG("lmp TX monitor.bind_ump_service_request\n");
    
    // try to send!
    monitor_bind_ump_service_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bind_ump_reply_monitor__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t mon_id, uintptr_t conn_id, monitor_errval_t err, struct capref notify)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_bind_ump_reply_monitor__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_ump_reply_monitor).mon_id = mon_id;
    ((_binding->tx_union).bind_ump_reply_monitor).conn_id = conn_id;
    ((_binding->tx_union).bind_ump_reply_monitor).err = err;
    ((_binding->tx_union).bind_ump_reply_monitor).notify = notify;
    FL_DEBUG("lmp TX monitor.bind_ump_reply_monitor\n");
    
    // try to send!
    monitor_bind_ump_reply_monitor__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bind_ump_reply_client__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t mon_id, uintptr_t conn_id, monitor_errval_t err, struct capref notify)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_bind_ump_reply_client__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bind_ump_reply_client).mon_id = mon_id;
    ((_binding->tx_union).bind_ump_reply_client).conn_id = conn_id;
    ((_binding->tx_union).bind_ump_reply_client).err = err;
    ((_binding->tx_union).bind_ump_reply_client).notify = notify;
    FL_DEBUG("lmp TX monitor.bind_ump_reply_client\n");
    
    // try to send!
    monitor_bind_ump_reply_client__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_ipi_alloc_notify_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, struct capref ep, uintptr_t state)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_ipi_alloc_notify_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).ipi_alloc_notify_request).ep = ep;
    ((_binding->tx_union).ipi_alloc_notify_request).state = state;
    FL_DEBUG("lmp TX monitor.ipi_alloc_notify_request\n");
    
    // try to send!
    monitor_ipi_alloc_notify_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_ipi_alloc_notify_reply__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t state, struct capref notify, monitor_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_ipi_alloc_notify_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).ipi_alloc_notify_reply).state = state;
    ((_binding->tx_union).ipi_alloc_notify_reply).notify = notify;
    ((_binding->tx_union).ipi_alloc_notify_reply).err = err;
    FL_DEBUG("lmp TX monitor.ipi_alloc_notify_reply\n");
    
    // try to send!
    monitor_ipi_alloc_notify_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_get_mem_iref_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_get_mem_iref_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX monitor.get_mem_iref_request\n");
    
    // try to send!
    monitor_get_mem_iref_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_get_mem_iref_reply__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_get_mem_iref_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).get_mem_iref_reply).iref = iref;
    FL_DEBUG("lmp TX monitor.get_mem_iref_reply\n");
    
    // try to send!
    monitor_get_mem_iref_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_get_name_iref_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t st)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_get_name_iref_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).get_name_iref_request).st = st;
    FL_DEBUG("lmp TX monitor.get_name_iref_request\n");
    
    // try to send!
    monitor_get_name_iref_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_get_name_iref_reply__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref, uintptr_t st)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_get_name_iref_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).get_name_iref_reply).iref = iref;
    ((_binding->tx_union).get_name_iref_reply).st = st;
    FL_DEBUG("lmp TX monitor.get_name_iref_reply\n");
    
    // try to send!
    monitor_get_name_iref_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_get_ramfs_iref_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t st)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_get_ramfs_iref_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).get_ramfs_iref_request).st = st;
    FL_DEBUG("lmp TX monitor.get_ramfs_iref_request\n");
    
    // try to send!
    monitor_get_ramfs_iref_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_get_ramfs_iref_reply__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref, uintptr_t st)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_get_ramfs_iref_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).get_ramfs_iref_reply).iref = iref;
    ((_binding->tx_union).get_ramfs_iref_reply).st = st;
    FL_DEBUG("lmp TX monitor.get_ramfs_iref_reply\n");
    
    // try to send!
    monitor_get_ramfs_iref_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_set_ramfs_iref_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_set_ramfs_iref_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).set_ramfs_iref_request).iref = iref;
    FL_DEBUG("lmp TX monitor.set_ramfs_iref_request\n");
    
    // try to send!
    monitor_set_ramfs_iref_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_set_mem_iref_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_set_mem_iref_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).set_mem_iref_request).iref = iref;
    FL_DEBUG("lmp TX monitor.set_mem_iref_request\n");
    
    // try to send!
    monitor_set_mem_iref_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_set_name_iref_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_set_name_iref_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).set_name_iref_request).iref = iref;
    FL_DEBUG("lmp TX monitor.set_name_iref_request\n");
    
    // try to send!
    monitor_set_name_iref_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_set_name_iref_reply__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_set_name_iref_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).set_name_iref_reply).err = err;
    FL_DEBUG("lmp TX monitor.set_name_iref_reply\n");
    
    // try to send!
    monitor_set_name_iref_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_get_monitor_rpc_iref_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t st)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_get_monitor_rpc_iref_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).get_monitor_rpc_iref_request).st = st;
    FL_DEBUG("lmp TX monitor.get_monitor_rpc_iref_request\n");
    
    // try to send!
    monitor_get_monitor_rpc_iref_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_get_monitor_rpc_iref_reply__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref, uintptr_t st)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_get_monitor_rpc_iref_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).get_monitor_rpc_iref_reply).iref = iref;
    ((_binding->tx_union).get_monitor_rpc_iref_reply).st = st;
    FL_DEBUG("lmp TX monitor.get_monitor_rpc_iref_reply\n");
    
    // try to send!
    monitor_get_monitor_rpc_iref_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_cap_send_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t mon_id, struct capref cap, monitor_capid_t_t capid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_cap_send_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).cap_send_request).mon_id = mon_id;
    ((_binding->tx_union).cap_send_request).cap = cap;
    ((_binding->tx_union).cap_send_request).capid = capid;
    FL_DEBUG("lmp TX monitor.cap_send_request\n");
    
    // try to send!
    monitor_cap_send_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_cap_move_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t mon_id, struct capref cap, monitor_capid_t_t capid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_cap_move_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).cap_move_request).mon_id = mon_id;
    ((_binding->tx_union).cap_move_request).cap = cap;
    ((_binding->tx_union).cap_move_request).capid = capid;
    FL_DEBUG("lmp TX monitor.cap_move_request\n");
    
    // try to send!
    monitor_cap_move_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_cap_receive_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t conn_id, monitor_errval_t err, struct capref cap, monitor_capid_t_t capid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_cap_receive_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).cap_receive_request).conn_id = conn_id;
    ((_binding->tx_union).cap_receive_request).err = err;
    ((_binding->tx_union).cap_receive_request).cap = cap;
    ((_binding->tx_union).cap_receive_request).capid = capid;
    FL_DEBUG("lmp TX monitor.cap_receive_request\n");
    
    // try to send!
    monitor_cap_receive_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_span_domain_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t domain_id, uint8_t core_id, struct capref vroot, struct capref disp)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_span_domain_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).span_domain_request).domain_id = domain_id;
    ((_binding->tx_union).span_domain_request).core_id = core_id;
    ((_binding->tx_union).span_domain_request).vroot = vroot;
    ((_binding->tx_union).span_domain_request).disp = disp;
    FL_DEBUG("lmp TX monitor.span_domain_request\n");
    
    // try to send!
    monitor_span_domain_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_span_domain_reply__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_errval_t err, uintptr_t domain_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_span_domain_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).span_domain_reply).err = err;
    ((_binding->tx_union).span_domain_reply).domain_id = domain_id;
    FL_DEBUG("lmp TX monitor.span_domain_reply\n");
    
    // try to send!
    monitor_span_domain_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_migrate_dispatcher_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uint8_t core_id, struct capref vroot, struct capref disp)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_migrate_dispatcher_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).migrate_dispatcher_request).core_id = core_id;
    ((_binding->tx_union).migrate_dispatcher_request).vroot = vroot;
    ((_binding->tx_union).migrate_dispatcher_request).disp = disp;
    FL_DEBUG("lmp TX monitor.migrate_dispatcher_request\n");
    
    // try to send!
    monitor_migrate_dispatcher_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multihop_routing_table_new__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_coreid_t max_coreid, monitor_coreid_t nentries)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_multihop_routing_table_new__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_routing_table_new).max_coreid = max_coreid;
    ((_binding->tx_union).multihop_routing_table_new).nentries = nentries;
    FL_DEBUG("lmp TX monitor.multihop_routing_table_new\n");
    
    // try to send!
    monitor_multihop_routing_table_new__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multihop_routing_table_set__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_coreid_t from, const monitor_coreid_t *to, size_t len)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_multihop_routing_table_set__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_routing_table_set).from = from;
    ((_binding->tx_union).multihop_routing_table_set).to = ((monitor_coreid_t *)(to));
    ((_binding->tx_union).multihop_routing_table_set).len = len;
    FL_DEBUG("lmp TX monitor.multihop_routing_table_set\n");
    
    // try to send!
    monitor_multihop_routing_table_set__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multihop_bind_client_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref, monitor_vci_t_t sender_vci)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_multihop_bind_client_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_bind_client_request).iref = iref;
    ((_binding->tx_union).multihop_bind_client_request).sender_vci = sender_vci;
    FL_DEBUG("lmp TX monitor.multihop_bind_client_request\n");
    
    // try to send!
    monitor_multihop_bind_client_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multihop_bind_client_reply__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_vci_t_t receiver_vci, monitor_vci_t_t sender_vci, monitor_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_multihop_bind_client_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_bind_client_reply).receiver_vci = receiver_vci;
    ((_binding->tx_union).multihop_bind_client_reply).sender_vci = sender_vci;
    ((_binding->tx_union).multihop_bind_client_reply).err = err;
    FL_DEBUG("lmp TX monitor.multihop_bind_client_reply\n");
    
    // try to send!
    monitor_multihop_bind_client_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multihop_bind_service_request__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t service_id, monitor_vci_t_t sender_vci)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_multihop_bind_service_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_bind_service_request).service_id = service_id;
    ((_binding->tx_union).multihop_bind_service_request).sender_vci = sender_vci;
    FL_DEBUG("lmp TX monitor.multihop_bind_service_request\n");
    
    // try to send!
    monitor_multihop_bind_service_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multihop_bind_service_reply__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_vci_t_t receiver_vci, monitor_vci_t_t sender_vci, monitor_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_multihop_bind_service_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_bind_service_reply).receiver_vci = receiver_vci;
    ((_binding->tx_union).multihop_bind_service_reply).sender_vci = sender_vci;
    ((_binding->tx_union).multihop_bind_service_reply).err = err;
    FL_DEBUG("lmp TX monitor.multihop_bind_service_reply\n");
    
    // try to send!
    monitor_multihop_bind_service_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multihop_message__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_vci_t_t vci, uint8_t direction, uint8_t flags, uint32_t ack, const uint8_t *payload, size_t size)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_multihop_message__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_message).vci = vci;
    ((_binding->tx_union).multihop_message).direction = direction;
    ((_binding->tx_union).multihop_message).flags = flags;
    ((_binding->tx_union).multihop_message).ack = ack;
    ((_binding->tx_union).multihop_message).payload = ((uint8_t *)(payload));
    ((_binding->tx_union).multihop_message).size = size;
    FL_DEBUG("lmp TX monitor.multihop_message\n");
    
    // try to send!
    monitor_multihop_message__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multihop_cap_send__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_vci_t_t vci, uint8_t direction, monitor_errval_t err, struct capref cap, monitor_capid_t_t capid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_multihop_cap_send__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).multihop_cap_send).vci = vci;
    ((_binding->tx_union).multihop_cap_send).direction = direction;
    ((_binding->tx_union).multihop_cap_send).err = err;
    ((_binding->tx_union).multihop_cap_send).cap = cap;
    ((_binding->tx_union).multihop_cap_send).capid = capid;
    FL_DEBUG("lmp TX monitor.multihop_cap_send\n");
    
    // try to send!
    monitor_multihop_cap_send__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_trace_prepare__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_coreid_t origin_core)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_trace_prepare__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).trace_prepare).origin_core = origin_core;
    FL_DEBUG("lmp TX monitor.trace_prepare\n");
    
    // try to send!
    monitor_trace_prepare__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_trace_prepare_finished__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_trace_prepare_finished__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX monitor.trace_prepare_finished\n");
    
    // try to send!
    monitor_trace_prepare_finished__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bfscope_flush_send__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_bfscope_flush_send__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).bfscope_flush_send).iref = iref;
    FL_DEBUG("lmp TX monitor.bfscope_flush_send\n");
    
    // try to send!
    monitor_bfscope_flush_send__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bfscope_flush_ack__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_bfscope_flush_ack__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX monitor.bfscope_flush_ack\n");
    
    // try to send!
    monitor_bfscope_flush_ack__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_migrate_dispatcher__lmp_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t domain_id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_migrate_dispatcher__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).migrate_dispatcher).domain_id = domain_id;
    FL_DEBUG("lmp TX monitor.migrate_dispatcher\n");
    
    // try to send!
    monitor_migrate_dispatcher__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}


/*
 * Send vtable
 */
static  struct monitor_tx_vtbl monitor_lmp_tx_vtbl = {
    .alloc_iref_request = monitor_alloc_iref_request__lmp_send,
    .alloc_iref_reply = monitor_alloc_iref_reply__lmp_send,
    .boot_core_request = monitor_boot_core_request__lmp_send,
    .boot_core_reply = monitor_boot_core_reply__lmp_send,
    .new_monitor_binding_request = monitor_new_monitor_binding_request__lmp_send,
    .new_monitor_binding_reply = monitor_new_monitor_binding_reply__lmp_send,
    .bind_lmp_client_request = monitor_bind_lmp_client_request__lmp_send,
    .multiboot_cap_request = monitor_multiboot_cap_request__lmp_send,
    .multiboot_cap_reply = monitor_multiboot_cap_reply__lmp_send,
    .bind_lmp_service_request = monitor_bind_lmp_service_request__lmp_send,
    .bind_lmp_reply_monitor = monitor_bind_lmp_reply_monitor__lmp_send,
    .bind_lmp_reply_client = monitor_bind_lmp_reply_client__lmp_send,
    .bind_ump_client_request = monitor_bind_ump_client_request__lmp_send,
    .bind_ump_service_request = monitor_bind_ump_service_request__lmp_send,
    .bind_ump_reply_monitor = monitor_bind_ump_reply_monitor__lmp_send,
    .bind_ump_reply_client = monitor_bind_ump_reply_client__lmp_send,
    .ipi_alloc_notify_request = monitor_ipi_alloc_notify_request__lmp_send,
    .ipi_alloc_notify_reply = monitor_ipi_alloc_notify_reply__lmp_send,
    .get_mem_iref_request = monitor_get_mem_iref_request__lmp_send,
    .get_mem_iref_reply = monitor_get_mem_iref_reply__lmp_send,
    .get_name_iref_request = monitor_get_name_iref_request__lmp_send,
    .get_name_iref_reply = monitor_get_name_iref_reply__lmp_send,
    .get_ramfs_iref_request = monitor_get_ramfs_iref_request__lmp_send,
    .get_ramfs_iref_reply = monitor_get_ramfs_iref_reply__lmp_send,
    .set_ramfs_iref_request = monitor_set_ramfs_iref_request__lmp_send,
    .set_mem_iref_request = monitor_set_mem_iref_request__lmp_send,
    .set_name_iref_request = monitor_set_name_iref_request__lmp_send,
    .set_name_iref_reply = monitor_set_name_iref_reply__lmp_send,
    .get_monitor_rpc_iref_request = monitor_get_monitor_rpc_iref_request__lmp_send,
    .get_monitor_rpc_iref_reply = monitor_get_monitor_rpc_iref_reply__lmp_send,
    .cap_send_request = monitor_cap_send_request__lmp_send,
    .cap_move_request = monitor_cap_move_request__lmp_send,
    .cap_receive_request = monitor_cap_receive_request__lmp_send,
    .span_domain_request = monitor_span_domain_request__lmp_send,
    .span_domain_reply = monitor_span_domain_reply__lmp_send,
    .migrate_dispatcher_request = monitor_migrate_dispatcher_request__lmp_send,
    .multihop_routing_table_new = monitor_multihop_routing_table_new__lmp_send,
    .multihop_routing_table_set = monitor_multihop_routing_table_set__lmp_send,
    .multihop_bind_client_request = monitor_multihop_bind_client_request__lmp_send,
    .multihop_bind_client_reply = monitor_multihop_bind_client_reply__lmp_send,
    .multihop_bind_service_request = monitor_multihop_bind_service_request__lmp_send,
    .multihop_bind_service_reply = monitor_multihop_bind_service_reply__lmp_send,
    .multihop_message = monitor_multihop_message__lmp_send,
    .multihop_cap_send = monitor_multihop_cap_send__lmp_send,
    .trace_prepare = monitor_trace_prepare__lmp_send,
    .trace_prepare_finished = monitor_trace_prepare_finished__lmp_send,
    .bfscope_flush_send = monitor_bfscope_flush_send__lmp_send,
    .bfscope_flush_ack = monitor_bfscope_flush_ack__lmp_send,
    .migrate_dispatcher = monitor_migrate_dispatcher__lmp_send,
};
/*
 * Receive handler
 */
 void monitor_lmp_rx_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_binding *_binding = arg;
    struct monitor_lmp_binding *b = arg;
    errval_t err;
    
    struct lmp_recv_msg msg = LMP_RECV_MSG_INIT;
    struct capref cap;
    struct event_closure recv_closure = (struct event_closure){  .handler = monitor_lmp_rx_handler,  .arg = arg };
    
    do {
        // try to retrieve a message from the channel
        err = lmp_chan_recv(&(b->chan), &msg, &cap);
        // check if we succeeded
        if (err_is_fail(err)) {
            if (err_no(err) == LIB_ERR_NO_LMP_MSG) {
                // no message
                break;
            } else {
                // real error
                (_binding->error_handler)(_binding, err_push(err, LIB_ERR_LMP_CHAN_RECV));
                return;
            }
        }
        
        // allocate a new receive slot if needed
        if (!capref_is_null(cap)) {
            err = lmp_chan_alloc_recv_slot(&(b->chan));
            if (err_is_fail(err)) {
                (_binding->error_handler)(_binding, err_push(err, LIB_ERR_LMP_ALLOC_RECV_SLOT));
            }
        }
        
        // is this the start of a new message?
        if ((_binding->rx_msgnum) == 0) {
            // check message length
            if (((msg.buf).msglen) == 0) {
                (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_EMPTY_MSG);
                break;
            }
            // unmarshall message number from first word, set fragment to 0
            _binding->rx_msgnum = (((msg.words)[0]) & 0xffff);
            _binding->rx_msg_fragment = 0;
        }
        
        // switch on message number and fragment number
        switch (_binding->rx_msgnum) {
        case monitor_alloc_iref_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).alloc_iref_request).service_id = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor.alloc_iref_request\n");
                assert(((_binding->rx_vtbl).alloc_iref_request) != NULL);
                ((_binding->rx_vtbl).alloc_iref_request)(_binding, ((_binding->rx_union).alloc_iref_request).service_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_alloc_iref_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).alloc_iref_reply).iref = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).alloc_iref_reply).service_id = ((msg.words)[1]);
                ((_binding->rx_union).alloc_iref_reply).err = ((msg.words)[2]);
                
                FL_DEBUG("lmp RX monitor.alloc_iref_reply\n");
                assert(((_binding->rx_vtbl).alloc_iref_reply) != NULL);
                ((_binding->rx_vtbl).alloc_iref_reply)(_binding, ((_binding->rx_union).alloc_iref_reply).service_id, ((_binding->rx_union).alloc_iref_reply).iref, ((_binding->rx_union).alloc_iref_reply).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_boot_core_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).boot_core_request).id = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).boot_core_request).frame = cap;
                
                FL_DEBUG("lmp RX monitor.boot_core_request\n");
                assert(((_binding->rx_vtbl).boot_core_request) != NULL);
                ((_binding->rx_vtbl).boot_core_request)(_binding, ((_binding->rx_union).boot_core_request).id, ((_binding->rx_union).boot_core_request).frame);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_boot_core_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).boot_core_reply).err = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor.boot_core_reply\n");
                assert(((_binding->rx_vtbl).boot_core_reply) != NULL);
                ((_binding->rx_vtbl).boot_core_reply)(_binding, ((_binding->rx_union).boot_core_reply).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_new_monitor_binding_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).new_monitor_binding_request).st = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor.new_monitor_binding_request\n");
                assert(((_binding->rx_vtbl).new_monitor_binding_request) != NULL);
                ((_binding->rx_vtbl).new_monitor_binding_request)(_binding, ((_binding->rx_union).new_monitor_binding_request).st);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_new_monitor_binding_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).new_monitor_binding_reply).err = ((msg.words)[1]);
                ((_binding->rx_union).new_monitor_binding_reply).st = ((msg.words)[2]);
                ((_binding->rx_union).new_monitor_binding_reply).ep = cap;
                
                FL_DEBUG("lmp RX monitor.new_monitor_binding_reply\n");
                assert(((_binding->rx_vtbl).new_monitor_binding_reply) != NULL);
                ((_binding->rx_vtbl).new_monitor_binding_reply)(_binding, ((_binding->rx_union).new_monitor_binding_reply).err, ((_binding->rx_union).new_monitor_binding_reply).ep, ((_binding->rx_union).new_monitor_binding_reply).st);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_bind_lmp_client_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_lmp_client_request).iref = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).bind_lmp_client_request).conn_id = ((msg.words)[1]);
                ((_binding->rx_union).bind_lmp_client_request).buflen = ((msg.words)[2]);
                ((_binding->rx_union).bind_lmp_client_request).ep = cap;
                
                FL_DEBUG("lmp RX monitor.bind_lmp_client_request\n");
                assert(((_binding->rx_vtbl).bind_lmp_client_request) != NULL);
                ((_binding->rx_vtbl).bind_lmp_client_request)(_binding, ((_binding->rx_union).bind_lmp_client_request).iref, ((_binding->rx_union).bind_lmp_client_request).conn_id, ((_binding->rx_union).bind_lmp_client_request).buflen, ((_binding->rx_union).bind_lmp_client_request).ep);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_multiboot_cap_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).multiboot_cap_request).slot = ((((msg.words)[0]) >> 16) & 0xffffffff);
                
                FL_DEBUG("lmp RX monitor.multiboot_cap_request\n");
                assert(((_binding->rx_vtbl).multiboot_cap_request) != NULL);
                ((_binding->rx_vtbl).multiboot_cap_request)(_binding, ((_binding->rx_union).multiboot_cap_request).slot);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_multiboot_cap_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).multiboot_cap_reply).err = ((msg.words)[1]);
                ((_binding->rx_union).multiboot_cap_reply).cap = cap;
                
                FL_DEBUG("lmp RX monitor.multiboot_cap_reply\n");
                assert(((_binding->rx_vtbl).multiboot_cap_reply) != NULL);
                ((_binding->rx_vtbl).multiboot_cap_reply)(_binding, ((_binding->rx_union).multiboot_cap_reply).cap, ((_binding->rx_union).multiboot_cap_reply).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_bind_lmp_service_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_lmp_service_request).service_id = ((msg.words)[1]);
                ((_binding->rx_union).bind_lmp_service_request).mon_id = ((msg.words)[2]);
                ((_binding->rx_union).bind_lmp_service_request).buflen = ((msg.words)[3]);
                ((_binding->rx_union).bind_lmp_service_request).ep = cap;
                
                FL_DEBUG("lmp RX monitor.bind_lmp_service_request\n");
                assert(((_binding->rx_vtbl).bind_lmp_service_request) != NULL);
                ((_binding->rx_vtbl).bind_lmp_service_request)(_binding, ((_binding->rx_union).bind_lmp_service_request).service_id, ((_binding->rx_union).bind_lmp_service_request).mon_id, ((_binding->rx_union).bind_lmp_service_request).buflen, ((_binding->rx_union).bind_lmp_service_request).ep);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_bind_lmp_reply_monitor__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_lmp_reply_monitor).err = ((msg.words)[1]);
                ((_binding->rx_union).bind_lmp_reply_monitor).mon_id = ((msg.words)[2]);
                ((_binding->rx_union).bind_lmp_reply_monitor).conn_id = ((msg.words)[3]);
                ((_binding->rx_union).bind_lmp_reply_monitor).ep = cap;
                
                FL_DEBUG("lmp RX monitor.bind_lmp_reply_monitor\n");
                assert(((_binding->rx_vtbl).bind_lmp_reply_monitor) != NULL);
                ((_binding->rx_vtbl).bind_lmp_reply_monitor)(_binding, ((_binding->rx_union).bind_lmp_reply_monitor).err, ((_binding->rx_union).bind_lmp_reply_monitor).mon_id, ((_binding->rx_union).bind_lmp_reply_monitor).conn_id, ((_binding->rx_union).bind_lmp_reply_monitor).ep);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_bind_lmp_reply_client__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_lmp_reply_client).err = ((msg.words)[1]);
                ((_binding->rx_union).bind_lmp_reply_client).mon_id = ((msg.words)[2]);
                ((_binding->rx_union).bind_lmp_reply_client).conn_id = ((msg.words)[3]);
                ((_binding->rx_union).bind_lmp_reply_client).ep = cap;
                
                FL_DEBUG("lmp RX monitor.bind_lmp_reply_client\n");
                assert(((_binding->rx_vtbl).bind_lmp_reply_client) != NULL);
                ((_binding->rx_vtbl).bind_lmp_reply_client)(_binding, ((_binding->rx_union).bind_lmp_reply_client).err, ((_binding->rx_union).bind_lmp_reply_client).mon_id, ((_binding->rx_union).bind_lmp_reply_client).conn_id, ((_binding->rx_union).bind_lmp_reply_client).ep);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_bind_ump_client_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_ump_client_request).iref = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).bind_ump_client_request).conn_id = ((msg.words)[1]);
                ((_binding->rx_union).bind_ump_client_request).channel_length_in = ((msg.words)[2]);
                ((_binding->rx_union).bind_ump_client_request).channel_length_out = ((msg.words)[3]);
                ((_binding->rx_union).bind_ump_client_request).frame = cap;
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_ump_client_request).notify = cap;
                
                FL_DEBUG("lmp RX monitor.bind_ump_client_request\n");
                assert(((_binding->rx_vtbl).bind_ump_client_request) != NULL);
                ((_binding->rx_vtbl).bind_ump_client_request)(_binding, ((_binding->rx_union).bind_ump_client_request).iref, ((_binding->rx_union).bind_ump_client_request).conn_id, ((_binding->rx_union).bind_ump_client_request).frame, ((_binding->rx_union).bind_ump_client_request).channel_length_in, ((_binding->rx_union).bind_ump_client_request).channel_length_out, ((_binding->rx_union).bind_ump_client_request).notify);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_bind_ump_service_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 5) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_ump_service_request).service_id = ((msg.words)[1]);
                ((_binding->rx_union).bind_ump_service_request).mon_id = ((msg.words)[2]);
                ((_binding->rx_union).bind_ump_service_request).channel_length_in = ((msg.words)[3]);
                ((_binding->rx_union).bind_ump_service_request).channel_length_out = ((msg.words)[4]);
                ((_binding->rx_union).bind_ump_service_request).frame = cap;
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_ump_service_request).notify = cap;
                
                FL_DEBUG("lmp RX monitor.bind_ump_service_request\n");
                assert(((_binding->rx_vtbl).bind_ump_service_request) != NULL);
                ((_binding->rx_vtbl).bind_ump_service_request)(_binding, ((_binding->rx_union).bind_ump_service_request).service_id, ((_binding->rx_union).bind_ump_service_request).mon_id, ((_binding->rx_union).bind_ump_service_request).frame, ((_binding->rx_union).bind_ump_service_request).channel_length_in, ((_binding->rx_union).bind_ump_service_request).channel_length_out, ((_binding->rx_union).bind_ump_service_request).notify);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_bind_ump_reply_monitor__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_ump_reply_monitor).mon_id = ((msg.words)[1]);
                ((_binding->rx_union).bind_ump_reply_monitor).conn_id = ((msg.words)[2]);
                ((_binding->rx_union).bind_ump_reply_monitor).err = ((msg.words)[3]);
                ((_binding->rx_union).bind_ump_reply_monitor).notify = cap;
                
                FL_DEBUG("lmp RX monitor.bind_ump_reply_monitor\n");
                assert(((_binding->rx_vtbl).bind_ump_reply_monitor) != NULL);
                ((_binding->rx_vtbl).bind_ump_reply_monitor)(_binding, ((_binding->rx_union).bind_ump_reply_monitor).mon_id, ((_binding->rx_union).bind_ump_reply_monitor).conn_id, ((_binding->rx_union).bind_ump_reply_monitor).err, ((_binding->rx_union).bind_ump_reply_monitor).notify);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_bind_ump_reply_client__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bind_ump_reply_client).mon_id = ((msg.words)[1]);
                ((_binding->rx_union).bind_ump_reply_client).conn_id = ((msg.words)[2]);
                ((_binding->rx_union).bind_ump_reply_client).err = ((msg.words)[3]);
                ((_binding->rx_union).bind_ump_reply_client).notify = cap;
                
                FL_DEBUG("lmp RX monitor.bind_ump_reply_client\n");
                assert(((_binding->rx_vtbl).bind_ump_reply_client) != NULL);
                ((_binding->rx_vtbl).bind_ump_reply_client)(_binding, ((_binding->rx_union).bind_ump_reply_client).mon_id, ((_binding->rx_union).bind_ump_reply_client).conn_id, ((_binding->rx_union).bind_ump_reply_client).err, ((_binding->rx_union).bind_ump_reply_client).notify);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_ipi_alloc_notify_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).ipi_alloc_notify_request).state = ((msg.words)[1]);
                ((_binding->rx_union).ipi_alloc_notify_request).ep = cap;
                
                FL_DEBUG("lmp RX monitor.ipi_alloc_notify_request\n");
                assert(((_binding->rx_vtbl).ipi_alloc_notify_request) != NULL);
                ((_binding->rx_vtbl).ipi_alloc_notify_request)(_binding, ((_binding->rx_union).ipi_alloc_notify_request).ep, ((_binding->rx_union).ipi_alloc_notify_request).state);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_ipi_alloc_notify_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).ipi_alloc_notify_reply).state = ((msg.words)[1]);
                ((_binding->rx_union).ipi_alloc_notify_reply).err = ((msg.words)[2]);
                ((_binding->rx_union).ipi_alloc_notify_reply).notify = cap;
                
                FL_DEBUG("lmp RX monitor.ipi_alloc_notify_reply\n");
                assert(((_binding->rx_vtbl).ipi_alloc_notify_reply) != NULL);
                ((_binding->rx_vtbl).ipi_alloc_notify_reply)(_binding, ((_binding->rx_union).ipi_alloc_notify_reply).state, ((_binding->rx_union).ipi_alloc_notify_reply).notify, ((_binding->rx_union).ipi_alloc_notify_reply).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_get_mem_iref_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX monitor.get_mem_iref_request\n");
                assert(((_binding->rx_vtbl).get_mem_iref_request) != NULL);
                ((_binding->rx_vtbl).get_mem_iref_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_get_mem_iref_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).get_mem_iref_reply).iref = ((((msg.words)[0]) >> 16) & 0xffffffff);
                
                FL_DEBUG("lmp RX monitor.get_mem_iref_reply\n");
                assert(((_binding->rx_vtbl).get_mem_iref_reply) != NULL);
                ((_binding->rx_vtbl).get_mem_iref_reply)(_binding, ((_binding->rx_union).get_mem_iref_reply).iref);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_get_name_iref_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).get_name_iref_request).st = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor.get_name_iref_request\n");
                assert(((_binding->rx_vtbl).get_name_iref_request) != NULL);
                ((_binding->rx_vtbl).get_name_iref_request)(_binding, ((_binding->rx_union).get_name_iref_request).st);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_get_name_iref_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).get_name_iref_reply).iref = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).get_name_iref_reply).st = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor.get_name_iref_reply\n");
                assert(((_binding->rx_vtbl).get_name_iref_reply) != NULL);
                ((_binding->rx_vtbl).get_name_iref_reply)(_binding, ((_binding->rx_union).get_name_iref_reply).iref, ((_binding->rx_union).get_name_iref_reply).st);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_get_ramfs_iref_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).get_ramfs_iref_request).st = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor.get_ramfs_iref_request\n");
                assert(((_binding->rx_vtbl).get_ramfs_iref_request) != NULL);
                ((_binding->rx_vtbl).get_ramfs_iref_request)(_binding, ((_binding->rx_union).get_ramfs_iref_request).st);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_get_ramfs_iref_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).get_ramfs_iref_reply).iref = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).get_ramfs_iref_reply).st = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor.get_ramfs_iref_reply\n");
                assert(((_binding->rx_vtbl).get_ramfs_iref_reply) != NULL);
                ((_binding->rx_vtbl).get_ramfs_iref_reply)(_binding, ((_binding->rx_union).get_ramfs_iref_reply).iref, ((_binding->rx_union).get_ramfs_iref_reply).st);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_set_ramfs_iref_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).set_ramfs_iref_request).iref = ((((msg.words)[0]) >> 16) & 0xffffffff);
                
                FL_DEBUG("lmp RX monitor.set_ramfs_iref_request\n");
                assert(((_binding->rx_vtbl).set_ramfs_iref_request) != NULL);
                ((_binding->rx_vtbl).set_ramfs_iref_request)(_binding, ((_binding->rx_union).set_ramfs_iref_request).iref);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_set_mem_iref_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).set_mem_iref_request).iref = ((((msg.words)[0]) >> 16) & 0xffffffff);
                
                FL_DEBUG("lmp RX monitor.set_mem_iref_request\n");
                assert(((_binding->rx_vtbl).set_mem_iref_request) != NULL);
                ((_binding->rx_vtbl).set_mem_iref_request)(_binding, ((_binding->rx_union).set_mem_iref_request).iref);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_set_name_iref_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).set_name_iref_request).iref = ((((msg.words)[0]) >> 16) & 0xffffffff);
                
                FL_DEBUG("lmp RX monitor.set_name_iref_request\n");
                assert(((_binding->rx_vtbl).set_name_iref_request) != NULL);
                ((_binding->rx_vtbl).set_name_iref_request)(_binding, ((_binding->rx_union).set_name_iref_request).iref);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_set_name_iref_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).set_name_iref_reply).err = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor.set_name_iref_reply\n");
                assert(((_binding->rx_vtbl).set_name_iref_reply) != NULL);
                ((_binding->rx_vtbl).set_name_iref_reply)(_binding, ((_binding->rx_union).set_name_iref_reply).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_get_monitor_rpc_iref_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).get_monitor_rpc_iref_request).st = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor.get_monitor_rpc_iref_request\n");
                assert(((_binding->rx_vtbl).get_monitor_rpc_iref_request) != NULL);
                ((_binding->rx_vtbl).get_monitor_rpc_iref_request)(_binding, ((_binding->rx_union).get_monitor_rpc_iref_request).st);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_get_monitor_rpc_iref_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).get_monitor_rpc_iref_reply).iref = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).get_monitor_rpc_iref_reply).st = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor.get_monitor_rpc_iref_reply\n");
                assert(((_binding->rx_vtbl).get_monitor_rpc_iref_reply) != NULL);
                ((_binding->rx_vtbl).get_monitor_rpc_iref_reply)(_binding, ((_binding->rx_union).get_monitor_rpc_iref_reply).iref, ((_binding->rx_union).get_monitor_rpc_iref_reply).st);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_cap_send_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).cap_send_request).capid = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).cap_send_request).mon_id = ((msg.words)[1]);
                ((_binding->rx_union).cap_send_request).cap = cap;
                
                FL_DEBUG("lmp RX monitor.cap_send_request\n");
                assert(((_binding->rx_vtbl).cap_send_request) != NULL);
                ((_binding->rx_vtbl).cap_send_request)(_binding, ((_binding->rx_union).cap_send_request).mon_id, ((_binding->rx_union).cap_send_request).cap, ((_binding->rx_union).cap_send_request).capid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_cap_move_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).cap_move_request).capid = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).cap_move_request).mon_id = ((msg.words)[1]);
                ((_binding->rx_union).cap_move_request).cap = cap;
                
                FL_DEBUG("lmp RX monitor.cap_move_request\n");
                assert(((_binding->rx_vtbl).cap_move_request) != NULL);
                ((_binding->rx_vtbl).cap_move_request)(_binding, ((_binding->rx_union).cap_move_request).mon_id, ((_binding->rx_union).cap_move_request).cap, ((_binding->rx_union).cap_move_request).capid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_cap_receive_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).cap_receive_request).capid = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).cap_receive_request).conn_id = ((msg.words)[1]);
                ((_binding->rx_union).cap_receive_request).err = ((msg.words)[2]);
                ((_binding->rx_union).cap_receive_request).cap = cap;
                
                FL_DEBUG("lmp RX monitor.cap_receive_request\n");
                assert(((_binding->rx_vtbl).cap_receive_request) != NULL);
                ((_binding->rx_vtbl).cap_receive_request)(_binding, ((_binding->rx_union).cap_receive_request).conn_id, ((_binding->rx_union).cap_receive_request).err, ((_binding->rx_union).cap_receive_request).cap, ((_binding->rx_union).cap_receive_request).capid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_span_domain_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).span_domain_request).core_id = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).span_domain_request).domain_id = ((msg.words)[1]);
                ((_binding->rx_union).span_domain_request).vroot = cap;
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).span_domain_request).disp = cap;
                
                FL_DEBUG("lmp RX monitor.span_domain_request\n");
                assert(((_binding->rx_vtbl).span_domain_request) != NULL);
                ((_binding->rx_vtbl).span_domain_request)(_binding, ((_binding->rx_union).span_domain_request).domain_id, ((_binding->rx_union).span_domain_request).core_id, ((_binding->rx_union).span_domain_request).vroot, ((_binding->rx_union).span_domain_request).disp);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_span_domain_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).span_domain_reply).err = ((msg.words)[1]);
                ((_binding->rx_union).span_domain_reply).domain_id = ((msg.words)[2]);
                
                FL_DEBUG("lmp RX monitor.span_domain_reply\n");
                assert(((_binding->rx_vtbl).span_domain_reply) != NULL);
                ((_binding->rx_vtbl).span_domain_reply)(_binding, ((_binding->rx_union).span_domain_reply).err, ((_binding->rx_union).span_domain_reply).domain_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_migrate_dispatcher_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).migrate_dispatcher_request).core_id = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).migrate_dispatcher_request).vroot = cap;
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).migrate_dispatcher_request).disp = cap;
                
                FL_DEBUG("lmp RX monitor.migrate_dispatcher_request\n");
                assert(((_binding->rx_vtbl).migrate_dispatcher_request) != NULL);
                ((_binding->rx_vtbl).migrate_dispatcher_request)(_binding, ((_binding->rx_union).migrate_dispatcher_request).core_id, ((_binding->rx_union).migrate_dispatcher_request).vroot, ((_binding->rx_union).migrate_dispatcher_request).disp);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_multihop_routing_table_new__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).multihop_routing_table_new).max_coreid = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).multihop_routing_table_new).nentries = ((((msg.words)[0]) >> 24) & 0xff);
                
                FL_DEBUG("lmp RX monitor.multihop_routing_table_new\n");
                assert(((_binding->rx_vtbl).multihop_routing_table_new) != NULL);
                ((_binding->rx_vtbl).multihop_routing_table_new)(_binding, ((_binding->rx_union).multihop_routing_table_new).max_coreid, ((_binding->rx_union).multihop_routing_table_new).nentries);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_multihop_routing_table_set__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).multihop_routing_table_set).from = ((((msg.words)[0]) >> 16) & 0xff);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                err = flounder_stub_lmp_recv_buf(&msg, (void **)(&(((_binding->rx_union).multihop_routing_table_set).to)), &(((_binding->rx_union).multihop_routing_table_set).len), &(_binding->rx_str_pos));
                if (err_is_ok(err)) {
                    FL_DEBUG("lmp RX monitor.multihop_routing_table_set\n");
                    assert(((_binding->rx_vtbl).multihop_routing_table_set) != NULL);
                    ((_binding->rx_vtbl).multihop_routing_table_set)(_binding, ((_binding->rx_union).multihop_routing_table_set).from, ((_binding->rx_union).multihop_routing_table_set).to, ((_binding->rx_union).multihop_routing_table_set).len);
                    _binding->rx_msgnum = 0;
                } else {
                    if (err_no(err) != FLOUNDER_ERR_BUF_RECV_MORE) {
                        (_binding->error_handler)(_binding, err);
                    }
                }
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_multihop_bind_client_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).multihop_bind_client_request).iref = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).multihop_bind_client_request).sender_vci = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor.multihop_bind_client_request\n");
                assert(((_binding->rx_vtbl).multihop_bind_client_request) != NULL);
                ((_binding->rx_vtbl).multihop_bind_client_request)(_binding, ((_binding->rx_union).multihop_bind_client_request).iref, ((_binding->rx_union).multihop_bind_client_request).sender_vci);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_multihop_bind_client_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).multihop_bind_client_reply).receiver_vci = ((msg.words)[1]);
                ((_binding->rx_union).multihop_bind_client_reply).sender_vci = ((msg.words)[2]);
                ((_binding->rx_union).multihop_bind_client_reply).err = ((msg.words)[3]);
                
                FL_DEBUG("lmp RX monitor.multihop_bind_client_reply\n");
                assert(((_binding->rx_vtbl).multihop_bind_client_reply) != NULL);
                ((_binding->rx_vtbl).multihop_bind_client_reply)(_binding, ((_binding->rx_union).multihop_bind_client_reply).receiver_vci, ((_binding->rx_union).multihop_bind_client_reply).sender_vci, ((_binding->rx_union).multihop_bind_client_reply).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_multihop_bind_service_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).multihop_bind_service_request).service_id = ((msg.words)[1]);
                ((_binding->rx_union).multihop_bind_service_request).sender_vci = ((msg.words)[2]);
                
                FL_DEBUG("lmp RX monitor.multihop_bind_service_request\n");
                assert(((_binding->rx_vtbl).multihop_bind_service_request) != NULL);
                ((_binding->rx_vtbl).multihop_bind_service_request)(_binding, ((_binding->rx_union).multihop_bind_service_request).service_id, ((_binding->rx_union).multihop_bind_service_request).sender_vci);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_multihop_bind_service_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).multihop_bind_service_reply).receiver_vci = ((msg.words)[1]);
                ((_binding->rx_union).multihop_bind_service_reply).sender_vci = ((msg.words)[2]);
                ((_binding->rx_union).multihop_bind_service_reply).err = ((msg.words)[3]);
                
                FL_DEBUG("lmp RX monitor.multihop_bind_service_reply\n");
                assert(((_binding->rx_vtbl).multihop_bind_service_reply) != NULL);
                ((_binding->rx_vtbl).multihop_bind_service_reply)(_binding, ((_binding->rx_union).multihop_bind_service_reply).receiver_vci, ((_binding->rx_union).multihop_bind_service_reply).sender_vci, ((_binding->rx_union).multihop_bind_service_reply).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_multihop_message__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).multihop_message).direction = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).multihop_message).flags = ((((msg.words)[0]) >> 24) & 0xff);
                ((_binding->rx_union).multihop_message).ack = ((((msg.words)[0]) >> 32) & 0xffffffff);
                ((_binding->rx_union).multihop_message).vci = ((msg.words)[1]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                err = flounder_stub_lmp_recv_buf(&msg, (void **)(&(((_binding->rx_union).multihop_message).payload)), &(((_binding->rx_union).multihop_message).size), &(_binding->rx_str_pos));
                if (err_is_ok(err)) {
                    FL_DEBUG("lmp RX monitor.multihop_message\n");
                    assert(((_binding->rx_vtbl).multihop_message) != NULL);
                    ((_binding->rx_vtbl).multihop_message)(_binding, ((_binding->rx_union).multihop_message).vci, ((_binding->rx_union).multihop_message).direction, ((_binding->rx_union).multihop_message).flags, ((_binding->rx_union).multihop_message).ack, ((_binding->rx_union).multihop_message).payload, ((_binding->rx_union).multihop_message).size);
                    _binding->rx_msgnum = 0;
                } else {
                    if (err_no(err) != FLOUNDER_ERR_BUF_RECV_MORE) {
                        (_binding->error_handler)(_binding, err);
                    }
                }
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_multihop_cap_send__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).multihop_cap_send).direction = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).multihop_cap_send).capid = ((((msg.words)[0]) >> 24) & 0xffffffff);
                ((_binding->rx_union).multihop_cap_send).vci = ((msg.words)[1]);
                ((_binding->rx_union).multihop_cap_send).err = ((msg.words)[2]);
                ((_binding->rx_union).multihop_cap_send).cap = cap;
                
                FL_DEBUG("lmp RX monitor.multihop_cap_send\n");
                assert(((_binding->rx_vtbl).multihop_cap_send) != NULL);
                ((_binding->rx_vtbl).multihop_cap_send)(_binding, ((_binding->rx_union).multihop_cap_send).vci, ((_binding->rx_union).multihop_cap_send).direction, ((_binding->rx_union).multihop_cap_send).err, ((_binding->rx_union).multihop_cap_send).cap, ((_binding->rx_union).multihop_cap_send).capid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_trace_prepare__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).trace_prepare).origin_core = ((((msg.words)[0]) >> 16) & 0xff);
                
                FL_DEBUG("lmp RX monitor.trace_prepare\n");
                assert(((_binding->rx_vtbl).trace_prepare) != NULL);
                ((_binding->rx_vtbl).trace_prepare)(_binding, ((_binding->rx_union).trace_prepare).origin_core);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_trace_prepare_finished__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX monitor.trace_prepare_finished\n");
                assert(((_binding->rx_vtbl).trace_prepare_finished) != NULL);
                ((_binding->rx_vtbl).trace_prepare_finished)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_bfscope_flush_send__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).bfscope_flush_send).iref = ((((msg.words)[0]) >> 16) & 0xffffffff);
                
                FL_DEBUG("lmp RX monitor.bfscope_flush_send\n");
                assert(((_binding->rx_vtbl).bfscope_flush_send) != NULL);
                ((_binding->rx_vtbl).bfscope_flush_send)(_binding, ((_binding->rx_union).bfscope_flush_send).iref);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_bfscope_flush_ack__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX monitor.bfscope_flush_ack\n");
                assert(((_binding->rx_vtbl).bfscope_flush_ack) != NULL);
                ((_binding->rx_vtbl).bfscope_flush_ack)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_migrate_dispatcher__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).migrate_dispatcher).domain_id = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor.migrate_dispatcher\n");
                assert(((_binding->rx_vtbl).migrate_dispatcher) != NULL);
                ((_binding->rx_vtbl).migrate_dispatcher)(_binding, ((_binding->rx_union).migrate_dispatcher).domain_id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        default:
            (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_MSGNUM);
            goto out;
        }
    } while (err_is_ok(err));
    out:
    // re-register for another receive notification
    err = lmp_chan_register_recv(&(b->chan), _binding->waitset, recv_closure);
    assert(err_is_ok(err));
}


/*
 * Control functions
 */
static  bool monitor_lmp_can_send(struct monitor_binding *b)
{
    return((b->tx_msgnum) == 0);
}

static  errval_t monitor_lmp_register_send(struct monitor_binding *b, struct waitset *ws, struct event_closure _continuation)
{
    return(flounder_support_register(ws, &(b->register_chanstate), _continuation, monitor_lmp_can_send(b)));
}

static  void monitor_lmp_default_error_handler(struct monitor_binding *b, errval_t err)
{
    DEBUG_ERR(err, "asynchronous error in Flounder-generated monitor lmp binding (default handler)");
    abort();
}

static  errval_t monitor_lmp_change_waitset(struct monitor_binding *_binding, struct waitset *ws)
{
    struct monitor_lmp_binding *b = (void *)(_binding);
    
    // Migrate register and TX continuation notifications
    flounder_support_migrate_notify(&(_binding->register_chanstate), ws);
    flounder_support_migrate_notify(&(_binding->tx_cont_chanstate), ws);
    
    // change waitset on binding
    _binding->waitset = ws;
    
    // Migrate send and receive notifications
    lmp_chan_migrate_recv(&(b->chan), ws);
    lmp_chan_migrate_send(&(b->chan), ws);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_lmp_control(struct monitor_binding *_binding, idc_control_t control)
{
    struct monitor_lmp_binding *b = (void *)(_binding);
    
    b->flags = idc_control_to_lmp_flags(control, b->flags);
    
    return(SYS_ERR_OK);
}

/*
 * Functions to initialise/destroy the binding state
 */
 void monitor_lmp_init(struct monitor_lmp_binding *b, struct waitset *waitset)
{
    (b->b).st = NULL;
    (b->b).waitset = waitset;
    event_mutex_init(&((b->b).mutex), waitset);
    (b->b).can_send = monitor_lmp_can_send;
    (b->b).register_send = monitor_lmp_register_send;
    (b->b).error_handler = monitor_lmp_default_error_handler;
    (b->b).tx_vtbl = monitor_lmp_tx_vtbl;
    memset(&((b->b).rx_vtbl), 0, sizeof((b->b).rx_vtbl));
    flounder_support_waitset_chanstate_init(&((b->b).register_chanstate));
    flounder_support_waitset_chanstate_init(&((b->b).tx_cont_chanstate));
    (b->b).tx_msgnum = 0;
    (b->b).rx_msgnum = 0;
    (b->b).tx_msg_fragment = 0;
    (b->b).rx_msg_fragment = 0;
    (b->b).tx_str_pos = 0;
    (b->b).rx_str_pos = 0;
    (b->b).tx_str_len = 0;
    (b->b).rx_str_len = 0;
    (b->b).bind_cont = NULL;
    lmp_chan_init(&(b->chan));
    (b->b).change_waitset = monitor_lmp_change_waitset;
    (b->b).control = monitor_lmp_control;
    b->flags = LMP_SEND_FLAGS_DEFAULT;
}

 void monitor_lmp_destroy(struct monitor_lmp_binding *b)
{
    flounder_support_waitset_chanstate_destroy(&((b->b).register_chanstate));
    flounder_support_waitset_chanstate_destroy(&((b->b).tx_cont_chanstate));
    lmp_chan_destroy(&(b->chan));
}


/*
 * Bind function
 */
static  void monitor_lmp_bind_continuation(void *st, errval_t err, struct lmp_chan *chan)
{
    struct monitor_lmp_binding *b = st;
    
    if (err_is_ok(err)) {
        // allocate a cap receive slot
        err = lmp_chan_alloc_recv_slot(chan);
        if (err_is_fail(err)) {
            err = err_push(err, LIB_ERR_LMP_ALLOC_RECV_SLOT);
            goto fail;
        }
        
        // register for receive
        err = lmp_chan_register_recv(chan, (b->b).waitset, (struct event_closure){  .handler = monitor_lmp_rx_handler,  .arg = b });
        if (err_is_fail(err)) {
            err = err_push(err, LIB_ERR_CHAN_REGISTER_RECV);
            goto fail;
        }
    } else {
        fail:
        monitor_lmp_destroy(b);
    }
    
    ((b->b).bind_cont)((b->b).st, err, &(b->b));
}

 errval_t monitor_lmp_bind(struct monitor_lmp_binding *b, iref_t iref, monitor_bind_continuation_fn *_continuation, void *st, struct waitset *waitset, idc_bind_flags_t flags, size_t lmp_buflen)
{
    errval_t err;
    monitor_lmp_init(b, waitset);
    (b->b).st = st;
    (b->b).bind_cont = _continuation;
    err = lmp_chan_bind(&(b->chan), (struct lmp_bind_continuation){  .handler = monitor_lmp_bind_continuation,  .st = b }, &((b->b).event_qnode), iref, lmp_buflen);
    if (err_is_fail(err)) {
        monitor_lmp_destroy(b);
    }
    return(err);
}


/*
 * Connect callback for export
 */
 errval_t monitor_lmp_connect_handler(void *st, size_t buflen_words, struct capref endpoint, struct lmp_chan **retchan)
{
    struct monitor_export *e = st;
    errval_t err;
    
    // allocate storage for binding
    struct monitor_lmp_binding *b = malloc(sizeof(struct monitor_lmp_binding ));
    if (b == NULL) {
        return(LIB_ERR_MALLOC_FAIL);
    }
    
    struct monitor_binding *_binding = &(b->b);
    monitor_lmp_init(b, e->waitset);
    
    // run user's connect handler
    assert(e->connect_cb);
    err = ((e->connect_cb)(e->st, _binding));
    if (err_is_fail(err)) {
        // connection refused
        monitor_lmp_destroy(b);
        return(err);
    }
    
    // accept the connection and setup the channel
    // FIXME: user policy needed to decide on the size of the message buffer?
    err = lmp_chan_accept(&(b->chan), buflen_words, endpoint);
    if (err_is_fail(err)) {
        err = err_push(err, LIB_ERR_LMP_CHAN_ACCEPT);
        (_binding->error_handler)(_binding, err);
        return(err);
    }
    
    // allocate a cap receive slot
    err = lmp_chan_alloc_recv_slot(&(b->chan));
    if (err_is_fail(err)) {
        err = err_push(err, LIB_ERR_LMP_ALLOC_RECV_SLOT);
        (_binding->error_handler)(_binding, err);
        return(err);
    }
    
    // register for receive
    err = lmp_chan_register_recv(&(b->chan), _binding->waitset, (struct event_closure){  .handler = monitor_lmp_rx_handler,  .arg = b });
    if (err_is_fail(err)) {
        err = err_push(err, LIB_ERR_CHAN_REGISTER_RECV);
        (_binding->error_handler)(_binding, err);
        return(err);
    }
    
    *retchan = (&(b->chan));
    
    return(SYS_ERR_OK);
}

