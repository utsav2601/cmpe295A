/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: usb_manager
 * INTEFACE FILE: ../if/usb_manager.if
 * INTERFACE DESCRIPTION: USB Manager Interface
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

/*
 * Generated Stub for RPC
 */

#include <barrelfish/barrelfish.h>
#include <flounder/flounder_support.h>
#include <if/usb_manager_rpcclient_defs.h>

/*
 * RPC wrapper functions
 */
static  errval_t usb_manager_connect__rpc(struct usb_manager_rpc_client *_rpc, iref_t driver_iref, uint16_t init_config, uint32_t *ret_error, uint8_t **ret_desc, size_t *length)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).connect_call)(_rpc->b, NOP_CONT, driver_iref, init_config));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *ret_error = (((_binding->rx_union).connect_response).ret_error);
    *ret_desc = (((_binding->rx_union).connect_response).ret_desc);
    *length = (((_binding->rx_union).connect_response).length);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_device_disconnect_notify__rpc(struct usb_manager_rpc_client *_rpc)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).device_disconnect_notify_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_request_read__rpc(struct usb_manager_rpc_client *_rpc, const uint8_t *request, size_t req_length, uint8_t **data, size_t *data_length, uint32_t *ret_status)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).request_read_call)(_rpc->b, NOP_CONT, request, req_length));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *data = (((_binding->rx_union).request_read_response).data);
    *data_length = (((_binding->rx_union).request_read_response).data_length);
    *ret_status = (((_binding->rx_union).request_read_response).ret_status);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_request_write__rpc(struct usb_manager_rpc_client *_rpc, const uint8_t *request, size_t req_length, const uint8_t *data, size_t data_length, uint32_t *ret_status)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).request_write_call)(_rpc->b, NOP_CONT, request, req_length, data, data_length));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *ret_status = (((_binding->rx_union).request_write_response).ret_status);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_request__rpc(struct usb_manager_rpc_client *_rpc, const uint8_t *request, size_t req_length, uint32_t *ret_status)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).request_call)(_rpc->b, NOP_CONT, request, req_length));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *ret_status = (((_binding->rx_union).request_response).ret_status);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_transfer_setup__rpc(struct usb_manager_rpc_client *_rpc, uint8_t type, usb_manager_setup_param_t params, uint32_t *ret_error, uint32_t *ret_tid)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).transfer_setup_call)(_rpc->b, NOP_CONT, type, params));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *ret_error = (((_binding->rx_union).transfer_setup_response).ret_error);
    *ret_tid = (((_binding->rx_union).transfer_setup_response).ret_tid);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_transfer_unsetup__rpc(struct usb_manager_rpc_client *_rpc, uint32_t tid, uint32_t *ret_error)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).transfer_unsetup_call)(_rpc->b, NOP_CONT, tid));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *ret_error = (((_binding->rx_union).transfer_unsetup_response).ret_error);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_transfer_start__rpc(struct usb_manager_rpc_client *_rpc, uint32_t tid, uint32_t *ret_error)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).transfer_start_call)(_rpc->b, NOP_CONT, tid));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *ret_error = (((_binding->rx_union).transfer_start_response).ret_error);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_transfer_stop__rpc(struct usb_manager_rpc_client *_rpc, uint32_t tid, uint32_t *ret_error)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).transfer_stop_call)(_rpc->b, NOP_CONT, tid));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *ret_error = (((_binding->rx_union).transfer_stop_response).ret_error);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_transfer_status__rpc(struct usb_manager_rpc_client *_rpc, uint32_t tid, uint32_t *ret_error, uint32_t *ret_actlen, uint32_t *ret_length, uint32_t *ret_actframes, uint32_t *ret_numframes)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).transfer_status_call)(_rpc->b, NOP_CONT, tid));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *ret_error = (((_binding->rx_union).transfer_status_response).ret_error);
    *ret_actlen = (((_binding->rx_union).transfer_status_response).ret_actlen);
    *ret_length = (((_binding->rx_union).transfer_status_response).ret_length);
    *ret_actframes = (((_binding->rx_union).transfer_status_response).ret_actframes);
    *ret_numframes = (((_binding->rx_union).transfer_status_response).ret_numframes);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_transfer_state__rpc(struct usb_manager_rpc_client *_rpc, uint32_t tid, uint32_t *ret_error, uint32_t *ret_state)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).transfer_state_call)(_rpc->b, NOP_CONT, tid));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *ret_error = (((_binding->rx_union).transfer_state_response).ret_error);
    *ret_state = (((_binding->rx_union).transfer_state_response).ret_state);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_transfer_clear_stall__rpc(struct usb_manager_rpc_client *_rpc, uint32_t tid, uint32_t *ret_error)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).transfer_clear_stall_call)(_rpc->b, NOP_CONT, tid));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *ret_error = (((_binding->rx_union).transfer_clear_stall_response).ret_error);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_transfer_done_notify__rpc(struct usb_manager_rpc_client *_rpc, uint32_t *tid, uint32_t *error, uint8_t **data, size_t *length)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).transfer_done_notify_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *tid = (((_binding->rx_union).transfer_done_notify_response).tid);
    *error = (((_binding->rx_union).transfer_done_notify_response).error);
    *data = (((_binding->rx_union).transfer_done_notify_response).data);
    *length = (((_binding->rx_union).transfer_done_notify_response).length);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_device_get_speed__rpc(struct usb_manager_rpc_client *_rpc, uint8_t *ret_speed)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).device_get_speed_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *ret_speed = (((_binding->rx_union).device_get_speed_response).ret_speed);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_device_get_state__rpc(struct usb_manager_rpc_client *_rpc, uint8_t *ret_state)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).device_get_state_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *ret_state = (((_binding->rx_union).device_get_state_response).ret_state);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_device_suspend__rpc(struct usb_manager_rpc_client *_rpc, uint32_t *ret_error)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).device_suspend_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *ret_error = (((_binding->rx_union).device_suspend_response).ret_error);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_device_resume__rpc(struct usb_manager_rpc_client *_rpc, uint32_t *ret_error)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).device_resume_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *ret_error = (((_binding->rx_union).device_resume_response).ret_error);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t usb_manager_device_powersave__rpc(struct usb_manager_rpc_client *_rpc, uint8_t powerstate, uint32_t *ret_error)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).device_powersave_call)(_rpc->b, NOP_CONT, powerstate));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct usb_manager_binding *_binding = _rpc->b;
    *ret_error = (((_binding->rx_union).device_powersave_response).ret_error);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}


/*
 * Receive handlers
 */
static  void usb_manager_connect__rpc_rx_handler(struct usb_manager_binding *_binding, uint32_t ret_error, uint8_t *ret_desc, size_t length)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).connect_response).ret_error = ret_error;
    ((_binding->rx_union).connect_response).ret_desc = ret_desc;
    ((_binding->rx_union).connect_response).length = length;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_device_disconnect_notify__rpc_rx_handler(struct usb_manager_binding *_binding)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_request_read__rpc_rx_handler(struct usb_manager_binding *_binding, uint8_t *data, size_t data_length, uint32_t ret_status)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).request_read_response).data = data;
    ((_binding->rx_union).request_read_response).data_length = data_length;
    ((_binding->rx_union).request_read_response).ret_status = ret_status;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_request_write__rpc_rx_handler(struct usb_manager_binding *_binding, uint32_t ret_status)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).request_write_response).ret_status = ret_status;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_request__rpc_rx_handler(struct usb_manager_binding *_binding, uint32_t ret_status)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).request_response).ret_status = ret_status;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_transfer_setup__rpc_rx_handler(struct usb_manager_binding *_binding, uint32_t ret_error, uint32_t ret_tid)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).transfer_setup_response).ret_error = ret_error;
    ((_binding->rx_union).transfer_setup_response).ret_tid = ret_tid;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_transfer_unsetup__rpc_rx_handler(struct usb_manager_binding *_binding, uint32_t ret_error)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).transfer_unsetup_response).ret_error = ret_error;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_transfer_start__rpc_rx_handler(struct usb_manager_binding *_binding, uint32_t ret_error)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).transfer_start_response).ret_error = ret_error;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_transfer_stop__rpc_rx_handler(struct usb_manager_binding *_binding, uint32_t ret_error)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).transfer_stop_response).ret_error = ret_error;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_transfer_status__rpc_rx_handler(struct usb_manager_binding *_binding, uint32_t ret_error, uint32_t ret_actlen, uint32_t ret_length, uint32_t ret_actframes, uint32_t ret_numframes)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).transfer_status_response).ret_error = ret_error;
    ((_binding->rx_union).transfer_status_response).ret_actlen = ret_actlen;
    ((_binding->rx_union).transfer_status_response).ret_length = ret_length;
    ((_binding->rx_union).transfer_status_response).ret_actframes = ret_actframes;
    ((_binding->rx_union).transfer_status_response).ret_numframes = ret_numframes;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_transfer_state__rpc_rx_handler(struct usb_manager_binding *_binding, uint32_t ret_error, uint32_t ret_state)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).transfer_state_response).ret_error = ret_error;
    ((_binding->rx_union).transfer_state_response).ret_state = ret_state;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_transfer_clear_stall__rpc_rx_handler(struct usb_manager_binding *_binding, uint32_t ret_error)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).transfer_clear_stall_response).ret_error = ret_error;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_transfer_done_notify__rpc_rx_handler(struct usb_manager_binding *_binding, uint32_t tid, uint32_t error, uint8_t *data, size_t length)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).transfer_done_notify_response).tid = tid;
    ((_binding->rx_union).transfer_done_notify_response).error = error;
    ((_binding->rx_union).transfer_done_notify_response).data = data;
    ((_binding->rx_union).transfer_done_notify_response).length = length;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_device_get_speed__rpc_rx_handler(struct usb_manager_binding *_binding, uint8_t ret_speed)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).device_get_speed_response).ret_speed = ret_speed;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_device_get_state__rpc_rx_handler(struct usb_manager_binding *_binding, uint8_t ret_state)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).device_get_state_response).ret_state = ret_state;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_device_suspend__rpc_rx_handler(struct usb_manager_binding *_binding, uint32_t ret_error)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).device_suspend_response).ret_error = ret_error;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_device_resume__rpc_rx_handler(struct usb_manager_binding *_binding, uint32_t ret_error)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).device_resume_response).ret_error = ret_error;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void usb_manager_device_powersave__rpc_rx_handler(struct usb_manager_binding *_binding, uint32_t ret_error)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).device_powersave_response).ret_error = ret_error;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}


/*
 * RPC Vtable
 */
static  struct usb_manager_rpc_vtbl usb_manager_rpc_vtbl = {
    .connect = usb_manager_connect__rpc,
    .device_disconnect_notify = usb_manager_device_disconnect_notify__rpc,
    .request_read = usb_manager_request_read__rpc,
    .request_write = usb_manager_request_write__rpc,
    .request = usb_manager_request__rpc,
    .transfer_setup = usb_manager_transfer_setup__rpc,
    .transfer_unsetup = usb_manager_transfer_unsetup__rpc,
    .transfer_start = usb_manager_transfer_start__rpc,
    .transfer_stop = usb_manager_transfer_stop__rpc,
    .transfer_status = usb_manager_transfer_status__rpc,
    .transfer_state = usb_manager_transfer_state__rpc,
    .transfer_clear_stall = usb_manager_transfer_clear_stall__rpc,
    .transfer_done_notify = usb_manager_transfer_done_notify__rpc,
    .device_get_speed = usb_manager_device_get_speed__rpc,
    .device_get_state = usb_manager_device_get_state__rpc,
    .device_suspend = usb_manager_device_suspend__rpc,
    .device_resume = usb_manager_device_resume__rpc,
    .device_powersave = usb_manager_device_powersave__rpc,
};

/*
 * Error handler
 */
static  void usb_manager_rpc_client_error(struct usb_manager_binding *_binding, errval_t _err)
{
    // get RPC client state pointer
    struct usb_manager_rpc_client *_rpc = _binding->st;
    
    if (_rpc->rpc_in_progress) {
        assert(err_is_fail(_err));
        _rpc->async_error = _err;
        // kick waitset with dummy event
        flounder_support_register(&(_rpc->rpc_waitset), &(_rpc->dummy_chanstate), dummy_event_closure, true);
    } else {
        USER_PANIC_ERR(_err, "async error in RPC");
    }
}


/*
 * Init function
 */
 errval_t usb_manager_rpc_client_init(struct usb_manager_rpc_client *rpc, struct usb_manager_binding *binding)
{
    errval_t _err;
    
    // Setup state of RPC client object
    rpc->b = binding;
    rpc->reply_present = false;
    rpc->rpc_in_progress = false;
    rpc->async_error = SYS_ERR_OK;
    waitset_init(&(rpc->rpc_waitset));
    flounder_support_waitset_chanstate_init(&(rpc->dummy_chanstate));
    rpc->vtbl = usb_manager_rpc_vtbl;
    binding->st = rpc;
    
    // Change waitset on binding
    _err = ((binding->change_waitset)(binding, &(rpc->rpc_waitset)));
    if (err_is_fail(_err)) {
        waitset_destroy(&(rpc->rpc_waitset));
        return(err_push(_err, FLOUNDER_ERR_CHANGE_WAITSET));
    }
    
    // Set RX handlers on binding object for RPCs
    (binding->rx_vtbl).connect_response = usb_manager_connect__rpc_rx_handler;
    (binding->rx_vtbl).device_disconnect_notify_response = usb_manager_device_disconnect_notify__rpc_rx_handler;
    (binding->rx_vtbl).request_read_response = usb_manager_request_read__rpc_rx_handler;
    (binding->rx_vtbl).request_write_response = usb_manager_request_write__rpc_rx_handler;
    (binding->rx_vtbl).request_response = usb_manager_request__rpc_rx_handler;
    (binding->rx_vtbl).transfer_setup_response = usb_manager_transfer_setup__rpc_rx_handler;
    (binding->rx_vtbl).transfer_unsetup_response = usb_manager_transfer_unsetup__rpc_rx_handler;
    (binding->rx_vtbl).transfer_start_response = usb_manager_transfer_start__rpc_rx_handler;
    (binding->rx_vtbl).transfer_stop_response = usb_manager_transfer_stop__rpc_rx_handler;
    (binding->rx_vtbl).transfer_status_response = usb_manager_transfer_status__rpc_rx_handler;
    (binding->rx_vtbl).transfer_state_response = usb_manager_transfer_state__rpc_rx_handler;
    (binding->rx_vtbl).transfer_clear_stall_response = usb_manager_transfer_clear_stall__rpc_rx_handler;
    (binding->rx_vtbl).transfer_done_notify_response = usb_manager_transfer_done_notify__rpc_rx_handler;
    (binding->rx_vtbl).device_get_speed_response = usb_manager_device_get_speed__rpc_rx_handler;
    (binding->rx_vtbl).device_get_state_response = usb_manager_device_get_state__rpc_rx_handler;
    (binding->rx_vtbl).device_suspend_response = usb_manager_device_suspend__rpc_rx_handler;
    (binding->rx_vtbl).device_resume_response = usb_manager_device_resume__rpc_rx_handler;
    (binding->rx_vtbl).device_powersave_response = usb_manager_device_powersave__rpc_rx_handler;
    
    // Set error handler on binding object
    binding->error_handler = usb_manager_rpc_client_error;
    
    return(SYS_ERR_OK);
}

