/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: virtio
 * INTEFACE FILE: ../if/virtio.if
 * INTERFACE DESCRIPTION: VirtIO Interface
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

/*
 * Generated Loopback stub
 */

#define _USE_XOPEN /* for strdup() */
#include <string.h>
#include <barrelfish/barrelfish.h>
#include <flounder/flounder_support.h>
#include <if/virtio_defs.h>
#include <if/virtio_loopback_defs.h>

/*
 * Message sender functions
 */
static  errval_t virtio_open_call__loopback_send(struct virtio_binding *_binding, struct event_closure _continuation, uint8_t backend)
{
    // call rx handler
    assert(((_binding->rx_vtbl).open_call) != NULL);
    ((_binding->rx_vtbl).open_call)(_binding, backend);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t virtio_open_response__loopback_send(struct virtio_binding *_binding, struct event_closure _continuation, virtio_errval_t err, struct capref devframe)
{
    // call rx handler
    assert(((_binding->rx_vtbl).open_response) != NULL);
    ((_binding->rx_vtbl).open_response)(_binding, err, devframe);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t virtio_close_call__loopback_send(struct virtio_binding *_binding, struct event_closure _continuation)
{
    // call rx handler
    assert(((_binding->rx_vtbl).close_call) != NULL);
    ((_binding->rx_vtbl).close_call)(_binding);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t virtio_close_response__loopback_send(struct virtio_binding *_binding, struct event_closure _continuation)
{
    // call rx handler
    assert(((_binding->rx_vtbl).close_response) != NULL);
    ((_binding->rx_vtbl).close_response)(_binding);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t virtio_add_call__loopback_send(struct virtio_binding *_binding, struct event_closure _continuation, uint16_t vq_id, uint16_t ndesc, uint8_t has_buffers, struct capref vring)
{
    // call rx handler
    assert(((_binding->rx_vtbl).add_call) != NULL);
    ((_binding->rx_vtbl).add_call)(_binding, vq_id, ndesc, has_buffers, vring);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t virtio_add_response__loopback_send(struct virtio_binding *_binding, struct event_closure _continuation, virtio_errval_t err)
{
    // call rx handler
    assert(((_binding->rx_vtbl).add_response) != NULL);
    ((_binding->rx_vtbl).add_response)(_binding, err);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t virtio_extend_call__loopback_send(struct virtio_binding *_binding, struct event_closure _continuation, uint16_t vq_id, struct capref vbuf)
{
    // call rx handler
    assert(((_binding->rx_vtbl).extend_call) != NULL);
    ((_binding->rx_vtbl).extend_call)(_binding, vq_id, vbuf);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t virtio_extend_response__loopback_send(struct virtio_binding *_binding, struct event_closure _continuation, virtio_errval_t err)
{
    // call rx handler
    assert(((_binding->rx_vtbl).extend_response) != NULL);
    ((_binding->rx_vtbl).extend_response)(_binding, err);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t virtio_req_call__loopback_send(struct virtio_binding *_binding, struct event_closure _continuation, uint64_t size)
{
    // call rx handler
    assert(((_binding->rx_vtbl).req_call) != NULL);
    ((_binding->rx_vtbl).req_call)(_binding, size);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t virtio_req_response__loopback_send(struct virtio_binding *_binding, struct event_closure _continuation, virtio_errval_t err, struct capref vring)
{
    // call rx handler
    assert(((_binding->rx_vtbl).req_response) != NULL);
    ((_binding->rx_vtbl).req_response)(_binding, err, vring);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}


/*
 * Send vtable
 */
static  struct virtio_tx_vtbl virtio_loopback_tx_vtbl = {
    .open_call = virtio_open_call__loopback_send,
    .open_response = virtio_open_response__loopback_send,
    .close_call = virtio_close_call__loopback_send,
    .close_response = virtio_close_response__loopback_send,
    .add_call = virtio_add_call__loopback_send,
    .add_response = virtio_add_response__loopback_send,
    .extend_call = virtio_extend_call__loopback_send,
    .extend_response = virtio_extend_response__loopback_send,
    .req_call = virtio_req_call__loopback_send,
    .req_response = virtio_req_response__loopback_send,
};
/*
 * Control functions
 */
static  bool virtio_loopback_can_send(struct virtio_binding *b)
{
    return(true);
}

static  errval_t virtio_loopback_register_send(struct virtio_binding *b, struct waitset *ws, struct event_closure _continuation)
{
    return(ERR_NOTIMP);
}

static  void virtio_loopback_default_error_handler(struct virtio_binding *b, errval_t err)
{
    DEBUG_ERR(err, "asynchronous error in Flounder-generated virtio loopback binding (default handler)");
    abort();
}

static  errval_t virtio_loopback_change_waitset(struct virtio_binding *_binding, struct waitset *ws)
{
    return(ERR_NOTIMP);
}

static  errval_t virtio_loopback_control(struct virtio_binding *_binding, idc_control_t control)
{
    // no control flags are supported
    return(SYS_ERR_OK);
}

/*
 * Function to initialise the binding state
 */
 void virtio_loopback_init(struct virtio_binding *_binding)
{
    (*_binding).st = NULL;
    (*_binding).waitset = NULL;
    event_mutex_init(&((*_binding).mutex), NULL);
    (*_binding).can_send = virtio_loopback_can_send;
    (*_binding).register_send = virtio_loopback_register_send;
    (*_binding).error_handler = virtio_loopback_default_error_handler;
    (*_binding).tx_vtbl = virtio_loopback_tx_vtbl;
    memset(&((*_binding).rx_vtbl), 0, sizeof((*_binding).rx_vtbl));
    flounder_support_waitset_chanstate_init(&((*_binding).register_chanstate));
    flounder_support_waitset_chanstate_init(&((*_binding).tx_cont_chanstate));
    (*_binding).tx_msgnum = 0;
    (*_binding).rx_msgnum = 0;
    (*_binding).tx_msg_fragment = 0;
    (*_binding).rx_msg_fragment = 0;
    (*_binding).tx_str_pos = 0;
    (*_binding).rx_str_pos = 0;
    (*_binding).tx_str_len = 0;
    (*_binding).rx_str_len = 0;
    (*_binding).bind_cont = NULL;
    _binding->change_waitset = virtio_loopback_change_waitset;
    _binding->control = virtio_loopback_control;
}

