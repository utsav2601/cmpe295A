/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: xmplthc
 * INTEFACE FILE: ../if/xmplthc.if
 * INTERFACE DESCRIPTION: Example thc interface
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

#include <stddef.h>
#ifdef BARRELFISH
#include <barrelfish/barrelfish.h>
#include <barrelfish/nameservice_client.h>
#include "if/xmplthc_thc.h"
#include "thc/thc.h"
#else
#include "xmplthc_thc.h"
#include "thc.h"
#endif // BARRELFISH

/*
 * Send functions
 */
static  errval_t xmplthc_client_mymsg__send(struct xmplthc_thc_client_binding_t *_thc_binding, int32_t i)
{
    struct xmplthc_binding *_idc_binding = (struct xmplthc_binding *)(_thc_binding->_c2s_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mymsg)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), i);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t xmplthc_client_mycall__send(struct xmplthc_thc_client_binding_t *_thc_binding, int32_t i)
{
    struct xmplthc_binding *_idc_binding = (struct xmplthc_binding *)(_thc_binding->_c2s_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mycall)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), i);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t xmplthc_client_myrpc__send(struct xmplthc_thc_client_binding_t *_thc_binding, int32_t i)
{
    struct xmplthc_binding *_idc_binding = (struct xmplthc_binding *)(_thc_binding->_c2s_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).myrpc_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), i);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t xmplthc_service_mymsg__send(struct xmplthc_thc_service_binding_t *_thc_binding, int32_t i)
{
    struct xmplthc_binding *_idc_binding = (struct xmplthc_binding *)(_thc_binding->_s2c_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mymsg)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), i);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t xmplthc_service_myresponse__send(struct xmplthc_thc_service_binding_t *_thc_binding, const char *s)
{
    struct xmplthc_binding *_idc_binding = (struct xmplthc_binding *)(_thc_binding->_s2c_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).myresponse)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), s);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t xmplthc_service_myrpc__send(struct xmplthc_thc_service_binding_t *_thc_binding, const char *s)
{
    struct xmplthc_binding *_idc_binding = (struct xmplthc_binding *)(_thc_binding->_s2c_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).myrpc_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), s);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t xmplthc_client_mymsg__send_x(struct xmplthc_thc_client_binding_t *_thc_binding, int32_t i)
{
    struct xmplthc_binding *_idc_binding = (struct xmplthc_binding *)(_thc_binding->_c2s_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mymsg)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), i);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t xmplthc_client_mycall__send_x(struct xmplthc_thc_client_binding_t *_thc_binding, int32_t i)
{
    struct xmplthc_binding *_idc_binding = (struct xmplthc_binding *)(_thc_binding->_c2s_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mycall)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), i);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t xmplthc_client_myrpc__send_x(struct xmplthc_thc_client_binding_t *_thc_binding, int32_t i)
{
    struct xmplthc_binding *_idc_binding = (struct xmplthc_binding *)(_thc_binding->_c2s_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).myrpc_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), i);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t xmplthc_service_mymsg__send_x(struct xmplthc_thc_service_binding_t *_thc_binding, int32_t i)
{
    struct xmplthc_binding *_idc_binding = (struct xmplthc_binding *)(_thc_binding->_s2c_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mymsg)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), i);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t xmplthc_service_myresponse__send_x(struct xmplthc_thc_service_binding_t *_thc_binding, const char *s)
{
    struct xmplthc_binding *_idc_binding = (struct xmplthc_binding *)(_thc_binding->_s2c_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).myresponse)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), s);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t xmplthc_service_myrpc__send_x(struct xmplthc_thc_service_binding_t *_thc_binding, const char *s)
{
    struct xmplthc_binding *_idc_binding = (struct xmplthc_binding *)(_thc_binding->_s2c_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).myrpc_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), s);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}



/*
 * Struct type for holding pointers to the args for each msg
 */
struct xmplthc_mymsg__ptr_args_t {
    int32_t *i;
};
struct xmplthc_mycall__ptr_args_t {
    int32_t *i;
};
struct xmplthc_myresponse__ptr_args_t {
    char **s;
};
struct xmplthc_myrpc__in_ptr_args_t {
    int32_t *i;
};
struct xmplthc_myrpc__out_ptr_args_t {
    char **s;
};
union xmplthc_myrpc___ptr_union_t {
    struct xmplthc_myrpc__in_ptr_args_t in;
    struct xmplthc_myrpc__out_ptr_args_t out;
};

/*
 * Struct type for Receive-any and Bottom-half receive functions to hold pointers-to-message-argument structs
 */
struct xmplthc_thc_ptr_arg_struct {
    struct xmplthc_mymsg__ptr_args_t mymsg;
    struct xmplthc_mycall__ptr_args_t mycall;
    struct xmplthc_myresponse__ptr_args_t myresponse;
    union xmplthc_myrpc___ptr_union_t myrpc;
};

/*
 * Receive functions
 */
static  errval_t xmplthc_client_mymsg__recv(struct xmplthc_thc_client_binding_t *_thc_binding, int32_t *i)
{
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    (_args.mymsg).i = i;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    return(thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_mymsg]), &_rxi));
}

static  errval_t xmplthc_client_myresponse__recv(struct xmplthc_thc_client_binding_t *_thc_binding, char **s)
{
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    (_args.myresponse).s = s;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    return(thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myresponse]), &_rxi));
}

static  errval_t xmplthc_client_myrpc__recv(struct xmplthc_thc_client_binding_t *_thc_binding, char **s)
{
    errval_t _result;
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.myrpc).out).s = s;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]), &_rxi);
    return(_result);
}

static  errval_t xmplthc_service_mymsg__recv(struct xmplthc_thc_service_binding_t *_thc_binding, int32_t *i)
{
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    (_args.mymsg).i = i;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    return(thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_mymsg]), &_rxi));
}

static  errval_t xmplthc_service_mycall__recv(struct xmplthc_thc_service_binding_t *_thc_binding, int32_t *i)
{
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    (_args.mycall).i = i;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    return(thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_mycall]), &_rxi));
}

static  errval_t xmplthc_service_myrpc__recv(struct xmplthc_thc_service_binding_t *_thc_binding, int32_t *i)
{
    errval_t _result;
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.myrpc).in).i = i;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_myrpc]), &_rxi);
    return(_result);
}

static  errval_t xmplthc_client_mymsg__recv_x(struct xmplthc_thc_client_binding_t *_thc_binding, int32_t *i)
{
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    (_args.mymsg).i = i;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    return(thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_mymsg]), &_rxi));
}

static  errval_t xmplthc_client_myresponse__recv_x(struct xmplthc_thc_client_binding_t *_thc_binding, char **s)
{
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    (_args.myresponse).s = s;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    return(thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myresponse]), &_rxi));
}

static  errval_t xmplthc_client_myrpc__recv_x(struct xmplthc_thc_client_binding_t *_thc_binding, char **s)
{
    errval_t _result;
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.myrpc).out).s = s;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]), &_rxi);
    return(_result);
}

static  errval_t xmplthc_service_mymsg__recv_x(struct xmplthc_thc_service_binding_t *_thc_binding, int32_t *i)
{
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    (_args.mymsg).i = i;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    return(thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_mymsg]), &_rxi));
}

static  errval_t xmplthc_service_mycall__recv_x(struct xmplthc_thc_service_binding_t *_thc_binding, int32_t *i)
{
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    (_args.mycall).i = i;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    return(thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_mycall]), &_rxi));
}

static  errval_t xmplthc_service_myrpc__recv_x(struct xmplthc_thc_service_binding_t *_thc_binding, int32_t *i)
{
    errval_t _result;
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.myrpc).in).i = i;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_myrpc]), &_rxi);
    return(_result);
}


/*
 * Receive-any functions
 */
static  errval_t xmplthc_recv_any__thc_client_fn(xmplthc_thc_client_binding_t *_thc_binding, struct xmplthc_client_msg *msg, struct xmplthc_client_selector ops)
{
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    errval_t _r = 0;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = ((int *)(&(msg->msg)));
    thc_start_receive_any(&(_thc_binding->thc_per_binding));
    if ((ops.mymsg) != 0) {
        (_args.mymsg).i = (&(((msg->args).mymsg).i));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_mymsg]), &_rxi);
    }
    if ((ops.myresponse) != 0) {
        (_args.myresponse).s = (&(((msg->args).myresponse).s));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myresponse]), &_rxi);
    }
    if ((ops.myrpc) != 0) {
        ((_args.myrpc).out).s = (&((((msg->args).myrpc).out).s));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]), &_rxi);
    }
    thc_wait_receive_any(&(_thc_binding->thc_per_binding), &_rxi);
    if ((ops.mymsg) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_mymsg]), &_rxi);
    }
    if ((ops.myresponse) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myresponse]), &_rxi);
    }
    if ((ops.myrpc) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]), &_rxi);
    }
    thc_end_receive_any(&(_thc_binding->thc_per_binding));
    return(_r);
}

static  errval_t xmplthc_recv_any__thc_service_fn(xmplthc_thc_service_binding_t *_thc_binding, struct xmplthc_service_msg *msg, struct xmplthc_service_selector ops)
{
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    errval_t _r = 0;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = ((int *)(&(msg->msg)));
    thc_start_receive_any(&(_thc_binding->thc_per_binding));
    if ((ops.mymsg) != 0) {
        (_args.mymsg).i = (&(((msg->args).mymsg).i));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_mymsg]), &_rxi);
    }
    if ((ops.mycall) != 0) {
        (_args.mycall).i = (&(((msg->args).mycall).i));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_mycall]), &_rxi);
    }
    if ((ops.myrpc) != 0) {
        ((_args.myrpc).in).i = (&((((msg->args).myrpc).in).i));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_myrpc]), &_rxi);
    }
    thc_wait_receive_any(&(_thc_binding->thc_per_binding), &_rxi);
    if ((ops.mymsg) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_mymsg]), &_rxi);
    }
    if ((ops.mycall) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_mycall]), &_rxi);
    }
    if ((ops.myrpc) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_myrpc]), &_rxi);
    }
    thc_end_receive_any(&(_thc_binding->thc_per_binding));
    return(_r);
}

static  errval_t xmplthc_recv_any__thc_client_fn_x(xmplthc_thc_client_binding_t *_thc_binding, struct xmplthc_client_msg *msg, struct xmplthc_client_selector ops)
{
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    errval_t _r = 0;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = ((int *)(&(msg->msg)));
    thc_start_receive_any(&(_thc_binding->thc_per_binding));
    if ((ops.mymsg) != 0) {
        (_args.mymsg).i = (&(((msg->args).mymsg).i));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_mymsg]), &_rxi);
    }
    if ((ops.myresponse) != 0) {
        (_args.myresponse).s = (&(((msg->args).myresponse).s));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myresponse]), &_rxi);
    }
    if ((ops.myrpc) != 0) {
        ((_args.myrpc).out).s = (&((((msg->args).myrpc).out).s));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]), &_rxi);
    }
    _r = thc_wait_receive_any_x(&(_thc_binding->thc_per_binding), &_rxi);
    if ((ops.mymsg) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_mymsg]), &_rxi);
    }
    if ((ops.myresponse) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myresponse]), &_rxi);
    }
    if ((ops.myrpc) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]), &_rxi);
    }
    thc_end_receive_any(&(_thc_binding->thc_per_binding));
    return(_r);
}

static  errval_t xmplthc_recv_any__thc_service_fn_x(xmplthc_thc_service_binding_t *_thc_binding, struct xmplthc_service_msg *msg, struct xmplthc_service_selector ops)
{
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    errval_t _r = 0;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = ((int *)(&(msg->msg)));
    thc_start_receive_any(&(_thc_binding->thc_per_binding));
    if ((ops.mymsg) != 0) {
        (_args.mymsg).i = (&(((msg->args).mymsg).i));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_mymsg]), &_rxi);
    }
    if ((ops.mycall) != 0) {
        (_args.mycall).i = (&(((msg->args).mycall).i));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_mycall]), &_rxi);
    }
    if ((ops.myrpc) != 0) {
        ((_args.myrpc).in).i = (&((((msg->args).myrpc).in).i));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_myrpc]), &_rxi);
    }
    _r = thc_wait_receive_any_x(&(_thc_binding->thc_per_binding), &_rxi);
    if ((ops.mymsg) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_mymsg]), &_rxi);
    }
    if ((ops.mycall) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_mycall]), &_rxi);
    }
    if ((ops.myrpc) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__call_myrpc]), &_rxi);
    }
    thc_end_receive_any(&(_thc_binding->thc_per_binding));
    return(_r);
}

/*
 * Bottom-half receive functions
 */
static  void xmplthc_client_mymsg__bh_recv(struct xmplthc_binding *_idc_binding, int32_t i)
{
    struct xmplthc_thc_client_binding_t *_thc_binding = (struct xmplthc_thc_client_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[xmplthc__resp_mymsg]));
    if (rxi == NULL) {
        return;
    }
    struct xmplthc_thc_ptr_arg_struct *__attribute__((unused)) _args = rxi->args;
    *(rxi->msg) = ((int )(xmplthc_mymsg));
    *((_args->mymsg).i) = i;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[xmplthc__resp_mymsg]), rxi);
}

static  void xmplthc_client_myresponse__bh_recv(struct xmplthc_binding *_idc_binding, char *s)
{
    struct xmplthc_thc_client_binding_t *_thc_binding = (struct xmplthc_thc_client_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[xmplthc__resp_myresponse]));
    if (rxi == NULL) {
        return;
    }
    struct xmplthc_thc_ptr_arg_struct *__attribute__((unused)) _args = rxi->args;
    *(rxi->msg) = ((int )(xmplthc_myresponse));
    *((_args->myresponse).s) = s;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[xmplthc__resp_myresponse]), rxi);
}

static  void xmplthc_client_myrpc__bh_recv(struct xmplthc_binding *_idc_binding, char *s)
{
    struct xmplthc_thc_client_binding_t *_thc_binding = (struct xmplthc_thc_client_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]));
    if (rxi == NULL) {
        return;
    }
    struct xmplthc_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(xmplthc_myrpc));
    *(((args->myrpc).out).s) = s;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]), rxi);
}

static  void xmplthc_service_mymsg__bh_recv(struct xmplthc_binding *_idc_binding, int32_t i)
{
    struct xmplthc_thc_service_binding_t *_thc_binding = (struct xmplthc_thc_service_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[xmplthc__call_mymsg]));
    if (rxi == NULL) {
        return;
    }
    struct xmplthc_thc_ptr_arg_struct *__attribute__((unused)) _args = rxi->args;
    *(rxi->msg) = ((int )(xmplthc_mymsg));
    *((_args->mymsg).i) = i;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[xmplthc__call_mymsg]), rxi);
}

static  void xmplthc_service_mycall__bh_recv(struct xmplthc_binding *_idc_binding, int32_t i)
{
    struct xmplthc_thc_service_binding_t *_thc_binding = (struct xmplthc_thc_service_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[xmplthc__call_mycall]));
    if (rxi == NULL) {
        return;
    }
    struct xmplthc_thc_ptr_arg_struct *__attribute__((unused)) _args = rxi->args;
    *(rxi->msg) = ((int )(xmplthc_mycall));
    *((_args->mycall).i) = i;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[xmplthc__call_mycall]), rxi);
}

static  void xmplthc_service_myrpc__bh_recv(struct xmplthc_binding *_idc_binding, int32_t i)
{
    struct xmplthc_thc_service_binding_t *_thc_binding = (struct xmplthc_thc_service_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[xmplthc__call_myrpc]));
    if (rxi == NULL) {
        return;
    }
    struct xmplthc_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(xmplthc_myrpc));
    *(((args->myrpc).in).i) = i;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[xmplthc__call_myrpc]), rxi);
}


/*
 * RPC-layer functions
 */
static  errval_t xmplthc_myrpc__call_seq(xmplthc_thc_client_binding_t *_thc_binding, int32_t i, char **s)
{
    ((_thc_binding->send).myrpc)(_thc_binding, i);
    return(((_thc_binding->recv).myrpc)(_thc_binding, s));
}

static  errval_t xmplthc_myrpc__call_fifo(xmplthc_thc_client_binding_t *_thc_binding, int32_t i, char **s)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]))->fifo_rpc_lock));
    ((_thc_binding->send).myrpc)(_thc_binding, i);
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]))->fifo_rpc_lock));
    thc_queue_await_turn(&((&((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]))->fifo_rpc_q), &_q);
    _result = (((_thc_binding->recv).myrpc)(_thc_binding, s));
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]), _bailed);
    return(_result);
}

static  errval_t xmplthc_myrpc__call_seq_x(xmplthc_thc_client_binding_t *_thc_binding, int32_t i, char **s)
{
    errval_t _result;
    _result = (((_thc_binding->send_x).myrpc)(_thc_binding, i));
    if (_result == THC_CANCELED) {
        return(THC_CANCELED);
    } else {
        struct xmplthc_thc_ptr_arg_struct _args;
        struct thc_receiver_info _rxi;
        int _msg;
        ((_args.myrpc).out).s = s;
        _rxi.waiter = NULL;
        _rxi.args = (&_args);
        _rxi.msg = (&_msg);
        _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]), &_rxi);
        if (_result == THC_CANCELED) {
            thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]), 1);
        }
        return(_result);
    }
}

static  errval_t xmplthc_myrpc__call_fifo_x(xmplthc_thc_client_binding_t *_thc_binding, int32_t i, char **s)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]))->fifo_rpc_lock));
    _result = (((_thc_binding->send_x).myrpc)(_thc_binding, i));
    if (_result == THC_CANCELED) {
        thc_lock_release(&((&((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]))->fifo_rpc_lock));
        return(THC_CANCELED);
    }
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]))->fifo_rpc_lock));
    _result = thc_queue_await_turn_x(&((&((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]))->fifo_rpc_q), &_q);
    if (_result == THC_CANCELED) {
        _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]))->fifo_rpc_q), &_q);
        thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]), _bailed);
        return(THC_CANCELED);
    }
    struct xmplthc_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.myrpc).out).s = s;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]), &_rxi);
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]), _bailed);
    return(_result);
}

/*
 * Initialization functions
 */
 errval_t xmplthc_thc_init_client(xmplthc_thc_client_binding_t *_thc_binding, struct xmplthc_binding *_c2s_idc_binding, struct xmplthc_binding *_s2c_idc_binding)
{
    CHECK_FIELD(struct xmplthc_binding, st);
    CHECK_FIELD(struct xmplthc_binding, waitset);
    CHECK_FIELD(struct xmplthc_binding, mutex);
    CHECK_FIELD(struct xmplthc_binding, can_send);
    CHECK_FIELD(struct xmplthc_binding, register_send);
    CHECK_FIELD(struct xmplthc_binding, change_waitset);
    CHECK_FIELD(struct xmplthc_binding, control);
    CHECK_FIELD(struct xmplthc_binding, error_handler);
    _thc_binding->_c2s_st = _c2s_idc_binding;
    _thc_binding->_s2c_st = _s2c_idc_binding;
    _c2s_idc_binding->st = _thc_binding;
    _s2c_idc_binding->st = _thc_binding;
    thc_seq_init(&(_thc_binding->ooo_rpc_seq));
    thc_init_per_binding_state(&(_thc_binding->thc_per_binding));
    (_thc_binding->send).mymsg = (&xmplthc_client_mymsg__send);
    (_thc_binding->send).mycall = (&xmplthc_client_mycall__send);
    (_thc_binding->send).myrpc = (&xmplthc_client_myrpc__send);
    (_thc_binding->send_x).mymsg = (&xmplthc_client_mymsg__send_x);
    (_thc_binding->send_x).mycall = (&xmplthc_client_mycall__send_x);
    (_thc_binding->send_x).myrpc = (&xmplthc_client_myrpc__send_x);
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[xmplthc__resp_mymsg]));
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[xmplthc__resp_myresponse]));
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[xmplthc__resp_myrpc]));
    (_s2c_idc_binding->rx_vtbl).mymsg = (&xmplthc_client_mymsg__bh_recv);
    (_s2c_idc_binding->rx_vtbl).myresponse = (&xmplthc_client_myresponse__bh_recv);
    (_s2c_idc_binding->rx_vtbl).myrpc_response = (&xmplthc_client_myrpc__bh_recv);
    (_thc_binding->recv).mymsg = (&xmplthc_client_mymsg__recv);
    (_thc_binding->recv).myresponse = (&xmplthc_client_myresponse__recv);
    (_thc_binding->recv).myrpc = (&xmplthc_client_myrpc__recv);
    (_thc_binding->recv_x).mymsg = (&xmplthc_client_mymsg__recv_x);
    (_thc_binding->recv_x).myresponse = (&xmplthc_client_myresponse__recv_x);
    (_thc_binding->recv_x).myrpc = (&xmplthc_client_myrpc__recv_x);
    _thc_binding->recv_any = xmplthc_recv_any__thc_client_fn;
    _thc_binding->recv_any_x = xmplthc_recv_any__thc_client_fn_x;
    (_thc_binding->call_seq).myrpc = xmplthc_myrpc__call_seq;
    (_thc_binding->call_fifo).myrpc = xmplthc_myrpc__call_fifo;
    (_thc_binding->call_seq_x).myrpc = xmplthc_myrpc__call_seq_x;
    (_thc_binding->call_fifo_x).myrpc = xmplthc_myrpc__call_fifo_x;
    return(0);
}

 errval_t xmplthc_thc_init_service(xmplthc_thc_service_binding_t *_thc_binding, struct xmplthc_binding *_c2s_idc_binding, struct xmplthc_binding *_s2c_idc_binding)
{
    CHECK_FIELD(struct xmplthc_binding, st);
    CHECK_FIELD(struct xmplthc_binding, waitset);
    CHECK_FIELD(struct xmplthc_binding, mutex);
    CHECK_FIELD(struct xmplthc_binding, can_send);
    CHECK_FIELD(struct xmplthc_binding, register_send);
    CHECK_FIELD(struct xmplthc_binding, change_waitset);
    CHECK_FIELD(struct xmplthc_binding, control);
    CHECK_FIELD(struct xmplthc_binding, error_handler);
    _thc_binding->_c2s_st = _c2s_idc_binding;
    _thc_binding->_s2c_st = _s2c_idc_binding;
    _c2s_idc_binding->st = _thc_binding;
    _s2c_idc_binding->st = _thc_binding;
    thc_init_per_binding_state(&(_thc_binding->thc_per_binding));
    (_thc_binding->send).mymsg = (&xmplthc_service_mymsg__send);
    (_thc_binding->send).myresponse = (&xmplthc_service_myresponse__send);
    (_thc_binding->send).myrpc = (&xmplthc_service_myrpc__send);
    (_thc_binding->send_x).mymsg = (&xmplthc_service_mymsg__send_x);
    (_thc_binding->send_x).myresponse = (&xmplthc_service_myresponse__send_x);
    (_thc_binding->send_x).myrpc = (&xmplthc_service_myrpc__send_x);
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[xmplthc__call_mymsg]));
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[xmplthc__call_mycall]));
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[xmplthc__call_myrpc]));
    (_c2s_idc_binding->rx_vtbl).mymsg = (&xmplthc_service_mymsg__bh_recv);
    (_c2s_idc_binding->rx_vtbl).mycall = (&xmplthc_service_mycall__bh_recv);
    (_c2s_idc_binding->rx_vtbl).myrpc_call = (&xmplthc_service_myrpc__bh_recv);
    (_thc_binding->recv).mymsg = (&xmplthc_service_mymsg__recv);
    (_thc_binding->recv).mycall = (&xmplthc_service_mycall__recv);
    (_thc_binding->recv).myrpc = (&xmplthc_service_myrpc__recv);
    (_thc_binding->recv_x).mymsg = (&xmplthc_service_mymsg__recv_x);
    (_thc_binding->recv_x).mycall = (&xmplthc_service_mycall__recv_x);
    (_thc_binding->recv_x).myrpc = (&xmplthc_service_myrpc__recv_x);
    _thc_binding->recv_any = xmplthc_recv_any__thc_service_fn;
    _thc_binding->recv_any_x = xmplthc_recv_any__thc_service_fn_x;
    return(0);
}


/*
 * Connection-management functions
 */
static  void xmplthc_thc_export_cb(void *st, errval_t err, iref_t iref)
{
    struct xmplthc_thc_export_info *info;
    info = ((struct xmplthc_thc_export_info *)(st));
    thc_lock_acquire(&(info->info_lock));
    if (err_is_fail(err)) {
        info->err = err;
    } else {
        if ((info->service_name) != NULL) {
            info->err = nameservice_register(info->service_name, iref);
        }
        if ((info->iref_ptr) != NULL) {
            *(info->iref_ptr) = iref;
        }
    }
    thc_sem_v(&(info->export_cb_done_sem));
}

static  errval_t xmplthc_thc_connect_cb(void *st, struct xmplthc_binding *b)
{
    struct xmplthc_thc_export_info *info;
    info = ((struct xmplthc_thc_export_info *)(st));
    thc_sem_p(&(info->accept_call_present_sem));
    thc_lock_acquire(&(info->info_lock));
    *(info->b) = b;
    thc_sem_v(&(info->connect_cb_done_sem));
    return(SYS_ERR_OK);
}

 errval_t xmplthc_thc_export(struct xmplthc_thc_export_info *info, const char *service_name, struct waitset *ws, idc_export_flags_t flags, iref_t *iref_ptr)
{
    errval_t err;
    thc_sem_init(&(info->export_cb_done_sem), 0);
    thc_sem_init(&(info->connect_cb_done_sem), 0);
    thc_sem_init(&(info->accept_call_present_sem), 0);
    thc_lock_init(&(info->info_lock));
    thc_lock_init(&(info->next_accept_lock));
    info->service_name = service_name;
    info->err = SYS_ERR_OK;
    info->iref_ptr = iref_ptr;
    err = xmplthc_export(info, xmplthc_thc_export_cb, xmplthc_thc_connect_cb, ws, flags);
    if (err_is_ok(err)) {
        thc_sem_p(&(info->export_cb_done_sem));
        err = (info->err);
        thc_lock_release(&(info->info_lock));
    }
    return(err);
}

 errval_t xmplthc_thc_accept(struct xmplthc_thc_export_info *info, struct xmplthc_binding **b)
{
    struct xmplthc_binding *priv_b;
    thc_lock_acquire(&(info->next_accept_lock));
    info->b = (&priv_b);
    thc_sem_v(&(info->accept_call_present_sem));
    thc_sem_p(&(info->connect_cb_done_sem));
    errval_t err = info->err;
    thc_lock_release(&(info->info_lock));
    thc_lock_release(&(info->next_accept_lock));
    if (err_is_ok(err)) {
        if (b != NULL) {
            *b = priv_b;
        }
    }
    return(err);
}

static  void xmplthc_thc_bind_cb(void *st, errval_t err, struct xmplthc_binding *b)
{
    struct xmplthc_thc_connect_info *info;
    info = ((struct xmplthc_thc_connect_info *)(st));
    info->err = err;
    if (err_is_ok(err)) {
        info->b = b;
    }
    thc_sem_v(&(info->bind_cb_done_sem));
}

 errval_t xmplthc_thc_connect(iref_t iref, struct waitset *ws, idc_bind_flags_t flags, struct xmplthc_binding **b)
{
    struct xmplthc_thc_connect_info info;
    errval_t err;
    thc_sem_init(&(info.bind_cb_done_sem), 0);
    info.err = SYS_ERR_OK;
    info.b = NULL;
    err = xmplthc_bind(iref, xmplthc_thc_bind_cb, &info, ws, flags);
    if (err_is_ok(err)) {
        thc_sem_p(&(info.bind_cb_done_sem));
        err = (info.err);
        if (err_is_ok(err)) {
            if (b != NULL) {
                *b = (info.b);
            }
        }
    }
    return(err);
}

 errval_t xmplthc_thc_connect_by_name(const char *service_name, struct waitset *ws, idc_bind_flags_t flags, struct xmplthc_binding **b)
{
    errval_t err;
    iref_t iref;
    err = nameservice_blocking_lookup(service_name, &iref);
    if (err_is_ok(err)) {
        err = xmplthc_thc_connect(iref, ws, flags, b);
    }
    return(err);
}


