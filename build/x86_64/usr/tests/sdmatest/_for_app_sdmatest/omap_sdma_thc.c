/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: omap_sdma
 * INTEFACE FILE: ../if/omap_sdma.if
 * INTERFACE DESCRIPTION: Interface for the OMAP44xx SDMA driver
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

#include <stddef.h>
#ifdef BARRELFISH
#include <barrelfish/barrelfish.h>
#include <barrelfish/nameservice_client.h>
#include "if/omap_sdma_thc.h"
#include "thc/thc.h"
#else
#include "omap_sdma_thc.h"
#include "thc.h"
#endif // BARRELFISH

/*
 * Send functions
 */
static  errval_t omap_sdma_client_mem_copy__send(struct omap_sdma_thc_client_binding_t *_thc_binding, struct capref dst, struct capref src)
{
    struct omap_sdma_binding *_idc_binding = (struct omap_sdma_binding *)(_thc_binding->_c2s_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mem_copy_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), dst, src);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t omap_sdma_client_mem_fill__send(struct omap_sdma_thc_client_binding_t *_thc_binding, struct capref dst, uint8_t color)
{
    struct omap_sdma_binding *_idc_binding = (struct omap_sdma_binding *)(_thc_binding->_c2s_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mem_fill_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), dst, color);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t omap_sdma_client_mem_copy_2d__send(struct omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_addr_2d_t dst, omap_sdma_addr_2d_t src, omap_sdma_count_2d_t count, bool transparent, omap_sdma_uint24_t color)
{
    struct omap_sdma_binding *_idc_binding = (struct omap_sdma_binding *)(_thc_binding->_c2s_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mem_copy_2d_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), dst, src, count, transparent, color);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t omap_sdma_client_mem_fill_2d__send(struct omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_addr_2d_t dst, omap_sdma_uint24_t color, omap_sdma_count_2d_t count)
{
    struct omap_sdma_binding *_idc_binding = (struct omap_sdma_binding *)(_thc_binding->_c2s_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mem_fill_2d_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), dst, color, count);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t omap_sdma_service_mem_copy__send(struct omap_sdma_thc_service_binding_t *_thc_binding, omap_sdma_errval_t err)
{
    struct omap_sdma_binding *_idc_binding = (struct omap_sdma_binding *)(_thc_binding->_s2c_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mem_copy_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), err);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t omap_sdma_service_mem_fill__send(struct omap_sdma_thc_service_binding_t *_thc_binding, omap_sdma_errval_t err)
{
    struct omap_sdma_binding *_idc_binding = (struct omap_sdma_binding *)(_thc_binding->_s2c_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mem_fill_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), err);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t omap_sdma_service_mem_copy_2d__send(struct omap_sdma_thc_service_binding_t *_thc_binding, omap_sdma_errval_t err)
{
    struct omap_sdma_binding *_idc_binding = (struct omap_sdma_binding *)(_thc_binding->_s2c_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mem_copy_2d_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), err);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t omap_sdma_service_mem_fill_2d__send(struct omap_sdma_thc_service_binding_t *_thc_binding, omap_sdma_errval_t err)
{
    struct omap_sdma_binding *_idc_binding = (struct omap_sdma_binding *)(_thc_binding->_s2c_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mem_fill_2d_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), err);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t omap_sdma_client_mem_copy__send_x(struct omap_sdma_thc_client_binding_t *_thc_binding, struct capref dst, struct capref src)
{
    struct omap_sdma_binding *_idc_binding = (struct omap_sdma_binding *)(_thc_binding->_c2s_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mem_copy_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), dst, src);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t omap_sdma_client_mem_fill__send_x(struct omap_sdma_thc_client_binding_t *_thc_binding, struct capref dst, uint8_t color)
{
    struct omap_sdma_binding *_idc_binding = (struct omap_sdma_binding *)(_thc_binding->_c2s_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mem_fill_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), dst, color);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t omap_sdma_client_mem_copy_2d__send_x(struct omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_addr_2d_t dst, omap_sdma_addr_2d_t src, omap_sdma_count_2d_t count, bool transparent, omap_sdma_uint24_t color)
{
    struct omap_sdma_binding *_idc_binding = (struct omap_sdma_binding *)(_thc_binding->_c2s_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mem_copy_2d_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), dst, src, count, transparent, color);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t omap_sdma_client_mem_fill_2d__send_x(struct omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_addr_2d_t dst, omap_sdma_uint24_t color, omap_sdma_count_2d_t count)
{
    struct omap_sdma_binding *_idc_binding = (struct omap_sdma_binding *)(_thc_binding->_c2s_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mem_fill_2d_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), dst, color, count);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t omap_sdma_service_mem_copy__send_x(struct omap_sdma_thc_service_binding_t *_thc_binding, omap_sdma_errval_t err)
{
    struct omap_sdma_binding *_idc_binding = (struct omap_sdma_binding *)(_thc_binding->_s2c_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mem_copy_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), err);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t omap_sdma_service_mem_fill__send_x(struct omap_sdma_thc_service_binding_t *_thc_binding, omap_sdma_errval_t err)
{
    struct omap_sdma_binding *_idc_binding = (struct omap_sdma_binding *)(_thc_binding->_s2c_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mem_fill_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), err);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t omap_sdma_service_mem_copy_2d__send_x(struct omap_sdma_thc_service_binding_t *_thc_binding, omap_sdma_errval_t err)
{
    struct omap_sdma_binding *_idc_binding = (struct omap_sdma_binding *)(_thc_binding->_s2c_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mem_copy_2d_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), err);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t omap_sdma_service_mem_fill_2d__send_x(struct omap_sdma_thc_service_binding_t *_thc_binding, omap_sdma_errval_t err)
{
    struct omap_sdma_binding *_idc_binding = (struct omap_sdma_binding *)(_thc_binding->_s2c_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).mem_fill_2d_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), err);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}



/*
 * Struct type for holding pointers to the args for each msg
 */
struct omap_sdma_mem_copy__in_ptr_args_t {
    struct capref *dst;
    struct capref *src;
};
struct omap_sdma_mem_copy__out_ptr_args_t {
    omap_sdma_errval_t *err;
};
union omap_sdma_mem_copy___ptr_union_t {
    struct omap_sdma_mem_copy__in_ptr_args_t in;
    struct omap_sdma_mem_copy__out_ptr_args_t out;
};
struct omap_sdma_mem_fill__in_ptr_args_t {
    struct capref *dst;
    uint8_t *color;
};
struct omap_sdma_mem_fill__out_ptr_args_t {
    omap_sdma_errval_t *err;
};
union omap_sdma_mem_fill___ptr_union_t {
    struct omap_sdma_mem_fill__in_ptr_args_t in;
    struct omap_sdma_mem_fill__out_ptr_args_t out;
};
struct omap_sdma_mem_copy_2d__in_ptr_args_t {
    omap_sdma_addr_2d_t *dst;
    omap_sdma_addr_2d_t *src;
    omap_sdma_count_2d_t *count;
    bool *transparent;
    omap_sdma_uint24_t *color;
};
struct omap_sdma_mem_copy_2d__out_ptr_args_t {
    omap_sdma_errval_t *err;
};
union omap_sdma_mem_copy_2d___ptr_union_t {
    struct omap_sdma_mem_copy_2d__in_ptr_args_t in;
    struct omap_sdma_mem_copy_2d__out_ptr_args_t out;
};
struct omap_sdma_mem_fill_2d__in_ptr_args_t {
    omap_sdma_addr_2d_t *dst;
    omap_sdma_uint24_t *color;
    omap_sdma_count_2d_t *count;
};
struct omap_sdma_mem_fill_2d__out_ptr_args_t {
    omap_sdma_errval_t *err;
};
union omap_sdma_mem_fill_2d___ptr_union_t {
    struct omap_sdma_mem_fill_2d__in_ptr_args_t in;
    struct omap_sdma_mem_fill_2d__out_ptr_args_t out;
};

/*
 * Struct type for Receive-any and Bottom-half receive functions to hold pointers-to-message-argument structs
 */
struct omap_sdma_thc_ptr_arg_struct {
    union omap_sdma_mem_copy___ptr_union_t mem_copy;
    union omap_sdma_mem_fill___ptr_union_t mem_fill;
    union omap_sdma_mem_copy_2d___ptr_union_t mem_copy_2d;
    union omap_sdma_mem_fill_2d___ptr_union_t mem_fill_2d;
};

/*
 * Receive functions
 */
static  errval_t omap_sdma_client_mem_copy__recv(struct omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_errval_t *err)
{
    errval_t _result;
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_copy).out).err = err;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]), &_rxi);
    return(_result);
}

static  errval_t omap_sdma_client_mem_fill__recv(struct omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_errval_t *err)
{
    errval_t _result;
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_fill).out).err = err;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]), &_rxi);
    return(_result);
}

static  errval_t omap_sdma_client_mem_copy_2d__recv(struct omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_errval_t *err)
{
    errval_t _result;
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_copy_2d).out).err = err;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]), &_rxi);
    return(_result);
}

static  errval_t omap_sdma_client_mem_fill_2d__recv(struct omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_errval_t *err)
{
    errval_t _result;
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_fill_2d).out).err = err;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]), &_rxi);
    return(_result);
}

static  errval_t omap_sdma_service_mem_copy__recv(struct omap_sdma_thc_service_binding_t *_thc_binding, struct capref *dst, struct capref *src)
{
    errval_t _result;
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_copy).in).dst = dst;
    ((_args.mem_copy).in).src = src;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy]), &_rxi);
    return(_result);
}

static  errval_t omap_sdma_service_mem_fill__recv(struct omap_sdma_thc_service_binding_t *_thc_binding, struct capref *dst, uint8_t *color)
{
    errval_t _result;
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_fill).in).dst = dst;
    ((_args.mem_fill).in).color = color;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill]), &_rxi);
    return(_result);
}

static  errval_t omap_sdma_service_mem_copy_2d__recv(struct omap_sdma_thc_service_binding_t *_thc_binding, omap_sdma_addr_2d_t *dst, omap_sdma_addr_2d_t *src, omap_sdma_count_2d_t *count, bool *transparent, omap_sdma_uint24_t *color)
{
    errval_t _result;
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_copy_2d).in).dst = dst;
    ((_args.mem_copy_2d).in).src = src;
    ((_args.mem_copy_2d).in).count = count;
    ((_args.mem_copy_2d).in).transparent = transparent;
    ((_args.mem_copy_2d).in).color = color;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy_2d]), &_rxi);
    return(_result);
}

static  errval_t omap_sdma_service_mem_fill_2d__recv(struct omap_sdma_thc_service_binding_t *_thc_binding, omap_sdma_addr_2d_t *dst, omap_sdma_uint24_t *color, omap_sdma_count_2d_t *count)
{
    errval_t _result;
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_fill_2d).in).dst = dst;
    ((_args.mem_fill_2d).in).color = color;
    ((_args.mem_fill_2d).in).count = count;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill_2d]), &_rxi);
    return(_result);
}

static  errval_t omap_sdma_client_mem_copy__recv_x(struct omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_errval_t *err)
{
    errval_t _result;
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_copy).out).err = err;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]), &_rxi);
    return(_result);
}

static  errval_t omap_sdma_client_mem_fill__recv_x(struct omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_errval_t *err)
{
    errval_t _result;
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_fill).out).err = err;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]), &_rxi);
    return(_result);
}

static  errval_t omap_sdma_client_mem_copy_2d__recv_x(struct omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_errval_t *err)
{
    errval_t _result;
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_copy_2d).out).err = err;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]), &_rxi);
    return(_result);
}

static  errval_t omap_sdma_client_mem_fill_2d__recv_x(struct omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_errval_t *err)
{
    errval_t _result;
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_fill_2d).out).err = err;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]), &_rxi);
    return(_result);
}

static  errval_t omap_sdma_service_mem_copy__recv_x(struct omap_sdma_thc_service_binding_t *_thc_binding, struct capref *dst, struct capref *src)
{
    errval_t _result;
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_copy).in).dst = dst;
    ((_args.mem_copy).in).src = src;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy]), &_rxi);
    return(_result);
}

static  errval_t omap_sdma_service_mem_fill__recv_x(struct omap_sdma_thc_service_binding_t *_thc_binding, struct capref *dst, uint8_t *color)
{
    errval_t _result;
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_fill).in).dst = dst;
    ((_args.mem_fill).in).color = color;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill]), &_rxi);
    return(_result);
}

static  errval_t omap_sdma_service_mem_copy_2d__recv_x(struct omap_sdma_thc_service_binding_t *_thc_binding, omap_sdma_addr_2d_t *dst, omap_sdma_addr_2d_t *src, omap_sdma_count_2d_t *count, bool *transparent, omap_sdma_uint24_t *color)
{
    errval_t _result;
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_copy_2d).in).dst = dst;
    ((_args.mem_copy_2d).in).src = src;
    ((_args.mem_copy_2d).in).count = count;
    ((_args.mem_copy_2d).in).transparent = transparent;
    ((_args.mem_copy_2d).in).color = color;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy_2d]), &_rxi);
    return(_result);
}

static  errval_t omap_sdma_service_mem_fill_2d__recv_x(struct omap_sdma_thc_service_binding_t *_thc_binding, omap_sdma_addr_2d_t *dst, omap_sdma_uint24_t *color, omap_sdma_count_2d_t *count)
{
    errval_t _result;
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_fill_2d).in).dst = dst;
    ((_args.mem_fill_2d).in).color = color;
    ((_args.mem_fill_2d).in).count = count;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill_2d]), &_rxi);
    return(_result);
}


/*
 * Receive-any functions
 */
static  errval_t omap_sdma_recv_any__thc_client_fn(omap_sdma_thc_client_binding_t *_thc_binding, struct omap_sdma_client_msg *msg, struct omap_sdma_client_selector ops)
{
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    errval_t _r = 0;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = ((int *)(&(msg->msg)));
    thc_start_receive_any(&(_thc_binding->thc_per_binding));
    if ((ops.mem_copy) != 0) {
        ((_args.mem_copy).out).err = (&((((msg->args).mem_copy).out).err));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]), &_rxi);
    }
    if ((ops.mem_fill) != 0) {
        ((_args.mem_fill).out).err = (&((((msg->args).mem_fill).out).err));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]), &_rxi);
    }
    if ((ops.mem_copy_2d) != 0) {
        ((_args.mem_copy_2d).out).err = (&((((msg->args).mem_copy_2d).out).err));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]), &_rxi);
    }
    if ((ops.mem_fill_2d) != 0) {
        ((_args.mem_fill_2d).out).err = (&((((msg->args).mem_fill_2d).out).err));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]), &_rxi);
    }
    thc_wait_receive_any(&(_thc_binding->thc_per_binding), &_rxi);
    if ((ops.mem_copy) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]), &_rxi);
    }
    if ((ops.mem_fill) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]), &_rxi);
    }
    if ((ops.mem_copy_2d) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]), &_rxi);
    }
    if ((ops.mem_fill_2d) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]), &_rxi);
    }
    thc_end_receive_any(&(_thc_binding->thc_per_binding));
    return(_r);
}

static  errval_t omap_sdma_recv_any__thc_service_fn(omap_sdma_thc_service_binding_t *_thc_binding, struct omap_sdma_service_msg *msg, struct omap_sdma_service_selector ops)
{
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    errval_t _r = 0;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = ((int *)(&(msg->msg)));
    thc_start_receive_any(&(_thc_binding->thc_per_binding));
    if ((ops.mem_copy) != 0) {
        ((_args.mem_copy).in).dst = (&((((msg->args).mem_copy).in).dst));
        ((_args.mem_copy).in).src = (&((((msg->args).mem_copy).in).src));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy]), &_rxi);
    }
    if ((ops.mem_fill) != 0) {
        ((_args.mem_fill).in).dst = (&((((msg->args).mem_fill).in).dst));
        ((_args.mem_fill).in).color = (&((((msg->args).mem_fill).in).color));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill]), &_rxi);
    }
    if ((ops.mem_copy_2d) != 0) {
        ((_args.mem_copy_2d).in).dst = (&((((msg->args).mem_copy_2d).in).dst));
        ((_args.mem_copy_2d).in).src = (&((((msg->args).mem_copy_2d).in).src));
        ((_args.mem_copy_2d).in).count = (&((((msg->args).mem_copy_2d).in).count));
        ((_args.mem_copy_2d).in).transparent = (&((((msg->args).mem_copy_2d).in).transparent));
        ((_args.mem_copy_2d).in).color = (&((((msg->args).mem_copy_2d).in).color));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy_2d]), &_rxi);
    }
    if ((ops.mem_fill_2d) != 0) {
        ((_args.mem_fill_2d).in).dst = (&((((msg->args).mem_fill_2d).in).dst));
        ((_args.mem_fill_2d).in).color = (&((((msg->args).mem_fill_2d).in).color));
        ((_args.mem_fill_2d).in).count = (&((((msg->args).mem_fill_2d).in).count));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill_2d]), &_rxi);
    }
    thc_wait_receive_any(&(_thc_binding->thc_per_binding), &_rxi);
    if ((ops.mem_copy) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy]), &_rxi);
    }
    if ((ops.mem_fill) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill]), &_rxi);
    }
    if ((ops.mem_copy_2d) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy_2d]), &_rxi);
    }
    if ((ops.mem_fill_2d) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill_2d]), &_rxi);
    }
    thc_end_receive_any(&(_thc_binding->thc_per_binding));
    return(_r);
}

static  errval_t omap_sdma_recv_any__thc_client_fn_x(omap_sdma_thc_client_binding_t *_thc_binding, struct omap_sdma_client_msg *msg, struct omap_sdma_client_selector ops)
{
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    errval_t _r = 0;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = ((int *)(&(msg->msg)));
    thc_start_receive_any(&(_thc_binding->thc_per_binding));
    if ((ops.mem_copy) != 0) {
        ((_args.mem_copy).out).err = (&((((msg->args).mem_copy).out).err));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]), &_rxi);
    }
    if ((ops.mem_fill) != 0) {
        ((_args.mem_fill).out).err = (&((((msg->args).mem_fill).out).err));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]), &_rxi);
    }
    if ((ops.mem_copy_2d) != 0) {
        ((_args.mem_copy_2d).out).err = (&((((msg->args).mem_copy_2d).out).err));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]), &_rxi);
    }
    if ((ops.mem_fill_2d) != 0) {
        ((_args.mem_fill_2d).out).err = (&((((msg->args).mem_fill_2d).out).err));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]), &_rxi);
    }
    _r = thc_wait_receive_any_x(&(_thc_binding->thc_per_binding), &_rxi);
    if ((ops.mem_copy) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]), &_rxi);
    }
    if ((ops.mem_fill) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]), &_rxi);
    }
    if ((ops.mem_copy_2d) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]), &_rxi);
    }
    if ((ops.mem_fill_2d) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]), &_rxi);
    }
    thc_end_receive_any(&(_thc_binding->thc_per_binding));
    return(_r);
}

static  errval_t omap_sdma_recv_any__thc_service_fn_x(omap_sdma_thc_service_binding_t *_thc_binding, struct omap_sdma_service_msg *msg, struct omap_sdma_service_selector ops)
{
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    errval_t _r = 0;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = ((int *)(&(msg->msg)));
    thc_start_receive_any(&(_thc_binding->thc_per_binding));
    if ((ops.mem_copy) != 0) {
        ((_args.mem_copy).in).dst = (&((((msg->args).mem_copy).in).dst));
        ((_args.mem_copy).in).src = (&((((msg->args).mem_copy).in).src));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy]), &_rxi);
    }
    if ((ops.mem_fill) != 0) {
        ((_args.mem_fill).in).dst = (&((((msg->args).mem_fill).in).dst));
        ((_args.mem_fill).in).color = (&((((msg->args).mem_fill).in).color));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill]), &_rxi);
    }
    if ((ops.mem_copy_2d) != 0) {
        ((_args.mem_copy_2d).in).dst = (&((((msg->args).mem_copy_2d).in).dst));
        ((_args.mem_copy_2d).in).src = (&((((msg->args).mem_copy_2d).in).src));
        ((_args.mem_copy_2d).in).count = (&((((msg->args).mem_copy_2d).in).count));
        ((_args.mem_copy_2d).in).transparent = (&((((msg->args).mem_copy_2d).in).transparent));
        ((_args.mem_copy_2d).in).color = (&((((msg->args).mem_copy_2d).in).color));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy_2d]), &_rxi);
    }
    if ((ops.mem_fill_2d) != 0) {
        ((_args.mem_fill_2d).in).dst = (&((((msg->args).mem_fill_2d).in).dst));
        ((_args.mem_fill_2d).in).color = (&((((msg->args).mem_fill_2d).in).color));
        ((_args.mem_fill_2d).in).count = (&((((msg->args).mem_fill_2d).in).count));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill_2d]), &_rxi);
    }
    _r = thc_wait_receive_any_x(&(_thc_binding->thc_per_binding), &_rxi);
    if ((ops.mem_copy) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy]), &_rxi);
    }
    if ((ops.mem_fill) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill]), &_rxi);
    }
    if ((ops.mem_copy_2d) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy_2d]), &_rxi);
    }
    if ((ops.mem_fill_2d) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill_2d]), &_rxi);
    }
    thc_end_receive_any(&(_thc_binding->thc_per_binding));
    return(_r);
}

/*
 * Bottom-half receive functions
 */
static  void omap_sdma_client_mem_copy__bh_recv(struct omap_sdma_binding *_idc_binding, omap_sdma_errval_t err)
{
    struct omap_sdma_thc_client_binding_t *_thc_binding = (struct omap_sdma_thc_client_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]));
    if (rxi == NULL) {
        return;
    }
    struct omap_sdma_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(omap_sdma_mem_copy));
    *(((args->mem_copy).out).err) = err;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]), rxi);
}

static  void omap_sdma_client_mem_fill__bh_recv(struct omap_sdma_binding *_idc_binding, omap_sdma_errval_t err)
{
    struct omap_sdma_thc_client_binding_t *_thc_binding = (struct omap_sdma_thc_client_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]));
    if (rxi == NULL) {
        return;
    }
    struct omap_sdma_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(omap_sdma_mem_fill));
    *(((args->mem_fill).out).err) = err;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]), rxi);
}

static  void omap_sdma_client_mem_copy_2d__bh_recv(struct omap_sdma_binding *_idc_binding, omap_sdma_errval_t err)
{
    struct omap_sdma_thc_client_binding_t *_thc_binding = (struct omap_sdma_thc_client_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]));
    if (rxi == NULL) {
        return;
    }
    struct omap_sdma_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(omap_sdma_mem_copy_2d));
    *(((args->mem_copy_2d).out).err) = err;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]), rxi);
}

static  void omap_sdma_client_mem_fill_2d__bh_recv(struct omap_sdma_binding *_idc_binding, omap_sdma_errval_t err)
{
    struct omap_sdma_thc_client_binding_t *_thc_binding = (struct omap_sdma_thc_client_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]));
    if (rxi == NULL) {
        return;
    }
    struct omap_sdma_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(omap_sdma_mem_fill_2d));
    *(((args->mem_fill_2d).out).err) = err;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]), rxi);
}

static  void omap_sdma_service_mem_copy__bh_recv(struct omap_sdma_binding *_idc_binding, struct capref dst, struct capref src)
{
    struct omap_sdma_thc_service_binding_t *_thc_binding = (struct omap_sdma_thc_service_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy]));
    if (rxi == NULL) {
        return;
    }
    struct omap_sdma_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(omap_sdma_mem_copy));
    *(((args->mem_copy).in).dst) = dst;
    *(((args->mem_copy).in).src) = src;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy]), rxi);
}

static  void omap_sdma_service_mem_fill__bh_recv(struct omap_sdma_binding *_idc_binding, struct capref dst, uint8_t color)
{
    struct omap_sdma_thc_service_binding_t *_thc_binding = (struct omap_sdma_thc_service_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill]));
    if (rxi == NULL) {
        return;
    }
    struct omap_sdma_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(omap_sdma_mem_fill));
    *(((args->mem_fill).in).dst) = dst;
    *(((args->mem_fill).in).color) = color;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill]), rxi);
}

static  void omap_sdma_service_mem_copy_2d__bh_recv(struct omap_sdma_binding *_idc_binding, omap_sdma_addr_2d_t dst, omap_sdma_addr_2d_t src, omap_sdma_count_2d_t count, bool transparent, omap_sdma_uint24_t color)
{
    struct omap_sdma_thc_service_binding_t *_thc_binding = (struct omap_sdma_thc_service_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy_2d]));
    if (rxi == NULL) {
        return;
    }
    struct omap_sdma_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(omap_sdma_mem_copy_2d));
    *(((args->mem_copy_2d).in).dst) = dst;
    *(((args->mem_copy_2d).in).src) = src;
    *(((args->mem_copy_2d).in).count) = count;
    *(((args->mem_copy_2d).in).transparent) = transparent;
    *(((args->mem_copy_2d).in).color) = color;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy_2d]), rxi);
}

static  void omap_sdma_service_mem_fill_2d__bh_recv(struct omap_sdma_binding *_idc_binding, omap_sdma_addr_2d_t dst, omap_sdma_uint24_t color, omap_sdma_count_2d_t count)
{
    struct omap_sdma_thc_service_binding_t *_thc_binding = (struct omap_sdma_thc_service_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill_2d]));
    if (rxi == NULL) {
        return;
    }
    struct omap_sdma_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(omap_sdma_mem_fill_2d));
    *(((args->mem_fill_2d).in).dst) = dst;
    *(((args->mem_fill_2d).in).color) = color;
    *(((args->mem_fill_2d).in).count) = count;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill_2d]), rxi);
}


/*
 * RPC-layer functions
 */
static  errval_t omap_sdma_mem_copy__call_seq(omap_sdma_thc_client_binding_t *_thc_binding, struct capref dst, struct capref src, omap_sdma_errval_t *err)
{
    ((_thc_binding->send).mem_copy)(_thc_binding, dst, src);
    return(((_thc_binding->recv).mem_copy)(_thc_binding, err));
}

static  errval_t omap_sdma_mem_fill__call_seq(omap_sdma_thc_client_binding_t *_thc_binding, struct capref dst, uint8_t color, omap_sdma_errval_t *err)
{
    ((_thc_binding->send).mem_fill)(_thc_binding, dst, color);
    return(((_thc_binding->recv).mem_fill)(_thc_binding, err));
}

static  errval_t omap_sdma_mem_copy_2d__call_seq(omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_addr_2d_t dst, omap_sdma_addr_2d_t src, omap_sdma_count_2d_t count, bool transparent, omap_sdma_uint24_t color, omap_sdma_errval_t *err)
{
    ((_thc_binding->send).mem_copy_2d)(_thc_binding, dst, src, count, transparent, color);
    return(((_thc_binding->recv).mem_copy_2d)(_thc_binding, err));
}

static  errval_t omap_sdma_mem_fill_2d__call_seq(omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_addr_2d_t dst, omap_sdma_uint24_t color, omap_sdma_count_2d_t count, omap_sdma_errval_t *err)
{
    ((_thc_binding->send).mem_fill_2d)(_thc_binding, dst, color, count);
    return(((_thc_binding->recv).mem_fill_2d)(_thc_binding, err));
}

static  errval_t omap_sdma_mem_copy__call_fifo(omap_sdma_thc_client_binding_t *_thc_binding, struct capref dst, struct capref src, omap_sdma_errval_t *err)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]))->fifo_rpc_lock));
    ((_thc_binding->send).mem_copy)(_thc_binding, dst, src);
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]))->fifo_rpc_lock));
    thc_queue_await_turn(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]))->fifo_rpc_q), &_q);
    _result = (((_thc_binding->recv).mem_copy)(_thc_binding, err));
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]), _bailed);
    return(_result);
}

static  errval_t omap_sdma_mem_fill__call_fifo(omap_sdma_thc_client_binding_t *_thc_binding, struct capref dst, uint8_t color, omap_sdma_errval_t *err)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]))->fifo_rpc_lock));
    ((_thc_binding->send).mem_fill)(_thc_binding, dst, color);
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]))->fifo_rpc_lock));
    thc_queue_await_turn(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]))->fifo_rpc_q), &_q);
    _result = (((_thc_binding->recv).mem_fill)(_thc_binding, err));
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]), _bailed);
    return(_result);
}

static  errval_t omap_sdma_mem_copy_2d__call_fifo(omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_addr_2d_t dst, omap_sdma_addr_2d_t src, omap_sdma_count_2d_t count, bool transparent, omap_sdma_uint24_t color, omap_sdma_errval_t *err)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]))->fifo_rpc_lock));
    ((_thc_binding->send).mem_copy_2d)(_thc_binding, dst, src, count, transparent, color);
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]))->fifo_rpc_lock));
    thc_queue_await_turn(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]))->fifo_rpc_q), &_q);
    _result = (((_thc_binding->recv).mem_copy_2d)(_thc_binding, err));
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]), _bailed);
    return(_result);
}

static  errval_t omap_sdma_mem_fill_2d__call_fifo(omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_addr_2d_t dst, omap_sdma_uint24_t color, omap_sdma_count_2d_t count, omap_sdma_errval_t *err)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]))->fifo_rpc_lock));
    ((_thc_binding->send).mem_fill_2d)(_thc_binding, dst, color, count);
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]))->fifo_rpc_lock));
    thc_queue_await_turn(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]))->fifo_rpc_q), &_q);
    _result = (((_thc_binding->recv).mem_fill_2d)(_thc_binding, err));
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]), _bailed);
    return(_result);
}

static  errval_t omap_sdma_mem_copy__call_seq_x(omap_sdma_thc_client_binding_t *_thc_binding, struct capref dst, struct capref src, omap_sdma_errval_t *err)
{
    errval_t _result;
    _result = (((_thc_binding->send_x).mem_copy)(_thc_binding, dst, src));
    if (_result == THC_CANCELED) {
        return(THC_CANCELED);
    } else {
        struct omap_sdma_thc_ptr_arg_struct _args;
        struct thc_receiver_info _rxi;
        int _msg;
        ((_args.mem_copy).out).err = err;
        _rxi.waiter = NULL;
        _rxi.args = (&_args);
        _rxi.msg = (&_msg);
        _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]), &_rxi);
        if (_result == THC_CANCELED) {
            thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]), 1);
        }
        return(_result);
    }
}

static  errval_t omap_sdma_mem_fill__call_seq_x(omap_sdma_thc_client_binding_t *_thc_binding, struct capref dst, uint8_t color, omap_sdma_errval_t *err)
{
    errval_t _result;
    _result = (((_thc_binding->send_x).mem_fill)(_thc_binding, dst, color));
    if (_result == THC_CANCELED) {
        return(THC_CANCELED);
    } else {
        struct omap_sdma_thc_ptr_arg_struct _args;
        struct thc_receiver_info _rxi;
        int _msg;
        ((_args.mem_fill).out).err = err;
        _rxi.waiter = NULL;
        _rxi.args = (&_args);
        _rxi.msg = (&_msg);
        _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]), &_rxi);
        if (_result == THC_CANCELED) {
            thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]), 1);
        }
        return(_result);
    }
}

static  errval_t omap_sdma_mem_copy_2d__call_seq_x(omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_addr_2d_t dst, omap_sdma_addr_2d_t src, omap_sdma_count_2d_t count, bool transparent, omap_sdma_uint24_t color, omap_sdma_errval_t *err)
{
    errval_t _result;
    _result = (((_thc_binding->send_x).mem_copy_2d)(_thc_binding, dst, src, count, transparent, color));
    if (_result == THC_CANCELED) {
        return(THC_CANCELED);
    } else {
        struct omap_sdma_thc_ptr_arg_struct _args;
        struct thc_receiver_info _rxi;
        int _msg;
        ((_args.mem_copy_2d).out).err = err;
        _rxi.waiter = NULL;
        _rxi.args = (&_args);
        _rxi.msg = (&_msg);
        _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]), &_rxi);
        if (_result == THC_CANCELED) {
            thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]), 1);
        }
        return(_result);
    }
}

static  errval_t omap_sdma_mem_fill_2d__call_seq_x(omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_addr_2d_t dst, omap_sdma_uint24_t color, omap_sdma_count_2d_t count, omap_sdma_errval_t *err)
{
    errval_t _result;
    _result = (((_thc_binding->send_x).mem_fill_2d)(_thc_binding, dst, color, count));
    if (_result == THC_CANCELED) {
        return(THC_CANCELED);
    } else {
        struct omap_sdma_thc_ptr_arg_struct _args;
        struct thc_receiver_info _rxi;
        int _msg;
        ((_args.mem_fill_2d).out).err = err;
        _rxi.waiter = NULL;
        _rxi.args = (&_args);
        _rxi.msg = (&_msg);
        _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]), &_rxi);
        if (_result == THC_CANCELED) {
            thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]), 1);
        }
        return(_result);
    }
}

static  errval_t omap_sdma_mem_copy__call_fifo_x(omap_sdma_thc_client_binding_t *_thc_binding, struct capref dst, struct capref src, omap_sdma_errval_t *err)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]))->fifo_rpc_lock));
    _result = (((_thc_binding->send_x).mem_copy)(_thc_binding, dst, src));
    if (_result == THC_CANCELED) {
        thc_lock_release(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]))->fifo_rpc_lock));
        return(THC_CANCELED);
    }
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]))->fifo_rpc_lock));
    _result = thc_queue_await_turn_x(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]))->fifo_rpc_q), &_q);
    if (_result == THC_CANCELED) {
        _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]))->fifo_rpc_q), &_q);
        thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]), _bailed);
        return(THC_CANCELED);
    }
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_copy).out).err = err;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]), &_rxi);
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]), _bailed);
    return(_result);
}

static  errval_t omap_sdma_mem_fill__call_fifo_x(omap_sdma_thc_client_binding_t *_thc_binding, struct capref dst, uint8_t color, omap_sdma_errval_t *err)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]))->fifo_rpc_lock));
    _result = (((_thc_binding->send_x).mem_fill)(_thc_binding, dst, color));
    if (_result == THC_CANCELED) {
        thc_lock_release(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]))->fifo_rpc_lock));
        return(THC_CANCELED);
    }
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]))->fifo_rpc_lock));
    _result = thc_queue_await_turn_x(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]))->fifo_rpc_q), &_q);
    if (_result == THC_CANCELED) {
        _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]))->fifo_rpc_q), &_q);
        thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]), _bailed);
        return(THC_CANCELED);
    }
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_fill).out).err = err;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]), &_rxi);
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]), _bailed);
    return(_result);
}

static  errval_t omap_sdma_mem_copy_2d__call_fifo_x(omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_addr_2d_t dst, omap_sdma_addr_2d_t src, omap_sdma_count_2d_t count, bool transparent, omap_sdma_uint24_t color, omap_sdma_errval_t *err)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]))->fifo_rpc_lock));
    _result = (((_thc_binding->send_x).mem_copy_2d)(_thc_binding, dst, src, count, transparent, color));
    if (_result == THC_CANCELED) {
        thc_lock_release(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]))->fifo_rpc_lock));
        return(THC_CANCELED);
    }
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]))->fifo_rpc_lock));
    _result = thc_queue_await_turn_x(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]))->fifo_rpc_q), &_q);
    if (_result == THC_CANCELED) {
        _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]))->fifo_rpc_q), &_q);
        thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]), _bailed);
        return(THC_CANCELED);
    }
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_copy_2d).out).err = err;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]), &_rxi);
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]), _bailed);
    return(_result);
}

static  errval_t omap_sdma_mem_fill_2d__call_fifo_x(omap_sdma_thc_client_binding_t *_thc_binding, omap_sdma_addr_2d_t dst, omap_sdma_uint24_t color, omap_sdma_count_2d_t count, omap_sdma_errval_t *err)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]))->fifo_rpc_lock));
    _result = (((_thc_binding->send_x).mem_fill_2d)(_thc_binding, dst, color, count));
    if (_result == THC_CANCELED) {
        thc_lock_release(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]))->fifo_rpc_lock));
        return(THC_CANCELED);
    }
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]))->fifo_rpc_lock));
    _result = thc_queue_await_turn_x(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]))->fifo_rpc_q), &_q);
    if (_result == THC_CANCELED) {
        _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]))->fifo_rpc_q), &_q);
        thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]), _bailed);
        return(THC_CANCELED);
    }
    struct omap_sdma_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.mem_fill_2d).out).err = err;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]), &_rxi);
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]), _bailed);
    return(_result);
}

/*
 * Initialization functions
 */
 errval_t omap_sdma_thc_init_client(omap_sdma_thc_client_binding_t *_thc_binding, struct omap_sdma_binding *_c2s_idc_binding, struct omap_sdma_binding *_s2c_idc_binding)
{
    CHECK_FIELD(struct omap_sdma_binding, st);
    CHECK_FIELD(struct omap_sdma_binding, waitset);
    CHECK_FIELD(struct omap_sdma_binding, mutex);
    CHECK_FIELD(struct omap_sdma_binding, can_send);
    CHECK_FIELD(struct omap_sdma_binding, register_send);
    CHECK_FIELD(struct omap_sdma_binding, change_waitset);
    CHECK_FIELD(struct omap_sdma_binding, control);
    CHECK_FIELD(struct omap_sdma_binding, error_handler);
    _thc_binding->_c2s_st = _c2s_idc_binding;
    _thc_binding->_s2c_st = _s2c_idc_binding;
    _c2s_idc_binding->st = _thc_binding;
    _s2c_idc_binding->st = _thc_binding;
    thc_seq_init(&(_thc_binding->ooo_rpc_seq));
    thc_init_per_binding_state(&(_thc_binding->thc_per_binding));
    (_thc_binding->send).mem_copy = (&omap_sdma_client_mem_copy__send);
    (_thc_binding->send).mem_fill = (&omap_sdma_client_mem_fill__send);
    (_thc_binding->send).mem_copy_2d = (&omap_sdma_client_mem_copy_2d__send);
    (_thc_binding->send).mem_fill_2d = (&omap_sdma_client_mem_fill_2d__send);
    (_thc_binding->send_x).mem_copy = (&omap_sdma_client_mem_copy__send_x);
    (_thc_binding->send_x).mem_fill = (&omap_sdma_client_mem_fill__send_x);
    (_thc_binding->send_x).mem_copy_2d = (&omap_sdma_client_mem_copy_2d__send_x);
    (_thc_binding->send_x).mem_fill_2d = (&omap_sdma_client_mem_fill_2d__send_x);
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy]));
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill]));
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_copy_2d]));
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[omap_sdma__resp_mem_fill_2d]));
    (_s2c_idc_binding->rx_vtbl).mem_copy_response = (&omap_sdma_client_mem_copy__bh_recv);
    (_s2c_idc_binding->rx_vtbl).mem_fill_response = (&omap_sdma_client_mem_fill__bh_recv);
    (_s2c_idc_binding->rx_vtbl).mem_copy_2d_response = (&omap_sdma_client_mem_copy_2d__bh_recv);
    (_s2c_idc_binding->rx_vtbl).mem_fill_2d_response = (&omap_sdma_client_mem_fill_2d__bh_recv);
    (_thc_binding->recv).mem_copy = (&omap_sdma_client_mem_copy__recv);
    (_thc_binding->recv).mem_fill = (&omap_sdma_client_mem_fill__recv);
    (_thc_binding->recv).mem_copy_2d = (&omap_sdma_client_mem_copy_2d__recv);
    (_thc_binding->recv).mem_fill_2d = (&omap_sdma_client_mem_fill_2d__recv);
    (_thc_binding->recv_x).mem_copy = (&omap_sdma_client_mem_copy__recv_x);
    (_thc_binding->recv_x).mem_fill = (&omap_sdma_client_mem_fill__recv_x);
    (_thc_binding->recv_x).mem_copy_2d = (&omap_sdma_client_mem_copy_2d__recv_x);
    (_thc_binding->recv_x).mem_fill_2d = (&omap_sdma_client_mem_fill_2d__recv_x);
    _thc_binding->recv_any = omap_sdma_recv_any__thc_client_fn;
    _thc_binding->recv_any_x = omap_sdma_recv_any__thc_client_fn_x;
    (_thc_binding->call_seq).mem_copy = omap_sdma_mem_copy__call_seq;
    (_thc_binding->call_seq).mem_fill = omap_sdma_mem_fill__call_seq;
    (_thc_binding->call_seq).mem_copy_2d = omap_sdma_mem_copy_2d__call_seq;
    (_thc_binding->call_seq).mem_fill_2d = omap_sdma_mem_fill_2d__call_seq;
    (_thc_binding->call_fifo).mem_copy = omap_sdma_mem_copy__call_fifo;
    (_thc_binding->call_fifo).mem_fill = omap_sdma_mem_fill__call_fifo;
    (_thc_binding->call_fifo).mem_copy_2d = omap_sdma_mem_copy_2d__call_fifo;
    (_thc_binding->call_fifo).mem_fill_2d = omap_sdma_mem_fill_2d__call_fifo;
    (_thc_binding->call_seq_x).mem_copy = omap_sdma_mem_copy__call_seq_x;
    (_thc_binding->call_seq_x).mem_fill = omap_sdma_mem_fill__call_seq_x;
    (_thc_binding->call_seq_x).mem_copy_2d = omap_sdma_mem_copy_2d__call_seq_x;
    (_thc_binding->call_seq_x).mem_fill_2d = omap_sdma_mem_fill_2d__call_seq_x;
    (_thc_binding->call_fifo_x).mem_copy = omap_sdma_mem_copy__call_fifo_x;
    (_thc_binding->call_fifo_x).mem_fill = omap_sdma_mem_fill__call_fifo_x;
    (_thc_binding->call_fifo_x).mem_copy_2d = omap_sdma_mem_copy_2d__call_fifo_x;
    (_thc_binding->call_fifo_x).mem_fill_2d = omap_sdma_mem_fill_2d__call_fifo_x;
    return(0);
}

 errval_t omap_sdma_thc_init_service(omap_sdma_thc_service_binding_t *_thc_binding, struct omap_sdma_binding *_c2s_idc_binding, struct omap_sdma_binding *_s2c_idc_binding)
{
    CHECK_FIELD(struct omap_sdma_binding, st);
    CHECK_FIELD(struct omap_sdma_binding, waitset);
    CHECK_FIELD(struct omap_sdma_binding, mutex);
    CHECK_FIELD(struct omap_sdma_binding, can_send);
    CHECK_FIELD(struct omap_sdma_binding, register_send);
    CHECK_FIELD(struct omap_sdma_binding, change_waitset);
    CHECK_FIELD(struct omap_sdma_binding, control);
    CHECK_FIELD(struct omap_sdma_binding, error_handler);
    _thc_binding->_c2s_st = _c2s_idc_binding;
    _thc_binding->_s2c_st = _s2c_idc_binding;
    _c2s_idc_binding->st = _thc_binding;
    _s2c_idc_binding->st = _thc_binding;
    thc_init_per_binding_state(&(_thc_binding->thc_per_binding));
    (_thc_binding->send).mem_copy = (&omap_sdma_service_mem_copy__send);
    (_thc_binding->send).mem_fill = (&omap_sdma_service_mem_fill__send);
    (_thc_binding->send).mem_copy_2d = (&omap_sdma_service_mem_copy_2d__send);
    (_thc_binding->send).mem_fill_2d = (&omap_sdma_service_mem_fill_2d__send);
    (_thc_binding->send_x).mem_copy = (&omap_sdma_service_mem_copy__send_x);
    (_thc_binding->send_x).mem_fill = (&omap_sdma_service_mem_fill__send_x);
    (_thc_binding->send_x).mem_copy_2d = (&omap_sdma_service_mem_copy_2d__send_x);
    (_thc_binding->send_x).mem_fill_2d = (&omap_sdma_service_mem_fill_2d__send_x);
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy]));
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill]));
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[omap_sdma__call_mem_copy_2d]));
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[omap_sdma__call_mem_fill_2d]));
    (_c2s_idc_binding->rx_vtbl).mem_copy_call = (&omap_sdma_service_mem_copy__bh_recv);
    (_c2s_idc_binding->rx_vtbl).mem_fill_call = (&omap_sdma_service_mem_fill__bh_recv);
    (_c2s_idc_binding->rx_vtbl).mem_copy_2d_call = (&omap_sdma_service_mem_copy_2d__bh_recv);
    (_c2s_idc_binding->rx_vtbl).mem_fill_2d_call = (&omap_sdma_service_mem_fill_2d__bh_recv);
    (_thc_binding->recv).mem_copy = (&omap_sdma_service_mem_copy__recv);
    (_thc_binding->recv).mem_fill = (&omap_sdma_service_mem_fill__recv);
    (_thc_binding->recv).mem_copy_2d = (&omap_sdma_service_mem_copy_2d__recv);
    (_thc_binding->recv).mem_fill_2d = (&omap_sdma_service_mem_fill_2d__recv);
    (_thc_binding->recv_x).mem_copy = (&omap_sdma_service_mem_copy__recv_x);
    (_thc_binding->recv_x).mem_fill = (&omap_sdma_service_mem_fill__recv_x);
    (_thc_binding->recv_x).mem_copy_2d = (&omap_sdma_service_mem_copy_2d__recv_x);
    (_thc_binding->recv_x).mem_fill_2d = (&omap_sdma_service_mem_fill_2d__recv_x);
    _thc_binding->recv_any = omap_sdma_recv_any__thc_service_fn;
    _thc_binding->recv_any_x = omap_sdma_recv_any__thc_service_fn_x;
    return(0);
}


/*
 * Connection-management functions
 */
static  void omap_sdma_thc_export_cb(void *st, errval_t err, iref_t iref)
{
    struct omap_sdma_thc_export_info *info;
    info = ((struct omap_sdma_thc_export_info *)(st));
    thc_lock_acquire(&(info->info_lock));
    if (err_is_fail(err)) {
        info->err = err;
    } else {
        if ((info->service_name) != NULL) {
            info->err = nameservice_register(info->service_name, iref);
        }
        if ((info->iref_ptr) != NULL) {
            *(info->iref_ptr) = iref;
        }
    }
    thc_sem_v(&(info->export_cb_done_sem));
}

static  errval_t omap_sdma_thc_connect_cb(void *st, struct omap_sdma_binding *b)
{
    struct omap_sdma_thc_export_info *info;
    info = ((struct omap_sdma_thc_export_info *)(st));
    thc_sem_p(&(info->accept_call_present_sem));
    thc_lock_acquire(&(info->info_lock));
    *(info->b) = b;
    thc_sem_v(&(info->connect_cb_done_sem));
    return(SYS_ERR_OK);
}

 errval_t omap_sdma_thc_export(struct omap_sdma_thc_export_info *info, const char *service_name, struct waitset *ws, idc_export_flags_t flags, iref_t *iref_ptr)
{
    errval_t err;
    thc_sem_init(&(info->export_cb_done_sem), 0);
    thc_sem_init(&(info->connect_cb_done_sem), 0);
    thc_sem_init(&(info->accept_call_present_sem), 0);
    thc_lock_init(&(info->info_lock));
    thc_lock_init(&(info->next_accept_lock));
    info->service_name = service_name;
    info->err = SYS_ERR_OK;
    info->iref_ptr = iref_ptr;
    err = omap_sdma_export(info, omap_sdma_thc_export_cb, omap_sdma_thc_connect_cb, ws, flags);
    if (err_is_ok(err)) {
        thc_sem_p(&(info->export_cb_done_sem));
        err = (info->err);
        thc_lock_release(&(info->info_lock));
    }
    return(err);
}

 errval_t omap_sdma_thc_accept(struct omap_sdma_thc_export_info *info, struct omap_sdma_binding **b)
{
    struct omap_sdma_binding *priv_b;
    thc_lock_acquire(&(info->next_accept_lock));
    info->b = (&priv_b);
    thc_sem_v(&(info->accept_call_present_sem));
    thc_sem_p(&(info->connect_cb_done_sem));
    errval_t err = info->err;
    thc_lock_release(&(info->info_lock));
    thc_lock_release(&(info->next_accept_lock));
    if (err_is_ok(err)) {
        if (b != NULL) {
            *b = priv_b;
        }
    }
    return(err);
}

static  void omap_sdma_thc_bind_cb(void *st, errval_t err, struct omap_sdma_binding *b)
{
    struct omap_sdma_thc_connect_info *info;
    info = ((struct omap_sdma_thc_connect_info *)(st));
    info->err = err;
    if (err_is_ok(err)) {
        info->b = b;
    }
    thc_sem_v(&(info->bind_cb_done_sem));
}

 errval_t omap_sdma_thc_connect(iref_t iref, struct waitset *ws, idc_bind_flags_t flags, struct omap_sdma_binding **b)
{
    struct omap_sdma_thc_connect_info info;
    errval_t err;
    thc_sem_init(&(info.bind_cb_done_sem), 0);
    info.err = SYS_ERR_OK;
    info.b = NULL;
    err = omap_sdma_bind(iref, omap_sdma_thc_bind_cb, &info, ws, flags);
    if (err_is_ok(err)) {
        thc_sem_p(&(info.bind_cb_done_sem));
        err = (info.err);
        if (err_is_ok(err)) {
            if (b != NULL) {
                *b = (info.b);
            }
        }
    }
    return(err);
}

 errval_t omap_sdma_thc_connect_by_name(const char *service_name, struct waitset *ws, idc_bind_flags_t flags, struct omap_sdma_binding **b)
{
    errval_t err;
    iref_t iref;
    err = nameservice_blocking_lookup(service_name, &iref);
    if (err_is_ok(err)) {
        err = omap_sdma_thc_connect(iref, ws, flags, b);
    }
    return(err);
}


