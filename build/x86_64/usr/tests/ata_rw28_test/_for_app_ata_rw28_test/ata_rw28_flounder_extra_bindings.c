/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: ata_rw28
 * INTEFACE FILE: ../if/ata_rw28.if
 * INTERFACE DESCRIPTION: ATA read & write with 28-bit LBA
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

/*
 * Generated Stub for AHCI
 */

#include <stdio.h>
#include <string.h>
#include <barrelfish/barrelfish.h>
#include <flounder/flounder_support.h>
#include <ahci/ahci_dma_pool.h>
#include <ahci/ahci_util.h>
#include <ahci/sata_fis.h>
#include <if/ata_rw28_ahci_defs.h>

/*
 * Forward decleration of state struct
 */
struct completed_rx_st;

/*
 * Command completed handler signature
 */
typedef  void completed_rx_fn_t(struct ahci_binding *_binding, struct completed_rx_st *completed_st);

/*
 * Command dispatch and completion state struct
 */
struct completed_rx_st {
    /* Callback for handling message-specifics for command completion */
    completed_rx_fn_t *completed_fn;
    /* The ata_rw28 ahci binding */
    struct ahci_ata_rw28_binding *ahci_ata_rw28_binding;
    /* The DMA region associated with this command, if any */
    struct ahci_dma_region *dma_region;
    /* Number of bytes in DMA region */
    size_t bytes;
    
    /* Command fis */
    void *fis;
    /* User's dispatch continuation */
    struct event_closure dispatch_continuation;
};

/*
 * Debug printf
 */
#if defined(FLOUNDER_AHCI_DEBUG) || defined(FLOUNDER_DEBUG) || defined(GLOBAL_DEBUG)
#define AHCI_DEBUG(x...) printf("ahci_flounder: " x)
#else
#define AHCI_DEBUG(x...) ((void)0)
#endif // defined(FLOUNDER_AHCI_DEBUG) || defined(FLOUNDER_DEBUG) || defined(GLOBAL_DEBUG)

/*
 * Receiver functions for AHCI
 */
static  void ahci_command_completed__rx(struct ahci_binding *_binding, void *tag)
{
    struct completed_rx_st *st = (struct completed_rx_st *)(tag);
    (st->completed_fn)(_binding, st);
    free(st);
}

static  void ata_rw28_read_dma__completed(struct ahci_binding *_binding, struct completed_rx_st *completed_st)
{
    struct ahci_ata_rw28_binding *b = completed_st->ahci_ata_rw28_binding;
    
    AHCI_DEBUG("entering %s\n", __func__);
    
    uint8_t *_data = malloc(completed_st->bytes);
    ahci_dma_region_copy_out(completed_st->dma_region, _data, 0, completed_st->bytes);
    
    (((b->b).rx_vtbl).read_dma_response)(&(b->b), _data, completed_st->bytes);
    
    // free dma region
    ahci_dma_region_free(completed_st->dma_region);
}

static  void ata_rw28_read_dma_block__completed(struct ahci_binding *_binding, struct completed_rx_st *completed_st)
{
    struct ahci_ata_rw28_binding *b = completed_st->ahci_ata_rw28_binding;
    
    AHCI_DEBUG("entering %s\n", __func__);
    
    uint8_t *_data = malloc(completed_st->bytes);
    ahci_dma_region_copy_out(completed_st->dma_region, _data, 0, completed_st->bytes);
    
    (((b->b).rx_vtbl).read_dma_block_response)(&(b->b), _data, completed_st->bytes);
    
    // free dma region
    ahci_dma_region_free(completed_st->dma_region);
}

static  void ata_rw28_write_dma__completed(struct ahci_binding *_binding, struct completed_rx_st *completed_st)
{
    struct ahci_ata_rw28_binding *b = completed_st->ahci_ata_rw28_binding;
    
    AHCI_DEBUG("entering %s\n", __func__);
    
    (((b->b).rx_vtbl).write_dma_response)(&(b->b), SYS_ERR_OK);
    
    // free dma region
    ahci_dma_region_free(completed_st->dma_region);
}

static  void ata_rw28_identify_device__completed(struct ahci_binding *_binding, struct completed_rx_st *completed_st)
{
    struct ahci_ata_rw28_binding *b = completed_st->ahci_ata_rw28_binding;
    
    AHCI_DEBUG("entering %s\n", __func__);
    
    uint8_t *_data = malloc(completed_st->bytes);
    ahci_dma_region_copy_out(completed_st->dma_region, _data, 0, completed_st->bytes);
    
    (((b->b).rx_vtbl).identify_device_response)(&(b->b), _data, completed_st->bytes);
    
    // free dma region
    ahci_dma_region_free(completed_st->dma_region);
}

static  void ata_rw28_flush_cache__completed(struct ahci_binding *_binding, struct completed_rx_st *completed_st)
{
    struct ahci_ata_rw28_binding *b = completed_st->ahci_ata_rw28_binding;
    
    AHCI_DEBUG("entering %s\n", __func__);
    
    (((b->b).rx_vtbl).flush_cache_response)(&(b->b), SYS_ERR_OK);
}


/*
 * Command issue callback for freeing resources
 */
static  void issue_command_cb(void *arg)
{
    struct completed_rx_st *st;
    st = ((struct completed_rx_st *)(arg));
    free(st->fis);
    st->fis = NULL;
    // XXX: use waitset_chan_trigger_closure?
    if ((st->dispatch_continuation).handler) {
        ((st->dispatch_continuation).handler)((st->dispatch_continuation).arg);
    }
}


/*
 * Message sender functions
 */
static  errval_t ata_rw28_read_dma_call__ahci_send(struct ata_rw28_binding *_binding, struct event_closure _continuation, uint32_t read_size, uint32_t start_lba)
{
    errval_t err = 0;
    struct ahci_ata_rw28_binding *b = (struct ahci_ata_rw28_binding *)(_binding);
    
    AHCI_DEBUG("entering %s\n", __func__);
    
    // allocate state structure
    struct completed_rx_st *completed_st = calloc(1, sizeof(struct completed_rx_st ));
    if (!completed_st) {
        err = LIB_ERR_MALLOC_FAIL;
        goto cleanup;
    }
    completed_st->completed_fn = ata_rw28_read_dma__completed;
    completed_st->ahci_ata_rw28_binding = b;
    completed_st->dispatch_continuation = _continuation;
    
    // determine sector size
    size_t sector_size = 512;
    if (ata_identify_plss_lls_rdf(&((b->b_lib)->identify))) {
        sector_size = (2 * ata_identify_wpls_rd(&((b->b_lib)->identify)));
    }
    
    completed_st->bytes = read_size;
    
    // determine sector count
    size_t dma_count;
    dma_count = CEIL_DIV(completed_st->bytes, sector_size);
    
    // determine size of DMA region, which must be a multiple of the sector count
    size_t dma_region_size = dma_count * sector_size;
    
    // setup DMA region
    err = ahci_dma_region_alloc(dma_region_size, &(completed_st->dma_region));
    if (err_is_fail(err)) {
        printf("alloc_region failed: 0x%" PRIxERRV "\n", err);
        goto cleanup;
    }
    
    // setup FIS
    size_t fis_size;
    err = sata_alloc_h2d_register_fis(&(completed_st->fis), &fis_size);
    if (err_is_fail(err)) {
        printf("sata_alloc_h2d_register_fis failed: 0x%" PRIxERRV "\n", err);
        goto cleanup;
    }
    sata_set_command(completed_st->fis, 0xc8);
    sata_set_count(completed_st->fis, dma_count);
    sata_set_lba28(completed_st->fis, start_lba);
    
    // issue command
    err = ahci_issue_command(b->b_lib, MKCLOSURE(issue_command_cb, completed_st), completed_st, (uint8_t *)(completed_st->fis), fis_size, false, completed_st->dma_region, completed_st->bytes);
    if (err_is_fail(err)) {
        printf("ahci_issue_command failed: 0x%" PRIxERRV "\n", err);
        goto cleanup;
    }
    
    return(SYS_ERR_OK);
    
    cleanup:
    
    // free memory
    if (completed_st) {
        if (completed_st->fis) {
            free(completed_st->fis);
        }
        if (completed_st->dma_region) {
            ahci_dma_region_free(completed_st->dma_region);
        }
        free(completed_st);
    }
    
    return(err);
}

static  errval_t ata_rw28_read_dma_block_call__ahci_send(struct ata_rw28_binding *_binding, struct event_closure _continuation, uint32_t lba)
{
    errval_t err = 0;
    struct ahci_ata_rw28_binding *b = (struct ahci_ata_rw28_binding *)(_binding);
    
    AHCI_DEBUG("entering %s\n", __func__);
    
    // allocate state structure
    struct completed_rx_st *completed_st = calloc(1, sizeof(struct completed_rx_st ));
    if (!completed_st) {
        err = LIB_ERR_MALLOC_FAIL;
        goto cleanup;
    }
    completed_st->completed_fn = ata_rw28_read_dma_block__completed;
    completed_st->ahci_ata_rw28_binding = b;
    completed_st->dispatch_continuation = _continuation;
    
    // determine sector size
    size_t sector_size = 512;
    if (ata_identify_plss_lls_rdf(&((b->b_lib)->identify))) {
        sector_size = (2 * ata_identify_wpls_rd(&((b->b_lib)->identify)));
    }
    
    completed_st->bytes = 512;
    
    // determine sector count
    size_t dma_count;
    dma_count = CEIL_DIV(completed_st->bytes, sector_size);
    
    // determine size of DMA region, which must be a multiple of the sector count
    size_t dma_region_size = dma_count * sector_size;
    
    // setup DMA region
    err = ahci_dma_region_alloc(dma_region_size, &(completed_st->dma_region));
    if (err_is_fail(err)) {
        printf("alloc_region failed: 0x%" PRIxERRV "\n", err);
        goto cleanup;
    }
    
    // setup FIS
    size_t fis_size;
    err = sata_alloc_h2d_register_fis(&(completed_st->fis), &fis_size);
    if (err_is_fail(err)) {
        printf("sata_alloc_h2d_register_fis failed: 0x%" PRIxERRV "\n", err);
        goto cleanup;
    }
    sata_set_command(completed_st->fis, 0xc8);
    sata_set_count(completed_st->fis, dma_count);
    sata_set_lba28(completed_st->fis, lba);
    
    // issue command
    err = ahci_issue_command(b->b_lib, MKCLOSURE(issue_command_cb, completed_st), completed_st, (uint8_t *)(completed_st->fis), fis_size, false, completed_st->dma_region, completed_st->bytes);
    if (err_is_fail(err)) {
        printf("ahci_issue_command failed: 0x%" PRIxERRV "\n", err);
        goto cleanup;
    }
    
    return(SYS_ERR_OK);
    
    cleanup:
    
    // free memory
    if (completed_st) {
        if (completed_st->fis) {
            free(completed_st->fis);
        }
        if (completed_st->dma_region) {
            ahci_dma_region_free(completed_st->dma_region);
        }
        free(completed_st);
    }
    
    return(err);
}

static  errval_t ata_rw28_write_dma_call__ahci_send(struct ata_rw28_binding *_binding, struct event_closure _continuation, const uint8_t *buffer, size_t buffer_size, uint32_t lba)
{
    errval_t err = 0;
    struct ahci_ata_rw28_binding *b = (struct ahci_ata_rw28_binding *)(_binding);
    
    AHCI_DEBUG("entering %s\n", __func__);
    
    // allocate state structure
    struct completed_rx_st *completed_st = calloc(1, sizeof(struct completed_rx_st ));
    if (!completed_st) {
        err = LIB_ERR_MALLOC_FAIL;
        goto cleanup;
    }
    completed_st->completed_fn = ata_rw28_write_dma__completed;
    completed_st->ahci_ata_rw28_binding = b;
    completed_st->dispatch_continuation = _continuation;
    
    // determine sector size
    size_t sector_size = 512;
    if (ata_identify_plss_lls_rdf(&((b->b_lib)->identify))) {
        sector_size = (2 * ata_identify_wpls_rd(&((b->b_lib)->identify)));
    }
    
    completed_st->bytes = buffer_size;
    
    // determine sector count
    size_t dma_count;
    dma_count = ((completed_st->bytes) / sector_size);
    // recalculate read size to match rounded down sector count
    completed_st->bytes = (dma_count * sector_size);
    
    // determine size of DMA region, which must be a multiple of the sector count
    size_t dma_region_size = dma_count * sector_size;
    
    // setup DMA region
    err = ahci_dma_region_alloc(dma_region_size, &(completed_st->dma_region));
    if (err_is_fail(err)) {
        printf("alloc_region failed: 0x%" PRIxERRV "\n", err);
        goto cleanup;
    }
    
    // copy in DMA data
    ahci_dma_region_copy_in(completed_st->dma_region, (void *)(buffer), 0, completed_st->bytes);
    
    // setup FIS
    size_t fis_size;
    err = sata_alloc_h2d_register_fis(&(completed_st->fis), &fis_size);
    if (err_is_fail(err)) {
        printf("sata_alloc_h2d_register_fis failed: 0x%" PRIxERRV "\n", err);
        goto cleanup;
    }
    sata_set_command(completed_st->fis, 0xca);
    sata_set_count(completed_st->fis, dma_count);
    sata_set_lba28(completed_st->fis, lba);
    
    // issue command
    err = ahci_issue_command(b->b_lib, MKCLOSURE(issue_command_cb, completed_st), completed_st, (uint8_t *)(completed_st->fis), fis_size, 1, completed_st->dma_region, completed_st->bytes);
    if (err_is_fail(err)) {
        printf("ahci_issue_command failed: 0x%" PRIxERRV "\n", err);
        goto cleanup;
    }
    
    return(SYS_ERR_OK);
    
    cleanup:
    
    // free memory
    if (completed_st) {
        if (completed_st->fis) {
            free(completed_st->fis);
        }
        if (completed_st->dma_region) {
            ahci_dma_region_free(completed_st->dma_region);
        }
        free(completed_st);
    }
    
    return(err);
}

static  errval_t ata_rw28_identify_device_call__ahci_send(struct ata_rw28_binding *_binding, struct event_closure _continuation)
{
    errval_t err = 0;
    struct ahci_ata_rw28_binding *b = (struct ahci_ata_rw28_binding *)(_binding);
    
    AHCI_DEBUG("entering %s\n", __func__);
    
    // allocate state structure
    struct completed_rx_st *completed_st = calloc(1, sizeof(struct completed_rx_st ));
    if (!completed_st) {
        err = LIB_ERR_MALLOC_FAIL;
        goto cleanup;
    }
    completed_st->completed_fn = ata_rw28_identify_device__completed;
    completed_st->ahci_ata_rw28_binding = b;
    completed_st->dispatch_continuation = _continuation;
    
    // determine sector size
    size_t sector_size = 512;
    if (ata_identify_plss_lls_rdf(&((b->b_lib)->identify))) {
        sector_size = (2 * ata_identify_wpls_rd(&((b->b_lib)->identify)));
    }
    
    completed_st->bytes = 512;
    
    // determine sector count
    size_t dma_count;
    dma_count = CEIL_DIV(completed_st->bytes, sector_size);
    
    // determine size of DMA region, which must be a multiple of the sector count
    size_t dma_region_size = dma_count * sector_size;
    
    // setup DMA region
    err = ahci_dma_region_alloc(dma_region_size, &(completed_st->dma_region));
    if (err_is_fail(err)) {
        printf("alloc_region failed: 0x%" PRIxERRV "\n", err);
        goto cleanup;
    }
    
    // setup FIS
    size_t fis_size;
    err = sata_alloc_h2d_register_fis(&(completed_st->fis), &fis_size);
    if (err_is_fail(err)) {
        printf("sata_alloc_h2d_register_fis failed: 0x%" PRIxERRV "\n", err);
        goto cleanup;
    }
    sata_set_command(completed_st->fis, 0xec);
    sata_set_count(completed_st->fis, dma_count);
    
    // issue command
    err = ahci_issue_command(b->b_lib, MKCLOSURE(issue_command_cb, completed_st), completed_st, (uint8_t *)(completed_st->fis), fis_size, false, completed_st->dma_region, completed_st->bytes);
    if (err_is_fail(err)) {
        printf("ahci_issue_command failed: 0x%" PRIxERRV "\n", err);
        goto cleanup;
    }
    
    return(SYS_ERR_OK);
    
    cleanup:
    
    // free memory
    if (completed_st) {
        if (completed_st->fis) {
            free(completed_st->fis);
        }
        if (completed_st->dma_region) {
            ahci_dma_region_free(completed_st->dma_region);
        }
        free(completed_st);
    }
    
    return(err);
}

static  errval_t ata_rw28_flush_cache_call__ahci_send(struct ata_rw28_binding *_binding, struct event_closure _continuation)
{
    errval_t err = 0;
    struct ahci_ata_rw28_binding *b = (struct ahci_ata_rw28_binding *)(_binding);
    
    AHCI_DEBUG("entering %s\n", __func__);
    
    // allocate state structure
    struct completed_rx_st *completed_st = calloc(1, sizeof(struct completed_rx_st ));
    if (!completed_st) {
        err = LIB_ERR_MALLOC_FAIL;
        goto cleanup;
    }
    completed_st->completed_fn = ata_rw28_flush_cache__completed;
    completed_st->ahci_ata_rw28_binding = b;
    completed_st->dispatch_continuation = _continuation;
    
    // determine sector size
    size_t sector_size = 512;
    if (ata_identify_plss_lls_rdf(&((b->b_lib)->identify))) {
        sector_size = (2 * ata_identify_wpls_rd(&((b->b_lib)->identify)));
    }
    
    // setup FIS
    size_t fis_size;
    err = sata_alloc_h2d_register_fis(&(completed_st->fis), &fis_size);
    if (err_is_fail(err)) {
        printf("sata_alloc_h2d_register_fis failed: 0x%" PRIxERRV "\n", err);
        goto cleanup;
    }
    sata_set_command(completed_st->fis, 0xe7);
    
    // issue command
    err = ahci_issue_command(b->b_lib, MKCLOSURE(issue_command_cb, completed_st), completed_st, (uint8_t *)(completed_st->fis), fis_size, false, NULL, 0);
    if (err_is_fail(err)) {
        printf("ahci_issue_command failed: 0x%" PRIxERRV "\n", err);
        goto cleanup;
    }
    
    return(SYS_ERR_OK);
    
    cleanup:
    
    // free memory
    if (completed_st) {
        if (completed_st->fis) {
            free(completed_st->fis);
        }
        if (completed_st->dma_region) {
            ahci_dma_region_free(completed_st->dma_region);
        }
        free(completed_st);
    }
    
    return(err);
}


/*
 * Send vtable
 */
static  struct ata_rw28_tx_vtbl ata_rw28_ahci_tx_vtbl = {
    .read_dma_call = ata_rw28_read_dma_call__ahci_send,
    .read_dma_response = NULL,
    .read_dma_block_call = ata_rw28_read_dma_block_call__ahci_send,
    .read_dma_block_response = NULL,
    .write_dma_call = ata_rw28_write_dma_call__ahci_send,
    .write_dma_response = NULL,
    .identify_device_call = ata_rw28_identify_device_call__ahci_send,
    .identify_device_response = NULL,
    .flush_cache_call = ata_rw28_flush_cache_call__ahci_send,
    .flush_cache_response = NULL,
};

/*
 * Control functions
 */
static  bool ata_rw28_ahci_can_send(struct ata_rw28_binding *_binding)
{
    struct ahci_ata_rw28_binding *b = (struct ahci_ata_rw28_binding *)(_binding);
    return(((b->b_lib)->can_send)(b->b_lib));
}

static  errval_t ata_rw28_ahci_register_send(struct ata_rw28_binding *_binding, struct waitset *waitset, struct event_closure _continuation)
{
    struct ahci_ata_rw28_binding *b = (struct ahci_ata_rw28_binding *)(_binding);
    return(((b->b_lib)->register_send)(b->b_lib, waitset, _continuation));
}

static  void ata_rw28_ahci_default_error_handler(struct ata_rw28_binding *b, errval_t err)
{
    DEBUG_ERR(err, "asynchronous error in Flounder-generated ata_rw28 ahci binding (default handler)");
    abort();
}

static  errval_t ahci_ata_rw28_change_waitset(struct ata_rw28_binding *_binding, struct waitset *ws)
{
    struct ahci_ata_rw28_binding *b = (struct ahci_ata_rw28_binding *)(_binding);
    
    // change waitset on binding
    _binding->waitset = ws;
    ((b->b_lib)->change_waitset)(b->b_lib, ws);
    
    return(SYS_ERR_OK);
}

/*
 * Binding initialization function
 */
 errval_t ahci_ata_rw28_init(struct ahci_ata_rw28_binding *binding, struct waitset *waitset, struct ahci_binding *ahci_binding)
{
    errval_t err = SYS_ERR_OK;
    
    (binding->b).st = NULL;
    (binding->b).waitset = waitset;
    event_mutex_init(&((binding->b).mutex), waitset);
    (binding->b).can_send = ata_rw28_ahci_can_send;
    (binding->b).register_send = ata_rw28_ahci_register_send;
    (binding->b).error_handler = ata_rw28_ahci_default_error_handler;
    (binding->b).tx_vtbl = ata_rw28_ahci_tx_vtbl;
    memset(&((binding->b).rx_vtbl), 0, sizeof((binding->b).rx_vtbl));
    flounder_support_waitset_chanstate_init(&((binding->b).register_chanstate));
    flounder_support_waitset_chanstate_init(&((binding->b).tx_cont_chanstate));
    (binding->b).tx_msgnum = 0;
    (binding->b).rx_msgnum = 0;
    (binding->b).tx_msg_fragment = 0;
    (binding->b).rx_msg_fragment = 0;
    (binding->b).tx_str_pos = 0;
    (binding->b).rx_str_pos = 0;
    (binding->b).tx_str_len = 0;
    (binding->b).rx_str_len = 0;
    (binding->b).bind_cont = NULL;
    (binding->b).change_waitset = ahci_ata_rw28_change_waitset;
    
    binding->b_lib = ahci_binding;
    ((binding->b_lib)->change_waitset)(binding->b_lib, waitset);
    
    ((binding->b_lib)->rx_vtbl).command_completed = ahci_command_completed__rx;
    
    // initialize DMA buffer pool with 1M space
    ahci_dma_pool_init(1048576);
    
    return(err);
}


/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: ata_rw28
 * INTEFACE FILE: ../if/ata_rw28.if
 * INTERFACE DESCRIPTION: ATA read & write with 28-bit LBA
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

/*
 * Generated Stub for RPC
 */

#include <barrelfish/barrelfish.h>
#include <flounder/flounder_support.h>
#include <if/ata_rw28_rpcclient_defs.h>

/*
 * RPC wrapper functions
 */
static  errval_t ata_rw28_read_dma__rpc(struct ata_rw28_rpc_client *_rpc, uint32_t read_size, uint32_t start_lba, uint8_t **buffer, size_t *buffer_size)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).read_dma_call)(_rpc->b, NOP_CONT, read_size, start_lba));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct ata_rw28_binding *_binding = _rpc->b;
    *buffer = (((_binding->rx_union).read_dma_response).buffer);
    *buffer_size = (((_binding->rx_union).read_dma_response).buffer_size);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t ata_rw28_read_dma_block__rpc(struct ata_rw28_rpc_client *_rpc, uint32_t lba, uint8_t **buffer, size_t *buffer_size)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).read_dma_block_call)(_rpc->b, NOP_CONT, lba));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct ata_rw28_binding *_binding = _rpc->b;
    *buffer = (((_binding->rx_union).read_dma_block_response).buffer);
    *buffer_size = (((_binding->rx_union).read_dma_block_response).buffer_size);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t ata_rw28_write_dma__rpc(struct ata_rw28_rpc_client *_rpc, const uint8_t *buffer, size_t buffer_size, uint32_t lba, ata_rw28_errval_t *status)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).write_dma_call)(_rpc->b, NOP_CONT, buffer, buffer_size, lba));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct ata_rw28_binding *_binding = _rpc->b;
    *status = (((_binding->rx_union).write_dma_response).status);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t ata_rw28_identify_device__rpc(struct ata_rw28_rpc_client *_rpc, uint8_t **buffer, size_t *buffer_size)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).identify_device_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct ata_rw28_binding *_binding = _rpc->b;
    *buffer = (((_binding->rx_union).identify_device_response).buffer);
    *buffer_size = (((_binding->rx_union).identify_device_response).buffer_size);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t ata_rw28_flush_cache__rpc(struct ata_rw28_rpc_client *_rpc, ata_rw28_errval_t *status)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).flush_cache_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct ata_rw28_binding *_binding = _rpc->b;
    *status = (((_binding->rx_union).flush_cache_response).status);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}


/*
 * Receive handlers
 */
static  void ata_rw28_read_dma__rpc_rx_handler(struct ata_rw28_binding *_binding, uint8_t *buffer, size_t buffer_size)
{
    // get RPC client state pointer
    struct ata_rw28_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).read_dma_response).buffer = buffer;
    ((_binding->rx_union).read_dma_response).buffer_size = buffer_size;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void ata_rw28_read_dma_block__rpc_rx_handler(struct ata_rw28_binding *_binding, uint8_t *buffer, size_t buffer_size)
{
    // get RPC client state pointer
    struct ata_rw28_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).read_dma_block_response).buffer = buffer;
    ((_binding->rx_union).read_dma_block_response).buffer_size = buffer_size;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void ata_rw28_write_dma__rpc_rx_handler(struct ata_rw28_binding *_binding, ata_rw28_errval_t status)
{
    // get RPC client state pointer
    struct ata_rw28_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).write_dma_response).status = status;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void ata_rw28_identify_device__rpc_rx_handler(struct ata_rw28_binding *_binding, uint8_t *buffer, size_t buffer_size)
{
    // get RPC client state pointer
    struct ata_rw28_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).identify_device_response).buffer = buffer;
    ((_binding->rx_union).identify_device_response).buffer_size = buffer_size;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void ata_rw28_flush_cache__rpc_rx_handler(struct ata_rw28_binding *_binding, ata_rw28_errval_t status)
{
    // get RPC client state pointer
    struct ata_rw28_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).flush_cache_response).status = status;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}


/*
 * RPC Vtable
 */
static  struct ata_rw28_rpc_vtbl ata_rw28_rpc_vtbl = {
    .read_dma = ata_rw28_read_dma__rpc,
    .read_dma_block = ata_rw28_read_dma_block__rpc,
    .write_dma = ata_rw28_write_dma__rpc,
    .identify_device = ata_rw28_identify_device__rpc,
    .flush_cache = ata_rw28_flush_cache__rpc,
};

/*
 * Error handler
 */
static  void ata_rw28_rpc_client_error(struct ata_rw28_binding *_binding, errval_t _err)
{
    // get RPC client state pointer
    struct ata_rw28_rpc_client *_rpc = _binding->st;
    
    if (_rpc->rpc_in_progress) {
        assert(err_is_fail(_err));
        _rpc->async_error = _err;
        // kick waitset with dummy event
        flounder_support_register(&(_rpc->rpc_waitset), &(_rpc->dummy_chanstate), dummy_event_closure, true);
    } else {
        USER_PANIC_ERR(_err, "async error in RPC");
    }
}


/*
 * Init function
 */
 errval_t ata_rw28_rpc_client_init(struct ata_rw28_rpc_client *rpc, struct ata_rw28_binding *binding)
{
    errval_t _err;
    
    // Setup state of RPC client object
    rpc->b = binding;
    rpc->reply_present = false;
    rpc->rpc_in_progress = false;
    rpc->async_error = SYS_ERR_OK;
    waitset_init(&(rpc->rpc_waitset));
    flounder_support_waitset_chanstate_init(&(rpc->dummy_chanstate));
    rpc->vtbl = ata_rw28_rpc_vtbl;
    binding->st = rpc;
    
    // Change waitset on binding
    _err = ((binding->change_waitset)(binding, &(rpc->rpc_waitset)));
    if (err_is_fail(_err)) {
        waitset_destroy(&(rpc->rpc_waitset));
        return(err_push(_err, FLOUNDER_ERR_CHANGE_WAITSET));
    }
    
    // Set RX handlers on binding object for RPCs
    (binding->rx_vtbl).read_dma_response = ata_rw28_read_dma__rpc_rx_handler;
    (binding->rx_vtbl).read_dma_block_response = ata_rw28_read_dma_block__rpc_rx_handler;
    (binding->rx_vtbl).write_dma_response = ata_rw28_write_dma__rpc_rx_handler;
    (binding->rx_vtbl).identify_device_response = ata_rw28_identify_device__rpc_rx_handler;
    (binding->rx_vtbl).flush_cache_response = ata_rw28_flush_cache__rpc_rx_handler;
    
    // Set error handler on binding object
    binding->error_handler = ata_rw28_rpc_client_error;
    
    return(SYS_ERR_OK);
}

