/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: mem
 * INTEFACE FILE: ../if/mem.if
 * INTERFACE DESCRIPTION: Memory allocation RPC interface
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

#include <stddef.h>
#ifdef BARRELFISH
#include <barrelfish/barrelfish.h>
#include <barrelfish/nameservice_client.h>
#include "if/mem_thc.h"
#include "thc/thc.h"
#else
#include "mem_thc.h"
#include "thc.h"
#endif // BARRELFISH

/*
 * Send functions
 */
static  errval_t mem_client_allocate__send(struct mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit)
{
    struct mem_binding *_idc_binding = (struct mem_binding *)(_thc_binding->_c2s_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).allocate_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), bits, minbase, maxlimit);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t mem_client_steal__send(struct mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit)
{
    struct mem_binding *_idc_binding = (struct mem_binding *)(_thc_binding->_c2s_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).steal_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), bits, minbase, maxlimit);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t mem_client_available__send(struct mem_thc_client_binding_t *_thc_binding)
{
    struct mem_binding *_idc_binding = (struct mem_binding *)(_thc_binding->_c2s_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).available_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)));
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t mem_client_free_monitor__send(struct mem_thc_client_binding_t *_thc_binding, struct capref mem_cap, mem_genpaddr_t base, uint8_t bits)
{
    struct mem_binding *_idc_binding = (struct mem_binding *)(_thc_binding->_c2s_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).free_monitor_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), mem_cap, base, bits);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t mem_service_allocate__send(struct mem_thc_service_binding_t *_thc_binding, mem_errval_t ret, struct capref mem_cap)
{
    struct mem_binding *_idc_binding = (struct mem_binding *)(_thc_binding->_s2c_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).allocate_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), ret, mem_cap);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t mem_service_steal__send(struct mem_thc_service_binding_t *_thc_binding, mem_errval_t ret, struct capref mem_cap)
{
    struct mem_binding *_idc_binding = (struct mem_binding *)(_thc_binding->_s2c_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).steal_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), ret, mem_cap);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t mem_service_available__send(struct mem_thc_service_binding_t *_thc_binding, mem_genpaddr_t mem_avail, mem_genpaddr_t mem_total)
{
    struct mem_binding *_idc_binding = (struct mem_binding *)(_thc_binding->_s2c_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).available_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), mem_avail, mem_total);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t mem_service_free_monitor__send(struct mem_thc_service_binding_t *_thc_binding, mem_errval_t err)
{
    struct mem_binding *_idc_binding = (struct mem_binding *)(_thc_binding->_s2c_st);
    thc_sem_p(&((_thc_binding->thc_per_binding).thc_next_sender));
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).free_monitor_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), err);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            thc_await_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t mem_client_allocate__send_x(struct mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit)
{
    struct mem_binding *_idc_binding = (struct mem_binding *)(_thc_binding->_c2s_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).allocate_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), bits, minbase, maxlimit);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t mem_client_steal__send_x(struct mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit)
{
    struct mem_binding *_idc_binding = (struct mem_binding *)(_thc_binding->_c2s_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).steal_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), bits, minbase, maxlimit);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t mem_client_available__send_x(struct mem_thc_client_binding_t *_thc_binding)
{
    struct mem_binding *_idc_binding = (struct mem_binding *)(_thc_binding->_c2s_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).available_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)));
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t mem_client_free_monitor__send_x(struct mem_thc_client_binding_t *_thc_binding, struct capref mem_cap, mem_genpaddr_t base, uint8_t bits)
{
    struct mem_binding *_idc_binding = (struct mem_binding *)(_thc_binding->_c2s_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).free_monitor_call)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), mem_cap, base, bits);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t mem_service_allocate__send_x(struct mem_thc_service_binding_t *_thc_binding, mem_errval_t ret, struct capref mem_cap)
{
    struct mem_binding *_idc_binding = (struct mem_binding *)(_thc_binding->_s2c_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).allocate_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), ret, mem_cap);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t mem_service_steal__send_x(struct mem_thc_service_binding_t *_thc_binding, mem_errval_t ret, struct capref mem_cap)
{
    struct mem_binding *_idc_binding = (struct mem_binding *)(_thc_binding->_s2c_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).steal_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), ret, mem_cap);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t mem_service_available__send_x(struct mem_thc_service_binding_t *_thc_binding, mem_genpaddr_t mem_avail, mem_genpaddr_t mem_total)
{
    struct mem_binding *_idc_binding = (struct mem_binding *)(_thc_binding->_s2c_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).available_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), mem_avail, mem_total);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}

static  errval_t mem_service_free_monitor__send_x(struct mem_thc_service_binding_t *_thc_binding, mem_errval_t err)
{
    struct mem_binding *_idc_binding = (struct mem_binding *)(_thc_binding->_s2c_st);
    if (thc_sem_p_x(&((_thc_binding->thc_per_binding).thc_next_sender)) == THC_CANCELED) {
        return(THC_CANCELED);
    }
    (_thc_binding->thc_per_binding).thc_send_complete = 0;
    THCIncSendCount();
    do {
        errval_t _r = ((_idc_binding->tx_vtbl).free_monitor_response)(_idc_binding, (MKCONT(thc_complete_send_cb, _idc_binding)), err);
        if (_r == FLOUNDER_ERR_TX_BUSY) {
            if (thc_await_send_x(&(_thc_binding->thc_per_binding), &(_idc_binding->st)) == THC_CANCELED) {
                thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
                return(THC_CANCELED);
            }
        } else {
            thc_complete_send(&(_thc_binding->thc_per_binding), &(_idc_binding->st));
            thc_sem_v(&((_thc_binding->thc_per_binding).thc_next_sender));
            return(_r);
        }
    } while (1);
}



/*
 * Struct type for holding pointers to the args for each msg
 */
struct mem_allocate__in_ptr_args_t {
    uint8_t *bits;
    mem_genpaddr_t *minbase;
    mem_genpaddr_t *maxlimit;
};
struct mem_allocate__out_ptr_args_t {
    mem_errval_t *ret;
    struct capref *mem_cap;
};
union mem_allocate___ptr_union_t {
    struct mem_allocate__in_ptr_args_t in;
    struct mem_allocate__out_ptr_args_t out;
};
struct mem_steal__in_ptr_args_t {
    uint8_t *bits;
    mem_genpaddr_t *minbase;
    mem_genpaddr_t *maxlimit;
};
struct mem_steal__out_ptr_args_t {
    mem_errval_t *ret;
    struct capref *mem_cap;
};
union mem_steal___ptr_union_t {
    struct mem_steal__in_ptr_args_t in;
    struct mem_steal__out_ptr_args_t out;
};
struct mem_available__in_ptr_args_t {
};
struct mem_available__out_ptr_args_t {
    mem_genpaddr_t *mem_avail;
    mem_genpaddr_t *mem_total;
};
union mem_available___ptr_union_t {
    struct mem_available__in_ptr_args_t in;
    struct mem_available__out_ptr_args_t out;
};
struct mem_free_monitor__in_ptr_args_t {
    struct capref *mem_cap;
    mem_genpaddr_t *base;
    uint8_t *bits;
};
struct mem_free_monitor__out_ptr_args_t {
    mem_errval_t *err;
};
union mem_free_monitor___ptr_union_t {
    struct mem_free_monitor__in_ptr_args_t in;
    struct mem_free_monitor__out_ptr_args_t out;
};

/*
 * Struct type for Receive-any and Bottom-half receive functions to hold pointers-to-message-argument structs
 */
struct mem_thc_ptr_arg_struct {
    union mem_allocate___ptr_union_t allocate;
    union mem_steal___ptr_union_t steal;
    union mem_available___ptr_union_t available;
    union mem_free_monitor___ptr_union_t free_monitor;
};

/*
 * Receive functions
 */
static  errval_t mem_client_allocate__recv(struct mem_thc_client_binding_t *_thc_binding, mem_errval_t *ret, struct capref *mem_cap)
{
    errval_t _result;
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.allocate).out).ret = ret;
    ((_args.allocate).out).mem_cap = mem_cap;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_allocate]), &_rxi);
    return(_result);
}

static  errval_t mem_client_steal__recv(struct mem_thc_client_binding_t *_thc_binding, mem_errval_t *ret, struct capref *mem_cap)
{
    errval_t _result;
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.steal).out).ret = ret;
    ((_args.steal).out).mem_cap = mem_cap;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_steal]), &_rxi);
    return(_result);
}

static  errval_t mem_client_available__recv(struct mem_thc_client_binding_t *_thc_binding, mem_genpaddr_t *mem_avail, mem_genpaddr_t *mem_total)
{
    errval_t _result;
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.available).out).mem_avail = mem_avail;
    ((_args.available).out).mem_total = mem_total;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_available]), &_rxi);
    return(_result);
}

static  errval_t mem_client_free_monitor__recv(struct mem_thc_client_binding_t *_thc_binding, mem_errval_t *err)
{
    errval_t _result;
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.free_monitor).out).err = err;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_free_monitor]), &_rxi);
    return(_result);
}

static  errval_t mem_service_allocate__recv(struct mem_thc_service_binding_t *_thc_binding, uint8_t *bits, mem_genpaddr_t *minbase, mem_genpaddr_t *maxlimit)
{
    errval_t _result;
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.allocate).in).bits = bits;
    ((_args.allocate).in).minbase = minbase;
    ((_args.allocate).in).maxlimit = maxlimit;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_allocate]), &_rxi);
    return(_result);
}

static  errval_t mem_service_steal__recv(struct mem_thc_service_binding_t *_thc_binding, uint8_t *bits, mem_genpaddr_t *minbase, mem_genpaddr_t *maxlimit)
{
    errval_t _result;
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.steal).in).bits = bits;
    ((_args.steal).in).minbase = minbase;
    ((_args.steal).in).maxlimit = maxlimit;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_steal]), &_rxi);
    return(_result);
}

static  errval_t mem_service_available__recv(struct mem_thc_service_binding_t *_thc_binding)
{
    errval_t _result;
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_available]), &_rxi);
    return(_result);
}

static  errval_t mem_service_free_monitor__recv(struct mem_thc_service_binding_t *_thc_binding, struct capref *mem_cap, mem_genpaddr_t *base, uint8_t *bits)
{
    errval_t _result;
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.free_monitor).in).mem_cap = mem_cap;
    ((_args.free_monitor).in).base = base;
    ((_args.free_monitor).in).bits = bits;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_free_monitor]), &_rxi);
    return(_result);
}

static  errval_t mem_client_allocate__recv_x(struct mem_thc_client_binding_t *_thc_binding, mem_errval_t *ret, struct capref *mem_cap)
{
    errval_t _result;
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.allocate).out).ret = ret;
    ((_args.allocate).out).mem_cap = mem_cap;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_allocate]), &_rxi);
    return(_result);
}

static  errval_t mem_client_steal__recv_x(struct mem_thc_client_binding_t *_thc_binding, mem_errval_t *ret, struct capref *mem_cap)
{
    errval_t _result;
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.steal).out).ret = ret;
    ((_args.steal).out).mem_cap = mem_cap;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_steal]), &_rxi);
    return(_result);
}

static  errval_t mem_client_available__recv_x(struct mem_thc_client_binding_t *_thc_binding, mem_genpaddr_t *mem_avail, mem_genpaddr_t *mem_total)
{
    errval_t _result;
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.available).out).mem_avail = mem_avail;
    ((_args.available).out).mem_total = mem_total;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_available]), &_rxi);
    return(_result);
}

static  errval_t mem_client_free_monitor__recv_x(struct mem_thc_client_binding_t *_thc_binding, mem_errval_t *err)
{
    errval_t _result;
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.free_monitor).out).err = err;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_free_monitor]), &_rxi);
    return(_result);
}

static  errval_t mem_service_allocate__recv_x(struct mem_thc_service_binding_t *_thc_binding, uint8_t *bits, mem_genpaddr_t *minbase, mem_genpaddr_t *maxlimit)
{
    errval_t _result;
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.allocate).in).bits = bits;
    ((_args.allocate).in).minbase = minbase;
    ((_args.allocate).in).maxlimit = maxlimit;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_allocate]), &_rxi);
    return(_result);
}

static  errval_t mem_service_steal__recv_x(struct mem_thc_service_binding_t *_thc_binding, uint8_t *bits, mem_genpaddr_t *minbase, mem_genpaddr_t *maxlimit)
{
    errval_t _result;
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.steal).in).bits = bits;
    ((_args.steal).in).minbase = minbase;
    ((_args.steal).in).maxlimit = maxlimit;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_steal]), &_rxi);
    return(_result);
}

static  errval_t mem_service_available__recv_x(struct mem_thc_service_binding_t *_thc_binding)
{
    errval_t _result;
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_available]), &_rxi);
    return(_result);
}

static  errval_t mem_service_free_monitor__recv_x(struct mem_thc_service_binding_t *_thc_binding, struct capref *mem_cap, mem_genpaddr_t *base, uint8_t *bits)
{
    errval_t _result;
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.free_monitor).in).mem_cap = mem_cap;
    ((_args.free_monitor).in).base = base;
    ((_args.free_monitor).in).bits = bits;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_free_monitor]), &_rxi);
    return(_result);
}


/*
 * Receive-any functions
 */
static  errval_t mem_recv_any__thc_client_fn(mem_thc_client_binding_t *_thc_binding, struct mem_client_msg *msg, struct mem_client_selector ops)
{
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    errval_t _r = 0;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = ((int *)(&(msg->msg)));
    thc_start_receive_any(&(_thc_binding->thc_per_binding));
    if ((ops.allocate) != 0) {
        ((_args.allocate).out).ret = (&((((msg->args).allocate).out).ret));
        ((_args.allocate).out).mem_cap = (&((((msg->args).allocate).out).mem_cap));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_allocate]), &_rxi);
    }
    if ((ops.steal) != 0) {
        ((_args.steal).out).ret = (&((((msg->args).steal).out).ret));
        ((_args.steal).out).mem_cap = (&((((msg->args).steal).out).mem_cap));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_steal]), &_rxi);
    }
    if ((ops.available) != 0) {
        ((_args.available).out).mem_avail = (&((((msg->args).available).out).mem_avail));
        ((_args.available).out).mem_total = (&((((msg->args).available).out).mem_total));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_available]), &_rxi);
    }
    if ((ops.free_monitor) != 0) {
        ((_args.free_monitor).out).err = (&((((msg->args).free_monitor).out).err));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_free_monitor]), &_rxi);
    }
    thc_wait_receive_any(&(_thc_binding->thc_per_binding), &_rxi);
    if ((ops.allocate) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_allocate]), &_rxi);
    }
    if ((ops.steal) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_steal]), &_rxi);
    }
    if ((ops.available) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_available]), &_rxi);
    }
    if ((ops.free_monitor) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_free_monitor]), &_rxi);
    }
    thc_end_receive_any(&(_thc_binding->thc_per_binding));
    return(_r);
}

static  errval_t mem_recv_any__thc_service_fn(mem_thc_service_binding_t *_thc_binding, struct mem_service_msg *msg, struct mem_service_selector ops)
{
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    errval_t _r = 0;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = ((int *)(&(msg->msg)));
    thc_start_receive_any(&(_thc_binding->thc_per_binding));
    if ((ops.allocate) != 0) {
        ((_args.allocate).in).bits = (&((((msg->args).allocate).in).bits));
        ((_args.allocate).in).minbase = (&((((msg->args).allocate).in).minbase));
        ((_args.allocate).in).maxlimit = (&((((msg->args).allocate).in).maxlimit));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_allocate]), &_rxi);
    }
    if ((ops.steal) != 0) {
        ((_args.steal).in).bits = (&((((msg->args).steal).in).bits));
        ((_args.steal).in).minbase = (&((((msg->args).steal).in).minbase));
        ((_args.steal).in).maxlimit = (&((((msg->args).steal).in).maxlimit));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_steal]), &_rxi);
    }
    if ((ops.available) != 0) {
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_available]), &_rxi);
    }
    if ((ops.free_monitor) != 0) {
        ((_args.free_monitor).in).mem_cap = (&((((msg->args).free_monitor).in).mem_cap));
        ((_args.free_monitor).in).base = (&((((msg->args).free_monitor).in).base));
        ((_args.free_monitor).in).bits = (&((((msg->args).free_monitor).in).bits));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_free_monitor]), &_rxi);
    }
    thc_wait_receive_any(&(_thc_binding->thc_per_binding), &_rxi);
    if ((ops.allocate) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_allocate]), &_rxi);
    }
    if ((ops.steal) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_steal]), &_rxi);
    }
    if ((ops.available) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_available]), &_rxi);
    }
    if ((ops.free_monitor) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_free_monitor]), &_rxi);
    }
    thc_end_receive_any(&(_thc_binding->thc_per_binding));
    return(_r);
}

static  errval_t mem_recv_any__thc_client_fn_x(mem_thc_client_binding_t *_thc_binding, struct mem_client_msg *msg, struct mem_client_selector ops)
{
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    errval_t _r = 0;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = ((int *)(&(msg->msg)));
    thc_start_receive_any(&(_thc_binding->thc_per_binding));
    if ((ops.allocate) != 0) {
        ((_args.allocate).out).ret = (&((((msg->args).allocate).out).ret));
        ((_args.allocate).out).mem_cap = (&((((msg->args).allocate).out).mem_cap));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_allocate]), &_rxi);
    }
    if ((ops.steal) != 0) {
        ((_args.steal).out).ret = (&((((msg->args).steal).out).ret));
        ((_args.steal).out).mem_cap = (&((((msg->args).steal).out).mem_cap));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_steal]), &_rxi);
    }
    if ((ops.available) != 0) {
        ((_args.available).out).mem_avail = (&((((msg->args).available).out).mem_avail));
        ((_args.available).out).mem_total = (&((((msg->args).available).out).mem_total));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_available]), &_rxi);
    }
    if ((ops.free_monitor) != 0) {
        ((_args.free_monitor).out).err = (&((((msg->args).free_monitor).out).err));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_free_monitor]), &_rxi);
    }
    _r = thc_wait_receive_any_x(&(_thc_binding->thc_per_binding), &_rxi);
    if ((ops.allocate) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_allocate]), &_rxi);
    }
    if ((ops.steal) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_steal]), &_rxi);
    }
    if ((ops.available) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_available]), &_rxi);
    }
    if ((ops.free_monitor) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_free_monitor]), &_rxi);
    }
    thc_end_receive_any(&(_thc_binding->thc_per_binding));
    return(_r);
}

static  errval_t mem_recv_any__thc_service_fn_x(mem_thc_service_binding_t *_thc_binding, struct mem_service_msg *msg, struct mem_service_selector ops)
{
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    errval_t _r = 0;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = ((int *)(&(msg->msg)));
    thc_start_receive_any(&(_thc_binding->thc_per_binding));
    if ((ops.allocate) != 0) {
        ((_args.allocate).in).bits = (&((((msg->args).allocate).in).bits));
        ((_args.allocate).in).minbase = (&((((msg->args).allocate).in).minbase));
        ((_args.allocate).in).maxlimit = (&((((msg->args).allocate).in).maxlimit));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_allocate]), &_rxi);
    }
    if ((ops.steal) != 0) {
        ((_args.steal).in).bits = (&((((msg->args).steal).in).bits));
        ((_args.steal).in).minbase = (&((((msg->args).steal).in).minbase));
        ((_args.steal).in).maxlimit = (&((((msg->args).steal).in).maxlimit));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_steal]), &_rxi);
    }
    if ((ops.available) != 0) {
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_available]), &_rxi);
    }
    if ((ops.free_monitor) != 0) {
        ((_args.free_monitor).in).mem_cap = (&((((msg->args).free_monitor).in).mem_cap));
        ((_args.free_monitor).in).base = (&((((msg->args).free_monitor).in).base));
        ((_args.free_monitor).in).bits = (&((((msg->args).free_monitor).in).bits));
        thc_start_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_free_monitor]), &_rxi);
    }
    _r = thc_wait_receive_any_x(&(_thc_binding->thc_per_binding), &_rxi);
    if ((ops.allocate) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_allocate]), &_rxi);
    }
    if ((ops.steal) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_steal]), &_rxi);
    }
    if ((ops.available) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_available]), &_rxi);
    }
    if ((ops.free_monitor) != 0) {
        thc_stop_receiving(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__call_free_monitor]), &_rxi);
    }
    thc_end_receive_any(&(_thc_binding->thc_per_binding));
    return(_r);
}

/*
 * Bottom-half receive functions
 */
static  void mem_client_allocate__bh_recv(struct mem_binding *_idc_binding, mem_errval_t ret, struct capref mem_cap)
{
    struct mem_thc_client_binding_t *_thc_binding = (struct mem_thc_client_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[mem__resp_allocate]));
    if (rxi == NULL) {
        return;
    }
    struct mem_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(mem_allocate));
    *(((args->allocate).out).ret) = ret;
    *(((args->allocate).out).mem_cap) = mem_cap;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[mem__resp_allocate]), rxi);
}

static  void mem_client_steal__bh_recv(struct mem_binding *_idc_binding, mem_errval_t ret, struct capref mem_cap)
{
    struct mem_thc_client_binding_t *_thc_binding = (struct mem_thc_client_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[mem__resp_steal]));
    if (rxi == NULL) {
        return;
    }
    struct mem_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(mem_steal));
    *(((args->steal).out).ret) = ret;
    *(((args->steal).out).mem_cap) = mem_cap;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[mem__resp_steal]), rxi);
}

static  void mem_client_available__bh_recv(struct mem_binding *_idc_binding, mem_genpaddr_t mem_avail, mem_genpaddr_t mem_total)
{
    struct mem_thc_client_binding_t *_thc_binding = (struct mem_thc_client_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[mem__resp_available]));
    if (rxi == NULL) {
        return;
    }
    struct mem_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(mem_available));
    *(((args->available).out).mem_avail) = mem_avail;
    *(((args->available).out).mem_total) = mem_total;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[mem__resp_available]), rxi);
}

static  void mem_client_free_monitor__bh_recv(struct mem_binding *_idc_binding, mem_errval_t err)
{
    struct mem_thc_client_binding_t *_thc_binding = (struct mem_thc_client_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[mem__resp_free_monitor]));
    if (rxi == NULL) {
        return;
    }
    struct mem_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(mem_free_monitor));
    *(((args->free_monitor).out).err) = err;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[mem__resp_free_monitor]), rxi);
}

static  void mem_service_allocate__bh_recv(struct mem_binding *_idc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit)
{
    struct mem_thc_service_binding_t *_thc_binding = (struct mem_thc_service_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[mem__call_allocate]));
    if (rxi == NULL) {
        return;
    }
    struct mem_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(mem_allocate));
    *(((args->allocate).in).bits) = bits;
    *(((args->allocate).in).minbase) = minbase;
    *(((args->allocate).in).maxlimit) = maxlimit;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[mem__call_allocate]), rxi);
}

static  void mem_service_steal__bh_recv(struct mem_binding *_idc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit)
{
    struct mem_thc_service_binding_t *_thc_binding = (struct mem_thc_service_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[mem__call_steal]));
    if (rxi == NULL) {
        return;
    }
    struct mem_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(mem_steal));
    *(((args->steal).in).bits) = bits;
    *(((args->steal).in).minbase) = minbase;
    *(((args->steal).in).maxlimit) = maxlimit;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[mem__call_steal]), rxi);
}

static  void mem_service_available__bh_recv(struct mem_binding *_idc_binding)
{
    struct mem_thc_service_binding_t *_thc_binding = (struct mem_thc_service_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[mem__call_available]));
    if (rxi == NULL) {
        return;
    }
    struct mem_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(mem_available));
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[mem__call_available]), rxi);
}

static  void mem_service_free_monitor__bh_recv(struct mem_binding *_idc_binding, struct capref mem_cap, mem_genpaddr_t base, uint8_t bits)
{
    struct mem_thc_service_binding_t *_thc_binding = (struct mem_thc_service_binding_t *)(_idc_binding->st);
    struct thc_receiver_info *rxi = thc_start_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[mem__call_free_monitor]));
    if (rxi == NULL) {
        return;
    }
    struct mem_thc_ptr_arg_struct *__attribute__((unused)) args = rxi->args;
    *(rxi->msg) = ((int )(mem_free_monitor));
    *(((args->free_monitor).in).mem_cap) = mem_cap;
    *(((args->free_monitor).in).base) = base;
    *(((args->free_monitor).in).bits) = bits;
    thc_end_bh(&(_thc_binding->thc_per_binding), _idc_binding, &((_thc_binding->thc_per_recv)[mem__call_free_monitor]), rxi);
}


/*
 * RPC-layer functions
 */
static  errval_t mem_allocate__call_seq(mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit, mem_errval_t *ret, struct capref *mem_cap)
{
    ((_thc_binding->send).allocate)(_thc_binding, bits, minbase, maxlimit);
    return(((_thc_binding->recv).allocate)(_thc_binding, ret, mem_cap));
}

static  errval_t mem_steal__call_seq(mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit, mem_errval_t *ret, struct capref *mem_cap)
{
    ((_thc_binding->send).steal)(_thc_binding, bits, minbase, maxlimit);
    return(((_thc_binding->recv).steal)(_thc_binding, ret, mem_cap));
}

static  errval_t mem_available__call_seq(mem_thc_client_binding_t *_thc_binding, mem_genpaddr_t *mem_avail, mem_genpaddr_t *mem_total)
{
    ((_thc_binding->send).available)(_thc_binding);
    return(((_thc_binding->recv).available)(_thc_binding, mem_avail, mem_total));
}

static  errval_t mem_free_monitor__call_seq(mem_thc_client_binding_t *_thc_binding, struct capref mem_cap, mem_genpaddr_t base, uint8_t bits, mem_errval_t *err)
{
    ((_thc_binding->send).free_monitor)(_thc_binding, mem_cap, base, bits);
    return(((_thc_binding->recv).free_monitor)(_thc_binding, err));
}

static  errval_t mem_allocate__call_fifo(mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit, mem_errval_t *ret, struct capref *mem_cap)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[mem__resp_allocate]))->fifo_rpc_lock));
    ((_thc_binding->send).allocate)(_thc_binding, bits, minbase, maxlimit);
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[mem__resp_allocate]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[mem__resp_allocate]))->fifo_rpc_lock));
    thc_queue_await_turn(&((&((_thc_binding->thc_per_recv)[mem__resp_allocate]))->fifo_rpc_q), &_q);
    _result = (((_thc_binding->recv).allocate)(_thc_binding, ret, mem_cap));
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[mem__resp_allocate]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_allocate]), _bailed);
    return(_result);
}

static  errval_t mem_steal__call_fifo(mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit, mem_errval_t *ret, struct capref *mem_cap)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[mem__resp_steal]))->fifo_rpc_lock));
    ((_thc_binding->send).steal)(_thc_binding, bits, minbase, maxlimit);
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[mem__resp_steal]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[mem__resp_steal]))->fifo_rpc_lock));
    thc_queue_await_turn(&((&((_thc_binding->thc_per_recv)[mem__resp_steal]))->fifo_rpc_q), &_q);
    _result = (((_thc_binding->recv).steal)(_thc_binding, ret, mem_cap));
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[mem__resp_steal]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_steal]), _bailed);
    return(_result);
}

static  errval_t mem_available__call_fifo(mem_thc_client_binding_t *_thc_binding, mem_genpaddr_t *mem_avail, mem_genpaddr_t *mem_total)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[mem__resp_available]))->fifo_rpc_lock));
    ((_thc_binding->send).available)(_thc_binding);
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[mem__resp_available]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[mem__resp_available]))->fifo_rpc_lock));
    thc_queue_await_turn(&((&((_thc_binding->thc_per_recv)[mem__resp_available]))->fifo_rpc_q), &_q);
    _result = (((_thc_binding->recv).available)(_thc_binding, mem_avail, mem_total));
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[mem__resp_available]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_available]), _bailed);
    return(_result);
}

static  errval_t mem_free_monitor__call_fifo(mem_thc_client_binding_t *_thc_binding, struct capref mem_cap, mem_genpaddr_t base, uint8_t bits, mem_errval_t *err)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[mem__resp_free_monitor]))->fifo_rpc_lock));
    ((_thc_binding->send).free_monitor)(_thc_binding, mem_cap, base, bits);
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[mem__resp_free_monitor]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[mem__resp_free_monitor]))->fifo_rpc_lock));
    thc_queue_await_turn(&((&((_thc_binding->thc_per_recv)[mem__resp_free_monitor]))->fifo_rpc_q), &_q);
    _result = (((_thc_binding->recv).free_monitor)(_thc_binding, err));
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[mem__resp_free_monitor]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_free_monitor]), _bailed);
    return(_result);
}

static  errval_t mem_allocate__call_seq_x(mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit, mem_errval_t *ret, struct capref *mem_cap)
{
    errval_t _result;
    _result = (((_thc_binding->send_x).allocate)(_thc_binding, bits, minbase, maxlimit));
    if (_result == THC_CANCELED) {
        return(THC_CANCELED);
    } else {
        struct mem_thc_ptr_arg_struct _args;
        struct thc_receiver_info _rxi;
        int _msg;
        ((_args.allocate).out).ret = ret;
        ((_args.allocate).out).mem_cap = mem_cap;
        _rxi.waiter = NULL;
        _rxi.args = (&_args);
        _rxi.msg = (&_msg);
        _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_allocate]), &_rxi);
        if (_result == THC_CANCELED) {
            thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_allocate]), 1);
        }
        return(_result);
    }
}

static  errval_t mem_steal__call_seq_x(mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit, mem_errval_t *ret, struct capref *mem_cap)
{
    errval_t _result;
    _result = (((_thc_binding->send_x).steal)(_thc_binding, bits, minbase, maxlimit));
    if (_result == THC_CANCELED) {
        return(THC_CANCELED);
    } else {
        struct mem_thc_ptr_arg_struct _args;
        struct thc_receiver_info _rxi;
        int _msg;
        ((_args.steal).out).ret = ret;
        ((_args.steal).out).mem_cap = mem_cap;
        _rxi.waiter = NULL;
        _rxi.args = (&_args);
        _rxi.msg = (&_msg);
        _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_steal]), &_rxi);
        if (_result == THC_CANCELED) {
            thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_steal]), 1);
        }
        return(_result);
    }
}

static  errval_t mem_available__call_seq_x(mem_thc_client_binding_t *_thc_binding, mem_genpaddr_t *mem_avail, mem_genpaddr_t *mem_total)
{
    errval_t _result;
    _result = (((_thc_binding->send_x).available)(_thc_binding));
    if (_result == THC_CANCELED) {
        return(THC_CANCELED);
    } else {
        struct mem_thc_ptr_arg_struct _args;
        struct thc_receiver_info _rxi;
        int _msg;
        ((_args.available).out).mem_avail = mem_avail;
        ((_args.available).out).mem_total = mem_total;
        _rxi.waiter = NULL;
        _rxi.args = (&_args);
        _rxi.msg = (&_msg);
        _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_available]), &_rxi);
        if (_result == THC_CANCELED) {
            thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_available]), 1);
        }
        return(_result);
    }
}

static  errval_t mem_free_monitor__call_seq_x(mem_thc_client_binding_t *_thc_binding, struct capref mem_cap, mem_genpaddr_t base, uint8_t bits, mem_errval_t *err)
{
    errval_t _result;
    _result = (((_thc_binding->send_x).free_monitor)(_thc_binding, mem_cap, base, bits));
    if (_result == THC_CANCELED) {
        return(THC_CANCELED);
    } else {
        struct mem_thc_ptr_arg_struct _args;
        struct thc_receiver_info _rxi;
        int _msg;
        ((_args.free_monitor).out).err = err;
        _rxi.waiter = NULL;
        _rxi.args = (&_args);
        _rxi.msg = (&_msg);
        _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_free_monitor]), &_rxi);
        if (_result == THC_CANCELED) {
            thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_free_monitor]), 1);
        }
        return(_result);
    }
}

static  errval_t mem_allocate__call_fifo_x(mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit, mem_errval_t *ret, struct capref *mem_cap)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[mem__resp_allocate]))->fifo_rpc_lock));
    _result = (((_thc_binding->send_x).allocate)(_thc_binding, bits, minbase, maxlimit));
    if (_result == THC_CANCELED) {
        thc_lock_release(&((&((_thc_binding->thc_per_recv)[mem__resp_allocate]))->fifo_rpc_lock));
        return(THC_CANCELED);
    }
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[mem__resp_allocate]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[mem__resp_allocate]))->fifo_rpc_lock));
    _result = thc_queue_await_turn_x(&((&((_thc_binding->thc_per_recv)[mem__resp_allocate]))->fifo_rpc_q), &_q);
    if (_result == THC_CANCELED) {
        _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[mem__resp_allocate]))->fifo_rpc_q), &_q);
        thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_allocate]), _bailed);
        return(THC_CANCELED);
    }
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.allocate).out).ret = ret;
    ((_args.allocate).out).mem_cap = mem_cap;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_allocate]), &_rxi);
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[mem__resp_allocate]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_allocate]), _bailed);
    return(_result);
}

static  errval_t mem_steal__call_fifo_x(mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit, mem_errval_t *ret, struct capref *mem_cap)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[mem__resp_steal]))->fifo_rpc_lock));
    _result = (((_thc_binding->send_x).steal)(_thc_binding, bits, minbase, maxlimit));
    if (_result == THC_CANCELED) {
        thc_lock_release(&((&((_thc_binding->thc_per_recv)[mem__resp_steal]))->fifo_rpc_lock));
        return(THC_CANCELED);
    }
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[mem__resp_steal]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[mem__resp_steal]))->fifo_rpc_lock));
    _result = thc_queue_await_turn_x(&((&((_thc_binding->thc_per_recv)[mem__resp_steal]))->fifo_rpc_q), &_q);
    if (_result == THC_CANCELED) {
        _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[mem__resp_steal]))->fifo_rpc_q), &_q);
        thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_steal]), _bailed);
        return(THC_CANCELED);
    }
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.steal).out).ret = ret;
    ((_args.steal).out).mem_cap = mem_cap;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_steal]), &_rxi);
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[mem__resp_steal]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_steal]), _bailed);
    return(_result);
}

static  errval_t mem_available__call_fifo_x(mem_thc_client_binding_t *_thc_binding, mem_genpaddr_t *mem_avail, mem_genpaddr_t *mem_total)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[mem__resp_available]))->fifo_rpc_lock));
    _result = (((_thc_binding->send_x).available)(_thc_binding));
    if (_result == THC_CANCELED) {
        thc_lock_release(&((&((_thc_binding->thc_per_recv)[mem__resp_available]))->fifo_rpc_lock));
        return(THC_CANCELED);
    }
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[mem__resp_available]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[mem__resp_available]))->fifo_rpc_lock));
    _result = thc_queue_await_turn_x(&((&((_thc_binding->thc_per_recv)[mem__resp_available]))->fifo_rpc_q), &_q);
    if (_result == THC_CANCELED) {
        _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[mem__resp_available]))->fifo_rpc_q), &_q);
        thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_available]), _bailed);
        return(THC_CANCELED);
    }
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.available).out).mem_avail = mem_avail;
    ((_args.available).out).mem_total = mem_total;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_available]), &_rxi);
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[mem__resp_available]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_available]), _bailed);
    return(_result);
}

static  errval_t mem_free_monitor__call_fifo_x(mem_thc_client_binding_t *_thc_binding, struct capref mem_cap, mem_genpaddr_t base, uint8_t bits, mem_errval_t *err)
{
    uint64_t _bailed;
    errval_t _result;
    thc_queue_entry_t _q;
    thc_lock_acquire(&((&((_thc_binding->thc_per_recv)[mem__resp_free_monitor]))->fifo_rpc_lock));
    _result = (((_thc_binding->send_x).free_monitor)(_thc_binding, mem_cap, base, bits));
    if (_result == THC_CANCELED) {
        thc_lock_release(&((&((_thc_binding->thc_per_recv)[mem__resp_free_monitor]))->fifo_rpc_lock));
        return(THC_CANCELED);
    }
    thc_queue_enter(&((&((_thc_binding->thc_per_recv)[mem__resp_free_monitor]))->fifo_rpc_q), &_q);
    thc_lock_release(&((&((_thc_binding->thc_per_recv)[mem__resp_free_monitor]))->fifo_rpc_lock));
    _result = thc_queue_await_turn_x(&((&((_thc_binding->thc_per_recv)[mem__resp_free_monitor]))->fifo_rpc_q), &_q);
    if (_result == THC_CANCELED) {
        _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[mem__resp_free_monitor]))->fifo_rpc_q), &_q);
        thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_free_monitor]), _bailed);
        return(THC_CANCELED);
    }
    struct mem_thc_ptr_arg_struct _args;
    struct thc_receiver_info _rxi;
    int _msg;
    ((_args.free_monitor).out).err = err;
    _rxi.waiter = NULL;
    _rxi.args = (&_args);
    _rxi.msg = (&_msg);
    _result = thc_receive_x(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_free_monitor]), &_rxi);
    _bailed = thc_queue_leave(&((&((_thc_binding->thc_per_recv)[mem__resp_free_monitor]))->fifo_rpc_q), &_q);
    thc_discard(&(_thc_binding->thc_per_binding), &((_thc_binding->thc_per_recv)[mem__resp_free_monitor]), _bailed);
    return(_result);
}

/*
 * Initialization functions
 */
 errval_t mem_thc_init_client(mem_thc_client_binding_t *_thc_binding, struct mem_binding *_c2s_idc_binding, struct mem_binding *_s2c_idc_binding)
{
    CHECK_FIELD(struct mem_binding, st);
    CHECK_FIELD(struct mem_binding, waitset);
    CHECK_FIELD(struct mem_binding, mutex);
    CHECK_FIELD(struct mem_binding, can_send);
    CHECK_FIELD(struct mem_binding, register_send);
    CHECK_FIELD(struct mem_binding, change_waitset);
    CHECK_FIELD(struct mem_binding, control);
    CHECK_FIELD(struct mem_binding, error_handler);
    _thc_binding->_c2s_st = _c2s_idc_binding;
    _thc_binding->_s2c_st = _s2c_idc_binding;
    _c2s_idc_binding->st = _thc_binding;
    _s2c_idc_binding->st = _thc_binding;
    thc_seq_init(&(_thc_binding->ooo_rpc_seq));
    thc_init_per_binding_state(&(_thc_binding->thc_per_binding));
    (_thc_binding->send).allocate = (&mem_client_allocate__send);
    (_thc_binding->send).steal = (&mem_client_steal__send);
    (_thc_binding->send).available = (&mem_client_available__send);
    (_thc_binding->send).free_monitor = (&mem_client_free_monitor__send);
    (_thc_binding->send_x).allocate = (&mem_client_allocate__send_x);
    (_thc_binding->send_x).steal = (&mem_client_steal__send_x);
    (_thc_binding->send_x).available = (&mem_client_available__send_x);
    (_thc_binding->send_x).free_monitor = (&mem_client_free_monitor__send_x);
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[mem__resp_allocate]));
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[mem__resp_steal]));
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[mem__resp_available]));
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[mem__resp_free_monitor]));
    (_s2c_idc_binding->rx_vtbl).allocate_response = (&mem_client_allocate__bh_recv);
    (_s2c_idc_binding->rx_vtbl).steal_response = (&mem_client_steal__bh_recv);
    (_s2c_idc_binding->rx_vtbl).available_response = (&mem_client_available__bh_recv);
    (_s2c_idc_binding->rx_vtbl).free_monitor_response = (&mem_client_free_monitor__bh_recv);
    (_thc_binding->recv).allocate = (&mem_client_allocate__recv);
    (_thc_binding->recv).steal = (&mem_client_steal__recv);
    (_thc_binding->recv).available = (&mem_client_available__recv);
    (_thc_binding->recv).free_monitor = (&mem_client_free_monitor__recv);
    (_thc_binding->recv_x).allocate = (&mem_client_allocate__recv_x);
    (_thc_binding->recv_x).steal = (&mem_client_steal__recv_x);
    (_thc_binding->recv_x).available = (&mem_client_available__recv_x);
    (_thc_binding->recv_x).free_monitor = (&mem_client_free_monitor__recv_x);
    _thc_binding->recv_any = mem_recv_any__thc_client_fn;
    _thc_binding->recv_any_x = mem_recv_any__thc_client_fn_x;
    (_thc_binding->call_seq).allocate = mem_allocate__call_seq;
    (_thc_binding->call_seq).steal = mem_steal__call_seq;
    (_thc_binding->call_seq).available = mem_available__call_seq;
    (_thc_binding->call_seq).free_monitor = mem_free_monitor__call_seq;
    (_thc_binding->call_fifo).allocate = mem_allocate__call_fifo;
    (_thc_binding->call_fifo).steal = mem_steal__call_fifo;
    (_thc_binding->call_fifo).available = mem_available__call_fifo;
    (_thc_binding->call_fifo).free_monitor = mem_free_monitor__call_fifo;
    (_thc_binding->call_seq_x).allocate = mem_allocate__call_seq_x;
    (_thc_binding->call_seq_x).steal = mem_steal__call_seq_x;
    (_thc_binding->call_seq_x).available = mem_available__call_seq_x;
    (_thc_binding->call_seq_x).free_monitor = mem_free_monitor__call_seq_x;
    (_thc_binding->call_fifo_x).allocate = mem_allocate__call_fifo_x;
    (_thc_binding->call_fifo_x).steal = mem_steal__call_fifo_x;
    (_thc_binding->call_fifo_x).available = mem_available__call_fifo_x;
    (_thc_binding->call_fifo_x).free_monitor = mem_free_monitor__call_fifo_x;
    return(0);
}

 errval_t mem_thc_init_service(mem_thc_service_binding_t *_thc_binding, struct mem_binding *_c2s_idc_binding, struct mem_binding *_s2c_idc_binding)
{
    CHECK_FIELD(struct mem_binding, st);
    CHECK_FIELD(struct mem_binding, waitset);
    CHECK_FIELD(struct mem_binding, mutex);
    CHECK_FIELD(struct mem_binding, can_send);
    CHECK_FIELD(struct mem_binding, register_send);
    CHECK_FIELD(struct mem_binding, change_waitset);
    CHECK_FIELD(struct mem_binding, control);
    CHECK_FIELD(struct mem_binding, error_handler);
    _thc_binding->_c2s_st = _c2s_idc_binding;
    _thc_binding->_s2c_st = _s2c_idc_binding;
    _c2s_idc_binding->st = _thc_binding;
    _s2c_idc_binding->st = _thc_binding;
    thc_init_per_binding_state(&(_thc_binding->thc_per_binding));
    (_thc_binding->send).allocate = (&mem_service_allocate__send);
    (_thc_binding->send).steal = (&mem_service_steal__send);
    (_thc_binding->send).available = (&mem_service_available__send);
    (_thc_binding->send).free_monitor = (&mem_service_free_monitor__send);
    (_thc_binding->send_x).allocate = (&mem_service_allocate__send_x);
    (_thc_binding->send_x).steal = (&mem_service_steal__send_x);
    (_thc_binding->send_x).available = (&mem_service_available__send_x);
    (_thc_binding->send_x).free_monitor = (&mem_service_free_monitor__send_x);
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[mem__call_allocate]));
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[mem__call_steal]));
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[mem__call_available]));
    thc_init_per_recv_state(&((_thc_binding->thc_per_recv)[mem__call_free_monitor]));
    (_c2s_idc_binding->rx_vtbl).allocate_call = (&mem_service_allocate__bh_recv);
    (_c2s_idc_binding->rx_vtbl).steal_call = (&mem_service_steal__bh_recv);
    (_c2s_idc_binding->rx_vtbl).available_call = (&mem_service_available__bh_recv);
    (_c2s_idc_binding->rx_vtbl).free_monitor_call = (&mem_service_free_monitor__bh_recv);
    (_thc_binding->recv).allocate = (&mem_service_allocate__recv);
    (_thc_binding->recv).steal = (&mem_service_steal__recv);
    (_thc_binding->recv).available = (&mem_service_available__recv);
    (_thc_binding->recv).free_monitor = (&mem_service_free_monitor__recv);
    (_thc_binding->recv_x).allocate = (&mem_service_allocate__recv_x);
    (_thc_binding->recv_x).steal = (&mem_service_steal__recv_x);
    (_thc_binding->recv_x).available = (&mem_service_available__recv_x);
    (_thc_binding->recv_x).free_monitor = (&mem_service_free_monitor__recv_x);
    _thc_binding->recv_any = mem_recv_any__thc_service_fn;
    _thc_binding->recv_any_x = mem_recv_any__thc_service_fn_x;
    return(0);
}


/*
 * Connection-management functions
 */
static  void mem_thc_export_cb(void *st, errval_t err, iref_t iref)
{
    struct mem_thc_export_info *info;
    info = ((struct mem_thc_export_info *)(st));
    thc_lock_acquire(&(info->info_lock));
    if (err_is_fail(err)) {
        info->err = err;
    } else {
        if ((info->service_name) != NULL) {
            info->err = nameservice_register(info->service_name, iref);
        }
        if ((info->iref_ptr) != NULL) {
            *(info->iref_ptr) = iref;
        }
    }
    thc_sem_v(&(info->export_cb_done_sem));
}

static  errval_t mem_thc_connect_cb(void *st, struct mem_binding *b)
{
    struct mem_thc_export_info *info;
    info = ((struct mem_thc_export_info *)(st));
    thc_sem_p(&(info->accept_call_present_sem));
    thc_lock_acquire(&(info->info_lock));
    *(info->b) = b;
    thc_sem_v(&(info->connect_cb_done_sem));
    return(SYS_ERR_OK);
}

 errval_t mem_thc_export(struct mem_thc_export_info *info, const char *service_name, struct waitset *ws, idc_export_flags_t flags, iref_t *iref_ptr)
{
    errval_t err;
    thc_sem_init(&(info->export_cb_done_sem), 0);
    thc_sem_init(&(info->connect_cb_done_sem), 0);
    thc_sem_init(&(info->accept_call_present_sem), 0);
    thc_lock_init(&(info->info_lock));
    thc_lock_init(&(info->next_accept_lock));
    info->service_name = service_name;
    info->err = SYS_ERR_OK;
    info->iref_ptr = iref_ptr;
    err = mem_export(info, mem_thc_export_cb, mem_thc_connect_cb, ws, flags);
    if (err_is_ok(err)) {
        thc_sem_p(&(info->export_cb_done_sem));
        err = (info->err);
        thc_lock_release(&(info->info_lock));
    }
    return(err);
}

 errval_t mem_thc_accept(struct mem_thc_export_info *info, struct mem_binding **b)
{
    struct mem_binding *priv_b;
    thc_lock_acquire(&(info->next_accept_lock));
    info->b = (&priv_b);
    thc_sem_v(&(info->accept_call_present_sem));
    thc_sem_p(&(info->connect_cb_done_sem));
    errval_t err = info->err;
    thc_lock_release(&(info->info_lock));
    thc_lock_release(&(info->next_accept_lock));
    if (err_is_ok(err)) {
        if (b != NULL) {
            *b = priv_b;
        }
    }
    return(err);
}

static  void mem_thc_bind_cb(void *st, errval_t err, struct mem_binding *b)
{
    struct mem_thc_connect_info *info;
    info = ((struct mem_thc_connect_info *)(st));
    info->err = err;
    if (err_is_ok(err)) {
        info->b = b;
    }
    thc_sem_v(&(info->bind_cb_done_sem));
}

 errval_t mem_thc_connect(iref_t iref, struct waitset *ws, idc_bind_flags_t flags, struct mem_binding **b)
{
    struct mem_thc_connect_info info;
    errval_t err;
    thc_sem_init(&(info.bind_cb_done_sem), 0);
    info.err = SYS_ERR_OK;
    info.b = NULL;
    err = mem_bind(iref, mem_thc_bind_cb, &info, ws, flags);
    if (err_is_ok(err)) {
        thc_sem_p(&(info.bind_cb_done_sem));
        err = (info.err);
        if (err_is_ok(err)) {
            if (b != NULL) {
                *b = (info.b);
            }
        }
    }
    return(err);
}

 errval_t mem_thc_connect_by_name(const char *service_name, struct waitset *ws, idc_bind_flags_t flags, struct mem_binding **b)
{
    errval_t err;
    iref_t iref;
    err = nameservice_blocking_lookup(service_name, &iref);
    if (err_is_ok(err)) {
        err = mem_thc_connect(iref, ws, flags, b);
    }
    return(err);
}


