#ifndef __mem_THC_IF_H
#define __mem_THC_IF_H 1
/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: mem
 * INTEFACE FILE: ../if/mem.if
 * INTERFACE DESCRIPTION: Memory allocation RPC interface
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */
#ifdef BARRELFISH
#include "thc/thcstubs.h"
#include "if/mem_defs.h"
#else
#include "thcstubs.h"
#include "mem.h"
#endif // BARRELFISH

/*
 * Typedefs for binding structures
 */

typedef struct mem_thc_client_binding_t mem_thc_client_binding_t;
typedef struct mem_thc_service_binding_t mem_thc_service_binding_t;

/*
 * Struct type for holding the args for each msg
 */
struct mem_allocate__in_args_t {
    uint8_t bits;
    mem_genpaddr_t minbase;
    mem_genpaddr_t maxlimit;
};
struct mem_allocate__out_args_t {
    mem_errval_t ret;
    struct capref mem_cap;
};
union mem_allocate___union_t {
    struct mem_allocate__in_args_t in;
    struct mem_allocate__out_args_t out;
};
struct mem_steal__in_args_t {
    uint8_t bits;
    mem_genpaddr_t minbase;
    mem_genpaddr_t maxlimit;
};
struct mem_steal__out_args_t {
    mem_errval_t ret;
    struct capref mem_cap;
};
union mem_steal___union_t {
    struct mem_steal__in_args_t in;
    struct mem_steal__out_args_t out;
};
struct mem_available__in_args_t {
};
struct mem_available__out_args_t {
    mem_genpaddr_t mem_avail;
    mem_genpaddr_t mem_total;
};
union mem_available___union_t {
    struct mem_available__in_args_t in;
    struct mem_available__out_args_t out;
};
struct mem_free_monitor__in_args_t {
    struct capref mem_cap;
    mem_genpaddr_t base;
    uint8_t bits;
};
struct mem_free_monitor__out_args_t {
    mem_errval_t err;
};
union mem_free_monitor___union_t {
    struct mem_free_monitor__in_args_t in;
    struct mem_free_monitor__out_args_t out;
};

/*
 * Union type for all message arguments
 */
union mem_thc_arg_union {
    union mem_allocate___union_t allocate;
    union mem_steal___union_t steal;
    union mem_available___union_t available;
    union mem_free_monitor___union_t free_monitor;
};

/*
 * Enumerations for message numbers
 */
typedef enum mem_msg_enum_t {
    mem_allocate,
    mem_steal,
    mem_available,
    mem_free_monitor
} mem_msg_enum_t;
typedef enum mem_call_msg_enum_t {
    mem__call_allocate,
    mem__call_steal,
    mem__call_available,
    mem__call_free_monitor
} mem_call_msg_enum_t;
typedef enum mem_resp_msg_enum_t {
    mem__resp_allocate,
    mem__resp_steal,
    mem__resp_available,
    mem__resp_free_monitor
} mem_resp_msg_enum_t;


/*
 * Signatures for individual send/receive operations
 */

typedef  errval_t (*mem_allocate__thc_client_send_t)(mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit);
typedef  errval_t (*mem_steal__thc_client_send_t)(mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit);
typedef  errval_t (*mem_available__thc_client_send_t)(mem_thc_client_binding_t *_thc_binding);
typedef  errval_t (*mem_free_monitor__thc_client_send_t)(mem_thc_client_binding_t *_thc_binding, struct capref mem_cap, mem_genpaddr_t base, uint8_t bits);
typedef  errval_t (*mem_allocate__thc_client_send_t_x)(mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit);
typedef  errval_t (*mem_steal__thc_client_send_t_x)(mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit);
typedef  errval_t (*mem_available__thc_client_send_t_x)(mem_thc_client_binding_t *_thc_binding);
typedef  errval_t (*mem_free_monitor__thc_client_send_t_x)(mem_thc_client_binding_t *_thc_binding, struct capref mem_cap, mem_genpaddr_t base, uint8_t bits);
typedef  errval_t (*mem_allocate__thc_service_recv_t)(mem_thc_service_binding_t *_thc_binding, uint8_t *bits, mem_genpaddr_t *minbase, mem_genpaddr_t *maxlimit);
typedef  errval_t (*mem_steal__thc_service_recv_t)(mem_thc_service_binding_t *_thc_binding, uint8_t *bits, mem_genpaddr_t *minbase, mem_genpaddr_t *maxlimit);
typedef  errval_t (*mem_available__thc_service_recv_t)(mem_thc_service_binding_t *_thc_binding);
typedef  errval_t (*mem_free_monitor__thc_service_recv_t)(mem_thc_service_binding_t *_thc_binding, struct capref *mem_cap, mem_genpaddr_t *base, uint8_t *bits);
typedef  errval_t (*mem_allocate__thc_service_recv_t_x)(mem_thc_service_binding_t *_thc_binding, uint8_t *bits, mem_genpaddr_t *minbase, mem_genpaddr_t *maxlimit);
typedef  errval_t (*mem_steal__thc_service_recv_t_x)(mem_thc_service_binding_t *_thc_binding, uint8_t *bits, mem_genpaddr_t *minbase, mem_genpaddr_t *maxlimit);
typedef  errval_t (*mem_available__thc_service_recv_t_x)(mem_thc_service_binding_t *_thc_binding);
typedef  errval_t (*mem_free_monitor__thc_service_recv_t_x)(mem_thc_service_binding_t *_thc_binding, struct capref *mem_cap, mem_genpaddr_t *base, uint8_t *bits);
typedef  errval_t (*mem_allocate__thc_service_send_t)(mem_thc_service_binding_t *_thc_binding, mem_errval_t ret, struct capref mem_cap);
typedef  errval_t (*mem_steal__thc_service_send_t)(mem_thc_service_binding_t *_thc_binding, mem_errval_t ret, struct capref mem_cap);
typedef  errval_t (*mem_available__thc_service_send_t)(mem_thc_service_binding_t *_thc_binding, mem_genpaddr_t mem_avail, mem_genpaddr_t mem_total);
typedef  errval_t (*mem_free_monitor__thc_service_send_t)(mem_thc_service_binding_t *_thc_binding, mem_errval_t err);
typedef  errval_t (*mem_allocate__thc_service_send_t_x)(mem_thc_service_binding_t *_thc_binding, mem_errval_t ret, struct capref mem_cap);
typedef  errval_t (*mem_steal__thc_service_send_t_x)(mem_thc_service_binding_t *_thc_binding, mem_errval_t ret, struct capref mem_cap);
typedef  errval_t (*mem_available__thc_service_send_t_x)(mem_thc_service_binding_t *_thc_binding, mem_genpaddr_t mem_avail, mem_genpaddr_t mem_total);
typedef  errval_t (*mem_free_monitor__thc_service_send_t_x)(mem_thc_service_binding_t *_thc_binding, mem_errval_t err);
typedef  errval_t (*mem_allocate__thc_client_recv_t)(mem_thc_client_binding_t *_thc_binding, mem_errval_t *ret, struct capref *mem_cap);
typedef  errval_t (*mem_steal__thc_client_recv_t)(mem_thc_client_binding_t *_thc_binding, mem_errval_t *ret, struct capref *mem_cap);
typedef  errval_t (*mem_available__thc_client_recv_t)(mem_thc_client_binding_t *_thc_binding, mem_genpaddr_t *mem_avail, mem_genpaddr_t *mem_total);
typedef  errval_t (*mem_free_monitor__thc_client_recv_t)(mem_thc_client_binding_t *_thc_binding, mem_errval_t *err);
typedef  errval_t (*mem_allocate__thc_client_recv_t_x)(mem_thc_client_binding_t *_thc_binding, mem_errval_t *ret, struct capref *mem_cap);
typedef  errval_t (*mem_steal__thc_client_recv_t_x)(mem_thc_client_binding_t *_thc_binding, mem_errval_t *ret, struct capref *mem_cap);
typedef  errval_t (*mem_available__thc_client_recv_t_x)(mem_thc_client_binding_t *_thc_binding, mem_genpaddr_t *mem_avail, mem_genpaddr_t *mem_total);
typedef  errval_t (*mem_free_monitor__thc_client_recv_t_x)(mem_thc_client_binding_t *_thc_binding, mem_errval_t *err);
typedef  errval_t (*mem_allocate__thc_call__t)(mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit, mem_errval_t *ret, struct capref *mem_cap);
typedef  errval_t (*mem_steal__thc_call__t)(mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit, mem_errval_t *ret, struct capref *mem_cap);
typedef  errval_t (*mem_available__thc_call__t)(mem_thc_client_binding_t *_thc_binding, mem_genpaddr_t *mem_avail, mem_genpaddr_t *mem_total);
typedef  errval_t (*mem_free_monitor__thc_call__t)(mem_thc_client_binding_t *_thc_binding, struct capref mem_cap, mem_genpaddr_t base, uint8_t bits, mem_errval_t *err);
typedef  errval_t (*mem_allocate__thc_call__t_x)(mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit, mem_errval_t *ret, struct capref *mem_cap);
typedef  errval_t (*mem_steal__thc_call__t_x)(mem_thc_client_binding_t *_thc_binding, uint8_t bits, mem_genpaddr_t minbase, mem_genpaddr_t maxlimit, mem_errval_t *ret, struct capref *mem_cap);
typedef  errval_t (*mem_available__thc_call__t_x)(mem_thc_client_binding_t *_thc_binding, mem_genpaddr_t *mem_avail, mem_genpaddr_t *mem_total);
typedef  errval_t (*mem_free_monitor__thc_call__t_x)(mem_thc_client_binding_t *_thc_binding, struct capref mem_cap, mem_genpaddr_t base, uint8_t bits, mem_errval_t *err);

/*
 * VTables of send/receive operations
 */

struct mem_thc_client_send_vtbl {
    mem_allocate__thc_client_send_t allocate;
    mem_steal__thc_client_send_t steal;
    mem_available__thc_client_send_t available;
    mem_free_monitor__thc_client_send_t free_monitor;
};
struct mem_thc_client_send_vtbl_x {
    mem_allocate__thc_client_send_t_x allocate;
    mem_steal__thc_client_send_t_x steal;
    mem_available__thc_client_send_t_x available;
    mem_free_monitor__thc_client_send_t_x free_monitor;
};
struct mem_thc_service_receive_vtbl {
    mem_allocate__thc_service_recv_t allocate;
    mem_steal__thc_service_recv_t steal;
    mem_available__thc_service_recv_t available;
    mem_free_monitor__thc_service_recv_t free_monitor;
};
struct mem_thc_service_receive_vtbl_x {
    mem_allocate__thc_service_recv_t_x allocate;
    mem_steal__thc_service_recv_t_x steal;
    mem_available__thc_service_recv_t_x available;
    mem_free_monitor__thc_service_recv_t_x free_monitor;
};
struct mem_service_selector {
    int allocate;
    int steal;
    int available;
    int free_monitor;
};
struct mem_thc_service_send_vtbl {
    mem_allocate__thc_service_send_t allocate;
    mem_steal__thc_service_send_t steal;
    mem_available__thc_service_send_t available;
    mem_free_monitor__thc_service_send_t free_monitor;
};
struct mem_thc_service_send_vtbl_x {
    mem_allocate__thc_service_send_t_x allocate;
    mem_steal__thc_service_send_t_x steal;
    mem_available__thc_service_send_t_x available;
    mem_free_monitor__thc_service_send_t_x free_monitor;
};
struct mem_thc_client_receive_vtbl {
    mem_allocate__thc_client_recv_t allocate;
    mem_steal__thc_client_recv_t steal;
    mem_available__thc_client_recv_t available;
    mem_free_monitor__thc_client_recv_t free_monitor;
};
struct mem_thc_client_receive_vtbl_x {
    mem_allocate__thc_client_recv_t_x allocate;
    mem_steal__thc_client_recv_t_x steal;
    mem_available__thc_client_recv_t_x available;
    mem_free_monitor__thc_client_recv_t_x free_monitor;
};
struct mem_client_selector {
    int allocate;
    int steal;
    int available;
    int free_monitor;
};

/*
 * VTables of RPC operations
 */

struct mem_thc_rpc_seq {
    mem_allocate__thc_call__t allocate;
    mem_steal__thc_call__t steal;
    mem_available__thc_call__t available;
    mem_free_monitor__thc_call__t free_monitor;
};
struct mem_thc_rpc_seq_x {
    mem_allocate__thc_call__t_x allocate;
    mem_steal__thc_call__t_x steal;
    mem_available__thc_call__t_x available;
    mem_free_monitor__thc_call__t_x free_monitor;
};
struct mem_thc_rpc_fifo {
    mem_allocate__thc_call__t allocate;
    mem_steal__thc_call__t steal;
    mem_available__thc_call__t available;
    mem_free_monitor__thc_call__t free_monitor;
};
struct mem_thc_rpc_fifo_x {
    mem_allocate__thc_call__t_x allocate;
    mem_steal__thc_call__t_x steal;
    mem_available__thc_call__t_x available;
    mem_free_monitor__thc_call__t_x free_monitor;
};
struct mem_thc_rpc_ooo {
};
struct mem_thc_rpc_ooo_x {
};

/*
 * Types for recv_any operations
 */

struct mem_client_msg {
    enum mem_msg_enum_t msg;
    union mem_thc_arg_union args;
};
typedef struct mem_client_msg mem_client_msg_t;
typedef  errval_t (*mem_recv_any__thc_client_t)(mem_thc_client_binding_t *_thc_binding, struct mem_client_msg *msg, struct mem_client_selector ops);
typedef  errval_t (*mem_recv_any__thc_client_t_x)(mem_thc_client_binding_t *_thc_binding, struct mem_client_msg *msg, struct mem_client_selector ops);
struct mem_service_msg {
    enum mem_msg_enum_t msg;
    union mem_thc_arg_union args;
};
typedef struct mem_service_msg mem_service_msg_t;
typedef  errval_t (*mem_recv_any__thc_service_t)(mem_thc_service_binding_t *_thc_binding, struct mem_service_msg *msg, struct mem_service_selector ops);
typedef  errval_t (*mem_recv_any__thc_service_t_x)(mem_thc_service_binding_t *_thc_binding, struct mem_service_msg *msg, struct mem_service_selector ops);

/*
 * Binding structures
 */

struct mem_thc_client_binding_t {
    struct thc_per_binding_state_t thc_per_binding;
    struct mem_thc_client_send_vtbl send;
    struct mem_thc_client_send_vtbl_x send_x;
    struct mem_thc_client_receive_vtbl recv;
    struct mem_thc_client_receive_vtbl_x recv_x;
    mem_recv_any__thc_client_t recv_any;
    mem_recv_any__thc_client_t_x recv_any_x;
    struct mem_thc_rpc_seq call_seq;
    struct mem_thc_rpc_fifo call_fifo;
    struct mem_thc_rpc_ooo call;
    struct mem_thc_rpc_seq_x call_seq_x;
    struct mem_thc_rpc_fifo_x call_fifo_x;
    struct mem_thc_rpc_ooo_x call_x;
    thc_seq_t ooo_rpc_seq;
    struct thc_per_recv_t thc_per_recv[4];
    void *_c2s_st;
    void *_s2c_st;
};
struct mem_thc_service_binding_t {
    struct thc_per_binding_state_t thc_per_binding;
    struct mem_thc_service_send_vtbl send;
    struct mem_thc_service_send_vtbl_x send_x;
    struct mem_thc_service_receive_vtbl recv;
    struct mem_thc_service_receive_vtbl_x recv_x;
    mem_recv_any__thc_service_t recv_any;
    mem_recv_any__thc_service_t_x recv_any_x;
    struct thc_per_recv_t thc_per_recv[4];
    void *_c2s_st;
    void *_s2c_st;
};

/*
 * Initialize a THC binding over an IDC binding
 * (defined in THC-stubs backend)
 */

extern  errval_t mem_thc_init_client(mem_thc_client_binding_t *thc, struct mem_binding *idc_c2s, struct mem_binding *idc_s2c);
extern  errval_t mem_thc_init_service(mem_thc_service_binding_t *thc, struct mem_binding *idc_c2s, struct mem_binding *idc_s2c);

/*
 * THC helper functions for establishing connections
 */
struct mem_thc_export_info {
    thc_sem_t export_cb_done_sem;
    thc_sem_t connect_cb_done_sem;
    thc_sem_t accept_call_present_sem;
    thc_lock_t next_accept_lock;
    struct mem_binding **b;
    thc_lock_t info_lock;
    errval_t err;
    const char *service_name;
    iref_t iref;
    iref_t *iref_ptr;
};
struct mem_thc_connect_info {
    thc_sem_t bind_cb_done_sem;
    errval_t err;
    struct mem_binding *b;
};
extern  errval_t mem_thc_export(struct mem_thc_export_info *info, const char *service_name, struct waitset *ws, idc_export_flags_t flags, iref_t *iref);
extern  errval_t mem_thc_accept(struct mem_thc_export_info *info, struct mem_binding **b);
extern  errval_t mem_thc_connect(iref_t iref, struct waitset *ws, idc_bind_flags_t flags, struct mem_binding **b);
extern  errval_t mem_thc_connect_by_name(const char *service_name, struct waitset *ws, idc_bind_flags_t flags, struct mem_binding **b);
#endif // __mem_THC_IF_H
