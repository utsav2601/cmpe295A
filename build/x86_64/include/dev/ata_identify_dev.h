#ifndef __ata_identify_DEV_H
#define __ata_identify_DEV_H 1
/*
 * DEVICE DEFINITION: ATA IDENTIFY results
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) ata_identify ## _ ## x
/*
 * Register type: ata_identify_gcbsi_t
 * Description: Implicit type of General configuration bit-significant information register
 * Fields:
 *   _anon0	(size 1, offset 0, init 0):	RSVD	_
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   ri	(size 1, offset 2, init 0):	RO	Response incomplete
 *   _anon3	(size 3, offset 3, init 0):	RSVD	_
 *   _anon6	(size 2, offset 6, init 0):	RSVD	_
 *   _anon8	(size 7, offset 8, init 0):	RSVD	_
 *   ad	(size 1, offset 15, init 0):	RO	0 = ATA device
 */
typedef uint16_t ata_identify_gcbsi_t;
#define ata_identify_gcbsi_default 0x0
static inline uint8_t ata_identify_gcbsi_ri_extract(ata_identify_gcbsi_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_gcbsi_ri_extract(ata_identify_gcbsi_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ata_identify_gcbsi_t ata_identify_gcbsi_ri_insert(ata_identify_gcbsi_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_gcbsi_t ata_identify_gcbsi_ri_insert(ata_identify_gcbsi_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffb) | (0x4 & (((ata_identify_gcbsi_t )(_fieldval)) << 2)));
}

static inline uint8_t ata_identify_gcbsi_ad_extract(ata_identify_gcbsi_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_gcbsi_ad_extract(ata_identify_gcbsi_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline ata_identify_gcbsi_t ata_identify_gcbsi_ad_insert(ata_identify_gcbsi_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_gcbsi_t ata_identify_gcbsi_ad_insert(ata_identify_gcbsi_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fff) | (0x8000 & (((ata_identify_gcbsi_t )(_fieldval)) << 15)));
}

static inline int ata_identify_gcbsi_prtval(char *_s, size_t _size, ata_identify_gcbsi_t _regval) __attribute__ ((always_inline));
static inline int ata_identify_gcbsi_prtval(char *_s, size_t _size, ata_identify_gcbsi_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ri =\t%" PRIx8 "\t(Response incomplete)\n", ata_identify_gcbsi_ri_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ad =\t%" PRIx8 "\t(0 = ATA device)\n", ata_identify_gcbsi_ad_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ata_identify_word47_t
 * Description: Implicit type of Stuff register
 * Fields:
 *   maxls	(size 8, offset 0, init 0):	RO	00h = Reserved, 01h-FFh = Maximum number of logical sectors that shall be transferred per DRQ data block on READ/WRITE MULTIPLE commands
 *   unk	(size 8, offset 8, init 0):	RO	Must be 80h
 */
typedef uint16_t ata_identify_word47_t;
#define ata_identify_word47_default 0x0
static inline uint8_t ata_identify_word47_maxls_extract(ata_identify_word47_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_word47_maxls_extract(ata_identify_word47_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline ata_identify_word47_t ata_identify_word47_maxls_insert(ata_identify_word47_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_word47_t ata_identify_word47_maxls_insert(ata_identify_word47_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff00) | (0xff & (((ata_identify_word47_t )(_fieldval)) << 0)));
}

static inline uint8_t ata_identify_word47_unk_extract(ata_identify_word47_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_word47_unk_extract(ata_identify_word47_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline ata_identify_word47_t ata_identify_word47_unk_insert(ata_identify_word47_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_word47_t ata_identify_word47_unk_insert(ata_identify_word47_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff) | (0xff00 & (((ata_identify_word47_t )(_fieldval)) << 8)));
}

static inline int ata_identify_word47_prtval(char *_s, size_t _size, ata_identify_word47_t _regval) __attribute__ ((always_inline));
static inline int ata_identify_word47_prtval(char *_s, size_t _size, ata_identify_word47_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " maxls =\t%" PRIx8 "\t(00h = Reserved, 01h-FFh = Maximum number of logical sectors that shall be transferred per DRQ data block on READ/WRITE MULTIPLE commands)\n", ata_identify_word47_maxls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " unk =\t%" PRIx8 "\t(Must be 80h)\n", ata_identify_word47_unk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ata_identify_tcfso_t
 * Description: Implicit type of Trusted Computing feature set options register
 * Fields:
 *   tc	(size 1, offset 0, init 0):	RO	Trusted Computing feature set is supported
 *   rsvd	(size 13, offset 1, init 0):	RO	Reserved for the Trusted Computing Group
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 */
typedef uint16_t ata_identify_tcfso_t;
#define ata_identify_tcfso_default 0x0
static inline uint8_t ata_identify_tcfso_tc_extract(ata_identify_tcfso_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_tcfso_tc_extract(ata_identify_tcfso_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ata_identify_tcfso_t ata_identify_tcfso_tc_insert(ata_identify_tcfso_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_tcfso_t ata_identify_tcfso_tc_insert(ata_identify_tcfso_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe) | (0x1 & (((ata_identify_tcfso_t )(_fieldval)) << 0)));
}

static inline uint16_t ata_identify_tcfso_rsvd_extract(ata_identify_tcfso_t _regval) __attribute__ ((always_inline));
static inline uint16_t ata_identify_tcfso_rsvd_extract(ata_identify_tcfso_t _regval)
{
    return((uint16_t )((_regval & 0x3ffe) >> 1));
}

static inline ata_identify_tcfso_t ata_identify_tcfso_rsvd_insert(ata_identify_tcfso_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_tcfso_t ata_identify_tcfso_rsvd_insert(ata_identify_tcfso_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xc001) | (0x3ffe & (((ata_identify_tcfso_t )(_fieldval)) << 1)));
}

static inline int ata_identify_tcfso_prtval(char *_s, size_t _size, ata_identify_tcfso_t _regval) __attribute__ ((always_inline));
static inline int ata_identify_tcfso_prtval(char *_s, size_t _size, ata_identify_tcfso_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc =\t%" PRIx8 "\t(Trusted Computing feature set is supported)\n", ata_identify_tcfso_tc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rsvd =\t%" PRIx16 "\t(Reserved for the Trusted Computing Group)\n", ata_identify_tcfso_rsvd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ata_identify_caps0_t
 * Description: Implicit type of Capabilities part 1 register
 * Fields:
 *   _anon0	(size 8, offset 0, init 0):	RSVD	_
 *   dmas	(size 1, offset 8, init 0):	RO	DMA supported
 *   lbas	(size 1, offset 9, init 0):	RO	LBA supported
 *   iord	(size 1, offset 10, init 0):	RO	IORDY may be disabled
 *   iors	(size 1, offset 11, init 0):	RO	IORDY supported
 *   _anon12	(size 1, offset 12, init 0):	RSVD	_
 *   sby	(size 1, offset 13, init 0):	RO	Standby tiemr values (0 = managed by device, 1 = as in standard)
 *   _anon14	(size 2, offset 14, init 0):	RSVD	_
 */
typedef uint16_t ata_identify_caps0_t;
#define ata_identify_caps0_default 0x0
static inline uint8_t ata_identify_caps0_dmas_extract(ata_identify_caps0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_caps0_dmas_extract(ata_identify_caps0_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ata_identify_caps0_t ata_identify_caps0_dmas_insert(ata_identify_caps0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_caps0_t ata_identify_caps0_dmas_insert(ata_identify_caps0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeff) | (0x100 & (((ata_identify_caps0_t )(_fieldval)) << 8)));
}

static inline uint8_t ata_identify_caps0_lbas_extract(ata_identify_caps0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_caps0_lbas_extract(ata_identify_caps0_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline ata_identify_caps0_t ata_identify_caps0_lbas_insert(ata_identify_caps0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_caps0_t ata_identify_caps0_lbas_insert(ata_identify_caps0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdff) | (0x200 & (((ata_identify_caps0_t )(_fieldval)) << 9)));
}

static inline uint8_t ata_identify_caps0_iord_extract(ata_identify_caps0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_caps0_iord_extract(ata_identify_caps0_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline ata_identify_caps0_t ata_identify_caps0_iord_insert(ata_identify_caps0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_caps0_t ata_identify_caps0_iord_insert(ata_identify_caps0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbff) | (0x400 & (((ata_identify_caps0_t )(_fieldval)) << 10)));
}

static inline uint8_t ata_identify_caps0_iors_extract(ata_identify_caps0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_caps0_iors_extract(ata_identify_caps0_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline ata_identify_caps0_t ata_identify_caps0_iors_insert(ata_identify_caps0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_caps0_t ata_identify_caps0_iors_insert(ata_identify_caps0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ff) | (0x800 & (((ata_identify_caps0_t )(_fieldval)) << 11)));
}

static inline uint8_t ata_identify_caps0_sby_extract(ata_identify_caps0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_caps0_sby_extract(ata_identify_caps0_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline ata_identify_caps0_t ata_identify_caps0_sby_insert(ata_identify_caps0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_caps0_t ata_identify_caps0_sby_insert(ata_identify_caps0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfff) | (0x2000 & (((ata_identify_caps0_t )(_fieldval)) << 13)));
}

static inline int ata_identify_caps0_prtval(char *_s, size_t _size, ata_identify_caps0_t _regval) __attribute__ ((always_inline));
static inline int ata_identify_caps0_prtval(char *_s, size_t _size, ata_identify_caps0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmas =\t%" PRIx8 "\t(DMA supported)\n", ata_identify_caps0_dmas_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbas =\t%" PRIx8 "\t(LBA supported)\n", ata_identify_caps0_lbas_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iord =\t%" PRIx8 "\t(IORDY may be disabled)\n", ata_identify_caps0_iord_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iors =\t%" PRIx8 "\t(IORDY supported)\n", ata_identify_caps0_iors_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sby =\t%" PRIx8 "\t(Standby tiemr values (0 = managed by device, 1 = as in standard))\n", ata_identify_caps0_sby_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ata_identify_caps1_t
 * Description: Implicit type of Capabilities part 2 register
 * Fields:
 *   dstm	(size 1, offset 0, init 0):	RO	Shall be set to one to indicate a device specific Standby timer value minimum.
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   _anon2	(size 12, offset 2, init 0):	RSVD	_
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 */
typedef uint16_t ata_identify_caps1_t;
#define ata_identify_caps1_default 0x0
static inline uint8_t ata_identify_caps1_dstm_extract(ata_identify_caps1_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_caps1_dstm_extract(ata_identify_caps1_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ata_identify_caps1_t ata_identify_caps1_dstm_insert(ata_identify_caps1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_caps1_t ata_identify_caps1_dstm_insert(ata_identify_caps1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe) | (0x1 & (((ata_identify_caps1_t )(_fieldval)) << 0)));
}

static inline int ata_identify_caps1_prtval(char *_s, size_t _size, ata_identify_caps1_t _regval) __attribute__ ((always_inline));
static inline int ata_identify_caps1_prtval(char *_s, size_t _size, ata_identify_caps1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dstm =\t%" PRIx8 "\t(Shall be set to one to indicate a device specific Standby timer value minimum.)\n", ata_identify_caps1_dstm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ata_identify_mwdma_t
 * Description: Implicit type of Supported DMA Modes register
 * Fields:
 *   m0sup	(size 1, offset 0, init 0):	RO	Multiword DMA mode 0 is supported
 *   m1sup	(size 1, offset 1, init 0):	RO	Multiword DMA mode 1 and below are supported
 *   m2sup	(size 1, offset 2, init 0):	RO	Multiword DMA mode 2 and below are supported
 *   _anon3	(size 5, offset 3, init 0):	RSVD	_
 *   m0sel	(size 1, offset 8, init 0):	RO	Multiword DMA mode 0 selected
 *   m1sel	(size 1, offset 9, init 0):	RO	Multiword DMA mode 1 selected
 *   m2sel	(size 1, offset 10, init 0):	RO	Multiword DMA mode 2 selected
 *   _anon11	(size 5, offset 11, init 0):	RSVD	_
 */
typedef uint16_t ata_identify_mwdma_t;
#define ata_identify_mwdma_default 0x0
static inline uint8_t ata_identify_mwdma_m0sup_extract(ata_identify_mwdma_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_mwdma_m0sup_extract(ata_identify_mwdma_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ata_identify_mwdma_t ata_identify_mwdma_m0sup_insert(ata_identify_mwdma_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_mwdma_t ata_identify_mwdma_m0sup_insert(ata_identify_mwdma_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe) | (0x1 & (((ata_identify_mwdma_t )(_fieldval)) << 0)));
}

static inline uint8_t ata_identify_mwdma_m1sup_extract(ata_identify_mwdma_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_mwdma_m1sup_extract(ata_identify_mwdma_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ata_identify_mwdma_t ata_identify_mwdma_m1sup_insert(ata_identify_mwdma_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_mwdma_t ata_identify_mwdma_m1sup_insert(ata_identify_mwdma_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffd) | (0x2 & (((ata_identify_mwdma_t )(_fieldval)) << 1)));
}

static inline uint8_t ata_identify_mwdma_m2sup_extract(ata_identify_mwdma_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_mwdma_m2sup_extract(ata_identify_mwdma_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ata_identify_mwdma_t ata_identify_mwdma_m2sup_insert(ata_identify_mwdma_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_mwdma_t ata_identify_mwdma_m2sup_insert(ata_identify_mwdma_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffb) | (0x4 & (((ata_identify_mwdma_t )(_fieldval)) << 2)));
}

static inline uint8_t ata_identify_mwdma_m0sel_extract(ata_identify_mwdma_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_mwdma_m0sel_extract(ata_identify_mwdma_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ata_identify_mwdma_t ata_identify_mwdma_m0sel_insert(ata_identify_mwdma_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_mwdma_t ata_identify_mwdma_m0sel_insert(ata_identify_mwdma_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeff) | (0x100 & (((ata_identify_mwdma_t )(_fieldval)) << 8)));
}

static inline uint8_t ata_identify_mwdma_m1sel_extract(ata_identify_mwdma_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_mwdma_m1sel_extract(ata_identify_mwdma_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline ata_identify_mwdma_t ata_identify_mwdma_m1sel_insert(ata_identify_mwdma_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_mwdma_t ata_identify_mwdma_m1sel_insert(ata_identify_mwdma_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdff) | (0x200 & (((ata_identify_mwdma_t )(_fieldval)) << 9)));
}

static inline uint8_t ata_identify_mwdma_m2sel_extract(ata_identify_mwdma_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_mwdma_m2sel_extract(ata_identify_mwdma_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline ata_identify_mwdma_t ata_identify_mwdma_m2sel_insert(ata_identify_mwdma_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_mwdma_t ata_identify_mwdma_m2sel_insert(ata_identify_mwdma_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbff) | (0x400 & (((ata_identify_mwdma_t )(_fieldval)) << 10)));
}

static inline int ata_identify_mwdma_prtval(char *_s, size_t _size, ata_identify_mwdma_t _regval) __attribute__ ((always_inline));
static inline int ata_identify_mwdma_prtval(char *_s, size_t _size, ata_identify_mwdma_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m0sup =\t%" PRIx8 "\t(Multiword DMA mode 0 is supported)\n", ata_identify_mwdma_m0sup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m1sup =\t%" PRIx8 "\t(Multiword DMA mode 1 and below are supported)\n", ata_identify_mwdma_m1sup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m2sup =\t%" PRIx8 "\t(Multiword DMA mode 2 and below are supported)\n", ata_identify_mwdma_m2sup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m0sel =\t%" PRIx8 "\t(Multiword DMA mode 0 selected)\n", ata_identify_mwdma_m0sel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m1sel =\t%" PRIx8 "\t(Multiword DMA mode 1 selected)\n", ata_identify_mwdma_m1sel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m2sel =\t%" PRIx8 "\t(Multiword DMA mode 2 selected)\n", ata_identify_mwdma_m2sel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ata_identify_pio_t
 * Description: Implicit type of Supported PIO modes register
 * Fields:
 *   msup	(size 8, offset 0, init 0):	RO	PIO modes supported
 *   _anon8	(size 8, offset 8, init 0):	RSVD	_
 */
typedef uint16_t ata_identify_pio_t;
#define ata_identify_pio_default 0x0
static inline uint8_t ata_identify_pio_msup_extract(ata_identify_pio_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_pio_msup_extract(ata_identify_pio_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline ata_identify_pio_t ata_identify_pio_msup_insert(ata_identify_pio_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_pio_t ata_identify_pio_msup_insert(ata_identify_pio_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff00) | (0xff & (((ata_identify_pio_t )(_fieldval)) << 0)));
}

static inline int ata_identify_pio_prtval(char *_s, size_t _size, ata_identify_pio_t _regval) __attribute__ ((always_inline));
static inline int ata_identify_pio_prtval(char *_s, size_t _size, ata_identify_pio_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msup =\t%" PRIx8 "\t(PIO modes supported)\n", ata_identify_pio_msup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ata_identify_majrn_t
 * Description: Implicit type of Major revision number register
 * Fields:
 *   _anon0	(size 1, offset 0, init 0):	RSVD	_
 *   _anon1	(size 3, offset 1, init 0):	RSVD	_
 *   a4	(size 1, offset 4, init 0):	RO	Supports ATA/ATAPI-4
 *   a5	(size 1, offset 5, init 0):	RO	Supports ATA/ATAPI-5
 *   a6	(size 1, offset 6, init 0):	RO	Supports ATA/ATAPI-6
 *   a7	(size 1, offset 7, init 0):	RO	Supports ATA/ATAPI-7
 *   a8	(size 1, offset 8, init 0):	RO	Supports ATA8-ACS
 *   _anon9	(size 7, offset 9, init 0):	RSVD	_
 */
typedef uint16_t ata_identify_majrn_t;
#define ata_identify_majrn_default 0x0
static inline uint8_t ata_identify_majrn_a4_extract(ata_identify_majrn_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_majrn_a4_extract(ata_identify_majrn_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ata_identify_majrn_t ata_identify_majrn_a4_insert(ata_identify_majrn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_majrn_t ata_identify_majrn_a4_insert(ata_identify_majrn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffef) | (0x10 & (((ata_identify_majrn_t )(_fieldval)) << 4)));
}

static inline uint8_t ata_identify_majrn_a5_extract(ata_identify_majrn_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_majrn_a5_extract(ata_identify_majrn_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ata_identify_majrn_t ata_identify_majrn_a5_insert(ata_identify_majrn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_majrn_t ata_identify_majrn_a5_insert(ata_identify_majrn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdf) | (0x20 & (((ata_identify_majrn_t )(_fieldval)) << 5)));
}

static inline uint8_t ata_identify_majrn_a6_extract(ata_identify_majrn_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_majrn_a6_extract(ata_identify_majrn_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline ata_identify_majrn_t ata_identify_majrn_a6_insert(ata_identify_majrn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_majrn_t ata_identify_majrn_a6_insert(ata_identify_majrn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbf) | (0x40 & (((ata_identify_majrn_t )(_fieldval)) << 6)));
}

static inline uint8_t ata_identify_majrn_a7_extract(ata_identify_majrn_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_majrn_a7_extract(ata_identify_majrn_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline ata_identify_majrn_t ata_identify_majrn_a7_insert(ata_identify_majrn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_majrn_t ata_identify_majrn_a7_insert(ata_identify_majrn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7f) | (0x80 & (((ata_identify_majrn_t )(_fieldval)) << 7)));
}

static inline uint8_t ata_identify_majrn_a8_extract(ata_identify_majrn_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_majrn_a8_extract(ata_identify_majrn_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ata_identify_majrn_t ata_identify_majrn_a8_insert(ata_identify_majrn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_majrn_t ata_identify_majrn_a8_insert(ata_identify_majrn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeff) | (0x100 & (((ata_identify_majrn_t )(_fieldval)) << 8)));
}

static inline int ata_identify_majrn_prtval(char *_s, size_t _size, ata_identify_majrn_t _regval) __attribute__ ((always_inline));
static inline int ata_identify_majrn_prtval(char *_s, size_t _size, ata_identify_majrn_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " a4 =\t%" PRIx8 "\t(Supports ATA/ATAPI-4)\n", ata_identify_majrn_a4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " a5 =\t%" PRIx8 "\t(Supports ATA/ATAPI-5)\n", ata_identify_majrn_a5_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " a6 =\t%" PRIx8 "\t(Supports ATA/ATAPI-6)\n", ata_identify_majrn_a6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " a7 =\t%" PRIx8 "\t(Supports ATA/ATAPI-7)\n", ata_identify_majrn_a7_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " a8 =\t%" PRIx8 "\t(Supports ATA8-ACS)\n", ata_identify_majrn_a8_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ata_identify_css0_t
 * Description: Implicit type of Command set supported part 1 register
 * Fields:
 *   smrt	(size 1, offset 0, init 0):	RO	SMART feature set supported
 *   secm	(size 1, offset 1, init 0):	RO	Security Mode feature set supported
 *   _anon2	(size 1, offset 2, init 0):	RSVD	_
 *   pwrm	(size 1, offset 3, init 0):	RO	Mandatory Power Management feature set supported
 *   pack	(size 1, offset 4, init 0):	RO	Cleared to indicate PACKET feature set not supported
 *   wrtc	(size 1, offset 5, init 0):	RO	Write cache supported
 *   loka	(size 1, offset 6, init 0):	RO	Look-ahead supported
 *   reli	(size 1, offset 7, init 0):	RO	Release interrupt supported
 *   svci	(size 1, offset 8, init 0):	RO	SERVICE interrupt supported
 *   drst	(size 1, offset 9, init 0):	RO	DEVICE RESET command supported
 *   hpa	(size 1, offset 10, init 0):	RO	Host Protected Area feature set supported
 *   _anon11	(size 1, offset 11, init 0):	RSVD	_
 *   wrtb	(size 1, offset 12, init 0):	RO	WRITE BUFFER command supported
 *   reab	(size 1, offset 13, init 0):	RO	READ BUFFER command supported
 *   nop	(size 1, offset 14, init 0):	RO	NOP command supported
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 */
typedef uint16_t ata_identify_css0_t;
#define ata_identify_css0_default 0x0
static inline uint8_t ata_identify_css0_smrt_extract(ata_identify_css0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_smrt_extract(ata_identify_css0_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ata_identify_css0_t ata_identify_css0_smrt_insert(ata_identify_css0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css0_t ata_identify_css0_smrt_insert(ata_identify_css0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe) | (0x1 & (((ata_identify_css0_t )(_fieldval)) << 0)));
}

static inline uint8_t ata_identify_css0_secm_extract(ata_identify_css0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_secm_extract(ata_identify_css0_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ata_identify_css0_t ata_identify_css0_secm_insert(ata_identify_css0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css0_t ata_identify_css0_secm_insert(ata_identify_css0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffd) | (0x2 & (((ata_identify_css0_t )(_fieldval)) << 1)));
}

static inline uint8_t ata_identify_css0_pwrm_extract(ata_identify_css0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_pwrm_extract(ata_identify_css0_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ata_identify_css0_t ata_identify_css0_pwrm_insert(ata_identify_css0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css0_t ata_identify_css0_pwrm_insert(ata_identify_css0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7) | (0x8 & (((ata_identify_css0_t )(_fieldval)) << 3)));
}

static inline uint8_t ata_identify_css0_pack_extract(ata_identify_css0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_pack_extract(ata_identify_css0_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ata_identify_css0_t ata_identify_css0_pack_insert(ata_identify_css0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css0_t ata_identify_css0_pack_insert(ata_identify_css0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffef) | (0x10 & (((ata_identify_css0_t )(_fieldval)) << 4)));
}

static inline uint8_t ata_identify_css0_wrtc_extract(ata_identify_css0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_wrtc_extract(ata_identify_css0_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ata_identify_css0_t ata_identify_css0_wrtc_insert(ata_identify_css0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css0_t ata_identify_css0_wrtc_insert(ata_identify_css0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdf) | (0x20 & (((ata_identify_css0_t )(_fieldval)) << 5)));
}

static inline uint8_t ata_identify_css0_loka_extract(ata_identify_css0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_loka_extract(ata_identify_css0_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline ata_identify_css0_t ata_identify_css0_loka_insert(ata_identify_css0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css0_t ata_identify_css0_loka_insert(ata_identify_css0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbf) | (0x40 & (((ata_identify_css0_t )(_fieldval)) << 6)));
}

static inline uint8_t ata_identify_css0_reli_extract(ata_identify_css0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_reli_extract(ata_identify_css0_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline ata_identify_css0_t ata_identify_css0_reli_insert(ata_identify_css0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css0_t ata_identify_css0_reli_insert(ata_identify_css0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7f) | (0x80 & (((ata_identify_css0_t )(_fieldval)) << 7)));
}

static inline uint8_t ata_identify_css0_svci_extract(ata_identify_css0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_svci_extract(ata_identify_css0_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ata_identify_css0_t ata_identify_css0_svci_insert(ata_identify_css0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css0_t ata_identify_css0_svci_insert(ata_identify_css0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeff) | (0x100 & (((ata_identify_css0_t )(_fieldval)) << 8)));
}

static inline uint8_t ata_identify_css0_drst_extract(ata_identify_css0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_drst_extract(ata_identify_css0_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline ata_identify_css0_t ata_identify_css0_drst_insert(ata_identify_css0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css0_t ata_identify_css0_drst_insert(ata_identify_css0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdff) | (0x200 & (((ata_identify_css0_t )(_fieldval)) << 9)));
}

static inline uint8_t ata_identify_css0_hpa_extract(ata_identify_css0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_hpa_extract(ata_identify_css0_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline ata_identify_css0_t ata_identify_css0_hpa_insert(ata_identify_css0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css0_t ata_identify_css0_hpa_insert(ata_identify_css0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbff) | (0x400 & (((ata_identify_css0_t )(_fieldval)) << 10)));
}

static inline uint8_t ata_identify_css0_wrtb_extract(ata_identify_css0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_wrtb_extract(ata_identify_css0_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline ata_identify_css0_t ata_identify_css0_wrtb_insert(ata_identify_css0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css0_t ata_identify_css0_wrtb_insert(ata_identify_css0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefff) | (0x1000 & (((ata_identify_css0_t )(_fieldval)) << 12)));
}

static inline uint8_t ata_identify_css0_reab_extract(ata_identify_css0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_reab_extract(ata_identify_css0_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline ata_identify_css0_t ata_identify_css0_reab_insert(ata_identify_css0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css0_t ata_identify_css0_reab_insert(ata_identify_css0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfff) | (0x2000 & (((ata_identify_css0_t )(_fieldval)) << 13)));
}

static inline uint8_t ata_identify_css0_nop_extract(ata_identify_css0_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_nop_extract(ata_identify_css0_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline ata_identify_css0_t ata_identify_css0_nop_insert(ata_identify_css0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css0_t ata_identify_css0_nop_insert(ata_identify_css0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfff) | (0x4000 & (((ata_identify_css0_t )(_fieldval)) << 14)));
}

static inline int ata_identify_css0_prtval(char *_s, size_t _size, ata_identify_css0_t _regval) __attribute__ ((always_inline));
static inline int ata_identify_css0_prtval(char *_s, size_t _size, ata_identify_css0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smrt =\t%" PRIx8 "\t(SMART feature set supported)\n", ata_identify_css0_smrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " secm =\t%" PRIx8 "\t(Security Mode feature set supported)\n", ata_identify_css0_secm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pwrm =\t%" PRIx8 "\t(Mandatory Power Management feature set supported)\n", ata_identify_css0_pwrm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pack =\t%" PRIx8 "\t(Cleared to indicate PACKET feature set not supported)\n", ata_identify_css0_pack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wrtc =\t%" PRIx8 "\t(Write cache supported)\n", ata_identify_css0_wrtc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " loka =\t%" PRIx8 "\t(Look-ahead supported)\n", ata_identify_css0_loka_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reli =\t%" PRIx8 "\t(Release interrupt supported)\n", ata_identify_css0_reli_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " svci =\t%" PRIx8 "\t(SERVICE interrupt supported)\n", ata_identify_css0_svci_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drst =\t%" PRIx8 "\t(DEVICE RESET command supported)\n", ata_identify_css0_drst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hpa =\t%" PRIx8 "\t(Host Protected Area feature set supported)\n", ata_identify_css0_hpa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wrtb =\t%" PRIx8 "\t(WRITE BUFFER command supported)\n", ata_identify_css0_wrtb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reab =\t%" PRIx8 "\t(READ BUFFER command supported)\n", ata_identify_css0_reab_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nop =\t%" PRIx8 "\t(NOP command supported)\n", ata_identify_css0_nop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ata_identify_css1_t
 * Description: Implicit type of Command sets supported part 2 register
 * Fields:
 *   dlmc	(size 1, offset 0, init 0):	RO	DOWNLOAD MICROCODE command supported
 *   dmaq	(size 1, offset 1, init 0):	RO	READ/WRITE DMA QUEUED supported
 *   cfa	(size 1, offset 2, init 0):	RO	CFA feature set supported
 *   apm	(size 1, offset 3, init 0):	RO	Advanced Power Management feature set supported
 *   _anon4	(size 1, offset 4, init 0):	RSVD	_
 *   puis	(size 1, offset 5, init 0):	RO	Power-Up In Standby feature set supported
 *   sfspn	(size 1, offset 6, init 0):	RO	SET FEATUREs subcommand required to spin-up after power-up
 *   orab	(size 1, offset 7, init 0):	RO	See Address Offset Reserved Area Boot, INCITS TR27:2001
 *   smsec	(size 1, offset 8, init 0):	RO	SET MAX security extension supported
 *   aam	(size 1, offset 9, init 0):	RO	Automatic Acoustic Management feature set supported
 *   lba48	(size 1, offset 10, init 0):	RO	48-bit Address feature set supported
 *   dco	(size 1, offset 11, init 0):	RO	Mandatory Device Configuration Overlay feature set supported
 *   flc	(size 1, offset 12, init 0):	RO	Mandatory FLUSH CACHE command supported
 *   flcx	(size 1, offset 13, init 0):	RO	FLUSH CACHE EXT command supported
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 */
typedef uint16_t ata_identify_css1_t;
#define ata_identify_css1_default 0x0
static inline uint8_t ata_identify_css1_dlmc_extract(ata_identify_css1_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_dlmc_extract(ata_identify_css1_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ata_identify_css1_t ata_identify_css1_dlmc_insert(ata_identify_css1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css1_t ata_identify_css1_dlmc_insert(ata_identify_css1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe) | (0x1 & (((ata_identify_css1_t )(_fieldval)) << 0)));
}

static inline uint8_t ata_identify_css1_dmaq_extract(ata_identify_css1_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_dmaq_extract(ata_identify_css1_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ata_identify_css1_t ata_identify_css1_dmaq_insert(ata_identify_css1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css1_t ata_identify_css1_dmaq_insert(ata_identify_css1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffd) | (0x2 & (((ata_identify_css1_t )(_fieldval)) << 1)));
}

static inline uint8_t ata_identify_css1_cfa_extract(ata_identify_css1_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_cfa_extract(ata_identify_css1_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ata_identify_css1_t ata_identify_css1_cfa_insert(ata_identify_css1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css1_t ata_identify_css1_cfa_insert(ata_identify_css1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffb) | (0x4 & (((ata_identify_css1_t )(_fieldval)) << 2)));
}

static inline uint8_t ata_identify_css1_apm_extract(ata_identify_css1_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_apm_extract(ata_identify_css1_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ata_identify_css1_t ata_identify_css1_apm_insert(ata_identify_css1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css1_t ata_identify_css1_apm_insert(ata_identify_css1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7) | (0x8 & (((ata_identify_css1_t )(_fieldval)) << 3)));
}

static inline uint8_t ata_identify_css1_puis_extract(ata_identify_css1_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_puis_extract(ata_identify_css1_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ata_identify_css1_t ata_identify_css1_puis_insert(ata_identify_css1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css1_t ata_identify_css1_puis_insert(ata_identify_css1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdf) | (0x20 & (((ata_identify_css1_t )(_fieldval)) << 5)));
}

static inline uint8_t ata_identify_css1_sfspn_extract(ata_identify_css1_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_sfspn_extract(ata_identify_css1_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline ata_identify_css1_t ata_identify_css1_sfspn_insert(ata_identify_css1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css1_t ata_identify_css1_sfspn_insert(ata_identify_css1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbf) | (0x40 & (((ata_identify_css1_t )(_fieldval)) << 6)));
}

static inline uint8_t ata_identify_css1_orab_extract(ata_identify_css1_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_orab_extract(ata_identify_css1_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline ata_identify_css1_t ata_identify_css1_orab_insert(ata_identify_css1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css1_t ata_identify_css1_orab_insert(ata_identify_css1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7f) | (0x80 & (((ata_identify_css1_t )(_fieldval)) << 7)));
}

static inline uint8_t ata_identify_css1_smsec_extract(ata_identify_css1_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_smsec_extract(ata_identify_css1_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ata_identify_css1_t ata_identify_css1_smsec_insert(ata_identify_css1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css1_t ata_identify_css1_smsec_insert(ata_identify_css1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeff) | (0x100 & (((ata_identify_css1_t )(_fieldval)) << 8)));
}

static inline uint8_t ata_identify_css1_aam_extract(ata_identify_css1_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_aam_extract(ata_identify_css1_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline ata_identify_css1_t ata_identify_css1_aam_insert(ata_identify_css1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css1_t ata_identify_css1_aam_insert(ata_identify_css1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdff) | (0x200 & (((ata_identify_css1_t )(_fieldval)) << 9)));
}

static inline uint8_t ata_identify_css1_lba48_extract(ata_identify_css1_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_lba48_extract(ata_identify_css1_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline ata_identify_css1_t ata_identify_css1_lba48_insert(ata_identify_css1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css1_t ata_identify_css1_lba48_insert(ata_identify_css1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbff) | (0x400 & (((ata_identify_css1_t )(_fieldval)) << 10)));
}

static inline uint8_t ata_identify_css1_dco_extract(ata_identify_css1_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_dco_extract(ata_identify_css1_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline ata_identify_css1_t ata_identify_css1_dco_insert(ata_identify_css1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css1_t ata_identify_css1_dco_insert(ata_identify_css1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ff) | (0x800 & (((ata_identify_css1_t )(_fieldval)) << 11)));
}

static inline uint8_t ata_identify_css1_flc_extract(ata_identify_css1_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_flc_extract(ata_identify_css1_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline ata_identify_css1_t ata_identify_css1_flc_insert(ata_identify_css1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css1_t ata_identify_css1_flc_insert(ata_identify_css1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefff) | (0x1000 & (((ata_identify_css1_t )(_fieldval)) << 12)));
}

static inline uint8_t ata_identify_css1_flcx_extract(ata_identify_css1_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_flcx_extract(ata_identify_css1_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline ata_identify_css1_t ata_identify_css1_flcx_insert(ata_identify_css1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css1_t ata_identify_css1_flcx_insert(ata_identify_css1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfff) | (0x2000 & (((ata_identify_css1_t )(_fieldval)) << 13)));
}

static inline int ata_identify_css1_prtval(char *_s, size_t _size, ata_identify_css1_t _regval) __attribute__ ((always_inline));
static inline int ata_identify_css1_prtval(char *_s, size_t _size, ata_identify_css1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlmc =\t%" PRIx8 "\t(DOWNLOAD MICROCODE command supported)\n", ata_identify_css1_dlmc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmaq =\t%" PRIx8 "\t(READ/WRITE DMA QUEUED supported)\n", ata_identify_css1_dmaq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfa =\t%" PRIx8 "\t(CFA feature set supported)\n", ata_identify_css1_cfa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apm =\t%" PRIx8 "\t(Advanced Power Management feature set supported)\n", ata_identify_css1_apm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " puis =\t%" PRIx8 "\t(Power-Up In Standby feature set supported)\n", ata_identify_css1_puis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sfspn =\t%" PRIx8 "\t(SET FEATUREs subcommand required to spin-up after power-up)\n", ata_identify_css1_sfspn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " orab =\t%" PRIx8 "\t(See Address Offset Reserved Area Boot, INCITS TR27:2001)\n", ata_identify_css1_orab_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smsec =\t%" PRIx8 "\t(SET MAX security extension supported)\n", ata_identify_css1_smsec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aam =\t%" PRIx8 "\t(Automatic Acoustic Management feature set supported)\n", ata_identify_css1_aam_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lba48 =\t%" PRIx8 "\t(48-bit Address feature set supported)\n", ata_identify_css1_lba48_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dco =\t%" PRIx8 "\t(Mandatory Device Configuration Overlay feature set supported)\n", ata_identify_css1_dco_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flc =\t%" PRIx8 "\t(Mandatory FLUSH CACHE command supported)\n", ata_identify_css1_flc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flcx =\t%" PRIx8 "\t(FLUSH CACHE EXT command supported)\n", ata_identify_css1_flcx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ata_identify_css2_t
 * Description: Implicit type of Command set/feature supported part 3 register
 * Fields:
 *   smtel	(size 1, offset 0, init 0):	RO	SMART error logging supported
 *   smtst	(size 1, offset 1, init 0):	RO	SMART self-test supported
 *   msn	(size 1, offset 2, init 0):	RO	Media serial number supported
 *   mcptc	(size 1, offset 3, init 0):	RO	Media Card Pass Through Command feature set supported
 *   strm	(size 1, offset 4, init 0):	RO	Streaming feature set supported
 *   gpl	(size 1, offset 5, init 0):	RO	General Purpose Logging feature set supported
 *   wdmafuax	(size 1, offset 6, init 0):	RO	WRITE DMA FUA EXT and WRITE MULTIPLE FUA EXT commands supported
 *   wdmaqfuax	(size 1, offset 7, init 0):	RO	WRITE DMA QUEUED FUA EXT command supported
 *   wwn64	(size 1, offset 8, init 0):	RO	64-bit World wide name supported
 *   _anon9	(size 2, offset 9, init 0):	RSVD	_
 *   _anon11	(size 2, offset 11, init 0):	RSVD	_
 *   iiwuf	(size 1, offset 13, init 0):	RO	IDLE IMMEDIATE with UNLOAD FEATURE supported
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 */
typedef uint16_t ata_identify_css2_t;
#define ata_identify_css2_default 0x0
static inline uint8_t ata_identify_css2_smtel_extract(ata_identify_css2_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_smtel_extract(ata_identify_css2_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ata_identify_css2_t ata_identify_css2_smtel_insert(ata_identify_css2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css2_t ata_identify_css2_smtel_insert(ata_identify_css2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe) | (0x1 & (((ata_identify_css2_t )(_fieldval)) << 0)));
}

static inline uint8_t ata_identify_css2_smtst_extract(ata_identify_css2_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_smtst_extract(ata_identify_css2_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ata_identify_css2_t ata_identify_css2_smtst_insert(ata_identify_css2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css2_t ata_identify_css2_smtst_insert(ata_identify_css2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffd) | (0x2 & (((ata_identify_css2_t )(_fieldval)) << 1)));
}

static inline uint8_t ata_identify_css2_msn_extract(ata_identify_css2_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_msn_extract(ata_identify_css2_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ata_identify_css2_t ata_identify_css2_msn_insert(ata_identify_css2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css2_t ata_identify_css2_msn_insert(ata_identify_css2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffb) | (0x4 & (((ata_identify_css2_t )(_fieldval)) << 2)));
}

static inline uint8_t ata_identify_css2_mcptc_extract(ata_identify_css2_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_mcptc_extract(ata_identify_css2_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ata_identify_css2_t ata_identify_css2_mcptc_insert(ata_identify_css2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css2_t ata_identify_css2_mcptc_insert(ata_identify_css2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7) | (0x8 & (((ata_identify_css2_t )(_fieldval)) << 3)));
}

static inline uint8_t ata_identify_css2_strm_extract(ata_identify_css2_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_strm_extract(ata_identify_css2_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ata_identify_css2_t ata_identify_css2_strm_insert(ata_identify_css2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css2_t ata_identify_css2_strm_insert(ata_identify_css2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffef) | (0x10 & (((ata_identify_css2_t )(_fieldval)) << 4)));
}

static inline uint8_t ata_identify_css2_gpl_extract(ata_identify_css2_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_gpl_extract(ata_identify_css2_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ata_identify_css2_t ata_identify_css2_gpl_insert(ata_identify_css2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css2_t ata_identify_css2_gpl_insert(ata_identify_css2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdf) | (0x20 & (((ata_identify_css2_t )(_fieldval)) << 5)));
}

static inline uint8_t ata_identify_css2_wdmafuax_extract(ata_identify_css2_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_wdmafuax_extract(ata_identify_css2_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline ata_identify_css2_t ata_identify_css2_wdmafuax_insert(ata_identify_css2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css2_t ata_identify_css2_wdmafuax_insert(ata_identify_css2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbf) | (0x40 & (((ata_identify_css2_t )(_fieldval)) << 6)));
}

static inline uint8_t ata_identify_css2_wdmaqfuax_extract(ata_identify_css2_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_wdmaqfuax_extract(ata_identify_css2_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline ata_identify_css2_t ata_identify_css2_wdmaqfuax_insert(ata_identify_css2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css2_t ata_identify_css2_wdmaqfuax_insert(ata_identify_css2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7f) | (0x80 & (((ata_identify_css2_t )(_fieldval)) << 7)));
}

static inline uint8_t ata_identify_css2_wwn64_extract(ata_identify_css2_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_wwn64_extract(ata_identify_css2_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ata_identify_css2_t ata_identify_css2_wwn64_insert(ata_identify_css2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css2_t ata_identify_css2_wwn64_insert(ata_identify_css2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeff) | (0x100 & (((ata_identify_css2_t )(_fieldval)) << 8)));
}

static inline uint8_t ata_identify_css2_iiwuf_extract(ata_identify_css2_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_iiwuf_extract(ata_identify_css2_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline ata_identify_css2_t ata_identify_css2_iiwuf_insert(ata_identify_css2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_css2_t ata_identify_css2_iiwuf_insert(ata_identify_css2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfff) | (0x2000 & (((ata_identify_css2_t )(_fieldval)) << 13)));
}

static inline int ata_identify_css2_prtval(char *_s, size_t _size, ata_identify_css2_t _regval) __attribute__ ((always_inline));
static inline int ata_identify_css2_prtval(char *_s, size_t _size, ata_identify_css2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smtel =\t%" PRIx8 "\t(SMART error logging supported)\n", ata_identify_css2_smtel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smtst =\t%" PRIx8 "\t(SMART self-test supported)\n", ata_identify_css2_smtst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msn =\t%" PRIx8 "\t(Media serial number supported)\n", ata_identify_css2_msn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mcptc =\t%" PRIx8 "\t(Media Card Pass Through Command feature set supported)\n", ata_identify_css2_mcptc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " strm =\t%" PRIx8 "\t(Streaming feature set supported)\n", ata_identify_css2_strm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpl =\t%" PRIx8 "\t(General Purpose Logging feature set supported)\n", ata_identify_css2_gpl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wdmafuax =\t%" PRIx8 "\t(WRITE DMA FUA EXT and WRITE MULTIPLE FUA EXT commands supported)\n", ata_identify_css2_wdmafuax_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wdmaqfuax =\t%" PRIx8 "\t(WRITE DMA QUEUED FUA EXT command supported)\n", ata_identify_css2_wdmaqfuax_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wwn64 =\t%" PRIx8 "\t(64-bit World wide name supported)\n", ata_identify_css2_wwn64_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iiwuf =\t%" PRIx8 "\t(IDLE IMMEDIATE with UNLOAD FEATURE supported)\n", ata_identify_css2_iiwuf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ata_identify_plss_t
 * Description: Implicit type of Physical Sector Size / Logical Sector Size register
 * Fields:
 *   lpp	(size 4, offset 0, init 0):	RO	2^X logical sectors per physical sector
 *   _anon4	(size 8, offset 4, init 0):	RSVD	_
 *   lls	(size 1, offset 12, init 0):	RO	Device Logical Sector Longer than 256 Words
 *   mlpp	(size 1, offset 13, init 0):	RO	Device has multiple logical sectors per phyiscal sector
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 */
typedef uint16_t ata_identify_plss_t;
#define ata_identify_plss_default 0x0
static inline uint8_t ata_identify_plss_lpp_extract(ata_identify_plss_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_plss_lpp_extract(ata_identify_plss_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline ata_identify_plss_t ata_identify_plss_lpp_insert(ata_identify_plss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_plss_t ata_identify_plss_lpp_insert(ata_identify_plss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff0) | (0xf & (((ata_identify_plss_t )(_fieldval)) << 0)));
}

static inline uint8_t ata_identify_plss_lls_extract(ata_identify_plss_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_plss_lls_extract(ata_identify_plss_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline ata_identify_plss_t ata_identify_plss_lls_insert(ata_identify_plss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_plss_t ata_identify_plss_lls_insert(ata_identify_plss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefff) | (0x1000 & (((ata_identify_plss_t )(_fieldval)) << 12)));
}

static inline uint8_t ata_identify_plss_mlpp_extract(ata_identify_plss_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_plss_mlpp_extract(ata_identify_plss_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline ata_identify_plss_t ata_identify_plss_mlpp_insert(ata_identify_plss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_plss_t ata_identify_plss_mlpp_insert(ata_identify_plss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfff) | (0x2000 & (((ata_identify_plss_t )(_fieldval)) << 13)));
}

static inline int ata_identify_plss_prtval(char *_s, size_t _size, ata_identify_plss_t _regval) __attribute__ ((always_inline));
static inline int ata_identify_plss_prtval(char *_s, size_t _size, ata_identify_plss_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpp =\t%" PRIx8 "\t(2^X logical sectors per physical sector)\n", ata_identify_plss_lpp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lls =\t%" PRIx8 "\t(Device Logical Sector Longer than 256 Words)\n", ata_identify_plss_lls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mlpp =\t%" PRIx8 "\t(Device has multiple logical sectors per phyiscal sector)\n", ata_identify_plss_mlpp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ata_identify_tmajrn_t
 * Description: Implicit type of Transport Major revision number register
 * Fields:
 *   v0	(size 1, offset 0, init 0):	RO	Type Parallel: ATA8-APT. Type Serial: ATA8-AST
 *   v1	(size 1, offset 1, init 0):	RO	Type Serial: SATA 1.0a
 *   v2	(size 1, offset 2, init 0):	RO	Type Serial: SATA II: Extensions
 *   v3	(size 1, offset 3, init 0):	RO	Type Serial: SATA Rev 2.5
 *   _anon4	(size 8, offset 4, init 0):	RSVD	_
 *   tt	(size 4, offset 12, init 0):	RO	Transport Type - 0 = Parallel, 1 = Serial, 2-15 = Reserved
 */
typedef uint16_t ata_identify_tmajrn_t;
#define ata_identify_tmajrn_default 0x0
static inline uint8_t ata_identify_tmajrn_v0_extract(ata_identify_tmajrn_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_tmajrn_v0_extract(ata_identify_tmajrn_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ata_identify_tmajrn_t ata_identify_tmajrn_v0_insert(ata_identify_tmajrn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_tmajrn_t ata_identify_tmajrn_v0_insert(ata_identify_tmajrn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe) | (0x1 & (((ata_identify_tmajrn_t )(_fieldval)) << 0)));
}

static inline uint8_t ata_identify_tmajrn_v1_extract(ata_identify_tmajrn_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_tmajrn_v1_extract(ata_identify_tmajrn_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ata_identify_tmajrn_t ata_identify_tmajrn_v1_insert(ata_identify_tmajrn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_tmajrn_t ata_identify_tmajrn_v1_insert(ata_identify_tmajrn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffd) | (0x2 & (((ata_identify_tmajrn_t )(_fieldval)) << 1)));
}

static inline uint8_t ata_identify_tmajrn_v2_extract(ata_identify_tmajrn_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_tmajrn_v2_extract(ata_identify_tmajrn_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ata_identify_tmajrn_t ata_identify_tmajrn_v2_insert(ata_identify_tmajrn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_tmajrn_t ata_identify_tmajrn_v2_insert(ata_identify_tmajrn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffb) | (0x4 & (((ata_identify_tmajrn_t )(_fieldval)) << 2)));
}

static inline uint8_t ata_identify_tmajrn_v3_extract(ata_identify_tmajrn_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_tmajrn_v3_extract(ata_identify_tmajrn_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ata_identify_tmajrn_t ata_identify_tmajrn_v3_insert(ata_identify_tmajrn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_tmajrn_t ata_identify_tmajrn_v3_insert(ata_identify_tmajrn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7) | (0x8 & (((ata_identify_tmajrn_t )(_fieldval)) << 3)));
}

static inline uint8_t ata_identify_tmajrn_tt_extract(ata_identify_tmajrn_t _regval) __attribute__ ((always_inline));
static inline uint8_t ata_identify_tmajrn_tt_extract(ata_identify_tmajrn_t _regval)
{
    return((uint8_t )((_regval & 0xf000) >> 12));
}

static inline ata_identify_tmajrn_t ata_identify_tmajrn_tt_insert(ata_identify_tmajrn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ata_identify_tmajrn_t ata_identify_tmajrn_tt_insert(ata_identify_tmajrn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff) | (0xf000 & (((ata_identify_tmajrn_t )(_fieldval)) << 12)));
}

static inline int ata_identify_tmajrn_prtval(char *_s, size_t _size, ata_identify_tmajrn_t _regval) __attribute__ ((always_inline));
static inline int ata_identify_tmajrn_prtval(char *_s, size_t _size, ata_identify_tmajrn_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v0 =\t%" PRIx8 "\t(Type Parallel: ATA8-APT. Type Serial: ATA8-AST)\n", ata_identify_tmajrn_v0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v1 =\t%" PRIx8 "\t(Type Serial: SATA 1.0a)\n", ata_identify_tmajrn_v1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v2 =\t%" PRIx8 "\t(Type Serial: SATA II: Extensions)\n", ata_identify_tmajrn_v2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v3 =\t%" PRIx8 "\t(Type Serial: SATA Rev 2.5)\n", ata_identify_tmajrn_v3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tt =\t%" PRIx8 "\t(Transport Type - 0 = Parallel, 1 = Serial, 2-15 = Reserved)\n", ata_identify_tmajrn_tt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t b;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum ata_identify_initials {
    ata_identify_gcbsi_initial = 0x0,
    ata_identify_sc_initial = 0x0,
    ata_identify_cfrsvd0_initial = 0x0,
    ata_identify_cfrsvd1_initial = 0x0,
    ata_identify_sn_initial = 0x0,
    ata_identify_fwrev_initial = 0x0,
    ata_identify_mn_initial = 0x0,
    ata_identify_word47_initial = 0x0,
    ata_identify_tcfso_initial = 0x0,
    ata_identify_caps0_initial = 0x0,
    ata_identify_caps1_initial = 0x0,
    ata_identify_tnuas_initial = 0x0,
    ata_identify_mwdma_initial = 0x0,
    ata_identify_pio_initial = 0x0,
    ata_identify_majrn_initial = 0x0,
    ata_identify_minrn_initial = 0x0,
    ata_identify_css0_initial = 0x0,
    ata_identify_css1_initial = 0x0,
    ata_identify_css2_initial = 0x0,
    ata_identify_tnuas48_initial = 0x0,
    ata_identify_plss_initial = 0x0,
    ata_identify_wpls_initial = 0x0,
    ata_identify_tmajrn_initial = 0x0,
    ata_identify_tminrn_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void ata_identify_initialize(__DN(t) *_dev, mackerel_addr_t b) __attribute__ ((always_inline));
static inline void ata_identify_initialize(__DN(t) *_dev, mackerel_addr_t b)
{
    _dev->b = b;
}

/*
 * Register gcbsi: General configuration bit-significant information
 * Type: ata_identify.gcbsi (Implicit type of General configuration bit-significant information register)
 *   _anon0	(size 1, offset 0, init 0):	RSVD	_
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   ri	(size 1, offset 2, init 0):	RO	Response incomplete
 *   _anon3	(size 3, offset 3, init 0):	RSVD	_
 *   _anon6	(size 2, offset 6, init 0):	RSVD	_
 *   _anon8	(size 7, offset 8, init 0):	RSVD	_
 *   ad	(size 1, offset 15, init 0):	RO	0 = ATA device
 */
static inline ata_identify_gcbsi_t ata_identify_gcbsi_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_gcbsi_t ata_identify_gcbsi_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x0));
}

static inline ata_identify_gcbsi_t ata_identify_gcbsi_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_gcbsi_t ata_identify_gcbsi_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x0));
}

static inline void ata_identify_gcbsi_rawwr(__DN(t) *_dev, ata_identify_gcbsi_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_gcbsi_rawwr(__DN(t) *_dev, ata_identify_gcbsi_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x0, _regval);
}

// Register gcbsi is not writeable
static inline int ata_identify_gcbsi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_gcbsi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ata_identify_gcbsi_t _regval = mackerel_read_addr_16(_dev->b, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gcbsi (General configuration bit-significant information): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ri =\t%" PRIx8 "\t(Response incomplete)\n", ata_identify_gcbsi_ri_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    // _anon6 is anonymous
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ad =\t%" PRIx8 "\t(0 = ATA device)\n", ata_identify_gcbsi_ad_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t ata_identify_gcbsi_ri_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_gcbsi_ri_rdf(__DN(t) *_dev)
{
    ata_identify_gcbsi_t _regval = mackerel_read_addr_16(_dev->b, 0x0);
    return(ata_identify_gcbsi_ri_extract(_regval));
}

static inline uint8_t ata_identify_gcbsi_ad_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_gcbsi_ad_rdf(__DN(t) *_dev)
{
    ata_identify_gcbsi_t _regval = mackerel_read_addr_16(_dev->b, 0x0);
    return(ata_identify_gcbsi_ad_extract(_regval));
}

/*
 * Register sc: Specific configuration
 * Type: ata_identify.uint16 (primitive type)
 */
static inline uint16_t ata_identify_sc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ata_identify_sc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x4));
}

static inline uint16_t ata_identify_sc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ata_identify_sc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x4));
}

static inline void ata_identify_sc_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_sc_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x4, _regval);
}

// Register sc is not writeable
static inline int ata_identify_sc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_sc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->b, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sc (Specific configuration): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register cfrsvd0: Reserved for assignment by the CompactFlash(TM) Association
 * Type: ata_identify.uint16 (primitive type)
 */
static inline uint16_t ata_identify_cfrsvd0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ata_identify_cfrsvd0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xe));
}

static inline uint16_t ata_identify_cfrsvd0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ata_identify_cfrsvd0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xe));
}

static inline void ata_identify_cfrsvd0_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_cfrsvd0_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0xe, _regval);
}

// Register cfrsvd0 is not writeable
static inline int ata_identify_cfrsvd0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_cfrsvd0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->b, 0xe);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cfrsvd0 (Reserved for assignment by the CompactFlash(TM) Association): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register cfrsvd1: Reserved for assignment by the CompactFlash(TM) Association
 * Type: ata_identify.uint16 (primitive type)
 */
static inline uint16_t ata_identify_cfrsvd1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ata_identify_cfrsvd1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x10));
}

static inline uint16_t ata_identify_cfrsvd1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ata_identify_cfrsvd1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x10));
}

static inline void ata_identify_cfrsvd1_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_cfrsvd1_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x10, _regval);
}

// Register cfrsvd1 is not writeable
static inline int ata_identify_cfrsvd1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_cfrsvd1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->b, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cfrsvd1 (Reserved for assignment by the CompactFlash(TM) Association): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register array sn: Serial number
 * Type: ata_identify.uint8 (primitive type)
 */
static const size_t ata_identify_sn_length = 20;
static inline uint8_t ata_identify_sn_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ata_identify_sn_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->b, 0x14 + (_i * (8 / 8))));
}

static inline uint8_t ata_identify_sn_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ata_identify_sn_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->b, 0x14 + (_i * (8 / 8))));
}

static inline void ata_identify_sn_rawwr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_sn_rawwr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->b, 0x14 + (_i * (8 / 8)), _regval);
}

// Register sn is not writeable
static inline int ata_identify_sn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int ata_identify_sn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->b, 0x14 + (_i * (8 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "sn", _i, "Serial number");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int ata_identify_sn_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_sn_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 20; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = ata_identify_sn_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array fwrev: Firmware revision
 * Type: ata_identify.uint8 (primitive type)
 */
static const size_t ata_identify_fwrev_length = 8;
static inline uint8_t ata_identify_fwrev_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ata_identify_fwrev_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->b, 0x2e + (_i * (8 / 8))));
}

static inline uint8_t ata_identify_fwrev_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ata_identify_fwrev_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->b, 0x2e + (_i * (8 / 8))));
}

static inline void ata_identify_fwrev_rawwr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_fwrev_rawwr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->b, 0x2e + (_i * (8 / 8)), _regval);
}

// Register fwrev is not writeable
static inline int ata_identify_fwrev_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int ata_identify_fwrev_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->b, 0x2e + (_i * (8 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "fwrev", _i, "Firmware revision");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int ata_identify_fwrev_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_fwrev_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = ata_identify_fwrev_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array mn: Model number
 * Type: ata_identify.uint8 (primitive type)
 */
static const size_t ata_identify_mn_length = 40;
static inline uint8_t ata_identify_mn_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ata_identify_mn_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->b, 0x36 + (_i * (8 / 8))));
}

static inline uint8_t ata_identify_mn_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ata_identify_mn_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->b, 0x36 + (_i * (8 / 8))));
}

static inline void ata_identify_mn_rawwr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_mn_rawwr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->b, 0x36 + (_i * (8 / 8)), _regval);
}

// Register mn is not writeable
static inline int ata_identify_mn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int ata_identify_mn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->b, 0x36 + (_i * (8 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "mn", _i, "Model number");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int ata_identify_mn_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_mn_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 40; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = ata_identify_mn_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register word47: Stuff
 * Type: ata_identify.word47 (Implicit type of Stuff register)
 *   maxls	(size 8, offset 0, init 0):	RO	00h = Reserved, 01h-FFh = Maximum number of logical sectors that shall be transferred per DRQ data block on READ/WRITE MULTIPLE commands
 *   unk	(size 8, offset 8, init 0):	RO	Must be 80h
 */
static inline ata_identify_word47_t ata_identify_word47_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_word47_t ata_identify_word47_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x5e));
}

static inline ata_identify_word47_t ata_identify_word47_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_word47_t ata_identify_word47_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x5e));
}

static inline void ata_identify_word47_rawwr(__DN(t) *_dev, ata_identify_word47_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_word47_rawwr(__DN(t) *_dev, ata_identify_word47_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x5e, _regval);
}

// Register word47 is not writeable
static inline int ata_identify_word47_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_word47_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ata_identify_word47_t _regval = mackerel_read_addr_16(_dev->b, 0x5e);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register word47 (Stuff): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " maxls =\t%" PRIx8 "\t(00h = Reserved, 01h-FFh = Maximum number of logical sectors that shall be transferred per DRQ data block on READ/WRITE MULTIPLE commands)\n", ata_identify_word47_maxls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " unk =\t%" PRIx8 "\t(Must be 80h)\n", ata_identify_word47_unk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t ata_identify_word47_maxls_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_word47_maxls_rdf(__DN(t) *_dev)
{
    ata_identify_word47_t _regval = mackerel_read_addr_16(_dev->b, 0x5e);
    return(ata_identify_word47_maxls_extract(_regval));
}

static inline uint8_t ata_identify_word47_unk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_word47_unk_rdf(__DN(t) *_dev)
{
    ata_identify_word47_t _regval = mackerel_read_addr_16(_dev->b, 0x5e);
    return(ata_identify_word47_unk_extract(_regval));
}

/*
 * Register tcfso: Trusted Computing feature set options
 * Type: ata_identify.tcfso (Implicit type of Trusted Computing feature set options register)
 *   tc	(size 1, offset 0, init 0):	RO	Trusted Computing feature set is supported
 *   rsvd	(size 13, offset 1, init 0):	RO	Reserved for the Trusted Computing Group
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 */
static inline ata_identify_tcfso_t ata_identify_tcfso_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_tcfso_t ata_identify_tcfso_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x60));
}

static inline ata_identify_tcfso_t ata_identify_tcfso_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_tcfso_t ata_identify_tcfso_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x60));
}

static inline void ata_identify_tcfso_rawwr(__DN(t) *_dev, ata_identify_tcfso_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_tcfso_rawwr(__DN(t) *_dev, ata_identify_tcfso_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x60, _regval);
}

// Register tcfso is not writeable
static inline int ata_identify_tcfso_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_tcfso_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ata_identify_tcfso_t _regval = mackerel_read_addr_16(_dev->b, 0x60);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tcfso (Trusted Computing feature set options): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc =\t%" PRIx8 "\t(Trusted Computing feature set is supported)\n", ata_identify_tcfso_tc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rsvd =\t%" PRIx16 "\t(Reserved for the Trusted Computing Group)\n", ata_identify_tcfso_rsvd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    // _anon15 is anonymous
    return(_r);
}

static inline uint8_t ata_identify_tcfso_tc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_tcfso_tc_rdf(__DN(t) *_dev)
{
    ata_identify_tcfso_t _regval = mackerel_read_addr_16(_dev->b, 0x60);
    return(ata_identify_tcfso_tc_extract(_regval));
}

static inline uint16_t ata_identify_tcfso_rsvd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ata_identify_tcfso_rsvd_rdf(__DN(t) *_dev)
{
    ata_identify_tcfso_t _regval = mackerel_read_addr_16(_dev->b, 0x60);
    return(ata_identify_tcfso_rsvd_extract(_regval));
}

/*
 * Register caps0: Capabilities part 1
 * Type: ata_identify.caps0 (Implicit type of Capabilities part 1 register)
 *   _anon0	(size 8, offset 0, init 0):	RSVD	_
 *   dmas	(size 1, offset 8, init 0):	RO	DMA supported
 *   lbas	(size 1, offset 9, init 0):	RO	LBA supported
 *   iord	(size 1, offset 10, init 0):	RO	IORDY may be disabled
 *   iors	(size 1, offset 11, init 0):	RO	IORDY supported
 *   _anon12	(size 1, offset 12, init 0):	RSVD	_
 *   sby	(size 1, offset 13, init 0):	RO	Standby tiemr values (0 = managed by device, 1 = as in standard)
 *   _anon14	(size 2, offset 14, init 0):	RSVD	_
 */
static inline ata_identify_caps0_t ata_identify_caps0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_caps0_t ata_identify_caps0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x62));
}

static inline ata_identify_caps0_t ata_identify_caps0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_caps0_t ata_identify_caps0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x62));
}

static inline void ata_identify_caps0_rawwr(__DN(t) *_dev, ata_identify_caps0_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_caps0_rawwr(__DN(t) *_dev, ata_identify_caps0_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x62, _regval);
}

// Register caps0 is not writeable
static inline int ata_identify_caps0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_caps0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ata_identify_caps0_t _regval = mackerel_read_addr_16(_dev->b, 0x62);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register caps0 (Capabilities part 1): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmas =\t%" PRIx8 "\t(DMA supported)\n", ata_identify_caps0_dmas_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbas =\t%" PRIx8 "\t(LBA supported)\n", ata_identify_caps0_lbas_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iord =\t%" PRIx8 "\t(IORDY may be disabled)\n", ata_identify_caps0_iord_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iors =\t%" PRIx8 "\t(IORDY supported)\n", ata_identify_caps0_iors_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sby =\t%" PRIx8 "\t(Standby tiemr values (0 = managed by device, 1 = as in standard))\n", ata_identify_caps0_sby_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    return(_r);
}

static inline uint8_t ata_identify_caps0_dmas_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_caps0_dmas_rdf(__DN(t) *_dev)
{
    ata_identify_caps0_t _regval = mackerel_read_addr_16(_dev->b, 0x62);
    return(ata_identify_caps0_dmas_extract(_regval));
}

static inline uint8_t ata_identify_caps0_lbas_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_caps0_lbas_rdf(__DN(t) *_dev)
{
    ata_identify_caps0_t _regval = mackerel_read_addr_16(_dev->b, 0x62);
    return(ata_identify_caps0_lbas_extract(_regval));
}

static inline uint8_t ata_identify_caps0_iord_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_caps0_iord_rdf(__DN(t) *_dev)
{
    ata_identify_caps0_t _regval = mackerel_read_addr_16(_dev->b, 0x62);
    return(ata_identify_caps0_iord_extract(_regval));
}

static inline uint8_t ata_identify_caps0_iors_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_caps0_iors_rdf(__DN(t) *_dev)
{
    ata_identify_caps0_t _regval = mackerel_read_addr_16(_dev->b, 0x62);
    return(ata_identify_caps0_iors_extract(_regval));
}

static inline uint8_t ata_identify_caps0_sby_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_caps0_sby_rdf(__DN(t) *_dev)
{
    ata_identify_caps0_t _regval = mackerel_read_addr_16(_dev->b, 0x62);
    return(ata_identify_caps0_sby_extract(_regval));
}

/*
 * Register caps1: Capabilities part 2
 * Type: ata_identify.caps1 (Implicit type of Capabilities part 2 register)
 *   dstm	(size 1, offset 0, init 0):	RO	Shall be set to one to indicate a device specific Standby timer value minimum.
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   _anon2	(size 12, offset 2, init 0):	RSVD	_
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 */
static inline ata_identify_caps1_t ata_identify_caps1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_caps1_t ata_identify_caps1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x64));
}

static inline ata_identify_caps1_t ata_identify_caps1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_caps1_t ata_identify_caps1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x64));
}

static inline void ata_identify_caps1_rawwr(__DN(t) *_dev, ata_identify_caps1_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_caps1_rawwr(__DN(t) *_dev, ata_identify_caps1_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x64, _regval);
}

// Register caps1 is not writeable
static inline int ata_identify_caps1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_caps1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ata_identify_caps1_t _regval = mackerel_read_addr_16(_dev->b, 0x64);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register caps1 (Capabilities part 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dstm =\t%" PRIx8 "\t(Shall be set to one to indicate a device specific Standby timer value minimum.)\n", ata_identify_caps1_dstm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    // _anon2 is anonymous
    // _anon14 is anonymous
    // _anon15 is anonymous
    return(_r);
}

static inline uint8_t ata_identify_caps1_dstm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_caps1_dstm_rdf(__DN(t) *_dev)
{
    ata_identify_caps1_t _regval = mackerel_read_addr_16(_dev->b, 0x64);
    return(ata_identify_caps1_dstm_extract(_regval));
}

/*
 * Register tnuas: Total number of user addressable sectors
 * Type: ata_identify.uint32 (primitive type)
 */
static inline uint32_t ata_identify_tnuas_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ata_identify_tnuas_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x78));
}

static inline uint32_t ata_identify_tnuas_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ata_identify_tnuas_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x78));
}

static inline void ata_identify_tnuas_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_tnuas_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x78, _regval);
}

// Register tnuas is not writeable
static inline int ata_identify_tnuas_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_tnuas_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->b, 0x78);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tnuas (Total number of user addressable sectors): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register mwdma: Supported DMA Modes
 * Type: ata_identify.mwdma (Implicit type of Supported DMA Modes register)
 *   m0sup	(size 1, offset 0, init 0):	RO	Multiword DMA mode 0 is supported
 *   m1sup	(size 1, offset 1, init 0):	RO	Multiword DMA mode 1 and below are supported
 *   m2sup	(size 1, offset 2, init 0):	RO	Multiword DMA mode 2 and below are supported
 *   _anon3	(size 5, offset 3, init 0):	RSVD	_
 *   m0sel	(size 1, offset 8, init 0):	RO	Multiword DMA mode 0 selected
 *   m1sel	(size 1, offset 9, init 0):	RO	Multiword DMA mode 1 selected
 *   m2sel	(size 1, offset 10, init 0):	RO	Multiword DMA mode 2 selected
 *   _anon11	(size 5, offset 11, init 0):	RSVD	_
 */
static inline ata_identify_mwdma_t ata_identify_mwdma_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_mwdma_t ata_identify_mwdma_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x7e));
}

static inline ata_identify_mwdma_t ata_identify_mwdma_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_mwdma_t ata_identify_mwdma_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x7e));
}

static inline void ata_identify_mwdma_rawwr(__DN(t) *_dev, ata_identify_mwdma_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_mwdma_rawwr(__DN(t) *_dev, ata_identify_mwdma_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x7e, _regval);
}

// Register mwdma is not writeable
static inline int ata_identify_mwdma_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_mwdma_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ata_identify_mwdma_t _regval = mackerel_read_addr_16(_dev->b, 0x7e);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mwdma (Supported DMA Modes): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m0sup =\t%" PRIx8 "\t(Multiword DMA mode 0 is supported)\n", ata_identify_mwdma_m0sup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m1sup =\t%" PRIx8 "\t(Multiword DMA mode 1 and below are supported)\n", ata_identify_mwdma_m1sup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m2sup =\t%" PRIx8 "\t(Multiword DMA mode 2 and below are supported)\n", ata_identify_mwdma_m2sup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m0sel =\t%" PRIx8 "\t(Multiword DMA mode 0 selected)\n", ata_identify_mwdma_m0sel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m1sel =\t%" PRIx8 "\t(Multiword DMA mode 1 selected)\n", ata_identify_mwdma_m1sel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m2sel =\t%" PRIx8 "\t(Multiword DMA mode 2 selected)\n", ata_identify_mwdma_m2sel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    return(_r);
}

static inline uint8_t ata_identify_mwdma_m0sup_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_mwdma_m0sup_rdf(__DN(t) *_dev)
{
    ata_identify_mwdma_t _regval = mackerel_read_addr_16(_dev->b, 0x7e);
    return(ata_identify_mwdma_m0sup_extract(_regval));
}

static inline uint8_t ata_identify_mwdma_m1sup_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_mwdma_m1sup_rdf(__DN(t) *_dev)
{
    ata_identify_mwdma_t _regval = mackerel_read_addr_16(_dev->b, 0x7e);
    return(ata_identify_mwdma_m1sup_extract(_regval));
}

static inline uint8_t ata_identify_mwdma_m2sup_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_mwdma_m2sup_rdf(__DN(t) *_dev)
{
    ata_identify_mwdma_t _regval = mackerel_read_addr_16(_dev->b, 0x7e);
    return(ata_identify_mwdma_m2sup_extract(_regval));
}

static inline uint8_t ata_identify_mwdma_m0sel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_mwdma_m0sel_rdf(__DN(t) *_dev)
{
    ata_identify_mwdma_t _regval = mackerel_read_addr_16(_dev->b, 0x7e);
    return(ata_identify_mwdma_m0sel_extract(_regval));
}

static inline uint8_t ata_identify_mwdma_m1sel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_mwdma_m1sel_rdf(__DN(t) *_dev)
{
    ata_identify_mwdma_t _regval = mackerel_read_addr_16(_dev->b, 0x7e);
    return(ata_identify_mwdma_m1sel_extract(_regval));
}

static inline uint8_t ata_identify_mwdma_m2sel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_mwdma_m2sel_rdf(__DN(t) *_dev)
{
    ata_identify_mwdma_t _regval = mackerel_read_addr_16(_dev->b, 0x7e);
    return(ata_identify_mwdma_m2sel_extract(_regval));
}

/*
 * Register pio: Supported PIO modes
 * Type: ata_identify.pio (Implicit type of Supported PIO modes register)
 *   msup	(size 8, offset 0, init 0):	RO	PIO modes supported
 *   _anon8	(size 8, offset 8, init 0):	RSVD	_
 */
static inline ata_identify_pio_t ata_identify_pio_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_pio_t ata_identify_pio_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x80));
}

static inline ata_identify_pio_t ata_identify_pio_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_pio_t ata_identify_pio_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x80));
}

static inline void ata_identify_pio_rawwr(__DN(t) *_dev, ata_identify_pio_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_pio_rawwr(__DN(t) *_dev, ata_identify_pio_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x80, _regval);
}

// Register pio is not writeable
static inline int ata_identify_pio_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_pio_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ata_identify_pio_t _regval = mackerel_read_addr_16(_dev->b, 0x80);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pio (Supported PIO modes): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msup =\t%" PRIx8 "\t(PIO modes supported)\n", ata_identify_pio_msup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t ata_identify_pio_msup_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_pio_msup_rdf(__DN(t) *_dev)
{
    ata_identify_pio_t _regval = mackerel_read_addr_16(_dev->b, 0x80);
    return(ata_identify_pio_msup_extract(_regval));
}

/*
 * Register majrn: Major revision number
 * Type: ata_identify.majrn (Implicit type of Major revision number register)
 *   _anon0	(size 1, offset 0, init 0):	RSVD	_
 *   _anon1	(size 3, offset 1, init 0):	RSVD	_
 *   a4	(size 1, offset 4, init 0):	RO	Supports ATA/ATAPI-4
 *   a5	(size 1, offset 5, init 0):	RO	Supports ATA/ATAPI-5
 *   a6	(size 1, offset 6, init 0):	RO	Supports ATA/ATAPI-6
 *   a7	(size 1, offset 7, init 0):	RO	Supports ATA/ATAPI-7
 *   a8	(size 1, offset 8, init 0):	RO	Supports ATA8-ACS
 *   _anon9	(size 7, offset 9, init 0):	RSVD	_
 */
static inline ata_identify_majrn_t ata_identify_majrn_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_majrn_t ata_identify_majrn_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xa0));
}

static inline ata_identify_majrn_t ata_identify_majrn_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_majrn_t ata_identify_majrn_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xa0));
}

static inline void ata_identify_majrn_rawwr(__DN(t) *_dev, ata_identify_majrn_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_majrn_rawwr(__DN(t) *_dev, ata_identify_majrn_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0xa0, _regval);
}

// Register majrn is not writeable
static inline int ata_identify_majrn_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_majrn_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ata_identify_majrn_t _regval = mackerel_read_addr_16(_dev->b, 0xa0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register majrn (Major revision number): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " a4 =\t%" PRIx8 "\t(Supports ATA/ATAPI-4)\n", ata_identify_majrn_a4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " a5 =\t%" PRIx8 "\t(Supports ATA/ATAPI-5)\n", ata_identify_majrn_a5_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " a6 =\t%" PRIx8 "\t(Supports ATA/ATAPI-6)\n", ata_identify_majrn_a6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " a7 =\t%" PRIx8 "\t(Supports ATA/ATAPI-7)\n", ata_identify_majrn_a7_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " a8 =\t%" PRIx8 "\t(Supports ATA8-ACS)\n", ata_identify_majrn_a8_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    return(_r);
}

static inline uint8_t ata_identify_majrn_a4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_majrn_a4_rdf(__DN(t) *_dev)
{
    ata_identify_majrn_t _regval = mackerel_read_addr_16(_dev->b, 0xa0);
    return(ata_identify_majrn_a4_extract(_regval));
}

static inline uint8_t ata_identify_majrn_a5_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_majrn_a5_rdf(__DN(t) *_dev)
{
    ata_identify_majrn_t _regval = mackerel_read_addr_16(_dev->b, 0xa0);
    return(ata_identify_majrn_a5_extract(_regval));
}

static inline uint8_t ata_identify_majrn_a6_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_majrn_a6_rdf(__DN(t) *_dev)
{
    ata_identify_majrn_t _regval = mackerel_read_addr_16(_dev->b, 0xa0);
    return(ata_identify_majrn_a6_extract(_regval));
}

static inline uint8_t ata_identify_majrn_a7_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_majrn_a7_rdf(__DN(t) *_dev)
{
    ata_identify_majrn_t _regval = mackerel_read_addr_16(_dev->b, 0xa0);
    return(ata_identify_majrn_a7_extract(_regval));
}

static inline uint8_t ata_identify_majrn_a8_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_majrn_a8_rdf(__DN(t) *_dev)
{
    ata_identify_majrn_t _regval = mackerel_read_addr_16(_dev->b, 0xa0);
    return(ata_identify_majrn_a8_extract(_regval));
}

/*
 * Register minrn: Minor revision number
 * Type: ata_identify.uint16 (primitive type)
 */
static inline uint16_t ata_identify_minrn_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ata_identify_minrn_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xa2));
}

static inline uint16_t ata_identify_minrn_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ata_identify_minrn_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xa2));
}

static inline void ata_identify_minrn_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_minrn_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0xa2, _regval);
}

// Register minrn is not writeable
static inline int ata_identify_minrn_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_minrn_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->b, 0xa2);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register minrn (Minor revision number): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register css0: Command set supported part 1
 * Type: ata_identify.css0 (Implicit type of Command set supported part 1 register)
 *   smrt	(size 1, offset 0, init 0):	RO	SMART feature set supported
 *   secm	(size 1, offset 1, init 0):	RO	Security Mode feature set supported
 *   _anon2	(size 1, offset 2, init 0):	RSVD	_
 *   pwrm	(size 1, offset 3, init 0):	RO	Mandatory Power Management feature set supported
 *   pack	(size 1, offset 4, init 0):	RO	Cleared to indicate PACKET feature set not supported
 *   wrtc	(size 1, offset 5, init 0):	RO	Write cache supported
 *   loka	(size 1, offset 6, init 0):	RO	Look-ahead supported
 *   reli	(size 1, offset 7, init 0):	RO	Release interrupt supported
 *   svci	(size 1, offset 8, init 0):	RO	SERVICE interrupt supported
 *   drst	(size 1, offset 9, init 0):	RO	DEVICE RESET command supported
 *   hpa	(size 1, offset 10, init 0):	RO	Host Protected Area feature set supported
 *   _anon11	(size 1, offset 11, init 0):	RSVD	_
 *   wrtb	(size 1, offset 12, init 0):	RO	WRITE BUFFER command supported
 *   reab	(size 1, offset 13, init 0):	RO	READ BUFFER command supported
 *   nop	(size 1, offset 14, init 0):	RO	NOP command supported
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 */
static inline ata_identify_css0_t ata_identify_css0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_css0_t ata_identify_css0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xa4));
}

static inline ata_identify_css0_t ata_identify_css0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_css0_t ata_identify_css0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xa4));
}

static inline void ata_identify_css0_rawwr(__DN(t) *_dev, ata_identify_css0_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_css0_rawwr(__DN(t) *_dev, ata_identify_css0_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0xa4, _regval);
}

// Register css0 is not writeable
static inline int ata_identify_css0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_css0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ata_identify_css0_t _regval = mackerel_read_addr_16(_dev->b, 0xa4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register css0 (Command set supported part 1): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smrt =\t%" PRIx8 "\t(SMART feature set supported)\n", ata_identify_css0_smrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " secm =\t%" PRIx8 "\t(Security Mode feature set supported)\n", ata_identify_css0_secm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pwrm =\t%" PRIx8 "\t(Mandatory Power Management feature set supported)\n", ata_identify_css0_pwrm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pack =\t%" PRIx8 "\t(Cleared to indicate PACKET feature set not supported)\n", ata_identify_css0_pack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wrtc =\t%" PRIx8 "\t(Write cache supported)\n", ata_identify_css0_wrtc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " loka =\t%" PRIx8 "\t(Look-ahead supported)\n", ata_identify_css0_loka_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reli =\t%" PRIx8 "\t(Release interrupt supported)\n", ata_identify_css0_reli_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " svci =\t%" PRIx8 "\t(SERVICE interrupt supported)\n", ata_identify_css0_svci_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drst =\t%" PRIx8 "\t(DEVICE RESET command supported)\n", ata_identify_css0_drst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hpa =\t%" PRIx8 "\t(Host Protected Area feature set supported)\n", ata_identify_css0_hpa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wrtb =\t%" PRIx8 "\t(WRITE BUFFER command supported)\n", ata_identify_css0_wrtb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reab =\t%" PRIx8 "\t(READ BUFFER command supported)\n", ata_identify_css0_reab_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nop =\t%" PRIx8 "\t(NOP command supported)\n", ata_identify_css0_nop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    return(_r);
}

static inline uint8_t ata_identify_css0_smrt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_smrt_rdf(__DN(t) *_dev)
{
    ata_identify_css0_t _regval = mackerel_read_addr_16(_dev->b, 0xa4);
    return(ata_identify_css0_smrt_extract(_regval));
}

static inline uint8_t ata_identify_css0_secm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_secm_rdf(__DN(t) *_dev)
{
    ata_identify_css0_t _regval = mackerel_read_addr_16(_dev->b, 0xa4);
    return(ata_identify_css0_secm_extract(_regval));
}

static inline uint8_t ata_identify_css0_pwrm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_pwrm_rdf(__DN(t) *_dev)
{
    ata_identify_css0_t _regval = mackerel_read_addr_16(_dev->b, 0xa4);
    return(ata_identify_css0_pwrm_extract(_regval));
}

static inline uint8_t ata_identify_css0_pack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_pack_rdf(__DN(t) *_dev)
{
    ata_identify_css0_t _regval = mackerel_read_addr_16(_dev->b, 0xa4);
    return(ata_identify_css0_pack_extract(_regval));
}

static inline uint8_t ata_identify_css0_wrtc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_wrtc_rdf(__DN(t) *_dev)
{
    ata_identify_css0_t _regval = mackerel_read_addr_16(_dev->b, 0xa4);
    return(ata_identify_css0_wrtc_extract(_regval));
}

static inline uint8_t ata_identify_css0_loka_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_loka_rdf(__DN(t) *_dev)
{
    ata_identify_css0_t _regval = mackerel_read_addr_16(_dev->b, 0xa4);
    return(ata_identify_css0_loka_extract(_regval));
}

static inline uint8_t ata_identify_css0_reli_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_reli_rdf(__DN(t) *_dev)
{
    ata_identify_css0_t _regval = mackerel_read_addr_16(_dev->b, 0xa4);
    return(ata_identify_css0_reli_extract(_regval));
}

static inline uint8_t ata_identify_css0_svci_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_svci_rdf(__DN(t) *_dev)
{
    ata_identify_css0_t _regval = mackerel_read_addr_16(_dev->b, 0xa4);
    return(ata_identify_css0_svci_extract(_regval));
}

static inline uint8_t ata_identify_css0_drst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_drst_rdf(__DN(t) *_dev)
{
    ata_identify_css0_t _regval = mackerel_read_addr_16(_dev->b, 0xa4);
    return(ata_identify_css0_drst_extract(_regval));
}

static inline uint8_t ata_identify_css0_hpa_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_hpa_rdf(__DN(t) *_dev)
{
    ata_identify_css0_t _regval = mackerel_read_addr_16(_dev->b, 0xa4);
    return(ata_identify_css0_hpa_extract(_regval));
}

static inline uint8_t ata_identify_css0_wrtb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_wrtb_rdf(__DN(t) *_dev)
{
    ata_identify_css0_t _regval = mackerel_read_addr_16(_dev->b, 0xa4);
    return(ata_identify_css0_wrtb_extract(_regval));
}

static inline uint8_t ata_identify_css0_reab_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_reab_rdf(__DN(t) *_dev)
{
    ata_identify_css0_t _regval = mackerel_read_addr_16(_dev->b, 0xa4);
    return(ata_identify_css0_reab_extract(_regval));
}

static inline uint8_t ata_identify_css0_nop_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css0_nop_rdf(__DN(t) *_dev)
{
    ata_identify_css0_t _regval = mackerel_read_addr_16(_dev->b, 0xa4);
    return(ata_identify_css0_nop_extract(_regval));
}

/*
 * Register css1: Command sets supported part 2
 * Type: ata_identify.css1 (Implicit type of Command sets supported part 2 register)
 *   dlmc	(size 1, offset 0, init 0):	RO	DOWNLOAD MICROCODE command supported
 *   dmaq	(size 1, offset 1, init 0):	RO	READ/WRITE DMA QUEUED supported
 *   cfa	(size 1, offset 2, init 0):	RO	CFA feature set supported
 *   apm	(size 1, offset 3, init 0):	RO	Advanced Power Management feature set supported
 *   _anon4	(size 1, offset 4, init 0):	RSVD	_
 *   puis	(size 1, offset 5, init 0):	RO	Power-Up In Standby feature set supported
 *   sfspn	(size 1, offset 6, init 0):	RO	SET FEATUREs subcommand required to spin-up after power-up
 *   orab	(size 1, offset 7, init 0):	RO	See Address Offset Reserved Area Boot, INCITS TR27:2001
 *   smsec	(size 1, offset 8, init 0):	RO	SET MAX security extension supported
 *   aam	(size 1, offset 9, init 0):	RO	Automatic Acoustic Management feature set supported
 *   lba48	(size 1, offset 10, init 0):	RO	48-bit Address feature set supported
 *   dco	(size 1, offset 11, init 0):	RO	Mandatory Device Configuration Overlay feature set supported
 *   flc	(size 1, offset 12, init 0):	RO	Mandatory FLUSH CACHE command supported
 *   flcx	(size 1, offset 13, init 0):	RO	FLUSH CACHE EXT command supported
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 */
static inline ata_identify_css1_t ata_identify_css1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_css1_t ata_identify_css1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xa6));
}

static inline ata_identify_css1_t ata_identify_css1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_css1_t ata_identify_css1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xa6));
}

static inline void ata_identify_css1_rawwr(__DN(t) *_dev, ata_identify_css1_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_css1_rawwr(__DN(t) *_dev, ata_identify_css1_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0xa6, _regval);
}

// Register css1 is not writeable
static inline int ata_identify_css1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_css1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ata_identify_css1_t _regval = mackerel_read_addr_16(_dev->b, 0xa6);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register css1 (Command sets supported part 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlmc =\t%" PRIx8 "\t(DOWNLOAD MICROCODE command supported)\n", ata_identify_css1_dlmc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmaq =\t%" PRIx8 "\t(READ/WRITE DMA QUEUED supported)\n", ata_identify_css1_dmaq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfa =\t%" PRIx8 "\t(CFA feature set supported)\n", ata_identify_css1_cfa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apm =\t%" PRIx8 "\t(Advanced Power Management feature set supported)\n", ata_identify_css1_apm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " puis =\t%" PRIx8 "\t(Power-Up In Standby feature set supported)\n", ata_identify_css1_puis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sfspn =\t%" PRIx8 "\t(SET FEATUREs subcommand required to spin-up after power-up)\n", ata_identify_css1_sfspn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " orab =\t%" PRIx8 "\t(See Address Offset Reserved Area Boot, INCITS TR27:2001)\n", ata_identify_css1_orab_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smsec =\t%" PRIx8 "\t(SET MAX security extension supported)\n", ata_identify_css1_smsec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aam =\t%" PRIx8 "\t(Automatic Acoustic Management feature set supported)\n", ata_identify_css1_aam_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lba48 =\t%" PRIx8 "\t(48-bit Address feature set supported)\n", ata_identify_css1_lba48_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dco =\t%" PRIx8 "\t(Mandatory Device Configuration Overlay feature set supported)\n", ata_identify_css1_dco_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flc =\t%" PRIx8 "\t(Mandatory FLUSH CACHE command supported)\n", ata_identify_css1_flc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flcx =\t%" PRIx8 "\t(FLUSH CACHE EXT command supported)\n", ata_identify_css1_flcx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    // _anon15 is anonymous
    return(_r);
}

static inline uint8_t ata_identify_css1_dlmc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_dlmc_rdf(__DN(t) *_dev)
{
    ata_identify_css1_t _regval = mackerel_read_addr_16(_dev->b, 0xa6);
    return(ata_identify_css1_dlmc_extract(_regval));
}

static inline uint8_t ata_identify_css1_dmaq_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_dmaq_rdf(__DN(t) *_dev)
{
    ata_identify_css1_t _regval = mackerel_read_addr_16(_dev->b, 0xa6);
    return(ata_identify_css1_dmaq_extract(_regval));
}

static inline uint8_t ata_identify_css1_cfa_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_cfa_rdf(__DN(t) *_dev)
{
    ata_identify_css1_t _regval = mackerel_read_addr_16(_dev->b, 0xa6);
    return(ata_identify_css1_cfa_extract(_regval));
}

static inline uint8_t ata_identify_css1_apm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_apm_rdf(__DN(t) *_dev)
{
    ata_identify_css1_t _regval = mackerel_read_addr_16(_dev->b, 0xa6);
    return(ata_identify_css1_apm_extract(_regval));
}

static inline uint8_t ata_identify_css1_puis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_puis_rdf(__DN(t) *_dev)
{
    ata_identify_css1_t _regval = mackerel_read_addr_16(_dev->b, 0xa6);
    return(ata_identify_css1_puis_extract(_regval));
}

static inline uint8_t ata_identify_css1_sfspn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_sfspn_rdf(__DN(t) *_dev)
{
    ata_identify_css1_t _regval = mackerel_read_addr_16(_dev->b, 0xa6);
    return(ata_identify_css1_sfspn_extract(_regval));
}

static inline uint8_t ata_identify_css1_orab_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_orab_rdf(__DN(t) *_dev)
{
    ata_identify_css1_t _regval = mackerel_read_addr_16(_dev->b, 0xa6);
    return(ata_identify_css1_orab_extract(_regval));
}

static inline uint8_t ata_identify_css1_smsec_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_smsec_rdf(__DN(t) *_dev)
{
    ata_identify_css1_t _regval = mackerel_read_addr_16(_dev->b, 0xa6);
    return(ata_identify_css1_smsec_extract(_regval));
}

static inline uint8_t ata_identify_css1_aam_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_aam_rdf(__DN(t) *_dev)
{
    ata_identify_css1_t _regval = mackerel_read_addr_16(_dev->b, 0xa6);
    return(ata_identify_css1_aam_extract(_regval));
}

static inline uint8_t ata_identify_css1_lba48_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_lba48_rdf(__DN(t) *_dev)
{
    ata_identify_css1_t _regval = mackerel_read_addr_16(_dev->b, 0xa6);
    return(ata_identify_css1_lba48_extract(_regval));
}

static inline uint8_t ata_identify_css1_dco_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_dco_rdf(__DN(t) *_dev)
{
    ata_identify_css1_t _regval = mackerel_read_addr_16(_dev->b, 0xa6);
    return(ata_identify_css1_dco_extract(_regval));
}

static inline uint8_t ata_identify_css1_flc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_flc_rdf(__DN(t) *_dev)
{
    ata_identify_css1_t _regval = mackerel_read_addr_16(_dev->b, 0xa6);
    return(ata_identify_css1_flc_extract(_regval));
}

static inline uint8_t ata_identify_css1_flcx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css1_flcx_rdf(__DN(t) *_dev)
{
    ata_identify_css1_t _regval = mackerel_read_addr_16(_dev->b, 0xa6);
    return(ata_identify_css1_flcx_extract(_regval));
}

/*
 * Register css2: Command set/feature supported part 3
 * Type: ata_identify.css2 (Implicit type of Command set/feature supported part 3 register)
 *   smtel	(size 1, offset 0, init 0):	RO	SMART error logging supported
 *   smtst	(size 1, offset 1, init 0):	RO	SMART self-test supported
 *   msn	(size 1, offset 2, init 0):	RO	Media serial number supported
 *   mcptc	(size 1, offset 3, init 0):	RO	Media Card Pass Through Command feature set supported
 *   strm	(size 1, offset 4, init 0):	RO	Streaming feature set supported
 *   gpl	(size 1, offset 5, init 0):	RO	General Purpose Logging feature set supported
 *   wdmafuax	(size 1, offset 6, init 0):	RO	WRITE DMA FUA EXT and WRITE MULTIPLE FUA EXT commands supported
 *   wdmaqfuax	(size 1, offset 7, init 0):	RO	WRITE DMA QUEUED FUA EXT command supported
 *   wwn64	(size 1, offset 8, init 0):	RO	64-bit World wide name supported
 *   _anon9	(size 2, offset 9, init 0):	RSVD	_
 *   _anon11	(size 2, offset 11, init 0):	RSVD	_
 *   iiwuf	(size 1, offset 13, init 0):	RO	IDLE IMMEDIATE with UNLOAD FEATURE supported
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 */
static inline ata_identify_css2_t ata_identify_css2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_css2_t ata_identify_css2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xa8));
}

static inline ata_identify_css2_t ata_identify_css2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_css2_t ata_identify_css2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xa8));
}

static inline void ata_identify_css2_rawwr(__DN(t) *_dev, ata_identify_css2_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_css2_rawwr(__DN(t) *_dev, ata_identify_css2_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0xa8, _regval);
}

// Register css2 is not writeable
static inline int ata_identify_css2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_css2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ata_identify_css2_t _regval = mackerel_read_addr_16(_dev->b, 0xa8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register css2 (Command set/feature supported part 3): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smtel =\t%" PRIx8 "\t(SMART error logging supported)\n", ata_identify_css2_smtel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smtst =\t%" PRIx8 "\t(SMART self-test supported)\n", ata_identify_css2_smtst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msn =\t%" PRIx8 "\t(Media serial number supported)\n", ata_identify_css2_msn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mcptc =\t%" PRIx8 "\t(Media Card Pass Through Command feature set supported)\n", ata_identify_css2_mcptc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " strm =\t%" PRIx8 "\t(Streaming feature set supported)\n", ata_identify_css2_strm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpl =\t%" PRIx8 "\t(General Purpose Logging feature set supported)\n", ata_identify_css2_gpl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wdmafuax =\t%" PRIx8 "\t(WRITE DMA FUA EXT and WRITE MULTIPLE FUA EXT commands supported)\n", ata_identify_css2_wdmafuax_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wdmaqfuax =\t%" PRIx8 "\t(WRITE DMA QUEUED FUA EXT command supported)\n", ata_identify_css2_wdmaqfuax_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wwn64 =\t%" PRIx8 "\t(64-bit World wide name supported)\n", ata_identify_css2_wwn64_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iiwuf =\t%" PRIx8 "\t(IDLE IMMEDIATE with UNLOAD FEATURE supported)\n", ata_identify_css2_iiwuf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    // _anon15 is anonymous
    return(_r);
}

static inline uint8_t ata_identify_css2_smtel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_smtel_rdf(__DN(t) *_dev)
{
    ata_identify_css2_t _regval = mackerel_read_addr_16(_dev->b, 0xa8);
    return(ata_identify_css2_smtel_extract(_regval));
}

static inline uint8_t ata_identify_css2_smtst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_smtst_rdf(__DN(t) *_dev)
{
    ata_identify_css2_t _regval = mackerel_read_addr_16(_dev->b, 0xa8);
    return(ata_identify_css2_smtst_extract(_regval));
}

static inline uint8_t ata_identify_css2_msn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_msn_rdf(__DN(t) *_dev)
{
    ata_identify_css2_t _regval = mackerel_read_addr_16(_dev->b, 0xa8);
    return(ata_identify_css2_msn_extract(_regval));
}

static inline uint8_t ata_identify_css2_mcptc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_mcptc_rdf(__DN(t) *_dev)
{
    ata_identify_css2_t _regval = mackerel_read_addr_16(_dev->b, 0xa8);
    return(ata_identify_css2_mcptc_extract(_regval));
}

static inline uint8_t ata_identify_css2_strm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_strm_rdf(__DN(t) *_dev)
{
    ata_identify_css2_t _regval = mackerel_read_addr_16(_dev->b, 0xa8);
    return(ata_identify_css2_strm_extract(_regval));
}

static inline uint8_t ata_identify_css2_gpl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_gpl_rdf(__DN(t) *_dev)
{
    ata_identify_css2_t _regval = mackerel_read_addr_16(_dev->b, 0xa8);
    return(ata_identify_css2_gpl_extract(_regval));
}

static inline uint8_t ata_identify_css2_wdmafuax_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_wdmafuax_rdf(__DN(t) *_dev)
{
    ata_identify_css2_t _regval = mackerel_read_addr_16(_dev->b, 0xa8);
    return(ata_identify_css2_wdmafuax_extract(_regval));
}

static inline uint8_t ata_identify_css2_wdmaqfuax_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_wdmaqfuax_rdf(__DN(t) *_dev)
{
    ata_identify_css2_t _regval = mackerel_read_addr_16(_dev->b, 0xa8);
    return(ata_identify_css2_wdmaqfuax_extract(_regval));
}

static inline uint8_t ata_identify_css2_wwn64_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_wwn64_rdf(__DN(t) *_dev)
{
    ata_identify_css2_t _regval = mackerel_read_addr_16(_dev->b, 0xa8);
    return(ata_identify_css2_wwn64_extract(_regval));
}

static inline uint8_t ata_identify_css2_iiwuf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_css2_iiwuf_rdf(__DN(t) *_dev)
{
    ata_identify_css2_t _regval = mackerel_read_addr_16(_dev->b, 0xa8);
    return(ata_identify_css2_iiwuf_extract(_regval));
}

/*
 * Register tnuas48: Total Number of User Addressable Sectors for the 48-bit Address feature set
 * Type: ata_identify.uint64 (primitive type)
 */
static inline uint64_t ata_identify_tnuas48_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint64_t ata_identify_tnuas48_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->b, 0xc8));
}

static inline uint64_t ata_identify_tnuas48_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint64_t ata_identify_tnuas48_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->b, 0xc8));
}

static inline void ata_identify_tnuas48_rawwr(__DN(t) *_dev, uint64_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_tnuas48_rawwr(__DN(t) *_dev, uint64_t _regval)
{
    mackerel_write_addr_64(_dev->b, 0xc8, _regval);
}

// Register tnuas48 is not writeable
static inline int ata_identify_tnuas48_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_tnuas48_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint64_t _regval = mackerel_read_addr_64(_dev->b, 0xc8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tnuas48 (Total Number of User Addressable Sectors for the 48-bit Address feature set): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx64 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register plss: Physical Sector Size / Logical Sector Size
 * Type: ata_identify.plss (Implicit type of Physical Sector Size / Logical Sector Size register)
 *   lpp	(size 4, offset 0, init 0):	RO	2^X logical sectors per physical sector
 *   _anon4	(size 8, offset 4, init 0):	RSVD	_
 *   lls	(size 1, offset 12, init 0):	RO	Device Logical Sector Longer than 256 Words
 *   mlpp	(size 1, offset 13, init 0):	RO	Device has multiple logical sectors per phyiscal sector
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 */
static inline ata_identify_plss_t ata_identify_plss_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_plss_t ata_identify_plss_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xd4));
}

static inline ata_identify_plss_t ata_identify_plss_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_plss_t ata_identify_plss_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xd4));
}

static inline void ata_identify_plss_rawwr(__DN(t) *_dev, ata_identify_plss_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_plss_rawwr(__DN(t) *_dev, ata_identify_plss_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0xd4, _regval);
}

// Register plss is not writeable
static inline int ata_identify_plss_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_plss_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ata_identify_plss_t _regval = mackerel_read_addr_16(_dev->b, 0xd4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register plss (Physical Sector Size / Logical Sector Size): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpp =\t%" PRIx8 "\t(2^X logical sectors per physical sector)\n", ata_identify_plss_lpp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lls =\t%" PRIx8 "\t(Device Logical Sector Longer than 256 Words)\n", ata_identify_plss_lls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mlpp =\t%" PRIx8 "\t(Device has multiple logical sectors per phyiscal sector)\n", ata_identify_plss_mlpp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    // _anon15 is anonymous
    return(_r);
}

static inline uint8_t ata_identify_plss_lpp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_plss_lpp_rdf(__DN(t) *_dev)
{
    ata_identify_plss_t _regval = mackerel_read_addr_16(_dev->b, 0xd4);
    return(ata_identify_plss_lpp_extract(_regval));
}

static inline uint8_t ata_identify_plss_lls_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_plss_lls_rdf(__DN(t) *_dev)
{
    ata_identify_plss_t _regval = mackerel_read_addr_16(_dev->b, 0xd4);
    return(ata_identify_plss_lls_extract(_regval));
}

static inline uint8_t ata_identify_plss_mlpp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_plss_mlpp_rdf(__DN(t) *_dev)
{
    ata_identify_plss_t _regval = mackerel_read_addr_16(_dev->b, 0xd4);
    return(ata_identify_plss_mlpp_extract(_regval));
}

/*
 * Register wpls: Words per Logical Sector
 * Type: ata_identify.uint32 (primitive type)
 */
static inline uint32_t ata_identify_wpls_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ata_identify_wpls_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0xea));
}

static inline uint32_t ata_identify_wpls_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ata_identify_wpls_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0xea));
}

static inline void ata_identify_wpls_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_wpls_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0xea, _regval);
}

// Register wpls is not writeable
static inline int ata_identify_wpls_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_wpls_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->b, 0xea);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register wpls (Words per Logical Sector): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register tmajrn: Transport Major revision number
 * Type: ata_identify.tmajrn (Implicit type of Transport Major revision number register)
 *   v0	(size 1, offset 0, init 0):	RO	Type Parallel: ATA8-APT. Type Serial: ATA8-AST
 *   v1	(size 1, offset 1, init 0):	RO	Type Serial: SATA 1.0a
 *   v2	(size 1, offset 2, init 0):	RO	Type Serial: SATA II: Extensions
 *   v3	(size 1, offset 3, init 0):	RO	Type Serial: SATA Rev 2.5
 *   _anon4	(size 8, offset 4, init 0):	RSVD	_
 *   tt	(size 4, offset 12, init 0):	RO	Transport Type - 0 = Parallel, 1 = Serial, 2-15 = Reserved
 */
static inline ata_identify_tmajrn_t ata_identify_tmajrn_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_tmajrn_t ata_identify_tmajrn_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x1bc));
}

static inline ata_identify_tmajrn_t ata_identify_tmajrn_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ata_identify_tmajrn_t ata_identify_tmajrn_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x1bc));
}

static inline void ata_identify_tmajrn_rawwr(__DN(t) *_dev, ata_identify_tmajrn_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_tmajrn_rawwr(__DN(t) *_dev, ata_identify_tmajrn_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x1bc, _regval);
}

// Register tmajrn is not writeable
static inline int ata_identify_tmajrn_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_tmajrn_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ata_identify_tmajrn_t _regval = mackerel_read_addr_16(_dev->b, 0x1bc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tmajrn (Transport Major revision number): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v0 =\t%" PRIx8 "\t(Type Parallel: ATA8-APT. Type Serial: ATA8-AST)\n", ata_identify_tmajrn_v0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v1 =\t%" PRIx8 "\t(Type Serial: SATA 1.0a)\n", ata_identify_tmajrn_v1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v2 =\t%" PRIx8 "\t(Type Serial: SATA II: Extensions)\n", ata_identify_tmajrn_v2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v3 =\t%" PRIx8 "\t(Type Serial: SATA Rev 2.5)\n", ata_identify_tmajrn_v3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tt =\t%" PRIx8 "\t(Transport Type - 0 = Parallel, 1 = Serial, 2-15 = Reserved)\n", ata_identify_tmajrn_tt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t ata_identify_tmajrn_v0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_tmajrn_v0_rdf(__DN(t) *_dev)
{
    ata_identify_tmajrn_t _regval = mackerel_read_addr_16(_dev->b, 0x1bc);
    return(ata_identify_tmajrn_v0_extract(_regval));
}

static inline uint8_t ata_identify_tmajrn_v1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_tmajrn_v1_rdf(__DN(t) *_dev)
{
    ata_identify_tmajrn_t _regval = mackerel_read_addr_16(_dev->b, 0x1bc);
    return(ata_identify_tmajrn_v1_extract(_regval));
}

static inline uint8_t ata_identify_tmajrn_v2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_tmajrn_v2_rdf(__DN(t) *_dev)
{
    ata_identify_tmajrn_t _regval = mackerel_read_addr_16(_dev->b, 0x1bc);
    return(ata_identify_tmajrn_v2_extract(_regval));
}

static inline uint8_t ata_identify_tmajrn_v3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_tmajrn_v3_rdf(__DN(t) *_dev)
{
    ata_identify_tmajrn_t _regval = mackerel_read_addr_16(_dev->b, 0x1bc);
    return(ata_identify_tmajrn_v3_extract(_regval));
}

static inline uint8_t ata_identify_tmajrn_tt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ata_identify_tmajrn_tt_rdf(__DN(t) *_dev)
{
    ata_identify_tmajrn_t _regval = mackerel_read_addr_16(_dev->b, 0x1bc);
    return(ata_identify_tmajrn_tt_extract(_regval));
}

/*
 * Register tminrn: Transport Minor revision number
 * Type: ata_identify.uint16 (primitive type)
 */
static inline uint16_t ata_identify_tminrn_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ata_identify_tminrn_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x1be));
}

static inline uint16_t ata_identify_tminrn_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ata_identify_tminrn_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x1be));
}

static inline void ata_identify_tminrn_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void ata_identify_tminrn_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x1be, _regval);
}

// Register tminrn is not writeable
static inline int ata_identify_tminrn_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_tminrn_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->b, 0x1be);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tminrn (Transport Minor revision number): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int ata_identify_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ata_identify_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device ata_identify (ATA IDENTIFY results):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_gcbsi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_sc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_cfrsvd0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_cfrsvd1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_sn_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_fwrev_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_mn_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_word47_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_tcfso_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_caps0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_caps1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_tnuas_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_mwdma_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_pio_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_majrn_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_minrn_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_css0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_css1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_css2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_tnuas48_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_plss_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_wpls_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_tmajrn_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ata_identify_tminrn_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device ata_identify\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __ata_identify_DEV_H
