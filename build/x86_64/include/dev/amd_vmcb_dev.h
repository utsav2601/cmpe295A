/*
 * DEVICE DEFINITION: AMD Virtual Machine Control Block
 * 
 * Copyright (c) 2007, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich.
 *  Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED: DO NOT EDIT!
 */

#ifndef __amd_vmcb_H
#define __amd_vmcb_H

#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR
#define __DN(x) amd_vmcb ## _ ## x
#ifdef amd_vmcb_PREFIX
#define __DP(x) __DP1(x,amd_vmcb_PREFIX)
#define __DP1(x1,x2) __DP2(x1,x2)
#define __DP2(x1,x2) x2 ## x1
#else
#define __DP(x) amd_vmcb##_ ##x
#endif
#define __STR(x) #x
#define __XTR(x) __STR(x)

/*
 * Register type: Implicit type of Intercept reads/writes to CR0-15 register
 */

/*
 * Dump of fields for register type: amd_vmcb_cr_access_t
 *   rdcr0 (size 1, offset 0):	 RW	  Intercept reads of CR0
 *   rdcr1 (size 1, offset 1):	 RW	  Intercept reads of CR1
 *   rdcr2 (size 1, offset 2):	 RW	  Intercept reads of CR2
 *   rdcr3 (size 1, offset 3):	 RW	  Intercept reads of CR3
 *   rdcr4 (size 1, offset 4):	 RW	  Intercept reads of CR4
 *   rdcr5 (size 1, offset 5):	 RW	  Intercept reads of CR5
 *   rdcr6 (size 1, offset 6):	 RW	  Intercept reads of CR6
 *   rdcr7 (size 1, offset 7):	 RW	  Intercept reads of CR7
 *   rdcr8 (size 1, offset 8):	 RW	  Intercept reads of CR8
 *   rdcr9 (size 1, offset 9):	 RW	  Intercept reads of CR9
 *   rdcr10 (size 1, offset 10):	 RW	  Intercept reads of CR10
 *   rdcr11 (size 1, offset 11):	 RW	  Intercept reads of CR11
 *   rdcr12 (size 1, offset 12):	 RW	  Intercept reads of CR12
 *   rdcr13 (size 1, offset 13):	 RW	  Intercept reads of CR13
 *   rdcr14 (size 1, offset 14):	 RW	  Intercept reads of CR14
 *   rdcr15 (size 1, offset 15):	 RW	  Intercept reads of CR15
 *   wrcr0 (size 1, offset 16):	 RW	  Intercept writes of CR0
 *   wrcr1 (size 1, offset 17):	 RW	  Intercept writes of CR1
 *   wrcr2 (size 1, offset 18):	 RW	  Intercept writes of CR2
 *   wrcr3 (size 1, offset 19):	 RW	  Intercept writes of CR3
 *   wrcr4 (size 1, offset 20):	 RW	  Intercept writes of CR4
 *   wrcr5 (size 1, offset 21):	 RW	  Intercept writes of CR5
 *   wrcr6 (size 1, offset 22):	 RW	  Intercept writes of CR6
 *   wrcr7 (size 1, offset 23):	 RW	  Intercept writes of CR7
 *   wrcr8 (size 1, offset 24):	 RW	  Intercept writes of CR8
 *   wrcr9 (size 1, offset 25):	 RW	  Intercept writes of CR9
 *   wrcr10 (size 1, offset 26):	 RW	  Intercept writes of CR10
 *   wrcr11 (size 1, offset 27):	 RW	  Intercept writes of CR11
 *   wrcr12 (size 1, offset 28):	 RW	  Intercept writes of CR12
 *   wrcr13 (size 1, offset 29):	 RW	  Intercept writes of CR13
 *   wrcr14 (size 1, offset 30):	 RW	  Intercept writes of CR14
 *   wrcr15 (size 1, offset 31):	 RW	  Intercept writes of CR15
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct amd_vmcb_cr_access_t {
    uint8_t	rdcr0	:1;
    uint8_t	rdcr1	:1;
    uint8_t	rdcr2	:1;
    uint8_t	rdcr3	:1;
    uint8_t	rdcr4	:1;
    uint8_t	rdcr5	:1;
    uint8_t	rdcr6	:1;
    uint8_t	rdcr7	:1;
    uint8_t	rdcr8	:1;
    uint8_t	rdcr9	:1;
    uint8_t	rdcr10	:1;
    uint8_t	rdcr11	:1;
    uint8_t	rdcr12	:1;
    uint8_t	rdcr13	:1;
    uint8_t	rdcr14	:1;
    uint8_t	rdcr15	:1;
    uint8_t	wrcr0	:1;
    uint8_t	wrcr1	:1;
    uint8_t	wrcr2	:1;
    uint8_t	wrcr3	:1;
    uint8_t	wrcr4	:1;
    uint8_t	wrcr5	:1;
    uint8_t	wrcr6	:1;
    uint8_t	wrcr7	:1;
    uint8_t	wrcr8	:1;
    uint8_t	wrcr9	:1;
    uint8_t	wrcr10	:1;
    uint8_t	wrcr11	:1;
    uint8_t	wrcr12	:1;
    uint8_t	wrcr13	:1;
    uint8_t	wrcr14	:1;
    uint8_t	wrcr15	:1;
} __attribute__ ((packed))
 amd_vmcb_cr_access_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(amd_vmcb_cr_access_t, sizeof(uint32_t));

typedef union amd_vmcb_cr_access_un {
    amd_vmcb_cr_access_t	val;
    uint32_t	raw;
}
 amd_vmcb_cr_access_un;
static inline int amd_vmcb_cr_access_prtval( char * s, size_t sz, amd_vmcb_cr_access_t v ) __attribute__ ((always_inline));
static inline int amd_vmcb_cr_access_prtval( char * s, size_t sz, amd_vmcb_cr_access_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdcr0=0x%"PRIx8" (Intercept reads of CR0)\n", (uint8_t)(v.rdcr0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdcr1=0x%"PRIx8" (Intercept reads of CR1)\n", (uint8_t)(v.rdcr1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdcr2=0x%"PRIx8" (Intercept reads of CR2)\n", (uint8_t)(v.rdcr2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdcr3=0x%"PRIx8" (Intercept reads of CR3)\n", (uint8_t)(v.rdcr3));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdcr4=0x%"PRIx8" (Intercept reads of CR4)\n", (uint8_t)(v.rdcr4));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdcr5=0x%"PRIx8" (Intercept reads of CR5)\n", (uint8_t)(v.rdcr5));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdcr6=0x%"PRIx8" (Intercept reads of CR6)\n", (uint8_t)(v.rdcr6));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdcr7=0x%"PRIx8" (Intercept reads of CR7)\n", (uint8_t)(v.rdcr7));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdcr8=0x%"PRIx8" (Intercept reads of CR8)\n", (uint8_t)(v.rdcr8));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdcr9=0x%"PRIx8" (Intercept reads of CR9)\n", (uint8_t)(v.rdcr9));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdcr10=0x%"PRIx8" (Intercept reads of CR10)\n", (uint8_t)(v.rdcr10));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdcr11=0x%"PRIx8" (Intercept reads of CR11)\n", (uint8_t)(v.rdcr11));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdcr12=0x%"PRIx8" (Intercept reads of CR12)\n", (uint8_t)(v.rdcr12));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdcr13=0x%"PRIx8" (Intercept reads of CR13)\n", (uint8_t)(v.rdcr13));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdcr14=0x%"PRIx8" (Intercept reads of CR14)\n", (uint8_t)(v.rdcr14));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdcr15=0x%"PRIx8" (Intercept reads of CR15)\n", (uint8_t)(v.rdcr15));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr0=0x%"PRIx8" (Intercept writes of CR0)\n", (uint8_t)(v.wrcr0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr1=0x%"PRIx8" (Intercept writes of CR1)\n", (uint8_t)(v.wrcr1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr2=0x%"PRIx8" (Intercept writes of CR2)\n", (uint8_t)(v.wrcr2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr3=0x%"PRIx8" (Intercept writes of CR3)\n", (uint8_t)(v.wrcr3));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr4=0x%"PRIx8" (Intercept writes of CR4)\n", (uint8_t)(v.wrcr4));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr5=0x%"PRIx8" (Intercept writes of CR5)\n", (uint8_t)(v.wrcr5));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr6=0x%"PRIx8" (Intercept writes of CR6)\n", (uint8_t)(v.wrcr6));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr7=0x%"PRIx8" (Intercept writes of CR7)\n", (uint8_t)(v.wrcr7));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr8=0x%"PRIx8" (Intercept writes of CR8)\n", (uint8_t)(v.wrcr8));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr9=0x%"PRIx8" (Intercept writes of CR9)\n", (uint8_t)(v.wrcr9));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr10=0x%"PRIx8" (Intercept writes of CR10)\n", (uint8_t)(v.wrcr10));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr11=0x%"PRIx8" (Intercept writes of CR11)\n", (uint8_t)(v.wrcr11));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr12=0x%"PRIx8" (Intercept writes of CR12)\n", (uint8_t)(v.wrcr12));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr13=0x%"PRIx8" (Intercept writes of CR13)\n", (uint8_t)(v.wrcr13));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr14=0x%"PRIx8" (Intercept writes of CR14)\n", (uint8_t)(v.wrcr14));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr15=0x%"PRIx8" (Intercept writes of CR15)\n", (uint8_t)(v.wrcr15));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Intercept reads/writes to DR0-15 register
 */

/*
 * Dump of fields for register type: amd_vmcb_dr_access_t
 *   rddr0 (size 1, offset 0):	 RW	  Intercept reads of DR0
 *   rddr1 (size 1, offset 1):	 RW	  Intercept reads of DR1
 *   rddr2 (size 1, offset 2):	 RW	  Intercept reads of DR2
 *   rddr3 (size 1, offset 3):	 RW	  Intercept reads of DR3
 *   rddr4 (size 1, offset 4):	 RW	  Intercept reads of DR4
 *   rddr5 (size 1, offset 5):	 RW	  Intercept reads of DR5
 *   rddr6 (size 1, offset 6):	 RW	  Intercept reads of DR6
 *   rddr7 (size 1, offset 7):	 RW	  Intercept reads of DR7
 *   rddr8 (size 1, offset 8):	 RW	  Intercept reads of DR8
 *   rddr9 (size 1, offset 9):	 RW	  Intercept reads of DR9
 *   rddr10 (size 1, offset 10):	 RW	  Intercept reads of DR10
 *   rddr11 (size 1, offset 11):	 RW	  Intercept reads of DR11
 *   rddr12 (size 1, offset 12):	 RW	  Intercept reads of DR12
 *   rddr13 (size 1, offset 13):	 RW	  Intercept reads of DR13
 *   rddr14 (size 1, offset 14):	 RW	  Intercept reads of DR14
 *   rddr15 (size 1, offset 15):	 RW	  Intercept reads of DR15
 *   wrdr0 (size 1, offset 16):	 RW	  Intercept writes of DR0
 *   wrdr1 (size 1, offset 17):	 RW	  Intercept writes of DR1
 *   wrdr2 (size 1, offset 18):	 RW	  Intercept writes of DR2
 *   wrdr3 (size 1, offset 19):	 RW	  Intercept writes of DR3
 *   wrdr4 (size 1, offset 20):	 RW	  Intercept writes of DR4
 *   wrdr5 (size 1, offset 21):	 RW	  Intercept writes of DR5
 *   wrdr6 (size 1, offset 22):	 RW	  Intercept writes of DR6
 *   wrdr7 (size 1, offset 23):	 RW	  Intercept writes of DR7
 *   wrdr8 (size 1, offset 24):	 RW	  Intercept writes of DR8
 *   wrdr9 (size 1, offset 25):	 RW	  Intercept writes of DR9
 *   wrdr10 (size 1, offset 26):	 RW	  Intercept writes of DR10
 *   wrdr11 (size 1, offset 27):	 RW	  Intercept writes of DR11
 *   wrdr12 (size 1, offset 28):	 RW	  Intercept writes of DR12
 *   wrdr13 (size 1, offset 29):	 RW	  Intercept writes of DR13
 *   wrdr14 (size 1, offset 30):	 RW	  Intercept writes of DR14
 *   wrdr15 (size 1, offset 31):	 RW	  Intercept writes of DR15
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct amd_vmcb_dr_access_t {
    uint8_t	rddr0	:1;
    uint8_t	rddr1	:1;
    uint8_t	rddr2	:1;
    uint8_t	rddr3	:1;
    uint8_t	rddr4	:1;
    uint8_t	rddr5	:1;
    uint8_t	rddr6	:1;
    uint8_t	rddr7	:1;
    uint8_t	rddr8	:1;
    uint8_t	rddr9	:1;
    uint8_t	rddr10	:1;
    uint8_t	rddr11	:1;
    uint8_t	rddr12	:1;
    uint8_t	rddr13	:1;
    uint8_t	rddr14	:1;
    uint8_t	rddr15	:1;
    uint8_t	wrdr0	:1;
    uint8_t	wrdr1	:1;
    uint8_t	wrdr2	:1;
    uint8_t	wrdr3	:1;
    uint8_t	wrdr4	:1;
    uint8_t	wrdr5	:1;
    uint8_t	wrdr6	:1;
    uint8_t	wrdr7	:1;
    uint8_t	wrdr8	:1;
    uint8_t	wrdr9	:1;
    uint8_t	wrdr10	:1;
    uint8_t	wrdr11	:1;
    uint8_t	wrdr12	:1;
    uint8_t	wrdr13	:1;
    uint8_t	wrdr14	:1;
    uint8_t	wrdr15	:1;
} __attribute__ ((packed))
 amd_vmcb_dr_access_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(amd_vmcb_dr_access_t, sizeof(uint32_t));

typedef union amd_vmcb_dr_access_un {
    amd_vmcb_dr_access_t	val;
    uint32_t	raw;
}
 amd_vmcb_dr_access_un;
static inline int amd_vmcb_dr_access_prtval( char * s, size_t sz, amd_vmcb_dr_access_t v ) __attribute__ ((always_inline));
static inline int amd_vmcb_dr_access_prtval( char * s, size_t sz, amd_vmcb_dr_access_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rddr0=0x%"PRIx8" (Intercept reads of DR0)\n", (uint8_t)(v.rddr0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rddr1=0x%"PRIx8" (Intercept reads of DR1)\n", (uint8_t)(v.rddr1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rddr2=0x%"PRIx8" (Intercept reads of DR2)\n", (uint8_t)(v.rddr2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rddr3=0x%"PRIx8" (Intercept reads of DR3)\n", (uint8_t)(v.rddr3));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rddr4=0x%"PRIx8" (Intercept reads of DR4)\n", (uint8_t)(v.rddr4));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rddr5=0x%"PRIx8" (Intercept reads of DR5)\n", (uint8_t)(v.rddr5));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rddr6=0x%"PRIx8" (Intercept reads of DR6)\n", (uint8_t)(v.rddr6));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rddr7=0x%"PRIx8" (Intercept reads of DR7)\n", (uint8_t)(v.rddr7));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rddr8=0x%"PRIx8" (Intercept reads of DR8)\n", (uint8_t)(v.rddr8));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rddr9=0x%"PRIx8" (Intercept reads of DR9)\n", (uint8_t)(v.rddr9));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rddr10=0x%"PRIx8" (Intercept reads of DR10)\n", (uint8_t)(v.rddr10));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rddr11=0x%"PRIx8" (Intercept reads of DR11)\n", (uint8_t)(v.rddr11));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rddr12=0x%"PRIx8" (Intercept reads of DR12)\n", (uint8_t)(v.rddr12));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rddr13=0x%"PRIx8" (Intercept reads of DR13)\n", (uint8_t)(v.rddr13));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rddr14=0x%"PRIx8" (Intercept reads of DR14)\n", (uint8_t)(v.rddr14));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rddr15=0x%"PRIx8" (Intercept reads of DR15)\n", (uint8_t)(v.rddr15));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrdr0=0x%"PRIx8" (Intercept writes of DR0)\n", (uint8_t)(v.wrdr0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrdr1=0x%"PRIx8" (Intercept writes of DR1)\n", (uint8_t)(v.wrdr1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrdr2=0x%"PRIx8" (Intercept writes of DR2)\n", (uint8_t)(v.wrdr2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrdr3=0x%"PRIx8" (Intercept writes of DR3)\n", (uint8_t)(v.wrdr3));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrdr4=0x%"PRIx8" (Intercept writes of DR4)\n", (uint8_t)(v.wrdr4));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrdr5=0x%"PRIx8" (Intercept writes of DR5)\n", (uint8_t)(v.wrdr5));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrdr6=0x%"PRIx8" (Intercept writes of DR6)\n", (uint8_t)(v.wrdr6));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrdr7=0x%"PRIx8" (Intercept writes of DR7)\n", (uint8_t)(v.wrdr7));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrdr8=0x%"PRIx8" (Intercept writes of DR8)\n", (uint8_t)(v.wrdr8));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrdr9=0x%"PRIx8" (Intercept writes of DR9)\n", (uint8_t)(v.wrdr9));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrdr10=0x%"PRIx8" (Intercept writes of DR10)\n", (uint8_t)(v.wrdr10));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrdr11=0x%"PRIx8" (Intercept writes of DR11)\n", (uint8_t)(v.wrdr11));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrdr12=0x%"PRIx8" (Intercept writes of DR12)\n", (uint8_t)(v.wrdr12));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrdr13=0x%"PRIx8" (Intercept writes of DR13)\n", (uint8_t)(v.wrdr13));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrdr14=0x%"PRIx8" (Intercept writes of DR14)\n", (uint8_t)(v.wrdr14));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrdr15=0x%"PRIx8" (Intercept writes of DR15)\n", (uint8_t)(v.wrdr15));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Intercept exception vectors 0-31 register
 */

/*
 * Dump of fields for register type: amd_vmcb_exceptions_t
 *   vector0 (size 1, offset 0):	 RW	  Intercept exception vector 0
 *   vector1 (size 1, offset 1):	 RW	  Intercept exception vector 1
 *   vector2 (size 1, offset 2):	 RW	  Intercept exception vector 2
 *   vector3 (size 1, offset 3):	 RW	  Intercept exception vector 3
 *   vector4 (size 1, offset 4):	 RW	  Intercept exception vector 4
 *   vector5 (size 1, offset 5):	 RW	  Intercept exception vector 5
 *   vector6 (size 1, offset 6):	 RW	  Intercept exception vector 6
 *   vector7 (size 1, offset 7):	 RW	  Intercept exception vector 7
 *   vector8 (size 1, offset 8):	 RW	  Intercept exception vector 8
 *   vector9 (size 1, offset 9):	 RW	  Intercept exception vector 9
 *   vector10 (size 1, offset 10):	 RW	  Intercept exception vector 10
 *   vector11 (size 1, offset 11):	 RW	  Intercept exception vector 11
 *   vector12 (size 1, offset 12):	 RW	  Intercept exception vector 12
 *   vector13 (size 1, offset 13):	 RW	  Intercept exception vector 13
 *   vector14 (size 1, offset 14):	 RW	  Intercept exception vector 14
 *   vector15 (size 1, offset 15):	 RW	  Intercept exception vector 15
 *   vector16 (size 1, offset 16):	 RW	  Intercept exception vector 16
 *   vector17 (size 1, offset 17):	 RW	  Intercept exception vector 17
 *   vector18 (size 1, offset 18):	 RW	  Intercept exception vector 18
 *   vector19 (size 1, offset 19):	 RW	  Intercept exception vector 19
 *   vector20 (size 1, offset 20):	 RW	  Intercept exception vector 20
 *   vector21 (size 1, offset 21):	 RW	  Intercept exception vector 21
 *   vector22 (size 1, offset 22):	 RW	  Intercept exception vector 22
 *   vector23 (size 1, offset 23):	 RW	  Intercept exception vector 23
 *   vector24 (size 1, offset 24):	 RW	  Intercept exception vector 24
 *   vector25 (size 1, offset 25):	 RW	  Intercept exception vector 25
 *   vector26 (size 1, offset 26):	 RW	  Intercept exception vector 26
 *   vector27 (size 1, offset 27):	 RW	  Intercept exception vector 27
 *   vector28 (size 1, offset 28):	 RW	  Intercept exception vector 28
 *   vector29 (size 1, offset 29):	 RW	  Intercept exception vector 29
 *   vector30 (size 1, offset 30):	 RW	  Intercept exception vector 30
 *   vector31 (size 1, offset 31):	 RW	  Intercept exception vector 31
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct amd_vmcb_exceptions_t {
    uint8_t	vector0	:1;
    uint8_t	vector1	:1;
    uint8_t	vector2	:1;
    uint8_t	vector3	:1;
    uint8_t	vector4	:1;
    uint8_t	vector5	:1;
    uint8_t	vector6	:1;
    uint8_t	vector7	:1;
    uint8_t	vector8	:1;
    uint8_t	vector9	:1;
    uint8_t	vector10	:1;
    uint8_t	vector11	:1;
    uint8_t	vector12	:1;
    uint8_t	vector13	:1;
    uint8_t	vector14	:1;
    uint8_t	vector15	:1;
    uint8_t	vector16	:1;
    uint8_t	vector17	:1;
    uint8_t	vector18	:1;
    uint8_t	vector19	:1;
    uint8_t	vector20	:1;
    uint8_t	vector21	:1;
    uint8_t	vector22	:1;
    uint8_t	vector23	:1;
    uint8_t	vector24	:1;
    uint8_t	vector25	:1;
    uint8_t	vector26	:1;
    uint8_t	vector27	:1;
    uint8_t	vector28	:1;
    uint8_t	vector29	:1;
    uint8_t	vector30	:1;
    uint8_t	vector31	:1;
} __attribute__ ((packed))
 amd_vmcb_exceptions_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(amd_vmcb_exceptions_t, sizeof(uint32_t));

typedef union amd_vmcb_exceptions_un {
    amd_vmcb_exceptions_t	val;
    uint32_t	raw;
}
 amd_vmcb_exceptions_un;
static inline int amd_vmcb_exceptions_prtval( char * s, size_t sz, amd_vmcb_exceptions_t v ) __attribute__ ((always_inline));
static inline int amd_vmcb_exceptions_prtval( char * s, size_t sz, amd_vmcb_exceptions_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector0=0x%"PRIx8" (Intercept exception vector 0)\n", (uint8_t)(v.vector0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector1=0x%"PRIx8" (Intercept exception vector 1)\n", (uint8_t)(v.vector1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector2=0x%"PRIx8" (Intercept exception vector 2)\n", (uint8_t)(v.vector2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector3=0x%"PRIx8" (Intercept exception vector 3)\n", (uint8_t)(v.vector3));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector4=0x%"PRIx8" (Intercept exception vector 4)\n", (uint8_t)(v.vector4));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector5=0x%"PRIx8" (Intercept exception vector 5)\n", (uint8_t)(v.vector5));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector6=0x%"PRIx8" (Intercept exception vector 6)\n", (uint8_t)(v.vector6));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector7=0x%"PRIx8" (Intercept exception vector 7)\n", (uint8_t)(v.vector7));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector8=0x%"PRIx8" (Intercept exception vector 8)\n", (uint8_t)(v.vector8));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector9=0x%"PRIx8" (Intercept exception vector 9)\n", (uint8_t)(v.vector9));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector10=0x%"PRIx8" (Intercept exception vector 10)\n", (uint8_t)(v.vector10));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector11=0x%"PRIx8" (Intercept exception vector 11)\n", (uint8_t)(v.vector11));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector12=0x%"PRIx8" (Intercept exception vector 12)\n", (uint8_t)(v.vector12));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector13=0x%"PRIx8" (Intercept exception vector 13)\n", (uint8_t)(v.vector13));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector14=0x%"PRIx8" (Intercept exception vector 14)\n", (uint8_t)(v.vector14));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector15=0x%"PRIx8" (Intercept exception vector 15)\n", (uint8_t)(v.vector15));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector16=0x%"PRIx8" (Intercept exception vector 16)\n", (uint8_t)(v.vector16));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector17=0x%"PRIx8" (Intercept exception vector 17)\n", (uint8_t)(v.vector17));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector18=0x%"PRIx8" (Intercept exception vector 18)\n", (uint8_t)(v.vector18));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector19=0x%"PRIx8" (Intercept exception vector 19)\n", (uint8_t)(v.vector19));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector20=0x%"PRIx8" (Intercept exception vector 20)\n", (uint8_t)(v.vector20));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector21=0x%"PRIx8" (Intercept exception vector 21)\n", (uint8_t)(v.vector21));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector22=0x%"PRIx8" (Intercept exception vector 22)\n", (uint8_t)(v.vector22));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector23=0x%"PRIx8" (Intercept exception vector 23)\n", (uint8_t)(v.vector23));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector24=0x%"PRIx8" (Intercept exception vector 24)\n", (uint8_t)(v.vector24));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector25=0x%"PRIx8" (Intercept exception vector 25)\n", (uint8_t)(v.vector25));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector26=0x%"PRIx8" (Intercept exception vector 26)\n", (uint8_t)(v.vector26));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector27=0x%"PRIx8" (Intercept exception vector 27)\n", (uint8_t)(v.vector27));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector28=0x%"PRIx8" (Intercept exception vector 28)\n", (uint8_t)(v.vector28));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector29=0x%"PRIx8" (Intercept exception vector 29)\n", (uint8_t)(v.vector29));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector30=0x%"PRIx8" (Intercept exception vector 30)\n", (uint8_t)(v.vector30));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector31=0x%"PRIx8" (Intercept exception vector 31)\n", (uint8_t)(v.vector31));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Various intercepts register
 */

/*
 * Dump of fields for register type: amd_vmcb_intercepts_t
 *   intr (size 1, offset 0):	 RW	  Intercept INTR instruction
 *   nmi (size 1, offset 1):	 RW	  Intercept NMI instruction
 *   smi (size 1, offset 2):	 RW	  Intercept SMI instruction
 *   init (size 1, offset 3):	 RW	  Intercept INIT instruction
 *   vintr (size 1, offset 4):	 RW	  Intercept VINTR instruction
 *   wrcr0 (size 1, offset 5):	 RW	  Intercept CR0 writes that change bits other than TS or MP
 *   rdidtr (size 1, offset 6):	 RW	  Intercept reads of IDTR
 *   rdgdtr (size 1, offset 7):	 RW	  Intercept reads of GDTR
 *   rdldtr (size 1, offset 8):	 RW	  Intercept reads of LDTR
 *   rdtr (size 1, offset 9):	 RW	  Intercept reads of TR
 *   wridtr (size 1, offset 10):	 RW	  Intercept writes of IDRT
 *   wrgdtr (size 1, offset 11):	 RW	  Intercept writes of GDTR
 *   wrldtr (size 1, offset 12):	 RW	  Intercept writes of LDTR
 *   wrtr (size 1, offset 13):	 RW	  Intercept writes of TR
 *   rdtsc (size 1, offset 14):	 RW	  Intercept RDTSC instruction
 *   rdpmc (size 1, offset 15):	 RW	  Intercept RDPMC instruction
 *   pushf (size 1, offset 16):	 RW	  Intercept PUSHF instruction
 *   popf (size 1, offset 17):	 RW	  Intercept POPF instruction
 *   cpuid (size 1, offset 18):	 RW	  Intercept CPUID instruction
 *   rsm (size 1, offset 19):	 RW	  Intercept RSM instruction
 *   iret (size 1, offset 20):	 RW	  Intercept IRET instruction
 *   intn (size 1, offset 21):	 RW	  Intercept INTn instruction
 *   invd (size 1, offset 22):	 RW	  Intercept INVD instruction
 *   pause (size 1, offset 23):	 RW	  Intercept PAUSE instruction
 *   hlt (size 1, offset 24):	 RW	  Intercept HLT instruction
 *   invlpg (size 1, offset 25):	 RW	  Intercept INVLPG instruction
 *   invlpga (size 1, offset 26):	 RW	  Intercept INVLPGA instruction
 *   ioio_prot (size 1, offset 27):	 RW	  Intercept IN/OUT accesses to selected ports
 *   msr_prot (size 1, offset 28):	 RW	  Intercept RDMSR or WRMSR accesses to selected MSRs
 *   task_switch (size 1, offset 29):	 RW	  Intercept task switches
 *   ferr_freeze (size 1, offset 30):	 RW	  Intercept processor freezing durich legacy FERR handling
 *   shutdown (size 1, offset 31):	 RW	  Intercept shutdown events
 *   vmrun (size 1, offset 32):	 RW	  Intercept VMRUN instruction
 *   vmmcall (size 1, offset 33):	 RW	  Intercept VMMCALL instruction
 *   vmload (size 1, offset 34):	 RW	  Intercept VMLOAD instruction
 *   vmsave (size 1, offset 35):	 RW	  Intercept VMSAVE instruction
 *   stgi (size 1, offset 36):	 RW	  Intercept STGI instruction
 *   clgi (size 1, offset 37):	 RW	  Intercept CLGI instruction
 *   skinit (size 1, offset 38):	 RW	  Intercept SKINIT instruction
 *   rdtscp (size 1, offset 39):	 RW	  Intercept RDTSCP instruction
 *   icebp (size 1, offset 40):	 RW	  Intercept ICEBP instruction
 *   wbinvd (size 1, offset 41):	 RW	  Intercept WBINVD instruction
 *   monitor (size 1, offset 42):	 RW	  Intercept MONITOR instruction
 *   mwait0 (size 1, offset 43):	 RW	  Intercept MWAIT instruction unconditionally
 *   mwait1 (size 1, offset 44):	 RW	  Intercept MWAIT instruction if monitor hardware is armed
 *   _anon45 (size 19, offset 45):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct amd_vmcb_intercepts_t {
    uint8_t	intr	:1;
    uint8_t	nmi	:1;
    uint8_t	smi	:1;
    uint8_t	init	:1;
    uint8_t	vintr	:1;
    uint8_t	wrcr0	:1;
    uint8_t	rdidtr	:1;
    uint8_t	rdgdtr	:1;
    uint8_t	rdldtr	:1;
    uint8_t	rdtr	:1;
    uint8_t	wridtr	:1;
    uint8_t	wrgdtr	:1;
    uint8_t	wrldtr	:1;
    uint8_t	wrtr	:1;
    uint8_t	rdtsc	:1;
    uint8_t	rdpmc	:1;
    uint8_t	pushf	:1;
    uint8_t	popf	:1;
    uint8_t	cpuid	:1;
    uint8_t	rsm	:1;
    uint8_t	iret	:1;
    uint8_t	intn	:1;
    uint8_t	invd	:1;
    uint8_t	pause	:1;
    uint8_t	hlt	:1;
    uint8_t	invlpg	:1;
    uint8_t	invlpga	:1;
    uint8_t	ioio_prot	:1;
    uint8_t	msr_prot	:1;
    uint8_t	task_switch	:1;
    uint8_t	ferr_freeze	:1;
    uint8_t	shutdown	:1;
    uint8_t	vmrun	:1;
    uint8_t	vmmcall	:1;
    uint8_t	vmload	:1;
    uint8_t	vmsave	:1;
    uint8_t	stgi	:1;
    uint8_t	clgi	:1;
    uint8_t	skinit	:1;
    uint8_t	rdtscp	:1;
    uint8_t	icebp	:1;
    uint8_t	wbinvd	:1;
    uint8_t	monitor	:1;
    uint8_t	mwait0	:1;
    uint8_t	mwait1	:1;
    uint32_t	_anon45	:19;
} __attribute__ ((packed))
 amd_vmcb_intercepts_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(amd_vmcb_intercepts_t, sizeof(uint64_t));

typedef union amd_vmcb_intercepts_un {
    amd_vmcb_intercepts_t	val;
    uint64_t	raw;
}
 amd_vmcb_intercepts_un;
static inline int amd_vmcb_intercepts_prtval( char * s, size_t sz, amd_vmcb_intercepts_t v ) __attribute__ ((always_inline));
static inline int amd_vmcb_intercepts_prtval( char * s, size_t sz, amd_vmcb_intercepts_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " intr=0x%"PRIx8" (Intercept INTR instruction)\n", (uint8_t)(v.intr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " nmi=0x%"PRIx8" (Intercept NMI instruction)\n", (uint8_t)(v.nmi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " smi=0x%"PRIx8" (Intercept SMI instruction)\n", (uint8_t)(v.smi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " init=0x%"PRIx8" (Intercept INIT instruction)\n", (uint8_t)(v.init));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vintr=0x%"PRIx8" (Intercept VINTR instruction)\n", (uint8_t)(v.vintr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrcr0=0x%"PRIx8" (Intercept CR0 writes that change bits other than TS or MP)\n", (uint8_t)(v.wrcr0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdidtr=0x%"PRIx8" (Intercept reads of IDTR)\n", (uint8_t)(v.rdidtr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdgdtr=0x%"PRIx8" (Intercept reads of GDTR)\n", (uint8_t)(v.rdgdtr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdldtr=0x%"PRIx8" (Intercept reads of LDTR)\n", (uint8_t)(v.rdldtr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdtr=0x%"PRIx8" (Intercept reads of TR)\n", (uint8_t)(v.rdtr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wridtr=0x%"PRIx8" (Intercept writes of IDRT)\n", (uint8_t)(v.wridtr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrgdtr=0x%"PRIx8" (Intercept writes of GDTR)\n", (uint8_t)(v.wrgdtr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrldtr=0x%"PRIx8" (Intercept writes of LDTR)\n", (uint8_t)(v.wrldtr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wrtr=0x%"PRIx8" (Intercept writes of TR)\n", (uint8_t)(v.wrtr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdtsc=0x%"PRIx8" (Intercept RDTSC instruction)\n", (uint8_t)(v.rdtsc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdpmc=0x%"PRIx8" (Intercept RDPMC instruction)\n", (uint8_t)(v.rdpmc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pushf=0x%"PRIx8" (Intercept PUSHF instruction)\n", (uint8_t)(v.pushf));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " popf=0x%"PRIx8" (Intercept POPF instruction)\n", (uint8_t)(v.popf));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cpuid=0x%"PRIx8" (Intercept CPUID instruction)\n", (uint8_t)(v.cpuid));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rsm=0x%"PRIx8" (Intercept RSM instruction)\n", (uint8_t)(v.rsm));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " iret=0x%"PRIx8" (Intercept IRET instruction)\n", (uint8_t)(v.iret));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " intn=0x%"PRIx8" (Intercept INTn instruction)\n", (uint8_t)(v.intn));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " invd=0x%"PRIx8" (Intercept INVD instruction)\n", (uint8_t)(v.invd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pause=0x%"PRIx8" (Intercept PAUSE instruction)\n", (uint8_t)(v.pause));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " hlt=0x%"PRIx8" (Intercept HLT instruction)\n", (uint8_t)(v.hlt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " invlpg=0x%"PRIx8" (Intercept INVLPG instruction)\n", (uint8_t)(v.invlpg));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " invlpga=0x%"PRIx8" (Intercept INVLPGA instruction)\n", (uint8_t)(v.invlpga));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ioio_prot=0x%"PRIx8" (Intercept IN/OUT accesses to selected ports)\n", (uint8_t)(v.ioio_prot));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " msr_prot=0x%"PRIx8" (Intercept RDMSR or WRMSR accesses to selected MSRs)\n", (uint8_t)(v.msr_prot));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " task_switch=0x%"PRIx8" (Intercept task switches)\n", (uint8_t)(v.task_switch));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ferr_freeze=0x%"PRIx8" (Intercept processor freezing durich legacy FERR handling)\n", (uint8_t)(v.ferr_freeze));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " shutdown=0x%"PRIx8" (Intercept shutdown events)\n", (uint8_t)(v.shutdown));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vmrun=0x%"PRIx8" (Intercept VMRUN instruction)\n", (uint8_t)(v.vmrun));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vmmcall=0x%"PRIx8" (Intercept VMMCALL instruction)\n", (uint8_t)(v.vmmcall));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vmload=0x%"PRIx8" (Intercept VMLOAD instruction)\n", (uint8_t)(v.vmload));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vmsave=0x%"PRIx8" (Intercept VMSAVE instruction)\n", (uint8_t)(v.vmsave));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " stgi=0x%"PRIx8" (Intercept STGI instruction)\n", (uint8_t)(v.stgi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " clgi=0x%"PRIx8" (Intercept CLGI instruction)\n", (uint8_t)(v.clgi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " skinit=0x%"PRIx8" (Intercept SKINIT instruction)\n", (uint8_t)(v.skinit));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdtscp=0x%"PRIx8" (Intercept RDTSCP instruction)\n", (uint8_t)(v.rdtscp));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " icebp=0x%"PRIx8" (Intercept ICEBP instruction)\n", (uint8_t)(v.icebp));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wbinvd=0x%"PRIx8" (Intercept WBINVD instruction)\n", (uint8_t)(v.wbinvd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " monitor=0x%"PRIx8" (Intercept MONITOR instruction)\n", (uint8_t)(v.monitor));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mwait0=0x%"PRIx8" (Intercept MWAIT instruction unconditionally)\n", (uint8_t)(v.mwait0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mwait1=0x%"PRIx8" (Intercept MWAIT instruction if monitor hardware is armed)\n", (uint8_t)(v.mwait1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Guest TLB settings register
 */

/*
 * Dump of fields for register type: amd_vmcb_tlb_t
 *   guest_asid (size 32, offset 0):	 RW	  Guest ASID
 *   control (size 8, offset 32):	 RW	  TLB control values
 *   _anon40 (size 24, offset 40):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct amd_vmcb_tlb_t {
    uint32_t	guest_asid	:32;
    uint8_t	control	:8;
    uint32_t	_anon40	:24;
} __attribute__ ((packed))
 amd_vmcb_tlb_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(amd_vmcb_tlb_t, sizeof(uint64_t));

typedef union amd_vmcb_tlb_un {
    amd_vmcb_tlb_t	val;
    uint64_t	raw;
}
 amd_vmcb_tlb_un;
static inline int amd_vmcb_tlb_prtval( char * s, size_t sz, amd_vmcb_tlb_t v ) __attribute__ ((always_inline));
static inline int amd_vmcb_tlb_prtval( char * s, size_t sz, amd_vmcb_tlb_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " guest_asid=0x%0"PRIx32" (Guest ASID)\n", (uint32_t)(v.guest_asid));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " control=0x%"PRIx8" (TLB control values)\n", (uint8_t)(v.control));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Virtual interrupt settings register
 */

/*
 * Dump of fields for register type: amd_vmcb_vintr_t
 *   vtpr (size 8, offset 0):	 RW	  Virtual TPR for the guest
 *   virq (size 1, offset 8):	 RW	  Virtual interrupt pernding
 *   _anon9 (size 7, offset 9):	 RSVD	  _
 *   vintr_prio (size 4, offset 16):	 RW	  Priority for virtual interrupt
 *   v_ign_tpr (size 1, offset 20):	 RW	  Virtual interrupt ignores the virtual TPR
 *   _anon21 (size 3, offset 21):	 RSVD	  _
 *   vintr_masking (size 1, offset 24):	 RW	  Virtualize masking of INTR interrupt
 *   _anon25 (size 7, offset 25):	 RSVD	  _
 *   vintr_vector (size 8, offset 32):	 RW	  Vector to use for this interrupt
 *   _anon40 (size 24, offset 40):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct amd_vmcb_vintr_t {
    uint8_t	vtpr	:8;
    uint8_t	virq	:1;
    uint8_t	_anon9	:7;
    uint8_t	vintr_prio	:4;
    uint8_t	v_ign_tpr	:1;
    uint8_t	_anon21	:3;
    uint8_t	vintr_masking	:1;
    uint8_t	_anon25	:7;
    uint8_t	vintr_vector	:8;
    uint32_t	_anon40	:24;
} __attribute__ ((packed))
 amd_vmcb_vintr_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(amd_vmcb_vintr_t, sizeof(uint64_t));

typedef union amd_vmcb_vintr_un {
    amd_vmcb_vintr_t	val;
    uint64_t	raw;
}
 amd_vmcb_vintr_un;
static inline int amd_vmcb_vintr_prtval( char * s, size_t sz, amd_vmcb_vintr_t v ) __attribute__ ((always_inline));
static inline int amd_vmcb_vintr_prtval( char * s, size_t sz, amd_vmcb_vintr_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vtpr=0x%"PRIx8" (Virtual TPR for the guest)\n", (uint8_t)(v.vtpr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " virq=0x%"PRIx8" (Virtual interrupt pernding)\n", (uint8_t)(v.virq));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vintr_prio=0x%"PRIx8" (Priority for virtual interrupt)\n", (uint8_t)(v.vintr_prio));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " v_ign_tpr=0x%"PRIx8" (Virtual interrupt ignores the virtual TPR)\n", (uint8_t)(v.v_ign_tpr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vintr_masking=0x%"PRIx8" (Virtualize masking of INTR interrupt)\n", (uint8_t)(v.vintr_masking));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vintr_vector=0x%"PRIx8" (Vector to use for this interrupt)\n", (uint8_t)(v.vintr_vector));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Guest interrupt settings register
 */

/*
 * Dump of fields for register type: amd_vmcb_intr_t
 *   interrupt_shadow (size 1, offset 0):	 RW	  Guest is in an interrupt shadow
 *   _anon1 (size 63, offset 1):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct amd_vmcb_intr_t {
    uint8_t	interrupt_shadow	:1;
    uint64_t	_anon1	:63;
} __attribute__ ((packed))
 amd_vmcb_intr_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(amd_vmcb_intr_t, sizeof(uint64_t));

typedef union amd_vmcb_intr_un {
    amd_vmcb_intr_t	val;
    uint64_t	raw;
}
 amd_vmcb_intr_un;
static inline int amd_vmcb_intr_prtval( char * s, size_t sz, amd_vmcb_intr_t v ) __attribute__ ((always_inline));
static inline int amd_vmcb_intr_prtval( char * s, size_t sz, amd_vmcb_intr_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " interrupt_shadow=0x%"PRIx8" (Guest is in an interrupt shadow)\n", (uint8_t)(v.interrupt_shadow));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Nested paging settings register
 */

/*
 * Dump of fields for register type: amd_vmcb_np_t
 *   enable (size 1, offset 0):	 RW	  Enable nested paging
 *   _anon1 (size 63, offset 1):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct amd_vmcb_np_t {
    uint8_t	enable	:1;
    uint64_t	_anon1	:63;
} __attribute__ ((packed))
 amd_vmcb_np_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(amd_vmcb_np_t, sizeof(uint64_t));

typedef union amd_vmcb_np_un {
    amd_vmcb_np_t	val;
    uint64_t	raw;
}
 amd_vmcb_np_un;
static inline int amd_vmcb_np_prtval( char * s, size_t sz, amd_vmcb_np_t v ) __attribute__ ((always_inline));
static inline int amd_vmcb_np_prtval( char * s, size_t sz, amd_vmcb_np_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " enable=0x%"PRIx8" (Enable nested paging)\n", (uint8_t)(v.enable));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Guest LBR settings register
 */

/*
 * Dump of fields for register type: amd_vmcb_lbr_t
 *   lbr_virtualization_enable (size 1, offset 0):	 RW	  Enable LBR virtualization
 *   _anon1 (size 63, offset 1):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct amd_vmcb_lbr_t {
    uint8_t	lbr_virtualization_enable	:1;
    uint64_t	_anon1	:63;
} __attribute__ ((packed))
 amd_vmcb_lbr_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(amd_vmcb_lbr_t, sizeof(uint64_t));

typedef union amd_vmcb_lbr_un {
    amd_vmcb_lbr_t	val;
    uint64_t	raw;
}
 amd_vmcb_lbr_un;
static inline int amd_vmcb_lbr_prtval( char * s, size_t sz, amd_vmcb_lbr_t v ) __attribute__ ((always_inline));
static inline int amd_vmcb_lbr_prtval( char * s, size_t sz, amd_vmcb_lbr_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lbr_virtualization_enable=0x%"PRIx8" (Enable LBR virtualization)\n", (uint8_t)(v.lbr_virtualization_enable));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Segment attributes
 */

/*
 * Dump of fields for register type: amd_vmcb_seg_attrib_t
 *   segtype (size 4, offset 0):	 NOATTR	  Segment type
 *   s (size 1, offset 4):	 NOATTR	  Segment descriptor type
 *   dpl (size 2, offset 5):	 NOATTR	  Descriptor privilege level
 *   p (size 1, offset 7):	 NOATTR	  Segment present
 *   avl (size 1, offset 8):	 NOATTR	  Available for use by system software
 *   l (size 1, offset 9):	 NOATTR	  64-bit code segment
 *   db (size 1, offset 10):	 NOATTR	  Default operation size (0: 16-bit, 1: 32-bit segment)
 *   g (size 1, offset 11):	 NOATTR	  Granularity
 *   _anon12 (size 4, offset 12):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct amd_vmcb_seg_attrib_t {
    uint8_t	segtype	:4;
    uint8_t	s	:1;
    uint8_t	dpl	:2;
    uint8_t	p	:1;
    uint8_t	avl	:1;
    uint8_t	l	:1;
    uint8_t	db	:1;
    uint8_t	g	:1;
    uint8_t	_anon12	:4;
} __attribute__ ((packed))
 amd_vmcb_seg_attrib_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(amd_vmcb_seg_attrib_t, sizeof(uint16_t));

typedef union amd_vmcb_seg_attrib_un {
    amd_vmcb_seg_attrib_t	val;
    uint16_t	raw;
}
 amd_vmcb_seg_attrib_un;
static inline int amd_vmcb_seg_attrib_prtval( char * s, size_t sz, amd_vmcb_seg_attrib_t v ) __attribute__ ((always_inline));
static inline int amd_vmcb_seg_attrib_prtval( char * s, size_t sz, amd_vmcb_seg_attrib_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " segtype=0x%"PRIx8" (Segment type)\n", (uint8_t)(v.segtype));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " s=0x%"PRIx8" (Segment descriptor type)\n", (uint8_t)(v.s));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dpl=0x%"PRIx8" (Descriptor privilege level)\n", (uint8_t)(v.dpl));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " p=0x%"PRIx8" (Segment present)\n", (uint8_t)(v.p));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " avl=0x%"PRIx8" (Available for use by system software)\n", (uint8_t)(v.avl));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " l=0x%"PRIx8" (64-bit code segment)\n", (uint8_t)(v.l));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " db=0x%"PRIx8" (Default operation size (0: 16-bit, 1: 32-bit segment))\n", (uint8_t)(v.db));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " g=0x%"PRIx8" (Granularity)\n", (uint8_t)(v.g));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Guest EFER register
 */

/*
 * Dump of fields for register type: amd_vmcb_efer_t
 *   sce (size 1, offset 0):	 RW	  System Call Extensions
 *   _anon1 (size 7, offset 1):	 MBZ	  _
 *   lme (size 1, offset 8):	 RW	  Long Mode Enable
 *   _anon9 (size 1, offset 9):	 MBZ	  _
 *   lma (size 1, offset 10):	 RW	  Long Mode Active
 *   nxe (size 1, offset 11):	 RW	  No-Execute Enable
 *   svme (size 1, offset 12):	 RW	  Secure Virtual Machine Enable
 *   _anon13 (size 1, offset 13):	 MBZ	  _
 *   ffxsr (size 1, offset 14):	 RW	  Fast FXSAVE/FXRSTOR
 *   _anon15 (size 49, offset 15):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct amd_vmcb_efer_t {
    uint8_t	sce	:1;
    uint8_t	_anon1	:7;
    uint8_t	lme	:1;
    uint8_t	_anon9	:1;
    uint8_t	lma	:1;
    uint8_t	nxe	:1;
    uint8_t	svme	:1;
    uint8_t	_anon13	:1;
    uint8_t	ffxsr	:1;
    uint64_t	_anon15	:49;
} __attribute__ ((packed))
 amd_vmcb_efer_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(amd_vmcb_efer_t, sizeof(uint64_t));

typedef union amd_vmcb_efer_un {
    amd_vmcb_efer_t	val;
    uint64_t	raw;
}
 amd_vmcb_efer_un;
static inline int amd_vmcb_efer_prtval( char * s, size_t sz, amd_vmcb_efer_t v ) __attribute__ ((always_inline));
static inline int amd_vmcb_efer_prtval( char * s, size_t sz, amd_vmcb_efer_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sce=0x%"PRIx8" (System Call Extensions)\n", (uint8_t)(v.sce));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lme=0x%"PRIx8" (Long Mode Enable)\n", (uint8_t)(v.lme));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lma=0x%"PRIx8" (Long Mode Active)\n", (uint8_t)(v.lma));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " nxe=0x%"PRIx8" (No-Execute Enable)\n", (uint8_t)(v.nxe));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " svme=0x%"PRIx8" (Secure Virtual Machine Enable)\n", (uint8_t)(v.svme));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ffxsr=0x%"PRIx8" (Fast FXSAVE/FXRSTOR)\n", (uint8_t)(v.ffxsr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Guest CR4 register
 */

/*
 * Dump of fields for register type: amd_vmcb_cr4_t
 *   vme (size 1, offset 0):	 RW	  Virtual-8086 Mode Extensions
 *   pvi (size 1, offset 1):	 RW	  Protected-Mode Virtual Interrupts
 *   tsd (size 1, offset 2):	 RW	  Time Stamp Disable
 *   de (size 1, offset 3):	 RW	  Debugging Extensions
 *   pse (size 1, offset 4):	 RW	  Page Size Extensions
 *   pae (size 1, offset 5):	 RW	  Physical-Address Extension
 *   mce (size 1, offset 6):	 RW	  Machine Check Enable
 *   pge (size 1, offset 7):	 RW	  Page-Global Enable
 *   pce (size 1, offset 8):	 RW	  Performance-Monitoring Counter Enable
 *   osfxsr (size 1, offset 9):	 RW	  Operating System FXSAVE/FXRSTOR Support
 *   osxmmecept (size 1, offset 10):	 RW	  Operating System Unmasked Exception Support
 *   _anon11 (size 53, offset 11):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct amd_vmcb_cr4_t {
    uint8_t	vme	:1;
    uint8_t	pvi	:1;
    uint8_t	tsd	:1;
    uint8_t	de	:1;
    uint8_t	pse	:1;
    uint8_t	pae	:1;
    uint8_t	mce	:1;
    uint8_t	pge	:1;
    uint8_t	pce	:1;
    uint8_t	osfxsr	:1;
    uint8_t	osxmmecept	:1;
    uint64_t	_anon11	:53;
} __attribute__ ((packed))
 amd_vmcb_cr4_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(amd_vmcb_cr4_t, sizeof(uint64_t));

typedef union amd_vmcb_cr4_un {
    amd_vmcb_cr4_t	val;
    uint64_t	raw;
}
 amd_vmcb_cr4_un;
static inline int amd_vmcb_cr4_prtval( char * s, size_t sz, amd_vmcb_cr4_t v ) __attribute__ ((always_inline));
static inline int amd_vmcb_cr4_prtval( char * s, size_t sz, amd_vmcb_cr4_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vme=0x%"PRIx8" (Virtual-8086 Mode Extensions)\n", (uint8_t)(v.vme));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pvi=0x%"PRIx8" (Protected-Mode Virtual Interrupts)\n", (uint8_t)(v.pvi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tsd=0x%"PRIx8" (Time Stamp Disable)\n", (uint8_t)(v.tsd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " de=0x%"PRIx8" (Debugging Extensions)\n", (uint8_t)(v.de));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pse=0x%"PRIx8" (Page Size Extensions)\n", (uint8_t)(v.pse));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pae=0x%"PRIx8" (Physical-Address Extension)\n", (uint8_t)(v.pae));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mce=0x%"PRIx8" (Machine Check Enable)\n", (uint8_t)(v.mce));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pge=0x%"PRIx8" (Page-Global Enable)\n", (uint8_t)(v.pge));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pce=0x%"PRIx8" (Performance-Monitoring Counter Enable)\n", (uint8_t)(v.pce));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " osfxsr=0x%"PRIx8" (Operating System FXSAVE/FXRSTOR Support)\n", (uint8_t)(v.osfxsr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " osxmmecept=0x%"PRIx8" (Operating System Unmasked Exception Support)\n", (uint8_t)(v.osxmmecept));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Guest CR0 register
 */

/*
 * Dump of fields for register type: amd_vmcb_cr0_t
 *   pe (size 1, offset 0):	 RW	  Protection Enabled
 *   mp (size 1, offset 1):	 RW	  Monitor Coprocessor
 *   em (size 1, offset 2):	 RW	  Emulation
 *   ts (size 1, offset 3):	 RW	  Task Switched
 *   et (size 1, offset 4):	 RO	  Extension Type
 *   ne (size 1, offset 5):	 RW	  Numeric Error
 *   _anon6 (size 10, offset 6):	 RSVD	  _
 *   wp (size 1, offset 16):	 RW	  Write Protect
 *   _anon17 (size 1, offset 17):	 RSVD	  _
 *   am (size 1, offset 18):	 RW	  Alignment Mask
 *   _anon19 (size 10, offset 19):	 RSVD	  _
 *   nw (size 1, offset 29):	 RW	  Not Writethrough
 *   cd (size 1, offset 30):	 RW	  Cache Disable
 *   pg (size 1, offset 31):	 RW	  Paging
 *   _anon32 (size 32, offset 32):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct amd_vmcb_cr0_t {
    uint8_t	pe	:1;
    uint8_t	mp	:1;
    uint8_t	em	:1;
    uint8_t	ts	:1;
    uint8_t	et	:1;
    uint8_t	ne	:1;
    uint16_t	_anon6	:10;
    uint8_t	wp	:1;
    uint8_t	_anon17	:1;
    uint8_t	am	:1;
    uint16_t	_anon19	:10;
    uint8_t	nw	:1;
    uint8_t	cd	:1;
    uint8_t	pg	:1;
    uint32_t	_anon32	:32;
} __attribute__ ((packed))
 amd_vmcb_cr0_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(amd_vmcb_cr0_t, sizeof(uint64_t));

typedef union amd_vmcb_cr0_un {
    amd_vmcb_cr0_t	val;
    uint64_t	raw;
}
 amd_vmcb_cr0_un;
static inline int amd_vmcb_cr0_prtval( char * s, size_t sz, amd_vmcb_cr0_t v ) __attribute__ ((always_inline));
static inline int amd_vmcb_cr0_prtval( char * s, size_t sz, amd_vmcb_cr0_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pe=0x%"PRIx8" (Protection Enabled)\n", (uint8_t)(v.pe));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mp=0x%"PRIx8" (Monitor Coprocessor)\n", (uint8_t)(v.mp));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " em=0x%"PRIx8" (Emulation)\n", (uint8_t)(v.em));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ts=0x%"PRIx8" (Task Switched)\n", (uint8_t)(v.ts));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " et=0x%"PRIx8" (Extension Type)\n", (uint8_t)(v.et));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ne=0x%"PRIx8" (Numeric Error)\n", (uint8_t)(v.ne));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wp=0x%"PRIx8" (Write Protect)\n", (uint8_t)(v.wp));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " am=0x%"PRIx8" (Alignment Mask)\n", (uint8_t)(v.am));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " nw=0x%"PRIx8" (Not Writethrough)\n", (uint8_t)(v.nw));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cd=0x%"PRIx8" (Cache Disable)\n", (uint8_t)(v.cd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pg=0x%"PRIx8" (Paging)\n", (uint8_t)(v.pg));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Guest RFLAGS register
 */

/*
 * Dump of fields for register type: amd_vmcb_rflags_t
 *   cf (size 1, offset 0):	 RW	  Carry Flag
 *   _anon1 (size 1, offset 1):	 RSVD	  _
 *   pf (size 1, offset 2):	 RW	  Parity Flag
 *   _anon3 (size 1, offset 3):	 RSVD	  _
 *   af (size 1, offset 4):	 RW	  Auxiliary Flag
 *   _anon5 (size 1, offset 5):	 RSVD	  _
 *   zf (size 1, offset 6):	 RW	  Zero Flag
 *   sf (size 1, offset 7):	 RW	  Sign Flag
 *   tf (size 1, offset 8):	 RW	  Trap Flag
 *   intrf (size 1, offset 9):	 RW	  Interrupt Flag
 *   df (size 1, offset 10):	 RW	  Direction Flag
 *   of (size 1, offset 11):	 RW	  Overflow Flag
 *   iopl (size 2, offset 12):	 RW	  I/O Privilege Level
 *   nt (size 1, offset 14):	 RW	  Nested Task
 *   _anon15 (size 1, offset 15):	 RSVD	  _
 *   rf (size 1, offset 16):	 RW	  Resume Flag
 *   vm (size 1, offset 17):	 RW	  Virtual-8086 Mode
 *   ac (size 1, offset 18):	 RW	  Alignment Check
 *   vif (size 1, offset 19):	 RW	  Virtual Interrupt Flag
 *   vip (size 1, offset 20):	 RW	  Virtual Interrupt Pending
 *   id (size 1, offset 21):	 RW	  ID Flag
 *   _anon22 (size 42, offset 22):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct amd_vmcb_rflags_t {
    uint8_t	cf	:1;
    uint8_t	_anon1	:1;
    uint8_t	pf	:1;
    uint8_t	_anon3	:1;
    uint8_t	af	:1;
    uint8_t	_anon5	:1;
    uint8_t	zf	:1;
    uint8_t	sf	:1;
    uint8_t	tf	:1;
    uint8_t	intrf	:1;
    uint8_t	df	:1;
    uint8_t	of	:1;
    uint8_t	iopl	:2;
    uint8_t	nt	:1;
    uint8_t	_anon15	:1;
    uint8_t	rf	:1;
    uint8_t	vm	:1;
    uint8_t	ac	:1;
    uint8_t	vif	:1;
    uint8_t	vip	:1;
    uint8_t	id	:1;
    uint64_t	_anon22	:42;
} __attribute__ ((packed))
 amd_vmcb_rflags_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(amd_vmcb_rflags_t, sizeof(uint64_t));

typedef union amd_vmcb_rflags_un {
    amd_vmcb_rflags_t	val;
    uint64_t	raw;
}
 amd_vmcb_rflags_un;
static inline int amd_vmcb_rflags_prtval( char * s, size_t sz, amd_vmcb_rflags_t v ) __attribute__ ((always_inline));
static inline int amd_vmcb_rflags_prtval( char * s, size_t sz, amd_vmcb_rflags_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cf=0x%"PRIx8" (Carry Flag)\n", (uint8_t)(v.cf));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pf=0x%"PRIx8" (Parity Flag)\n", (uint8_t)(v.pf));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " af=0x%"PRIx8" (Auxiliary Flag)\n", (uint8_t)(v.af));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " zf=0x%"PRIx8" (Zero Flag)\n", (uint8_t)(v.zf));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sf=0x%"PRIx8" (Sign Flag)\n", (uint8_t)(v.sf));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tf=0x%"PRIx8" (Trap Flag)\n", (uint8_t)(v.tf));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " intrf=0x%"PRIx8" (Interrupt Flag)\n", (uint8_t)(v.intrf));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " df=0x%"PRIx8" (Direction Flag)\n", (uint8_t)(v.df));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " of=0x%"PRIx8" (Overflow Flag)\n", (uint8_t)(v.of));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " iopl=0x%"PRIx8" (I/O Privilege Level)\n", (uint8_t)(v.iopl));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " nt=0x%"PRIx8" (Nested Task)\n", (uint8_t)(v.nt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rf=0x%"PRIx8" (Resume Flag)\n", (uint8_t)(v.rf));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vm=0x%"PRIx8" (Virtual-8086 Mode)\n", (uint8_t)(v.vm));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ac=0x%"PRIx8" (Alignment Check)\n", (uint8_t)(v.ac));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vif=0x%"PRIx8" (Virtual Interrupt Flag)\n", (uint8_t)(v.vif));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vip=0x%"PRIx8" (Virtual Interrupt Pending)\n", (uint8_t)(v.vip));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " id=0x%"PRIx8" (ID Flag)\n", (uint8_t)(v.id));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Device representation structure
 */
typedef struct __DN(t) {
    // Device arguments
    mackerel_addr_t	base;
    // Shadow registers
}
 __DN(t);

/*
 * Device Initialization function
 */
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_addr_t base ) __attribute__ ((always_inline));
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_addr_t base )
{
    /* Setting up device arguments*/
    _dev->base = base;
    /* Setting up shadow registers*/
}

// No user-defined spaces

/*
 * Register cr_access (Intercept reads/writes to CR0-15); type amd_vmcb.cr_access (Implicit type of Intercept reads/writes to CR0-15 register)
 */

/*
 * Dump of fields for register: cr_access
 *   rdcr0 (size 1, offset 0):	 RW	  Intercept reads of CR0
 *   rdcr1 (size 1, offset 1):	 RW	  Intercept reads of CR1
 *   rdcr2 (size 1, offset 2):	 RW	  Intercept reads of CR2
 *   rdcr3 (size 1, offset 3):	 RW	  Intercept reads of CR3
 *   rdcr4 (size 1, offset 4):	 RW	  Intercept reads of CR4
 *   rdcr5 (size 1, offset 5):	 RW	  Intercept reads of CR5
 *   rdcr6 (size 1, offset 6):	 RW	  Intercept reads of CR6
 *   rdcr7 (size 1, offset 7):	 RW	  Intercept reads of CR7
 *   rdcr8 (size 1, offset 8):	 RW	  Intercept reads of CR8
 *   rdcr9 (size 1, offset 9):	 RW	  Intercept reads of CR9
 *   rdcr10 (size 1, offset 10):	 RW	  Intercept reads of CR10
 *   rdcr11 (size 1, offset 11):	 RW	  Intercept reads of CR11
 *   rdcr12 (size 1, offset 12):	 RW	  Intercept reads of CR12
 *   rdcr13 (size 1, offset 13):	 RW	  Intercept reads of CR13
 *   rdcr14 (size 1, offset 14):	 RW	  Intercept reads of CR14
 *   rdcr15 (size 1, offset 15):	 RW	  Intercept reads of CR15
 *   wrcr0 (size 1, offset 16):	 RW	  Intercept writes of CR0
 *   wrcr1 (size 1, offset 17):	 RW	  Intercept writes of CR1
 *   wrcr2 (size 1, offset 18):	 RW	  Intercept writes of CR2
 *   wrcr3 (size 1, offset 19):	 RW	  Intercept writes of CR3
 *   wrcr4 (size 1, offset 20):	 RW	  Intercept writes of CR4
 *   wrcr5 (size 1, offset 21):	 RW	  Intercept writes of CR5
 *   wrcr6 (size 1, offset 22):	 RW	  Intercept writes of CR6
 *   wrcr7 (size 1, offset 23):	 RW	  Intercept writes of CR7
 *   wrcr8 (size 1, offset 24):	 RW	  Intercept writes of CR8
 *   wrcr9 (size 1, offset 25):	 RW	  Intercept writes of CR9
 *   wrcr10 (size 1, offset 26):	 RW	  Intercept writes of CR10
 *   wrcr11 (size 1, offset 27):	 RW	  Intercept writes of CR11
 *   wrcr12 (size 1, offset 28):	 RW	  Intercept writes of CR12
 *   wrcr13 (size 1, offset 29):	 RW	  Intercept writes of CR13
 *   wrcr14 (size 1, offset 30):	 RW	  Intercept writes of CR14
 *   wrcr15 (size 1, offset 31):	 RW	  Intercept writes of CR15
 */

static inline uint32_t __DP(cr_access_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(cr_access_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x0));
}

static inline amd_vmcb_cr_access_t __DP(cr_access_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_cr_access_t __DP(cr_access_rd)( __DN(t) * _dev )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    return u.val;
}

static inline void __DP(cr_access_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x0),val);
}

static inline void __DP(cr_access_wr)( __DN(t) * _dev, amd_vmcb_cr_access_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wr)( __DN(t) * _dev, amd_vmcb_cr_access_t val )
{
    amd_vmcb_cr_access_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_rdcr0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_rdcr0_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.rdcr0 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_rdcr1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_rdcr1_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.rdcr1 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_rdcr2_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_rdcr2_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.rdcr2 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_rdcr3_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_rdcr3_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.rdcr3 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_rdcr4_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_rdcr4_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.rdcr4 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_rdcr5_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_rdcr5_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.rdcr5 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_rdcr6_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_rdcr6_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.rdcr6 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_rdcr7_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_rdcr7_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.rdcr7 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_rdcr8_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_rdcr8_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.rdcr8 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_rdcr9_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_rdcr9_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.rdcr9 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_rdcr10_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_rdcr10_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.rdcr10 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_rdcr11_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_rdcr11_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.rdcr11 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_rdcr12_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_rdcr12_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.rdcr12 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_rdcr13_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_rdcr13_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.rdcr13 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_rdcr14_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_rdcr14_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.rdcr14 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_rdcr15_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_rdcr15_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.rdcr15 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_wrcr0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wrcr0_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.wrcr0 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_wrcr1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wrcr1_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.wrcr1 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_wrcr2_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wrcr2_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.wrcr2 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_wrcr3_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wrcr3_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.wrcr3 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_wrcr4_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wrcr4_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.wrcr4 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_wrcr5_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wrcr5_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.wrcr5 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_wrcr6_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wrcr6_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.wrcr6 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_wrcr7_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wrcr7_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.wrcr7 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_wrcr8_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wrcr8_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.wrcr8 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_wrcr9_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wrcr9_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.wrcr9 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_wrcr10_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wrcr10_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.wrcr10 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_wrcr11_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wrcr11_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.wrcr11 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_wrcr12_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wrcr12_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.wrcr12 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_wrcr13_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wrcr13_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.wrcr13 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_wrcr14_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wrcr14_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.wrcr14 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}

static inline void __DP(cr_access_wrcr15_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr_access_wrcr15_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    u.val.wrcr15 = val;
    mackerel_write_addr_32(_dev->base,(0x0),u.raw);
}


static inline int __DP(cr_access_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cr_access_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_cr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cr_access (Intercept reads/writes to CR0-15):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.rdcr0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdcr0 =\t0x%"PRIx8" (Intercept reads of CR0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdcr1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdcr1 =\t0x%"PRIx8" (Intercept reads of CR1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdcr2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdcr2 =\t0x%"PRIx8" (Intercept reads of CR2", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdcr3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdcr3 =\t0x%"PRIx8" (Intercept reads of CR3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdcr4;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdcr4 =\t0x%"PRIx8" (Intercept reads of CR4", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdcr5;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdcr5 =\t0x%"PRIx8" (Intercept reads of CR5", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdcr6;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdcr6 =\t0x%"PRIx8" (Intercept reads of CR6", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdcr7;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdcr7 =\t0x%"PRIx8" (Intercept reads of CR7", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdcr8;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdcr8 =\t0x%"PRIx8" (Intercept reads of CR8", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdcr9;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdcr9 =\t0x%"PRIx8" (Intercept reads of CR9", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdcr10;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdcr10 =\t0x%"PRIx8" (Intercept reads of CR10", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdcr11;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdcr11 =\t0x%"PRIx8" (Intercept reads of CR11", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdcr12;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdcr12 =\t0x%"PRIx8" (Intercept reads of CR12", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdcr13;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdcr13 =\t0x%"PRIx8" (Intercept reads of CR13", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdcr14;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdcr14 =\t0x%"PRIx8" (Intercept reads of CR14", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdcr15;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdcr15 =\t0x%"PRIx8" (Intercept reads of CR15", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr0 =\t0x%"PRIx8" (Intercept writes of CR0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr1 =\t0x%"PRIx8" (Intercept writes of CR1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr2 =\t0x%"PRIx8" (Intercept writes of CR2", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr3 =\t0x%"PRIx8" (Intercept writes of CR3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr4;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr4 =\t0x%"PRIx8" (Intercept writes of CR4", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr5;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr5 =\t0x%"PRIx8" (Intercept writes of CR5", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr6;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr6 =\t0x%"PRIx8" (Intercept writes of CR6", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr7;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr7 =\t0x%"PRIx8" (Intercept writes of CR7", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr8;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr8 =\t0x%"PRIx8" (Intercept writes of CR8", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr9;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr9 =\t0x%"PRIx8" (Intercept writes of CR9", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr10;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr10 =\t0x%"PRIx8" (Intercept writes of CR10", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr11;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr11 =\t0x%"PRIx8" (Intercept writes of CR11", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr12;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr12 =\t0x%"PRIx8" (Intercept writes of CR12", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr13;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr13 =\t0x%"PRIx8" (Intercept writes of CR13", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr14;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr14 =\t0x%"PRIx8" (Intercept writes of CR14", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr15;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr15 =\t0x%"PRIx8" (Intercept writes of CR15", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register dr_access (Intercept reads/writes to DR0-15); type amd_vmcb.dr_access (Implicit type of Intercept reads/writes to DR0-15 register)
 */

/*
 * Dump of fields for register: dr_access
 *   rddr0 (size 1, offset 0):	 RW	  Intercept reads of DR0
 *   rddr1 (size 1, offset 1):	 RW	  Intercept reads of DR1
 *   rddr2 (size 1, offset 2):	 RW	  Intercept reads of DR2
 *   rddr3 (size 1, offset 3):	 RW	  Intercept reads of DR3
 *   rddr4 (size 1, offset 4):	 RW	  Intercept reads of DR4
 *   rddr5 (size 1, offset 5):	 RW	  Intercept reads of DR5
 *   rddr6 (size 1, offset 6):	 RW	  Intercept reads of DR6
 *   rddr7 (size 1, offset 7):	 RW	  Intercept reads of DR7
 *   rddr8 (size 1, offset 8):	 RW	  Intercept reads of DR8
 *   rddr9 (size 1, offset 9):	 RW	  Intercept reads of DR9
 *   rddr10 (size 1, offset 10):	 RW	  Intercept reads of DR10
 *   rddr11 (size 1, offset 11):	 RW	  Intercept reads of DR11
 *   rddr12 (size 1, offset 12):	 RW	  Intercept reads of DR12
 *   rddr13 (size 1, offset 13):	 RW	  Intercept reads of DR13
 *   rddr14 (size 1, offset 14):	 RW	  Intercept reads of DR14
 *   rddr15 (size 1, offset 15):	 RW	  Intercept reads of DR15
 *   wrdr0 (size 1, offset 16):	 RW	  Intercept writes of DR0
 *   wrdr1 (size 1, offset 17):	 RW	  Intercept writes of DR1
 *   wrdr2 (size 1, offset 18):	 RW	  Intercept writes of DR2
 *   wrdr3 (size 1, offset 19):	 RW	  Intercept writes of DR3
 *   wrdr4 (size 1, offset 20):	 RW	  Intercept writes of DR4
 *   wrdr5 (size 1, offset 21):	 RW	  Intercept writes of DR5
 *   wrdr6 (size 1, offset 22):	 RW	  Intercept writes of DR6
 *   wrdr7 (size 1, offset 23):	 RW	  Intercept writes of DR7
 *   wrdr8 (size 1, offset 24):	 RW	  Intercept writes of DR8
 *   wrdr9 (size 1, offset 25):	 RW	  Intercept writes of DR9
 *   wrdr10 (size 1, offset 26):	 RW	  Intercept writes of DR10
 *   wrdr11 (size 1, offset 27):	 RW	  Intercept writes of DR11
 *   wrdr12 (size 1, offset 28):	 RW	  Intercept writes of DR12
 *   wrdr13 (size 1, offset 29):	 RW	  Intercept writes of DR13
 *   wrdr14 (size 1, offset 30):	 RW	  Intercept writes of DR14
 *   wrdr15 (size 1, offset 31):	 RW	  Intercept writes of DR15
 */

static inline uint32_t __DP(dr_access_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(dr_access_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4));
}

static inline amd_vmcb_dr_access_t __DP(dr_access_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_dr_access_t __DP(dr_access_rd)( __DN(t) * _dev )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    return u.val;
}

static inline void __DP(dr_access_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x4),val);
}

static inline void __DP(dr_access_wr)( __DN(t) * _dev, amd_vmcb_dr_access_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wr)( __DN(t) * _dev, amd_vmcb_dr_access_t val )
{
    amd_vmcb_dr_access_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_rddr0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_rddr0_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.rddr0 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_rddr1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_rddr1_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.rddr1 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_rddr2_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_rddr2_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.rddr2 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_rddr3_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_rddr3_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.rddr3 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_rddr4_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_rddr4_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.rddr4 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_rddr5_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_rddr5_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.rddr5 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_rddr6_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_rddr6_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.rddr6 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_rddr7_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_rddr7_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.rddr7 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_rddr8_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_rddr8_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.rddr8 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_rddr9_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_rddr9_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.rddr9 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_rddr10_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_rddr10_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.rddr10 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_rddr11_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_rddr11_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.rddr11 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_rddr12_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_rddr12_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.rddr12 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_rddr13_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_rddr13_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.rddr13 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_rddr14_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_rddr14_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.rddr14 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_rddr15_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_rddr15_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.rddr15 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_wrdr0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wrdr0_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.wrdr0 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_wrdr1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wrdr1_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.wrdr1 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_wrdr2_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wrdr2_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.wrdr2 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_wrdr3_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wrdr3_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.wrdr3 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_wrdr4_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wrdr4_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.wrdr4 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_wrdr5_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wrdr5_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.wrdr5 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_wrdr6_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wrdr6_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.wrdr6 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_wrdr7_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wrdr7_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.wrdr7 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_wrdr8_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wrdr8_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.wrdr8 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_wrdr9_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wrdr9_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.wrdr9 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_wrdr10_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wrdr10_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.wrdr10 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_wrdr11_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wrdr11_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.wrdr11 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_wrdr12_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wrdr12_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.wrdr12 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_wrdr13_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wrdr13_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.wrdr13 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_wrdr14_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wrdr14_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.wrdr14 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}

static inline void __DP(dr_access_wrdr15_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dr_access_wrdr15_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    u.val.wrdr15 = val;
    mackerel_write_addr_32(_dev->base,(0x4),u.raw);
}


static inline int __DP(dr_access_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(dr_access_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_dr_access_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register dr_access (Intercept reads/writes to DR0-15):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.rddr0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rddr0 =\t0x%"PRIx8" (Intercept reads of DR0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rddr1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rddr1 =\t0x%"PRIx8" (Intercept reads of DR1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rddr2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rddr2 =\t0x%"PRIx8" (Intercept reads of DR2", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rddr3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rddr3 =\t0x%"PRIx8" (Intercept reads of DR3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rddr4;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rddr4 =\t0x%"PRIx8" (Intercept reads of DR4", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rddr5;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rddr5 =\t0x%"PRIx8" (Intercept reads of DR5", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rddr6;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rddr6 =\t0x%"PRIx8" (Intercept reads of DR6", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rddr7;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rddr7 =\t0x%"PRIx8" (Intercept reads of DR7", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rddr8;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rddr8 =\t0x%"PRIx8" (Intercept reads of DR8", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rddr9;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rddr9 =\t0x%"PRIx8" (Intercept reads of DR9", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rddr10;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rddr10 =\t0x%"PRIx8" (Intercept reads of DR10", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rddr11;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rddr11 =\t0x%"PRIx8" (Intercept reads of DR11", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rddr12;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rddr12 =\t0x%"PRIx8" (Intercept reads of DR12", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rddr13;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rddr13 =\t0x%"PRIx8" (Intercept reads of DR13", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rddr14;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rddr14 =\t0x%"PRIx8" (Intercept reads of DR14", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rddr15;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rddr15 =\t0x%"PRIx8" (Intercept reads of DR15", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrdr0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrdr0 =\t0x%"PRIx8" (Intercept writes of DR0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrdr1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrdr1 =\t0x%"PRIx8" (Intercept writes of DR1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrdr2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrdr2 =\t0x%"PRIx8" (Intercept writes of DR2", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrdr3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrdr3 =\t0x%"PRIx8" (Intercept writes of DR3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrdr4;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrdr4 =\t0x%"PRIx8" (Intercept writes of DR4", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrdr5;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrdr5 =\t0x%"PRIx8" (Intercept writes of DR5", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrdr6;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrdr6 =\t0x%"PRIx8" (Intercept writes of DR6", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrdr7;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrdr7 =\t0x%"PRIx8" (Intercept writes of DR7", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrdr8;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrdr8 =\t0x%"PRIx8" (Intercept writes of DR8", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrdr9;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrdr9 =\t0x%"PRIx8" (Intercept writes of DR9", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrdr10;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrdr10 =\t0x%"PRIx8" (Intercept writes of DR10", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrdr11;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrdr11 =\t0x%"PRIx8" (Intercept writes of DR11", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrdr12;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrdr12 =\t0x%"PRIx8" (Intercept writes of DR12", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrdr13;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrdr13 =\t0x%"PRIx8" (Intercept writes of DR13", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrdr14;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrdr14 =\t0x%"PRIx8" (Intercept writes of DR14", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrdr15;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrdr15 =\t0x%"PRIx8" (Intercept writes of DR15", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register exceptions (Intercept exception vectors 0-31); type amd_vmcb.exceptions (Implicit type of Intercept exception vectors 0-31 register)
 */

/*
 * Dump of fields for register: exceptions
 *   vector0 (size 1, offset 0):	 RW	  Intercept exception vector 0
 *   vector1 (size 1, offset 1):	 RW	  Intercept exception vector 1
 *   vector2 (size 1, offset 2):	 RW	  Intercept exception vector 2
 *   vector3 (size 1, offset 3):	 RW	  Intercept exception vector 3
 *   vector4 (size 1, offset 4):	 RW	  Intercept exception vector 4
 *   vector5 (size 1, offset 5):	 RW	  Intercept exception vector 5
 *   vector6 (size 1, offset 6):	 RW	  Intercept exception vector 6
 *   vector7 (size 1, offset 7):	 RW	  Intercept exception vector 7
 *   vector8 (size 1, offset 8):	 RW	  Intercept exception vector 8
 *   vector9 (size 1, offset 9):	 RW	  Intercept exception vector 9
 *   vector10 (size 1, offset 10):	 RW	  Intercept exception vector 10
 *   vector11 (size 1, offset 11):	 RW	  Intercept exception vector 11
 *   vector12 (size 1, offset 12):	 RW	  Intercept exception vector 12
 *   vector13 (size 1, offset 13):	 RW	  Intercept exception vector 13
 *   vector14 (size 1, offset 14):	 RW	  Intercept exception vector 14
 *   vector15 (size 1, offset 15):	 RW	  Intercept exception vector 15
 *   vector16 (size 1, offset 16):	 RW	  Intercept exception vector 16
 *   vector17 (size 1, offset 17):	 RW	  Intercept exception vector 17
 *   vector18 (size 1, offset 18):	 RW	  Intercept exception vector 18
 *   vector19 (size 1, offset 19):	 RW	  Intercept exception vector 19
 *   vector20 (size 1, offset 20):	 RW	  Intercept exception vector 20
 *   vector21 (size 1, offset 21):	 RW	  Intercept exception vector 21
 *   vector22 (size 1, offset 22):	 RW	  Intercept exception vector 22
 *   vector23 (size 1, offset 23):	 RW	  Intercept exception vector 23
 *   vector24 (size 1, offset 24):	 RW	  Intercept exception vector 24
 *   vector25 (size 1, offset 25):	 RW	  Intercept exception vector 25
 *   vector26 (size 1, offset 26):	 RW	  Intercept exception vector 26
 *   vector27 (size 1, offset 27):	 RW	  Intercept exception vector 27
 *   vector28 (size 1, offset 28):	 RW	  Intercept exception vector 28
 *   vector29 (size 1, offset 29):	 RW	  Intercept exception vector 29
 *   vector30 (size 1, offset 30):	 RW	  Intercept exception vector 30
 *   vector31 (size 1, offset 31):	 RW	  Intercept exception vector 31
 */

static inline uint32_t __DP(exceptions_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(exceptions_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x8));
}

static inline amd_vmcb_exceptions_t __DP(exceptions_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_exceptions_t __DP(exceptions_rd)( __DN(t) * _dev )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    return u.val;
}

static inline void __DP(exceptions_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x8),val);
}

static inline void __DP(exceptions_wr)( __DN(t) * _dev, amd_vmcb_exceptions_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_wr)( __DN(t) * _dev, amd_vmcb_exceptions_t val )
{
    amd_vmcb_exceptions_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector0_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector0 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector1_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector1 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector2_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector2_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector2 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector3_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector3_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector3 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector4_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector4_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector4 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector5_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector5_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector5 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector6_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector6_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector6 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector7_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector7_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector7 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector8_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector8_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector8 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector9_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector9_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector9 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector10_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector10_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector10 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector11_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector11_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector11 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector12_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector12_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector12 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector13_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector13_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector13 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector14_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector14_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector14 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector15_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector15_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector15 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector16_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector16_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector16 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector17_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector17_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector17 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector18_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector18_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector18 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector19_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector19_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector19 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector20_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector20_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector20 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector21_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector21_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector21 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector22_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector22_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector22 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector23_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector23_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector23 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector24_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector24_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector24 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector25_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector25_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector25 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector26_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector26_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector26 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector27_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector27_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector27 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector28_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector28_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector28 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector29_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector29_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector29 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector30_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector30_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector30 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}

static inline void __DP(exceptions_vector31_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(exceptions_vector31_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    u.val.vector31 = val;
    mackerel_write_addr_32(_dev->base,(0x8),u.raw);
}


static inline int __DP(exceptions_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(exceptions_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_exceptions_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x8));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register exceptions (Intercept exception vectors 0-31):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.vector0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector0 =\t0x%"PRIx8" (Intercept exception vector 0", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector1 =\t0x%"PRIx8" (Intercept exception vector 1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector2 =\t0x%"PRIx8" (Intercept exception vector 2", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector3 =\t0x%"PRIx8" (Intercept exception vector 3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector4;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector4 =\t0x%"PRIx8" (Intercept exception vector 4", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector5;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector5 =\t0x%"PRIx8" (Intercept exception vector 5", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector6;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector6 =\t0x%"PRIx8" (Intercept exception vector 6", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector7;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector7 =\t0x%"PRIx8" (Intercept exception vector 7", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector8;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector8 =\t0x%"PRIx8" (Intercept exception vector 8", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector9;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector9 =\t0x%"PRIx8" (Intercept exception vector 9", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector10;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector10 =\t0x%"PRIx8" (Intercept exception vector 10", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector11;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector11 =\t0x%"PRIx8" (Intercept exception vector 11", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector12;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector12 =\t0x%"PRIx8" (Intercept exception vector 12", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector13;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector13 =\t0x%"PRIx8" (Intercept exception vector 13", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector14;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector14 =\t0x%"PRIx8" (Intercept exception vector 14", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector15;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector15 =\t0x%"PRIx8" (Intercept exception vector 15", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector16;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector16 =\t0x%"PRIx8" (Intercept exception vector 16", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector17;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector17 =\t0x%"PRIx8" (Intercept exception vector 17", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector18;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector18 =\t0x%"PRIx8" (Intercept exception vector 18", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector19;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector19 =\t0x%"PRIx8" (Intercept exception vector 19", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector20;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector20 =\t0x%"PRIx8" (Intercept exception vector 20", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector21;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector21 =\t0x%"PRIx8" (Intercept exception vector 21", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector22;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector22 =\t0x%"PRIx8" (Intercept exception vector 22", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector23;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector23 =\t0x%"PRIx8" (Intercept exception vector 23", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector24;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector24 =\t0x%"PRIx8" (Intercept exception vector 24", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector25;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector25 =\t0x%"PRIx8" (Intercept exception vector 25", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector26;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector26 =\t0x%"PRIx8" (Intercept exception vector 26", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector27;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector27 =\t0x%"PRIx8" (Intercept exception vector 27", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector28;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector28 =\t0x%"PRIx8" (Intercept exception vector 28", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector29;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector29 =\t0x%"PRIx8" (Intercept exception vector 29", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector30;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector30 =\t0x%"PRIx8" (Intercept exception vector 30", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vector31;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector31 =\t0x%"PRIx8" (Intercept exception vector 31", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register intercepts (Various intercepts); type amd_vmcb.intercepts (Implicit type of Various intercepts register)
 */

/*
 * Dump of fields for register: intercepts
 *   intr (size 1, offset 0):	 RW	  Intercept INTR instruction
 *   nmi (size 1, offset 1):	 RW	  Intercept NMI instruction
 *   smi (size 1, offset 2):	 RW	  Intercept SMI instruction
 *   init (size 1, offset 3):	 RW	  Intercept INIT instruction
 *   vintr (size 1, offset 4):	 RW	  Intercept VINTR instruction
 *   wrcr0 (size 1, offset 5):	 RW	  Intercept CR0 writes that change bits other than TS or MP
 *   rdidtr (size 1, offset 6):	 RW	  Intercept reads of IDTR
 *   rdgdtr (size 1, offset 7):	 RW	  Intercept reads of GDTR
 *   rdldtr (size 1, offset 8):	 RW	  Intercept reads of LDTR
 *   rdtr (size 1, offset 9):	 RW	  Intercept reads of TR
 *   wridtr (size 1, offset 10):	 RW	  Intercept writes of IDRT
 *   wrgdtr (size 1, offset 11):	 RW	  Intercept writes of GDTR
 *   wrldtr (size 1, offset 12):	 RW	  Intercept writes of LDTR
 *   wrtr (size 1, offset 13):	 RW	  Intercept writes of TR
 *   rdtsc (size 1, offset 14):	 RW	  Intercept RDTSC instruction
 *   rdpmc (size 1, offset 15):	 RW	  Intercept RDPMC instruction
 *   pushf (size 1, offset 16):	 RW	  Intercept PUSHF instruction
 *   popf (size 1, offset 17):	 RW	  Intercept POPF instruction
 *   cpuid (size 1, offset 18):	 RW	  Intercept CPUID instruction
 *   rsm (size 1, offset 19):	 RW	  Intercept RSM instruction
 *   iret (size 1, offset 20):	 RW	  Intercept IRET instruction
 *   intn (size 1, offset 21):	 RW	  Intercept INTn instruction
 *   invd (size 1, offset 22):	 RW	  Intercept INVD instruction
 *   pause (size 1, offset 23):	 RW	  Intercept PAUSE instruction
 *   hlt (size 1, offset 24):	 RW	  Intercept HLT instruction
 *   invlpg (size 1, offset 25):	 RW	  Intercept INVLPG instruction
 *   invlpga (size 1, offset 26):	 RW	  Intercept INVLPGA instruction
 *   ioio_prot (size 1, offset 27):	 RW	  Intercept IN/OUT accesses to selected ports
 *   msr_prot (size 1, offset 28):	 RW	  Intercept RDMSR or WRMSR accesses to selected MSRs
 *   task_switch (size 1, offset 29):	 RW	  Intercept task switches
 *   ferr_freeze (size 1, offset 30):	 RW	  Intercept processor freezing durich legacy FERR handling
 *   shutdown (size 1, offset 31):	 RW	  Intercept shutdown events
 *   vmrun (size 1, offset 32):	 RW	  Intercept VMRUN instruction
 *   vmmcall (size 1, offset 33):	 RW	  Intercept VMMCALL instruction
 *   vmload (size 1, offset 34):	 RW	  Intercept VMLOAD instruction
 *   vmsave (size 1, offset 35):	 RW	  Intercept VMSAVE instruction
 *   stgi (size 1, offset 36):	 RW	  Intercept STGI instruction
 *   clgi (size 1, offset 37):	 RW	  Intercept CLGI instruction
 *   skinit (size 1, offset 38):	 RW	  Intercept SKINIT instruction
 *   rdtscp (size 1, offset 39):	 RW	  Intercept RDTSCP instruction
 *   icebp (size 1, offset 40):	 RW	  Intercept ICEBP instruction
 *   wbinvd (size 1, offset 41):	 RW	  Intercept WBINVD instruction
 *   monitor (size 1, offset 42):	 RW	  Intercept MONITOR instruction
 *   mwait0 (size 1, offset 43):	 RW	  Intercept MWAIT instruction unconditionally
 *   mwait1 (size 1, offset 44):	 RW	  Intercept MWAIT instruction if monitor hardware is armed
 *   _anon45 (size 19, offset 45):	 RSVD	  _
 */

static inline uint64_t __DP(intercepts_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(intercepts_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0xc));
}

static inline amd_vmcb_intercepts_t __DP(intercepts_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_intercepts_t __DP(intercepts_rd)( __DN(t) * _dev )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    return u.val;
}

static inline void __DP(intercepts_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0xc),val);
}

static inline void __DP(intercepts_wr)( __DN(t) * _dev, amd_vmcb_intercepts_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_wr)( __DN(t) * _dev, amd_vmcb_intercepts_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.intr 	= val.intr;
    u.val.nmi 	= val.nmi;
    u.val.smi 	= val.smi;
    u.val.init 	= val.init;
    u.val.vintr 	= val.vintr;
    u.val.wrcr0 	= val.wrcr0;
    u.val.rdidtr 	= val.rdidtr;
    u.val.rdgdtr 	= val.rdgdtr;
    u.val.rdldtr 	= val.rdldtr;
    u.val.rdtr 	= val.rdtr;
    u.val.wridtr 	= val.wridtr;
    u.val.wrgdtr 	= val.wrgdtr;
    u.val.wrldtr 	= val.wrldtr;
    u.val.wrtr 	= val.wrtr;
    u.val.rdtsc 	= val.rdtsc;
    u.val.rdpmc 	= val.rdpmc;
    u.val.pushf 	= val.pushf;
    u.val.popf 	= val.popf;
    u.val.cpuid 	= val.cpuid;
    u.val.rsm 	= val.rsm;
    u.val.iret 	= val.iret;
    u.val.intn 	= val.intn;
    u.val.invd 	= val.invd;
    u.val.pause 	= val.pause;
    u.val.hlt 	= val.hlt;
    u.val.invlpg 	= val.invlpg;
    u.val.invlpga 	= val.invlpga;
    u.val.ioio_prot 	= val.ioio_prot;
    u.val.msr_prot 	= val.msr_prot;
    u.val.task_switch 	= val.task_switch;
    u.val.ferr_freeze 	= val.ferr_freeze;
    u.val.shutdown 	= val.shutdown;
    u.val.vmrun 	= val.vmrun;
    u.val.vmmcall 	= val.vmmcall;
    u.val.vmload 	= val.vmload;
    u.val.vmsave 	= val.vmsave;
    u.val.stgi 	= val.stgi;
    u.val.clgi 	= val.clgi;
    u.val.skinit 	= val.skinit;
    u.val.rdtscp 	= val.rdtscp;
    u.val.icebp 	= val.icebp;
    u.val.wbinvd 	= val.wbinvd;
    u.val.monitor 	= val.monitor;
    u.val.mwait0 	= val.mwait0;
    u.val.mwait1 	= val.mwait1;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_intr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_intr_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.intr = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_nmi_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_nmi_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.nmi = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_smi_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_smi_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.smi = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_init_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_init_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.init = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_vintr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_vintr_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.vintr = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_wrcr0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_wrcr0_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.wrcr0 = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_rdidtr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_rdidtr_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.rdidtr = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_rdgdtr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_rdgdtr_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.rdgdtr = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_rdldtr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_rdldtr_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.rdldtr = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_rdtr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_rdtr_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.rdtr = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_wridtr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_wridtr_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.wridtr = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_wrgdtr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_wrgdtr_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.wrgdtr = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_wrldtr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_wrldtr_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.wrldtr = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_wrtr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_wrtr_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.wrtr = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_rdtsc_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_rdtsc_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.rdtsc = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_rdpmc_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_rdpmc_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.rdpmc = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_pushf_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_pushf_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.pushf = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_popf_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_popf_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.popf = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_cpuid_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_cpuid_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.cpuid = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_rsm_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_rsm_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.rsm = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_iret_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_iret_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.iret = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_intn_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_intn_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.intn = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_invd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_invd_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.invd = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_pause_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_pause_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.pause = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_hlt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_hlt_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.hlt = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_invlpg_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_invlpg_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.invlpg = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_invlpga_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_invlpga_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.invlpga = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_ioio_prot_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_ioio_prot_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.ioio_prot = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_msr_prot_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_msr_prot_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.msr_prot = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_task_switch_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_task_switch_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.task_switch = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_ferr_freeze_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_ferr_freeze_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.ferr_freeze = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_shutdown_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_shutdown_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.shutdown = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_vmrun_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_vmrun_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.vmrun = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_vmmcall_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_vmmcall_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.vmmcall = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_vmload_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_vmload_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.vmload = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_vmsave_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_vmsave_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.vmsave = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_stgi_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_stgi_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.stgi = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_clgi_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_clgi_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.clgi = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_skinit_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_skinit_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.skinit = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_rdtscp_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_rdtscp_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.rdtscp = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_icebp_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_icebp_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.icebp = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_wbinvd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_wbinvd_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.wbinvd = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_monitor_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_monitor_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.monitor = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_mwait0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_mwait0_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.mwait0 = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}

static inline void __DP(intercepts_mwait1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intercepts_mwait1_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    u.val.mwait1 = val;
    mackerel_write_addr_64(_dev->base,(0xc),u.raw);
}


static inline int __DP(intercepts_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(intercepts_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_intercepts_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xc));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register intercepts (Various intercepts):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.intr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " intr =\t0x%"PRIx8" (Intercept INTR instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.nmi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " nmi =\t0x%"PRIx8" (Intercept NMI instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.smi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " smi =\t0x%"PRIx8" (Intercept SMI instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.init;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " init =\t0x%"PRIx8" (Intercept INIT instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vintr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vintr =\t0x%"PRIx8" (Intercept VINTR instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrcr0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrcr0 =\t0x%"PRIx8" (Intercept CR0 writes that change bits other than TS or MP", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdidtr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdidtr =\t0x%"PRIx8" (Intercept reads of IDTR", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdgdtr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdgdtr =\t0x%"PRIx8" (Intercept reads of GDTR", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdldtr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdldtr =\t0x%"PRIx8" (Intercept reads of LDTR", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdtr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdtr =\t0x%"PRIx8" (Intercept reads of TR", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wridtr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wridtr =\t0x%"PRIx8" (Intercept writes of IDRT", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrgdtr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrgdtr =\t0x%"PRIx8" (Intercept writes of GDTR", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrldtr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrldtr =\t0x%"PRIx8" (Intercept writes of LDTR", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wrtr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wrtr =\t0x%"PRIx8" (Intercept writes of TR", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdtsc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdtsc =\t0x%"PRIx8" (Intercept RDTSC instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdpmc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdpmc =\t0x%"PRIx8" (Intercept RDPMC instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pushf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pushf =\t0x%"PRIx8" (Intercept PUSHF instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.popf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " popf =\t0x%"PRIx8" (Intercept POPF instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cpuid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cpuid =\t0x%"PRIx8" (Intercept CPUID instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rsm;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rsm =\t0x%"PRIx8" (Intercept RSM instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.iret;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " iret =\t0x%"PRIx8" (Intercept IRET instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.intn;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " intn =\t0x%"PRIx8" (Intercept INTn instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.invd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " invd =\t0x%"PRIx8" (Intercept INVD instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pause;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pause =\t0x%"PRIx8" (Intercept PAUSE instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.hlt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " hlt =\t0x%"PRIx8" (Intercept HLT instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.invlpg;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " invlpg =\t0x%"PRIx8" (Intercept INVLPG instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.invlpga;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " invlpga =\t0x%"PRIx8" (Intercept INVLPGA instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ioio_prot;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ioio_prot =\t0x%"PRIx8" (Intercept IN/OUT accesses to selected ports", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.msr_prot;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " msr_prot =\t0x%"PRIx8" (Intercept RDMSR or WRMSR accesses to selected MSRs", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.task_switch;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " task_switch =\t0x%"PRIx8" (Intercept task switches", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ferr_freeze;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ferr_freeze =\t0x%"PRIx8" (Intercept processor freezing durich legacy FERR handling", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.shutdown;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " shutdown =\t0x%"PRIx8" (Intercept shutdown events", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vmrun;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vmrun =\t0x%"PRIx8" (Intercept VMRUN instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vmmcall;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vmmcall =\t0x%"PRIx8" (Intercept VMMCALL instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vmload;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vmload =\t0x%"PRIx8" (Intercept VMLOAD instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vmsave;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vmsave =\t0x%"PRIx8" (Intercept VMSAVE instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.stgi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " stgi =\t0x%"PRIx8" (Intercept STGI instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.clgi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " clgi =\t0x%"PRIx8" (Intercept CLGI instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.skinit;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " skinit =\t0x%"PRIx8" (Intercept SKINIT instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdtscp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdtscp =\t0x%"PRIx8" (Intercept RDTSCP instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.icebp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " icebp =\t0x%"PRIx8" (Intercept ICEBP instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wbinvd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wbinvd =\t0x%"PRIx8" (Intercept WBINVD instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.monitor;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " monitor =\t0x%"PRIx8" (Intercept MONITOR instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mwait0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mwait0 =\t0x%"PRIx8" (Intercept MWAIT instruction unconditionally", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mwait1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mwait1 =\t0x%"PRIx8" (Intercept MWAIT instruction if monitor hardware is armed", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register iopm_base_pa (Physical base address of IOPM (bits 11:0 are ignored)); type amd_vmcb.uint64
 */

static inline uint64_t __DP(iopm_base_pa_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(iopm_base_pa_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x40));
}

static inline uint64_t __DP(iopm_base_pa_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(iopm_base_pa_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x40));
}

static inline void __DP(iopm_base_pa_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(iopm_base_pa_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x40),val);
}

static inline void __DP(iopm_base_pa_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(iopm_base_pa_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x40),val);
}


static inline int __DP(iopm_base_pa_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(iopm_base_pa_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register iopm_base_pa (Physical base address of IOPM (bits 11:0 are ignored)):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x40)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register msrpm_base_pa (Physical base address of MSRPM (bits 11:0 are ignored)); type amd_vmcb.uint64
 */

static inline uint64_t __DP(msrpm_base_pa_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(msrpm_base_pa_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x48));
}

static inline uint64_t __DP(msrpm_base_pa_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(msrpm_base_pa_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x48));
}

static inline void __DP(msrpm_base_pa_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(msrpm_base_pa_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x48),val);
}

static inline void __DP(msrpm_base_pa_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(msrpm_base_pa_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x48),val);
}


static inline int __DP(msrpm_base_pa_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(msrpm_base_pa_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register msrpm_base_pa (Physical base address of MSRPM (bits 11:0 are ignored)):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x48)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register tsc_offset (To be added in RDTSC and RDTSCP); type amd_vmcb.uint64
 */

static inline uint64_t __DP(tsc_offset_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(tsc_offset_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x50));
}

static inline uint64_t __DP(tsc_offset_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(tsc_offset_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x50));
}

static inline void __DP(tsc_offset_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(tsc_offset_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x50),val);
}

static inline void __DP(tsc_offset_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(tsc_offset_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x50),val);
}


static inline int __DP(tsc_offset_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tsc_offset_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tsc_offset (To be added in RDTSC and RDTSCP):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x50)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register tlb (Guest TLB settings); type amd_vmcb.tlb (Implicit type of Guest TLB settings register)
 */

/*
 * Dump of fields for register: tlb
 *   guest_asid (size 32, offset 0):	 RW	  Guest ASID
 *   control (size 8, offset 32):	 RW	  TLB control values
 *   _anon40 (size 24, offset 40):	 RSVD	  _
 */

static inline uint64_t __DP(tlb_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(tlb_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x58));
}

static inline amd_vmcb_tlb_t __DP(tlb_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_tlb_t __DP(tlb_rd)( __DN(t) * _dev )
{
    amd_vmcb_tlb_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x58));
    return u.val;
}

static inline void __DP(tlb_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(tlb_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x58),val);
}

static inline void __DP(tlb_wr)( __DN(t) * _dev, amd_vmcb_tlb_t val ) __attribute__ ((always_inline));
static inline void __DP(tlb_wr)( __DN(t) * _dev, amd_vmcb_tlb_t val )
{
    amd_vmcb_tlb_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x58));
    u.val.guest_asid 	= val.guest_asid;
    u.val.control 	= val.control;
    mackerel_write_addr_64(_dev->base,(0x58),u.raw);
}

static inline void __DP(tlb_guest_asid_wrf)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(tlb_guest_asid_wrf)( __DN(t) * _dev, uint32_t val )
{
    amd_vmcb_tlb_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x58));
    u.val.guest_asid = val;
    mackerel_write_addr_64(_dev->base,(0x58),u.raw);
}

static inline void __DP(tlb_control_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tlb_control_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_tlb_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x58));
    u.val.control = val;
    mackerel_write_addr_64(_dev->base,(0x58),u.raw);
}


static inline int __DP(tlb_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tlb_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_tlb_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x58));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tlb (Guest TLB settings):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.guest_asid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " guest_asid =\t0x%0"PRIx32" (Guest ASID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.control;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " control =\t0x%"PRIx8" (TLB control values", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register vintr (Virtual interrupt settings); type amd_vmcb.vintr (Implicit type of Virtual interrupt settings register)
 */

/*
 * Dump of fields for register: vintr
 *   vtpr (size 8, offset 0):	 RW	  Virtual TPR for the guest
 *   virq (size 1, offset 8):	 RW	  Virtual interrupt pernding
 *   _anon9 (size 7, offset 9):	 RSVD	  _
 *   vintr_prio (size 4, offset 16):	 RW	  Priority for virtual interrupt
 *   v_ign_tpr (size 1, offset 20):	 RW	  Virtual interrupt ignores the virtual TPR
 *   _anon21 (size 3, offset 21):	 RSVD	  _
 *   vintr_masking (size 1, offset 24):	 RW	  Virtualize masking of INTR interrupt
 *   _anon25 (size 7, offset 25):	 RSVD	  _
 *   vintr_vector (size 8, offset 32):	 RW	  Vector to use for this interrupt
 *   _anon40 (size 24, offset 40):	 RSVD	  _
 */

static inline uint64_t __DP(vintr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(vintr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x60));
}

static inline amd_vmcb_vintr_t __DP(vintr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_vintr_t __DP(vintr_rd)( __DN(t) * _dev )
{
    amd_vmcb_vintr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x60));
    return u.val;
}

static inline void __DP(vintr_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(vintr_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x60),val);
}

static inline void __DP(vintr_wr)( __DN(t) * _dev, amd_vmcb_vintr_t val ) __attribute__ ((always_inline));
static inline void __DP(vintr_wr)( __DN(t) * _dev, amd_vmcb_vintr_t val )
{
    amd_vmcb_vintr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x60));
    u.val.vtpr 	= val.vtpr;
    u.val.virq 	= val.virq;
    u.val.vintr_prio 	= val.vintr_prio;
    u.val.v_ign_tpr 	= val.v_ign_tpr;
    u.val.vintr_masking 	= val.vintr_masking;
    u.val.vintr_vector 	= val.vintr_vector;
    mackerel_write_addr_64(_dev->base,(0x60),u.raw);
}

static inline void __DP(vintr_vtpr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(vintr_vtpr_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_vintr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x60));
    u.val.vtpr = val;
    mackerel_write_addr_64(_dev->base,(0x60),u.raw);
}

static inline void __DP(vintr_virq_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(vintr_virq_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_vintr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x60));
    u.val.virq = val;
    mackerel_write_addr_64(_dev->base,(0x60),u.raw);
}

static inline void __DP(vintr_vintr_prio_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(vintr_vintr_prio_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_vintr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x60));
    u.val.vintr_prio = val;
    mackerel_write_addr_64(_dev->base,(0x60),u.raw);
}

static inline void __DP(vintr_v_ign_tpr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(vintr_v_ign_tpr_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_vintr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x60));
    u.val.v_ign_tpr = val;
    mackerel_write_addr_64(_dev->base,(0x60),u.raw);
}

static inline void __DP(vintr_vintr_masking_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(vintr_vintr_masking_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_vintr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x60));
    u.val.vintr_masking = val;
    mackerel_write_addr_64(_dev->base,(0x60),u.raw);
}

static inline void __DP(vintr_vintr_vector_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(vintr_vintr_vector_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_vintr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x60));
    u.val.vintr_vector = val;
    mackerel_write_addr_64(_dev->base,(0x60),u.raw);
}


static inline int __DP(vintr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(vintr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_vintr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x60));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register vintr (Virtual interrupt settings):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.vtpr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vtpr =\t0x%"PRIx8" (Virtual TPR for the guest", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.virq;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " virq =\t0x%"PRIx8" (Virtual interrupt pernding", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.vintr_prio;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vintr_prio =\t0x%"PRIx8" (Priority for virtual interrupt", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.v_ign_tpr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " v_ign_tpr =\t0x%"PRIx8" (Virtual interrupt ignores the virtual TPR", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.vintr_masking;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vintr_masking =\t0x%"PRIx8" (Virtualize masking of INTR interrupt", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.vintr_vector;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vintr_vector =\t0x%"PRIx8" (Vector to use for this interrupt", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register intr (Guest interrupt settings); type amd_vmcb.intr (Implicit type of Guest interrupt settings register)
 */

/*
 * Dump of fields for register: intr
 *   interrupt_shadow (size 1, offset 0):	 RW	  Guest is in an interrupt shadow
 *   _anon1 (size 63, offset 1):	 RSVD	  _
 */

static inline uint64_t __DP(intr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(intr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x68));
}

static inline amd_vmcb_intr_t __DP(intr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_intr_t __DP(intr_rd)( __DN(t) * _dev )
{
    amd_vmcb_intr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x68));
    return u.val;
}

static inline void __DP(intr_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(intr_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x68),val);
}

static inline void __DP(intr_wr)( __DN(t) * _dev, amd_vmcb_intr_t val ) __attribute__ ((always_inline));
static inline void __DP(intr_wr)( __DN(t) * _dev, amd_vmcb_intr_t val )
{
    amd_vmcb_intr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x68));
    u.val.interrupt_shadow 	= val.interrupt_shadow;
    mackerel_write_addr_64(_dev->base,(0x68),u.raw);
}

static inline void __DP(intr_interrupt_shadow_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(intr_interrupt_shadow_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_intr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x68));
    u.val.interrupt_shadow = val;
    mackerel_write_addr_64(_dev->base,(0x68),u.raw);
}


static inline int __DP(intr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(intr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_intr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x68));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register intr (Guest interrupt settings):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.interrupt_shadow;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " interrupt_shadow =\t0x%"PRIx8" (Guest is in an interrupt shadow", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register exitcode (Guest EXITCODE); type amd_vmcb.uint64
 */

static inline uint64_t __DP(exitcode_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(exitcode_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x70));
}

static inline uint64_t __DP(exitcode_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(exitcode_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x70));
}

static inline void __DP(exitcode_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(exitcode_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x70),val);
}

static inline void __DP(exitcode_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(exitcode_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x70),val);
}


static inline int __DP(exitcode_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(exitcode_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register exitcode (Guest EXITCODE):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x70)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register exitinfo1 (Guest EXITINFO1); type amd_vmcb.uint64
 */

static inline uint64_t __DP(exitinfo1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(exitinfo1_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x78));
}

static inline uint64_t __DP(exitinfo1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(exitinfo1_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x78));
}

static inline void __DP(exitinfo1_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(exitinfo1_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x78),val);
}

static inline void __DP(exitinfo1_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(exitinfo1_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x78),val);
}


static inline int __DP(exitinfo1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(exitinfo1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register exitinfo1 (Guest EXITINFO1):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x78)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register exitinfo2 (Guest EXITINFO2); type amd_vmcb.uint64
 */

static inline uint64_t __DP(exitinfo2_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(exitinfo2_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x80));
}

static inline uint64_t __DP(exitinfo2_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(exitinfo2_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x80));
}

static inline void __DP(exitinfo2_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(exitinfo2_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x80),val);
}

static inline void __DP(exitinfo2_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(exitinfo2_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x80),val);
}


static inline int __DP(exitinfo2_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(exitinfo2_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register exitinfo2 (Guest EXITINFO2):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x80)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register exitintinfo (Guest EXITINTINFO); type amd_vmcb.uint64
 */

static inline uint64_t __DP(exitintinfo_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(exitintinfo_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x88));
}

static inline uint64_t __DP(exitintinfo_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(exitintinfo_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x88));
}

static inline void __DP(exitintinfo_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(exitintinfo_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x88),val);
}

static inline void __DP(exitintinfo_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(exitintinfo_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x88),val);
}


static inline int __DP(exitintinfo_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(exitintinfo_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register exitintinfo (Guest EXITINTINFO):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x88)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register np (Nested paging settings); type amd_vmcb.np (Implicit type of Nested paging settings register)
 */

/*
 * Dump of fields for register: np
 *   enable (size 1, offset 0):	 RW	  Enable nested paging
 *   _anon1 (size 63, offset 1):	 RSVD	  _
 */

static inline uint64_t __DP(np_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(np_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x90));
}

static inline amd_vmcb_np_t __DP(np_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_np_t __DP(np_rd)( __DN(t) * _dev )
{
    amd_vmcb_np_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x90));
    return u.val;
}

static inline void __DP(np_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(np_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x90),val);
}

static inline void __DP(np_wr)( __DN(t) * _dev, amd_vmcb_np_t val ) __attribute__ ((always_inline));
static inline void __DP(np_wr)( __DN(t) * _dev, amd_vmcb_np_t val )
{
    amd_vmcb_np_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x90));
    u.val.enable 	= val.enable;
    mackerel_write_addr_64(_dev->base,(0x90),u.raw);
}

static inline void __DP(np_enable_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(np_enable_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_np_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x90));
    u.val.enable = val;
    mackerel_write_addr_64(_dev->base,(0x90),u.raw);
}


static inline int __DP(np_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(np_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_np_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x90));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register np (Nested paging settings):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " enable =\t0x%"PRIx8" (Enable nested paging", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eventinj (Event injection); type amd_vmcb.uint64
 */

static inline uint64_t __DP(eventinj_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(eventinj_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0xa8));
}

static inline uint64_t __DP(eventinj_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(eventinj_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0xa8));
}

static inline void __DP(eventinj_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(eventinj_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0xa8),val);
}

static inline void __DP(eventinj_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(eventinj_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0xa8),val);
}


static inline int __DP(eventinj_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eventinj_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eventinj (Event injection):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0xa8)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ncr3 (Nested page table CR3 to use for nested paging); type amd_vmcb.uint64
 */

static inline uint64_t __DP(ncr3_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(ncr3_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0xb0));
}

static inline uint64_t __DP(ncr3_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(ncr3_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0xb0));
}

static inline void __DP(ncr3_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(ncr3_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0xb0),val);
}

static inline void __DP(ncr3_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(ncr3_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0xb0),val);
}


static inline int __DP(ncr3_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ncr3_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ncr3 (Nested page table CR3 to use for nested paging):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0xb0)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register lbr (Guest LBR settings); type amd_vmcb.lbr (Implicit type of Guest LBR settings register)
 */

/*
 * Dump of fields for register: lbr
 *   lbr_virtualization_enable (size 1, offset 0):	 RW	  Enable LBR virtualization
 *   _anon1 (size 63, offset 1):	 RSVD	  _
 */

static inline uint64_t __DP(lbr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(lbr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0xb8));
}

static inline amd_vmcb_lbr_t __DP(lbr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_lbr_t __DP(lbr_rd)( __DN(t) * _dev )
{
    amd_vmcb_lbr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xb8));
    return u.val;
}

static inline void __DP(lbr_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(lbr_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0xb8),val);
}

static inline void __DP(lbr_wr)( __DN(t) * _dev, amd_vmcb_lbr_t val ) __attribute__ ((always_inline));
static inline void __DP(lbr_wr)( __DN(t) * _dev, amd_vmcb_lbr_t val )
{
    amd_vmcb_lbr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xb8));
    u.val.lbr_virtualization_enable 	= val.lbr_virtualization_enable;
    mackerel_write_addr_64(_dev->base,(0xb8),u.raw);
}

static inline void __DP(lbr_lbr_virtualization_enable_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lbr_lbr_virtualization_enable_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_lbr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xb8));
    u.val.lbr_virtualization_enable = val;
    mackerel_write_addr_64(_dev->base,(0xb8),u.raw);
}


static inline int __DP(lbr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(lbr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_lbr_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0xb8));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register lbr (Guest LBR settings):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.lbr_virtualization_enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lbr_virtualization_enable =\t0x%"PRIx8" (Enable LBR virtualization", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register es_selector (Guest ES selector); type amd_vmcb.uint16
 */

static inline uint16_t __DP(es_selector_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(es_selector_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x400));
}

static inline uint16_t __DP(es_selector_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(es_selector_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x400));
}

static inline void __DP(es_selector_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(es_selector_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x400),val);
}

static inline void __DP(es_selector_wr)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(es_selector_wr)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x400),val);
}


static inline int __DP(es_selector_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(es_selector_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register es_selector (Guest ES selector):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_addr_16(_dev->base,(0x400)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register es_attrib (Guest ES attrib); type amd_vmcb.seg_attrib (Segment attributes)
 */

/*
 * Dump of fields for register: es_attrib
 *   segtype (size 4, offset 0):	 RW	  Segment type
 *   s (size 1, offset 4):	 RW	  Segment descriptor type
 *   dpl (size 2, offset 5):	 RW	  Descriptor privilege level
 *   p (size 1, offset 7):	 RW	  Segment present
 *   avl (size 1, offset 8):	 RW	  Available for use by system software
 *   l (size 1, offset 9):	 RW	  64-bit code segment
 *   db (size 1, offset 10):	 RW	  Default operation size (0: 16-bit, 1: 32-bit segment)
 *   g (size 1, offset 11):	 RW	  Granularity
 *   _anon12 (size 4, offset 12):	 RSVD	  _
 */

static inline uint16_t __DP(es_attrib_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(es_attrib_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x402));
}

static inline amd_vmcb_seg_attrib_t __DP(es_attrib_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_seg_attrib_t __DP(es_attrib_rd)( __DN(t) * _dev )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x402));
    return u.val;
}

static inline void __DP(es_attrib_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(es_attrib_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x402),val);
}

static inline void __DP(es_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val ) __attribute__ ((always_inline));
static inline void __DP(es_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x402));
    u.val.segtype 	= val.segtype;
    u.val.s 	= val.s;
    u.val.dpl 	= val.dpl;
    u.val.p 	= val.p;
    u.val.avl 	= val.avl;
    u.val.l 	= val.l;
    u.val.db 	= val.db;
    u.val.g 	= val.g;
    mackerel_write_addr_16(_dev->base,(0x402),u.raw);
}

static inline void __DP(es_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(es_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x402));
    u.val.segtype = val;
    mackerel_write_addr_16(_dev->base,(0x402),u.raw);
}

static inline void __DP(es_attrib_s_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(es_attrib_s_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x402));
    u.val.s = val;
    mackerel_write_addr_16(_dev->base,(0x402),u.raw);
}

static inline void __DP(es_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(es_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x402));
    u.val.dpl = val;
    mackerel_write_addr_16(_dev->base,(0x402),u.raw);
}

static inline void __DP(es_attrib_p_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(es_attrib_p_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x402));
    u.val.p = val;
    mackerel_write_addr_16(_dev->base,(0x402),u.raw);
}

static inline void __DP(es_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(es_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x402));
    u.val.avl = val;
    mackerel_write_addr_16(_dev->base,(0x402),u.raw);
}

static inline void __DP(es_attrib_l_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(es_attrib_l_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x402));
    u.val.l = val;
    mackerel_write_addr_16(_dev->base,(0x402),u.raw);
}

static inline void __DP(es_attrib_db_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(es_attrib_db_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x402));
    u.val.db = val;
    mackerel_write_addr_16(_dev->base,(0x402),u.raw);
}

static inline void __DP(es_attrib_g_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(es_attrib_g_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x402));
    u.val.g = val;
    mackerel_write_addr_16(_dev->base,(0x402),u.raw);
}


static inline int __DP(es_attrib_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(es_attrib_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x402));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register es_attrib (Guest ES attrib):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.segtype;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " segtype =\t0x%"PRIx8" (Segment type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.s;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " s =\t0x%"PRIx8" (Segment descriptor type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dpl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dpl =\t0x%"PRIx8" (Descriptor privilege level", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.p;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " p =\t0x%"PRIx8" (Segment present", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.avl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " avl =\t0x%"PRIx8" (Available for use by system software", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.l;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " l =\t0x%"PRIx8" (64-bit code segment", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.db;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " db =\t0x%"PRIx8" (Default operation size (0: 16-bit, 1: 32-bit segment)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.g;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " g =\t0x%"PRIx8" (Granularity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register es_limit (Guest ES limit); type amd_vmcb.uint32
 */

static inline uint32_t __DP(es_limit_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(es_limit_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x404));
}

static inline uint32_t __DP(es_limit_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(es_limit_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x404));
}

static inline void __DP(es_limit_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(es_limit_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x404),val);
}

static inline void __DP(es_limit_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(es_limit_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x404),val);
}


static inline int __DP(es_limit_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(es_limit_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register es_limit (Guest ES limit):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x404)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register es_base (Guest ES base); type amd_vmcb.uint64
 */

static inline uint64_t __DP(es_base_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(es_base_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x408));
}

static inline uint64_t __DP(es_base_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(es_base_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x408));
}

static inline void __DP(es_base_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(es_base_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x408),val);
}

static inline void __DP(es_base_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(es_base_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x408),val);
}


static inline int __DP(es_base_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(es_base_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register es_base (Guest ES base):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x408)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register cs_selector (Guest CS selector); type amd_vmcb.uint16
 */

static inline uint16_t __DP(cs_selector_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(cs_selector_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x410));
}

static inline uint16_t __DP(cs_selector_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(cs_selector_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x410));
}

static inline void __DP(cs_selector_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(cs_selector_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x410),val);
}

static inline void __DP(cs_selector_wr)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(cs_selector_wr)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x410),val);
}


static inline int __DP(cs_selector_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cs_selector_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cs_selector (Guest CS selector):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_addr_16(_dev->base,(0x410)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register cs_attrib (Guest CS attrib); type amd_vmcb.seg_attrib (Segment attributes)
 */

/*
 * Dump of fields for register: cs_attrib
 *   segtype (size 4, offset 0):	 RW	  Segment type
 *   s (size 1, offset 4):	 RW	  Segment descriptor type
 *   dpl (size 2, offset 5):	 RW	  Descriptor privilege level
 *   p (size 1, offset 7):	 RW	  Segment present
 *   avl (size 1, offset 8):	 RW	  Available for use by system software
 *   l (size 1, offset 9):	 RW	  64-bit code segment
 *   db (size 1, offset 10):	 RW	  Default operation size (0: 16-bit, 1: 32-bit segment)
 *   g (size 1, offset 11):	 RW	  Granularity
 *   _anon12 (size 4, offset 12):	 RSVD	  _
 */

static inline uint16_t __DP(cs_attrib_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(cs_attrib_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x412));
}

static inline amd_vmcb_seg_attrib_t __DP(cs_attrib_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_seg_attrib_t __DP(cs_attrib_rd)( __DN(t) * _dev )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x412));
    return u.val;
}

static inline void __DP(cs_attrib_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(cs_attrib_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x412),val);
}

static inline void __DP(cs_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val ) __attribute__ ((always_inline));
static inline void __DP(cs_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x412));
    u.val.segtype 	= val.segtype;
    u.val.s 	= val.s;
    u.val.dpl 	= val.dpl;
    u.val.p 	= val.p;
    u.val.avl 	= val.avl;
    u.val.l 	= val.l;
    u.val.db 	= val.db;
    u.val.g 	= val.g;
    mackerel_write_addr_16(_dev->base,(0x412),u.raw);
}

static inline void __DP(cs_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cs_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x412));
    u.val.segtype = val;
    mackerel_write_addr_16(_dev->base,(0x412),u.raw);
}

static inline void __DP(cs_attrib_s_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cs_attrib_s_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x412));
    u.val.s = val;
    mackerel_write_addr_16(_dev->base,(0x412),u.raw);
}

static inline void __DP(cs_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cs_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x412));
    u.val.dpl = val;
    mackerel_write_addr_16(_dev->base,(0x412),u.raw);
}

static inline void __DP(cs_attrib_p_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cs_attrib_p_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x412));
    u.val.p = val;
    mackerel_write_addr_16(_dev->base,(0x412),u.raw);
}

static inline void __DP(cs_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cs_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x412));
    u.val.avl = val;
    mackerel_write_addr_16(_dev->base,(0x412),u.raw);
}

static inline void __DP(cs_attrib_l_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cs_attrib_l_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x412));
    u.val.l = val;
    mackerel_write_addr_16(_dev->base,(0x412),u.raw);
}

static inline void __DP(cs_attrib_db_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cs_attrib_db_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x412));
    u.val.db = val;
    mackerel_write_addr_16(_dev->base,(0x412),u.raw);
}

static inline void __DP(cs_attrib_g_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cs_attrib_g_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x412));
    u.val.g = val;
    mackerel_write_addr_16(_dev->base,(0x412),u.raw);
}


static inline int __DP(cs_attrib_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cs_attrib_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x412));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cs_attrib (Guest CS attrib):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.segtype;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " segtype =\t0x%"PRIx8" (Segment type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.s;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " s =\t0x%"PRIx8" (Segment descriptor type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dpl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dpl =\t0x%"PRIx8" (Descriptor privilege level", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.p;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " p =\t0x%"PRIx8" (Segment present", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.avl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " avl =\t0x%"PRIx8" (Available for use by system software", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.l;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " l =\t0x%"PRIx8" (64-bit code segment", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.db;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " db =\t0x%"PRIx8" (Default operation size (0: 16-bit, 1: 32-bit segment)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.g;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " g =\t0x%"PRIx8" (Granularity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register cs_limit (Guest CS limit); type amd_vmcb.uint32
 */

static inline uint32_t __DP(cs_limit_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(cs_limit_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x414));
}

static inline uint32_t __DP(cs_limit_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(cs_limit_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x414));
}

static inline void __DP(cs_limit_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(cs_limit_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x414),val);
}

static inline void __DP(cs_limit_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(cs_limit_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x414),val);
}


static inline int __DP(cs_limit_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cs_limit_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cs_limit (Guest CS limit):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x414)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register cs_base (Guest CS base); type amd_vmcb.uint64
 */

static inline uint64_t __DP(cs_base_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(cs_base_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x418));
}

static inline uint64_t __DP(cs_base_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(cs_base_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x418));
}

static inline void __DP(cs_base_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(cs_base_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x418),val);
}

static inline void __DP(cs_base_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(cs_base_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x418),val);
}


static inline int __DP(cs_base_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cs_base_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cs_base (Guest CS base):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x418)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ss_selector (Guest SS selector); type amd_vmcb.uint16
 */

static inline uint16_t __DP(ss_selector_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(ss_selector_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x420));
}

static inline uint16_t __DP(ss_selector_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(ss_selector_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x420));
}

static inline void __DP(ss_selector_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(ss_selector_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x420),val);
}

static inline void __DP(ss_selector_wr)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(ss_selector_wr)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x420),val);
}


static inline int __DP(ss_selector_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ss_selector_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ss_selector (Guest SS selector):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_addr_16(_dev->base,(0x420)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ss_attrib (Guest SS attrib); type amd_vmcb.seg_attrib (Segment attributes)
 */

/*
 * Dump of fields for register: ss_attrib
 *   segtype (size 4, offset 0):	 RW	  Segment type
 *   s (size 1, offset 4):	 RW	  Segment descriptor type
 *   dpl (size 2, offset 5):	 RW	  Descriptor privilege level
 *   p (size 1, offset 7):	 RW	  Segment present
 *   avl (size 1, offset 8):	 RW	  Available for use by system software
 *   l (size 1, offset 9):	 RW	  64-bit code segment
 *   db (size 1, offset 10):	 RW	  Default operation size (0: 16-bit, 1: 32-bit segment)
 *   g (size 1, offset 11):	 RW	  Granularity
 *   _anon12 (size 4, offset 12):	 RSVD	  _
 */

static inline uint16_t __DP(ss_attrib_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(ss_attrib_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x422));
}

static inline amd_vmcb_seg_attrib_t __DP(ss_attrib_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_seg_attrib_t __DP(ss_attrib_rd)( __DN(t) * _dev )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x422));
    return u.val;
}

static inline void __DP(ss_attrib_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(ss_attrib_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x422),val);
}

static inline void __DP(ss_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val ) __attribute__ ((always_inline));
static inline void __DP(ss_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x422));
    u.val.segtype 	= val.segtype;
    u.val.s 	= val.s;
    u.val.dpl 	= val.dpl;
    u.val.p 	= val.p;
    u.val.avl 	= val.avl;
    u.val.l 	= val.l;
    u.val.db 	= val.db;
    u.val.g 	= val.g;
    mackerel_write_addr_16(_dev->base,(0x422),u.raw);
}

static inline void __DP(ss_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ss_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x422));
    u.val.segtype = val;
    mackerel_write_addr_16(_dev->base,(0x422),u.raw);
}

static inline void __DP(ss_attrib_s_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ss_attrib_s_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x422));
    u.val.s = val;
    mackerel_write_addr_16(_dev->base,(0x422),u.raw);
}

static inline void __DP(ss_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ss_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x422));
    u.val.dpl = val;
    mackerel_write_addr_16(_dev->base,(0x422),u.raw);
}

static inline void __DP(ss_attrib_p_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ss_attrib_p_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x422));
    u.val.p = val;
    mackerel_write_addr_16(_dev->base,(0x422),u.raw);
}

static inline void __DP(ss_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ss_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x422));
    u.val.avl = val;
    mackerel_write_addr_16(_dev->base,(0x422),u.raw);
}

static inline void __DP(ss_attrib_l_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ss_attrib_l_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x422));
    u.val.l = val;
    mackerel_write_addr_16(_dev->base,(0x422),u.raw);
}

static inline void __DP(ss_attrib_db_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ss_attrib_db_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x422));
    u.val.db = val;
    mackerel_write_addr_16(_dev->base,(0x422),u.raw);
}

static inline void __DP(ss_attrib_g_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ss_attrib_g_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x422));
    u.val.g = val;
    mackerel_write_addr_16(_dev->base,(0x422),u.raw);
}


static inline int __DP(ss_attrib_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ss_attrib_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x422));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ss_attrib (Guest SS attrib):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.segtype;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " segtype =\t0x%"PRIx8" (Segment type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.s;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " s =\t0x%"PRIx8" (Segment descriptor type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dpl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dpl =\t0x%"PRIx8" (Descriptor privilege level", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.p;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " p =\t0x%"PRIx8" (Segment present", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.avl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " avl =\t0x%"PRIx8" (Available for use by system software", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.l;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " l =\t0x%"PRIx8" (64-bit code segment", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.db;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " db =\t0x%"PRIx8" (Default operation size (0: 16-bit, 1: 32-bit segment)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.g;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " g =\t0x%"PRIx8" (Granularity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register ss_limit (Guest SS limit); type amd_vmcb.uint32
 */

static inline uint32_t __DP(ss_limit_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ss_limit_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x424));
}

static inline uint32_t __DP(ss_limit_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ss_limit_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x424));
}

static inline void __DP(ss_limit_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ss_limit_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x424),val);
}

static inline void __DP(ss_limit_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ss_limit_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x424),val);
}


static inline int __DP(ss_limit_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ss_limit_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ss_limit (Guest SS limit):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x424)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ss_base (Guest SS base); type amd_vmcb.uint64
 */

static inline uint64_t __DP(ss_base_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(ss_base_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x428));
}

static inline uint64_t __DP(ss_base_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(ss_base_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x428));
}

static inline void __DP(ss_base_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(ss_base_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x428),val);
}

static inline void __DP(ss_base_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(ss_base_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x428),val);
}


static inline int __DP(ss_base_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ss_base_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ss_base (Guest SS base):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x428)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ds_selector (Guest DS selector); type amd_vmcb.uint16
 */

static inline uint16_t __DP(ds_selector_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(ds_selector_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x430));
}

static inline uint16_t __DP(ds_selector_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(ds_selector_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x430));
}

static inline void __DP(ds_selector_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(ds_selector_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x430),val);
}

static inline void __DP(ds_selector_wr)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(ds_selector_wr)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x430),val);
}


static inline int __DP(ds_selector_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ds_selector_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ds_selector (Guest DS selector):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_addr_16(_dev->base,(0x430)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ds_attrib (Guest DS attrib); type amd_vmcb.seg_attrib (Segment attributes)
 */

/*
 * Dump of fields for register: ds_attrib
 *   segtype (size 4, offset 0):	 RW	  Segment type
 *   s (size 1, offset 4):	 RW	  Segment descriptor type
 *   dpl (size 2, offset 5):	 RW	  Descriptor privilege level
 *   p (size 1, offset 7):	 RW	  Segment present
 *   avl (size 1, offset 8):	 RW	  Available for use by system software
 *   l (size 1, offset 9):	 RW	  64-bit code segment
 *   db (size 1, offset 10):	 RW	  Default operation size (0: 16-bit, 1: 32-bit segment)
 *   g (size 1, offset 11):	 RW	  Granularity
 *   _anon12 (size 4, offset 12):	 RSVD	  _
 */

static inline uint16_t __DP(ds_attrib_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(ds_attrib_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x432));
}

static inline amd_vmcb_seg_attrib_t __DP(ds_attrib_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_seg_attrib_t __DP(ds_attrib_rd)( __DN(t) * _dev )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x432));
    return u.val;
}

static inline void __DP(ds_attrib_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(ds_attrib_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x432),val);
}

static inline void __DP(ds_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val ) __attribute__ ((always_inline));
static inline void __DP(ds_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x432));
    u.val.segtype 	= val.segtype;
    u.val.s 	= val.s;
    u.val.dpl 	= val.dpl;
    u.val.p 	= val.p;
    u.val.avl 	= val.avl;
    u.val.l 	= val.l;
    u.val.db 	= val.db;
    u.val.g 	= val.g;
    mackerel_write_addr_16(_dev->base,(0x432),u.raw);
}

static inline void __DP(ds_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ds_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x432));
    u.val.segtype = val;
    mackerel_write_addr_16(_dev->base,(0x432),u.raw);
}

static inline void __DP(ds_attrib_s_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ds_attrib_s_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x432));
    u.val.s = val;
    mackerel_write_addr_16(_dev->base,(0x432),u.raw);
}

static inline void __DP(ds_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ds_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x432));
    u.val.dpl = val;
    mackerel_write_addr_16(_dev->base,(0x432),u.raw);
}

static inline void __DP(ds_attrib_p_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ds_attrib_p_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x432));
    u.val.p = val;
    mackerel_write_addr_16(_dev->base,(0x432),u.raw);
}

static inline void __DP(ds_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ds_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x432));
    u.val.avl = val;
    mackerel_write_addr_16(_dev->base,(0x432),u.raw);
}

static inline void __DP(ds_attrib_l_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ds_attrib_l_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x432));
    u.val.l = val;
    mackerel_write_addr_16(_dev->base,(0x432),u.raw);
}

static inline void __DP(ds_attrib_db_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ds_attrib_db_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x432));
    u.val.db = val;
    mackerel_write_addr_16(_dev->base,(0x432),u.raw);
}

static inline void __DP(ds_attrib_g_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ds_attrib_g_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x432));
    u.val.g = val;
    mackerel_write_addr_16(_dev->base,(0x432),u.raw);
}


static inline int __DP(ds_attrib_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ds_attrib_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x432));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ds_attrib (Guest DS attrib):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.segtype;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " segtype =\t0x%"PRIx8" (Segment type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.s;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " s =\t0x%"PRIx8" (Segment descriptor type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dpl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dpl =\t0x%"PRIx8" (Descriptor privilege level", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.p;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " p =\t0x%"PRIx8" (Segment present", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.avl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " avl =\t0x%"PRIx8" (Available for use by system software", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.l;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " l =\t0x%"PRIx8" (64-bit code segment", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.db;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " db =\t0x%"PRIx8" (Default operation size (0: 16-bit, 1: 32-bit segment)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.g;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " g =\t0x%"PRIx8" (Granularity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register ds_limit (Guest DS limit); type amd_vmcb.uint32
 */

static inline uint32_t __DP(ds_limit_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ds_limit_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x434));
}

static inline uint32_t __DP(ds_limit_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ds_limit_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x434));
}

static inline void __DP(ds_limit_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ds_limit_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x434),val);
}

static inline void __DP(ds_limit_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ds_limit_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x434),val);
}


static inline int __DP(ds_limit_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ds_limit_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ds_limit (Guest DS limit):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x434)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ds_base (Guest DS base); type amd_vmcb.uint64
 */

static inline uint64_t __DP(ds_base_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(ds_base_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x438));
}

static inline uint64_t __DP(ds_base_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(ds_base_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x438));
}

static inline void __DP(ds_base_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(ds_base_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x438),val);
}

static inline void __DP(ds_base_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(ds_base_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x438),val);
}


static inline int __DP(ds_base_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ds_base_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ds_base (Guest DS base):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x438)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register fs_selector (Guest FS selector); type amd_vmcb.uint16
 */

static inline uint16_t __DP(fs_selector_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(fs_selector_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x440));
}

static inline uint16_t __DP(fs_selector_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(fs_selector_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x440));
}

static inline void __DP(fs_selector_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(fs_selector_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x440),val);
}

static inline void __DP(fs_selector_wr)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(fs_selector_wr)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x440),val);
}


static inline int __DP(fs_selector_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(fs_selector_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register fs_selector (Guest FS selector):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_addr_16(_dev->base,(0x440)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register fs_attrib (Guest FS attrib); type amd_vmcb.seg_attrib (Segment attributes)
 */

/*
 * Dump of fields for register: fs_attrib
 *   segtype (size 4, offset 0):	 RW	  Segment type
 *   s (size 1, offset 4):	 RW	  Segment descriptor type
 *   dpl (size 2, offset 5):	 RW	  Descriptor privilege level
 *   p (size 1, offset 7):	 RW	  Segment present
 *   avl (size 1, offset 8):	 RW	  Available for use by system software
 *   l (size 1, offset 9):	 RW	  64-bit code segment
 *   db (size 1, offset 10):	 RW	  Default operation size (0: 16-bit, 1: 32-bit segment)
 *   g (size 1, offset 11):	 RW	  Granularity
 *   _anon12 (size 4, offset 12):	 RSVD	  _
 */

static inline uint16_t __DP(fs_attrib_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(fs_attrib_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x442));
}

static inline amd_vmcb_seg_attrib_t __DP(fs_attrib_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_seg_attrib_t __DP(fs_attrib_rd)( __DN(t) * _dev )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x442));
    return u.val;
}

static inline void __DP(fs_attrib_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(fs_attrib_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x442),val);
}

static inline void __DP(fs_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val ) __attribute__ ((always_inline));
static inline void __DP(fs_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x442));
    u.val.segtype 	= val.segtype;
    u.val.s 	= val.s;
    u.val.dpl 	= val.dpl;
    u.val.p 	= val.p;
    u.val.avl 	= val.avl;
    u.val.l 	= val.l;
    u.val.db 	= val.db;
    u.val.g 	= val.g;
    mackerel_write_addr_16(_dev->base,(0x442),u.raw);
}

static inline void __DP(fs_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fs_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x442));
    u.val.segtype = val;
    mackerel_write_addr_16(_dev->base,(0x442),u.raw);
}

static inline void __DP(fs_attrib_s_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fs_attrib_s_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x442));
    u.val.s = val;
    mackerel_write_addr_16(_dev->base,(0x442),u.raw);
}

static inline void __DP(fs_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fs_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x442));
    u.val.dpl = val;
    mackerel_write_addr_16(_dev->base,(0x442),u.raw);
}

static inline void __DP(fs_attrib_p_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fs_attrib_p_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x442));
    u.val.p = val;
    mackerel_write_addr_16(_dev->base,(0x442),u.raw);
}

static inline void __DP(fs_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fs_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x442));
    u.val.avl = val;
    mackerel_write_addr_16(_dev->base,(0x442),u.raw);
}

static inline void __DP(fs_attrib_l_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fs_attrib_l_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x442));
    u.val.l = val;
    mackerel_write_addr_16(_dev->base,(0x442),u.raw);
}

static inline void __DP(fs_attrib_db_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fs_attrib_db_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x442));
    u.val.db = val;
    mackerel_write_addr_16(_dev->base,(0x442),u.raw);
}

static inline void __DP(fs_attrib_g_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fs_attrib_g_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x442));
    u.val.g = val;
    mackerel_write_addr_16(_dev->base,(0x442),u.raw);
}


static inline int __DP(fs_attrib_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(fs_attrib_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x442));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register fs_attrib (Guest FS attrib):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.segtype;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " segtype =\t0x%"PRIx8" (Segment type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.s;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " s =\t0x%"PRIx8" (Segment descriptor type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dpl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dpl =\t0x%"PRIx8" (Descriptor privilege level", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.p;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " p =\t0x%"PRIx8" (Segment present", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.avl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " avl =\t0x%"PRIx8" (Available for use by system software", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.l;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " l =\t0x%"PRIx8" (64-bit code segment", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.db;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " db =\t0x%"PRIx8" (Default operation size (0: 16-bit, 1: 32-bit segment)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.g;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " g =\t0x%"PRIx8" (Granularity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register fs_limit (Guest FS limit); type amd_vmcb.uint32
 */

static inline uint32_t __DP(fs_limit_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(fs_limit_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x444));
}

static inline uint32_t __DP(fs_limit_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(fs_limit_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x444));
}

static inline void __DP(fs_limit_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(fs_limit_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x444),val);
}

static inline void __DP(fs_limit_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(fs_limit_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x444),val);
}


static inline int __DP(fs_limit_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(fs_limit_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register fs_limit (Guest FS limit):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x444)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register fs_base (Guest FS base); type amd_vmcb.uint64
 */

static inline uint64_t __DP(fs_base_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(fs_base_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x448));
}

static inline uint64_t __DP(fs_base_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(fs_base_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x448));
}

static inline void __DP(fs_base_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(fs_base_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x448),val);
}

static inline void __DP(fs_base_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(fs_base_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x448),val);
}


static inline int __DP(fs_base_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(fs_base_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register fs_base (Guest FS base):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x448)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register gs_selector (Guest GS selector); type amd_vmcb.uint16
 */

static inline uint16_t __DP(gs_selector_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(gs_selector_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x450));
}

static inline uint16_t __DP(gs_selector_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(gs_selector_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x450));
}

static inline void __DP(gs_selector_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(gs_selector_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x450),val);
}

static inline void __DP(gs_selector_wr)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(gs_selector_wr)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x450),val);
}


static inline int __DP(gs_selector_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gs_selector_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gs_selector (Guest GS selector):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_addr_16(_dev->base,(0x450)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register gs_attrib (Guest GS attrib); type amd_vmcb.seg_attrib (Segment attributes)
 */

/*
 * Dump of fields for register: gs_attrib
 *   segtype (size 4, offset 0):	 RW	  Segment type
 *   s (size 1, offset 4):	 RW	  Segment descriptor type
 *   dpl (size 2, offset 5):	 RW	  Descriptor privilege level
 *   p (size 1, offset 7):	 RW	  Segment present
 *   avl (size 1, offset 8):	 RW	  Available for use by system software
 *   l (size 1, offset 9):	 RW	  64-bit code segment
 *   db (size 1, offset 10):	 RW	  Default operation size (0: 16-bit, 1: 32-bit segment)
 *   g (size 1, offset 11):	 RW	  Granularity
 *   _anon12 (size 4, offset 12):	 RSVD	  _
 */

static inline uint16_t __DP(gs_attrib_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(gs_attrib_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x452));
}

static inline amd_vmcb_seg_attrib_t __DP(gs_attrib_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_seg_attrib_t __DP(gs_attrib_rd)( __DN(t) * _dev )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x452));
    return u.val;
}

static inline void __DP(gs_attrib_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(gs_attrib_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x452),val);
}

static inline void __DP(gs_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val ) __attribute__ ((always_inline));
static inline void __DP(gs_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x452));
    u.val.segtype 	= val.segtype;
    u.val.s 	= val.s;
    u.val.dpl 	= val.dpl;
    u.val.p 	= val.p;
    u.val.avl 	= val.avl;
    u.val.l 	= val.l;
    u.val.db 	= val.db;
    u.val.g 	= val.g;
    mackerel_write_addr_16(_dev->base,(0x452),u.raw);
}

static inline void __DP(gs_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gs_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x452));
    u.val.segtype = val;
    mackerel_write_addr_16(_dev->base,(0x452),u.raw);
}

static inline void __DP(gs_attrib_s_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gs_attrib_s_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x452));
    u.val.s = val;
    mackerel_write_addr_16(_dev->base,(0x452),u.raw);
}

static inline void __DP(gs_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gs_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x452));
    u.val.dpl = val;
    mackerel_write_addr_16(_dev->base,(0x452),u.raw);
}

static inline void __DP(gs_attrib_p_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gs_attrib_p_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x452));
    u.val.p = val;
    mackerel_write_addr_16(_dev->base,(0x452),u.raw);
}

static inline void __DP(gs_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gs_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x452));
    u.val.avl = val;
    mackerel_write_addr_16(_dev->base,(0x452),u.raw);
}

static inline void __DP(gs_attrib_l_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gs_attrib_l_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x452));
    u.val.l = val;
    mackerel_write_addr_16(_dev->base,(0x452),u.raw);
}

static inline void __DP(gs_attrib_db_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gs_attrib_db_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x452));
    u.val.db = val;
    mackerel_write_addr_16(_dev->base,(0x452),u.raw);
}

static inline void __DP(gs_attrib_g_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gs_attrib_g_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x452));
    u.val.g = val;
    mackerel_write_addr_16(_dev->base,(0x452),u.raw);
}


static inline int __DP(gs_attrib_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gs_attrib_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x452));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gs_attrib (Guest GS attrib):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.segtype;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " segtype =\t0x%"PRIx8" (Segment type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.s;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " s =\t0x%"PRIx8" (Segment descriptor type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dpl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dpl =\t0x%"PRIx8" (Descriptor privilege level", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.p;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " p =\t0x%"PRIx8" (Segment present", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.avl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " avl =\t0x%"PRIx8" (Available for use by system software", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.l;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " l =\t0x%"PRIx8" (64-bit code segment", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.db;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " db =\t0x%"PRIx8" (Default operation size (0: 16-bit, 1: 32-bit segment)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.g;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " g =\t0x%"PRIx8" (Granularity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register gs_limit (Guest GS limit); type amd_vmcb.uint32
 */

static inline uint32_t __DP(gs_limit_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gs_limit_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x454));
}

static inline uint32_t __DP(gs_limit_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gs_limit_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x454));
}

static inline void __DP(gs_limit_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(gs_limit_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x454),val);
}

static inline void __DP(gs_limit_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(gs_limit_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x454),val);
}


static inline int __DP(gs_limit_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gs_limit_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gs_limit (Guest GS limit):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x454)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register gs_base (Guest GS base); type amd_vmcb.uint64
 */

static inline uint64_t __DP(gs_base_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(gs_base_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x458));
}

static inline uint64_t __DP(gs_base_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(gs_base_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x458));
}

static inline void __DP(gs_base_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(gs_base_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x458),val);
}

static inline void __DP(gs_base_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(gs_base_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x458),val);
}


static inline int __DP(gs_base_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gs_base_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gs_base (Guest GS base):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x458)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register gdtr_selector (Guest GTDR selector); type amd_vmcb.uint16
 */

static inline uint16_t __DP(gdtr_selector_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(gdtr_selector_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x460));
}

static inline uint16_t __DP(gdtr_selector_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(gdtr_selector_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x460));
}

static inline void __DP(gdtr_selector_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(gdtr_selector_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x460),val);
}

static inline void __DP(gdtr_selector_wr)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(gdtr_selector_wr)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x460),val);
}


static inline int __DP(gdtr_selector_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gdtr_selector_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gdtr_selector (Guest GTDR selector):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_addr_16(_dev->base,(0x460)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register gdtr_attrib (Guest GTDR attrib); type amd_vmcb.seg_attrib (Segment attributes)
 */

/*
 * Dump of fields for register: gdtr_attrib
 *   segtype (size 4, offset 0):	 RW	  Segment type
 *   s (size 1, offset 4):	 RW	  Segment descriptor type
 *   dpl (size 2, offset 5):	 RW	  Descriptor privilege level
 *   p (size 1, offset 7):	 RW	  Segment present
 *   avl (size 1, offset 8):	 RW	  Available for use by system software
 *   l (size 1, offset 9):	 RW	  64-bit code segment
 *   db (size 1, offset 10):	 RW	  Default operation size (0: 16-bit, 1: 32-bit segment)
 *   g (size 1, offset 11):	 RW	  Granularity
 *   _anon12 (size 4, offset 12):	 RSVD	  _
 */

static inline uint16_t __DP(gdtr_attrib_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(gdtr_attrib_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x462));
}

static inline amd_vmcb_seg_attrib_t __DP(gdtr_attrib_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_seg_attrib_t __DP(gdtr_attrib_rd)( __DN(t) * _dev )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x462));
    return u.val;
}

static inline void __DP(gdtr_attrib_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(gdtr_attrib_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x462),val);
}

static inline void __DP(gdtr_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val ) __attribute__ ((always_inline));
static inline void __DP(gdtr_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x462));
    u.val.segtype 	= val.segtype;
    u.val.s 	= val.s;
    u.val.dpl 	= val.dpl;
    u.val.p 	= val.p;
    u.val.avl 	= val.avl;
    u.val.l 	= val.l;
    u.val.db 	= val.db;
    u.val.g 	= val.g;
    mackerel_write_addr_16(_dev->base,(0x462),u.raw);
}

static inline void __DP(gdtr_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gdtr_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x462));
    u.val.segtype = val;
    mackerel_write_addr_16(_dev->base,(0x462),u.raw);
}

static inline void __DP(gdtr_attrib_s_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gdtr_attrib_s_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x462));
    u.val.s = val;
    mackerel_write_addr_16(_dev->base,(0x462),u.raw);
}

static inline void __DP(gdtr_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gdtr_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x462));
    u.val.dpl = val;
    mackerel_write_addr_16(_dev->base,(0x462),u.raw);
}

static inline void __DP(gdtr_attrib_p_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gdtr_attrib_p_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x462));
    u.val.p = val;
    mackerel_write_addr_16(_dev->base,(0x462),u.raw);
}

static inline void __DP(gdtr_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gdtr_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x462));
    u.val.avl = val;
    mackerel_write_addr_16(_dev->base,(0x462),u.raw);
}

static inline void __DP(gdtr_attrib_l_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gdtr_attrib_l_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x462));
    u.val.l = val;
    mackerel_write_addr_16(_dev->base,(0x462),u.raw);
}

static inline void __DP(gdtr_attrib_db_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gdtr_attrib_db_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x462));
    u.val.db = val;
    mackerel_write_addr_16(_dev->base,(0x462),u.raw);
}

static inline void __DP(gdtr_attrib_g_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(gdtr_attrib_g_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x462));
    u.val.g = val;
    mackerel_write_addr_16(_dev->base,(0x462),u.raw);
}


static inline int __DP(gdtr_attrib_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gdtr_attrib_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x462));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gdtr_attrib (Guest GTDR attrib):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.segtype;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " segtype =\t0x%"PRIx8" (Segment type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.s;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " s =\t0x%"PRIx8" (Segment descriptor type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dpl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dpl =\t0x%"PRIx8" (Descriptor privilege level", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.p;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " p =\t0x%"PRIx8" (Segment present", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.avl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " avl =\t0x%"PRIx8" (Available for use by system software", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.l;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " l =\t0x%"PRIx8" (64-bit code segment", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.db;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " db =\t0x%"PRIx8" (Default operation size (0: 16-bit, 1: 32-bit segment)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.g;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " g =\t0x%"PRIx8" (Granularity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register gdtr_limit (Guest GTDR limit); type amd_vmcb.uint32
 */

static inline uint32_t __DP(gdtr_limit_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gdtr_limit_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x464));
}

static inline uint32_t __DP(gdtr_limit_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(gdtr_limit_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x464));
}

static inline void __DP(gdtr_limit_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(gdtr_limit_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x464),val);
}

static inline void __DP(gdtr_limit_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(gdtr_limit_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x464),val);
}


static inline int __DP(gdtr_limit_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gdtr_limit_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gdtr_limit (Guest GTDR limit):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x464)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register gdtr_base (Guest GTDR base); type amd_vmcb.uint64
 */

static inline uint64_t __DP(gdtr_base_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(gdtr_base_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x468));
}

static inline uint64_t __DP(gdtr_base_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(gdtr_base_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x468));
}

static inline void __DP(gdtr_base_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(gdtr_base_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x468),val);
}

static inline void __DP(gdtr_base_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(gdtr_base_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x468),val);
}


static inline int __DP(gdtr_base_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gdtr_base_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gdtr_base (Guest GTDR base):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x468)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ldtr_selector (Guest LTDR selector); type amd_vmcb.uint16
 */

static inline uint16_t __DP(ldtr_selector_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(ldtr_selector_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x470));
}

static inline uint16_t __DP(ldtr_selector_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(ldtr_selector_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x470));
}

static inline void __DP(ldtr_selector_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(ldtr_selector_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x470),val);
}

static inline void __DP(ldtr_selector_wr)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(ldtr_selector_wr)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x470),val);
}


static inline int __DP(ldtr_selector_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ldtr_selector_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ldtr_selector (Guest LTDR selector):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_addr_16(_dev->base,(0x470)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ldtr_attrib (Guest LTDR attrib); type amd_vmcb.seg_attrib (Segment attributes)
 */

/*
 * Dump of fields for register: ldtr_attrib
 *   segtype (size 4, offset 0):	 RW	  Segment type
 *   s (size 1, offset 4):	 RW	  Segment descriptor type
 *   dpl (size 2, offset 5):	 RW	  Descriptor privilege level
 *   p (size 1, offset 7):	 RW	  Segment present
 *   avl (size 1, offset 8):	 RW	  Available for use by system software
 *   l (size 1, offset 9):	 RW	  64-bit code segment
 *   db (size 1, offset 10):	 RW	  Default operation size (0: 16-bit, 1: 32-bit segment)
 *   g (size 1, offset 11):	 RW	  Granularity
 *   _anon12 (size 4, offset 12):	 RSVD	  _
 */

static inline uint16_t __DP(ldtr_attrib_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(ldtr_attrib_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x472));
}

static inline amd_vmcb_seg_attrib_t __DP(ldtr_attrib_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_seg_attrib_t __DP(ldtr_attrib_rd)( __DN(t) * _dev )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x472));
    return u.val;
}

static inline void __DP(ldtr_attrib_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(ldtr_attrib_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x472),val);
}

static inline void __DP(ldtr_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val ) __attribute__ ((always_inline));
static inline void __DP(ldtr_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x472));
    u.val.segtype 	= val.segtype;
    u.val.s 	= val.s;
    u.val.dpl 	= val.dpl;
    u.val.p 	= val.p;
    u.val.avl 	= val.avl;
    u.val.l 	= val.l;
    u.val.db 	= val.db;
    u.val.g 	= val.g;
    mackerel_write_addr_16(_dev->base,(0x472),u.raw);
}

static inline void __DP(ldtr_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ldtr_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x472));
    u.val.segtype = val;
    mackerel_write_addr_16(_dev->base,(0x472),u.raw);
}

static inline void __DP(ldtr_attrib_s_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ldtr_attrib_s_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x472));
    u.val.s = val;
    mackerel_write_addr_16(_dev->base,(0x472),u.raw);
}

static inline void __DP(ldtr_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ldtr_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x472));
    u.val.dpl = val;
    mackerel_write_addr_16(_dev->base,(0x472),u.raw);
}

static inline void __DP(ldtr_attrib_p_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ldtr_attrib_p_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x472));
    u.val.p = val;
    mackerel_write_addr_16(_dev->base,(0x472),u.raw);
}

static inline void __DP(ldtr_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ldtr_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x472));
    u.val.avl = val;
    mackerel_write_addr_16(_dev->base,(0x472),u.raw);
}

static inline void __DP(ldtr_attrib_l_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ldtr_attrib_l_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x472));
    u.val.l = val;
    mackerel_write_addr_16(_dev->base,(0x472),u.raw);
}

static inline void __DP(ldtr_attrib_db_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ldtr_attrib_db_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x472));
    u.val.db = val;
    mackerel_write_addr_16(_dev->base,(0x472),u.raw);
}

static inline void __DP(ldtr_attrib_g_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ldtr_attrib_g_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x472));
    u.val.g = val;
    mackerel_write_addr_16(_dev->base,(0x472),u.raw);
}


static inline int __DP(ldtr_attrib_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ldtr_attrib_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x472));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ldtr_attrib (Guest LTDR attrib):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.segtype;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " segtype =\t0x%"PRIx8" (Segment type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.s;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " s =\t0x%"PRIx8" (Segment descriptor type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dpl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dpl =\t0x%"PRIx8" (Descriptor privilege level", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.p;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " p =\t0x%"PRIx8" (Segment present", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.avl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " avl =\t0x%"PRIx8" (Available for use by system software", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.l;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " l =\t0x%"PRIx8" (64-bit code segment", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.db;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " db =\t0x%"PRIx8" (Default operation size (0: 16-bit, 1: 32-bit segment)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.g;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " g =\t0x%"PRIx8" (Granularity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register ldtr_limit (Guest LTDR limit); type amd_vmcb.uint32
 */

static inline uint32_t __DP(ldtr_limit_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ldtr_limit_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x474));
}

static inline uint32_t __DP(ldtr_limit_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ldtr_limit_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x474));
}

static inline void __DP(ldtr_limit_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ldtr_limit_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x474),val);
}

static inline void __DP(ldtr_limit_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ldtr_limit_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x474),val);
}


static inline int __DP(ldtr_limit_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ldtr_limit_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ldtr_limit (Guest LTDR limit):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x474)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ldtr_base (Guest LTDR base); type amd_vmcb.uint64
 */

static inline uint64_t __DP(ldtr_base_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(ldtr_base_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x478));
}

static inline uint64_t __DP(ldtr_base_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(ldtr_base_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x478));
}

static inline void __DP(ldtr_base_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(ldtr_base_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x478),val);
}

static inline void __DP(ldtr_base_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(ldtr_base_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x478),val);
}


static inline int __DP(ldtr_base_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ldtr_base_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ldtr_base (Guest LTDR base):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x478)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register idtr_selector (Guest ITDR selector); type amd_vmcb.uint16
 */

static inline uint16_t __DP(idtr_selector_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(idtr_selector_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x480));
}

static inline uint16_t __DP(idtr_selector_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(idtr_selector_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x480));
}

static inline void __DP(idtr_selector_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(idtr_selector_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x480),val);
}

static inline void __DP(idtr_selector_wr)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(idtr_selector_wr)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x480),val);
}


static inline int __DP(idtr_selector_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(idtr_selector_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register idtr_selector (Guest ITDR selector):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_addr_16(_dev->base,(0x480)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register idtr_attrib (Guest ITDR attrib); type amd_vmcb.seg_attrib (Segment attributes)
 */

/*
 * Dump of fields for register: idtr_attrib
 *   segtype (size 4, offset 0):	 RW	  Segment type
 *   s (size 1, offset 4):	 RW	  Segment descriptor type
 *   dpl (size 2, offset 5):	 RW	  Descriptor privilege level
 *   p (size 1, offset 7):	 RW	  Segment present
 *   avl (size 1, offset 8):	 RW	  Available for use by system software
 *   l (size 1, offset 9):	 RW	  64-bit code segment
 *   db (size 1, offset 10):	 RW	  Default operation size (0: 16-bit, 1: 32-bit segment)
 *   g (size 1, offset 11):	 RW	  Granularity
 *   _anon12 (size 4, offset 12):	 RSVD	  _
 */

static inline uint16_t __DP(idtr_attrib_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(idtr_attrib_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x482));
}

static inline amd_vmcb_seg_attrib_t __DP(idtr_attrib_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_seg_attrib_t __DP(idtr_attrib_rd)( __DN(t) * _dev )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x482));
    return u.val;
}

static inline void __DP(idtr_attrib_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(idtr_attrib_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x482),val);
}

static inline void __DP(idtr_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val ) __attribute__ ((always_inline));
static inline void __DP(idtr_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x482));
    u.val.segtype 	= val.segtype;
    u.val.s 	= val.s;
    u.val.dpl 	= val.dpl;
    u.val.p 	= val.p;
    u.val.avl 	= val.avl;
    u.val.l 	= val.l;
    u.val.db 	= val.db;
    u.val.g 	= val.g;
    mackerel_write_addr_16(_dev->base,(0x482),u.raw);
}

static inline void __DP(idtr_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(idtr_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x482));
    u.val.segtype = val;
    mackerel_write_addr_16(_dev->base,(0x482),u.raw);
}

static inline void __DP(idtr_attrib_s_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(idtr_attrib_s_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x482));
    u.val.s = val;
    mackerel_write_addr_16(_dev->base,(0x482),u.raw);
}

static inline void __DP(idtr_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(idtr_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x482));
    u.val.dpl = val;
    mackerel_write_addr_16(_dev->base,(0x482),u.raw);
}

static inline void __DP(idtr_attrib_p_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(idtr_attrib_p_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x482));
    u.val.p = val;
    mackerel_write_addr_16(_dev->base,(0x482),u.raw);
}

static inline void __DP(idtr_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(idtr_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x482));
    u.val.avl = val;
    mackerel_write_addr_16(_dev->base,(0x482),u.raw);
}

static inline void __DP(idtr_attrib_l_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(idtr_attrib_l_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x482));
    u.val.l = val;
    mackerel_write_addr_16(_dev->base,(0x482),u.raw);
}

static inline void __DP(idtr_attrib_db_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(idtr_attrib_db_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x482));
    u.val.db = val;
    mackerel_write_addr_16(_dev->base,(0x482),u.raw);
}

static inline void __DP(idtr_attrib_g_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(idtr_attrib_g_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x482));
    u.val.g = val;
    mackerel_write_addr_16(_dev->base,(0x482),u.raw);
}


static inline int __DP(idtr_attrib_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(idtr_attrib_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x482));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register idtr_attrib (Guest ITDR attrib):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.segtype;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " segtype =\t0x%"PRIx8" (Segment type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.s;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " s =\t0x%"PRIx8" (Segment descriptor type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dpl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dpl =\t0x%"PRIx8" (Descriptor privilege level", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.p;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " p =\t0x%"PRIx8" (Segment present", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.avl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " avl =\t0x%"PRIx8" (Available for use by system software", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.l;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " l =\t0x%"PRIx8" (64-bit code segment", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.db;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " db =\t0x%"PRIx8" (Default operation size (0: 16-bit, 1: 32-bit segment)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.g;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " g =\t0x%"PRIx8" (Granularity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register idtr_limit (Guest ITDR limit); type amd_vmcb.uint32
 */

static inline uint32_t __DP(idtr_limit_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(idtr_limit_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x484));
}

static inline uint32_t __DP(idtr_limit_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(idtr_limit_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x484));
}

static inline void __DP(idtr_limit_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(idtr_limit_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x484),val);
}

static inline void __DP(idtr_limit_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(idtr_limit_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x484),val);
}


static inline int __DP(idtr_limit_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(idtr_limit_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register idtr_limit (Guest ITDR limit):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x484)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register idtr_base (Guest ITDR base); type amd_vmcb.uint64
 */

static inline uint64_t __DP(idtr_base_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(idtr_base_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x488));
}

static inline uint64_t __DP(idtr_base_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(idtr_base_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x488));
}

static inline void __DP(idtr_base_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(idtr_base_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x488),val);
}

static inline void __DP(idtr_base_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(idtr_base_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x488),val);
}


static inline int __DP(idtr_base_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(idtr_base_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register idtr_base (Guest ITDR base):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x488)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register tr_selector (Guest TR selector); type amd_vmcb.uint16
 */

static inline uint16_t __DP(tr_selector_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(tr_selector_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x490));
}

static inline uint16_t __DP(tr_selector_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(tr_selector_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x490));
}

static inline void __DP(tr_selector_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(tr_selector_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x490),val);
}

static inline void __DP(tr_selector_wr)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(tr_selector_wr)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x490),val);
}


static inline int __DP(tr_selector_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tr_selector_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tr_selector (Guest TR selector):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_addr_16(_dev->base,(0x490)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register tr_attrib (Guest TR attrib); type amd_vmcb.seg_attrib (Segment attributes)
 */

/*
 * Dump of fields for register: tr_attrib
 *   segtype (size 4, offset 0):	 RW	  Segment type
 *   s (size 1, offset 4):	 RW	  Segment descriptor type
 *   dpl (size 2, offset 5):	 RW	  Descriptor privilege level
 *   p (size 1, offset 7):	 RW	  Segment present
 *   avl (size 1, offset 8):	 RW	  Available for use by system software
 *   l (size 1, offset 9):	 RW	  64-bit code segment
 *   db (size 1, offset 10):	 RW	  Default operation size (0: 16-bit, 1: 32-bit segment)
 *   g (size 1, offset 11):	 RW	  Granularity
 *   _anon12 (size 4, offset 12):	 RSVD	  _
 */

static inline uint16_t __DP(tr_attrib_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(tr_attrib_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0x492));
}

static inline amd_vmcb_seg_attrib_t __DP(tr_attrib_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_seg_attrib_t __DP(tr_attrib_rd)( __DN(t) * _dev )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x492));
    return u.val;
}

static inline void __DP(tr_attrib_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(tr_attrib_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0x492),val);
}

static inline void __DP(tr_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val ) __attribute__ ((always_inline));
static inline void __DP(tr_attrib_wr)( __DN(t) * _dev, amd_vmcb_seg_attrib_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x492));
    u.val.segtype 	= val.segtype;
    u.val.s 	= val.s;
    u.val.dpl 	= val.dpl;
    u.val.p 	= val.p;
    u.val.avl 	= val.avl;
    u.val.l 	= val.l;
    u.val.db 	= val.db;
    u.val.g 	= val.g;
    mackerel_write_addr_16(_dev->base,(0x492),u.raw);
}

static inline void __DP(tr_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tr_attrib_segtype_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x492));
    u.val.segtype = val;
    mackerel_write_addr_16(_dev->base,(0x492),u.raw);
}

static inline void __DP(tr_attrib_s_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tr_attrib_s_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x492));
    u.val.s = val;
    mackerel_write_addr_16(_dev->base,(0x492),u.raw);
}

static inline void __DP(tr_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tr_attrib_dpl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x492));
    u.val.dpl = val;
    mackerel_write_addr_16(_dev->base,(0x492),u.raw);
}

static inline void __DP(tr_attrib_p_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tr_attrib_p_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x492));
    u.val.p = val;
    mackerel_write_addr_16(_dev->base,(0x492),u.raw);
}

static inline void __DP(tr_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tr_attrib_avl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x492));
    u.val.avl = val;
    mackerel_write_addr_16(_dev->base,(0x492),u.raw);
}

static inline void __DP(tr_attrib_l_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tr_attrib_l_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x492));
    u.val.l = val;
    mackerel_write_addr_16(_dev->base,(0x492),u.raw);
}

static inline void __DP(tr_attrib_db_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tr_attrib_db_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x492));
    u.val.db = val;
    mackerel_write_addr_16(_dev->base,(0x492),u.raw);
}

static inline void __DP(tr_attrib_g_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tr_attrib_g_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x492));
    u.val.g = val;
    mackerel_write_addr_16(_dev->base,(0x492),u.raw);
}


static inline int __DP(tr_attrib_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tr_attrib_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_seg_attrib_un  u;
    u.raw = mackerel_read_addr_16(_dev->base,(0x492));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tr_attrib (Guest TR attrib):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.segtype;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " segtype =\t0x%"PRIx8" (Segment type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.s;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " s =\t0x%"PRIx8" (Segment descriptor type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dpl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dpl =\t0x%"PRIx8" (Descriptor privilege level", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.p;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " p =\t0x%"PRIx8" (Segment present", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.avl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " avl =\t0x%"PRIx8" (Available for use by system software", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.l;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " l =\t0x%"PRIx8" (64-bit code segment", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.db;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " db =\t0x%"PRIx8" (Default operation size (0: 16-bit, 1: 32-bit segment)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.g;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " g =\t0x%"PRIx8" (Granularity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register tr_limit (Guest TR limit); type amd_vmcb.uint32
 */

static inline uint32_t __DP(tr_limit_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tr_limit_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x494));
}

static inline uint32_t __DP(tr_limit_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tr_limit_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x494));
}

static inline void __DP(tr_limit_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(tr_limit_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x494),val);
}

static inline void __DP(tr_limit_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(tr_limit_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x494),val);
}


static inline int __DP(tr_limit_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tr_limit_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tr_limit (Guest TR limit):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x494)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register tr_base (Guest TR base); type amd_vmcb.uint64
 */

static inline uint64_t __DP(tr_base_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(tr_base_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x498));
}

static inline uint64_t __DP(tr_base_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(tr_base_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x498));
}

static inline void __DP(tr_base_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(tr_base_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x498),val);
}

static inline void __DP(tr_base_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(tr_base_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x498),val);
}


static inline int __DP(tr_base_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tr_base_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tr_base (Guest TR base):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x498)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register cpl (Guest current protection level); type amd_vmcb.uint8
 */

static inline uint8_t __DP(cpl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(cpl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0x4cb));
}

static inline uint8_t __DP(cpl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(cpl_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0x4cb));
}

static inline void __DP(cpl_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cpl_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x4cb),val);
}

static inline void __DP(cpl_wr)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cpl_wr)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x4cb),val);
}


static inline int __DP(cpl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cpl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cpl (Guest current protection level):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_addr_8(_dev->base,(0x4cb)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register efer (Guest EFER); type amd_vmcb.efer (Implicit type of Guest EFER register)
 */

/*
 * Dump of fields for register: efer
 *   sce (size 1, offset 0):	 RW	  System Call Extensions
 *   _anon1 (size 7, offset 1):	 MBZ	  _
 *   lme (size 1, offset 8):	 RW	  Long Mode Enable
 *   _anon9 (size 1, offset 9):	 MBZ	  _
 *   lma (size 1, offset 10):	 RW	  Long Mode Active
 *   nxe (size 1, offset 11):	 RW	  No-Execute Enable
 *   svme (size 1, offset 12):	 RW	  Secure Virtual Machine Enable
 *   _anon13 (size 1, offset 13):	 MBZ	  _
 *   ffxsr (size 1, offset 14):	 RW	  Fast FXSAVE/FXRSTOR
 *   _anon15 (size 49, offset 15):	 MBZ	  _
 */

static inline uint64_t __DP(efer_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(efer_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x4d0));
}

static inline amd_vmcb_efer_t __DP(efer_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_efer_t __DP(efer_rd)( __DN(t) * _dev )
{
    amd_vmcb_efer_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x4d0));
    return u.val;
}

static inline void __DP(efer_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(efer_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x4d0),val);
}

static inline void __DP(efer_wr)( __DN(t) * _dev, amd_vmcb_efer_t val ) __attribute__ ((always_inline));
static inline void __DP(efer_wr)( __DN(t) * _dev, amd_vmcb_efer_t val )
{
    amd_vmcb_efer_un  u;
    u.val = val;
    u.val._anon1 	= 0;
    u.val._anon9 	= 0;
    u.val._anon13 	= 0;
    u.val._anon15 	= 0;
    mackerel_write_addr_64(_dev->base,(0x4d0),u.raw);
}

static inline void __DP(efer_sce_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(efer_sce_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_efer_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x4d0));
    u.val._anon1 	= 0;
    u.val._anon9 	= 0;
    u.val._anon13 	= 0;
    u.val._anon15 	= 0;
    u.val.sce = val;
    mackerel_write_addr_64(_dev->base,(0x4d0),u.raw);
}

static inline void __DP(efer_lme_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(efer_lme_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_efer_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x4d0));
    u.val._anon1 	= 0;
    u.val._anon9 	= 0;
    u.val._anon13 	= 0;
    u.val._anon15 	= 0;
    u.val.lme = val;
    mackerel_write_addr_64(_dev->base,(0x4d0),u.raw);
}

static inline void __DP(efer_lma_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(efer_lma_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_efer_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x4d0));
    u.val._anon1 	= 0;
    u.val._anon9 	= 0;
    u.val._anon13 	= 0;
    u.val._anon15 	= 0;
    u.val.lma = val;
    mackerel_write_addr_64(_dev->base,(0x4d0),u.raw);
}

static inline void __DP(efer_nxe_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(efer_nxe_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_efer_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x4d0));
    u.val._anon1 	= 0;
    u.val._anon9 	= 0;
    u.val._anon13 	= 0;
    u.val._anon15 	= 0;
    u.val.nxe = val;
    mackerel_write_addr_64(_dev->base,(0x4d0),u.raw);
}

static inline void __DP(efer_svme_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(efer_svme_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_efer_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x4d0));
    u.val._anon1 	= 0;
    u.val._anon9 	= 0;
    u.val._anon13 	= 0;
    u.val._anon15 	= 0;
    u.val.svme = val;
    mackerel_write_addr_64(_dev->base,(0x4d0),u.raw);
}

static inline void __DP(efer_ffxsr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(efer_ffxsr_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_efer_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x4d0));
    u.val._anon1 	= 0;
    u.val._anon9 	= 0;
    u.val._anon13 	= 0;
    u.val._anon15 	= 0;
    u.val.ffxsr = val;
    mackerel_write_addr_64(_dev->base,(0x4d0),u.raw);
}


static inline int __DP(efer_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(efer_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_efer_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x4d0));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register efer (Guest EFER):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.sce;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sce =\t0x%"PRIx8" (System Call Extensions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.lme;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lme =\t0x%"PRIx8" (Long Mode Enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.lma;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lma =\t0x%"PRIx8" (Long Mode Active", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.nxe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " nxe =\t0x%"PRIx8" (No-Execute Enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.svme;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " svme =\t0x%"PRIx8" (Secure Virtual Machine Enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.ffxsr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ffxsr =\t0x%"PRIx8" (Fast FXSAVE/FXRSTOR", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register cr4 (Guest CR4); type amd_vmcb.cr4 (Implicit type of Guest CR4 register)
 */

/*
 * Dump of fields for register: cr4
 *   vme (size 1, offset 0):	 RW	  Virtual-8086 Mode Extensions
 *   pvi (size 1, offset 1):	 RW	  Protected-Mode Virtual Interrupts
 *   tsd (size 1, offset 2):	 RW	  Time Stamp Disable
 *   de (size 1, offset 3):	 RW	  Debugging Extensions
 *   pse (size 1, offset 4):	 RW	  Page Size Extensions
 *   pae (size 1, offset 5):	 RW	  Physical-Address Extension
 *   mce (size 1, offset 6):	 RW	  Machine Check Enable
 *   pge (size 1, offset 7):	 RW	  Page-Global Enable
 *   pce (size 1, offset 8):	 RW	  Performance-Monitoring Counter Enable
 *   osfxsr (size 1, offset 9):	 RW	  Operating System FXSAVE/FXRSTOR Support
 *   osxmmecept (size 1, offset 10):	 RW	  Operating System Unmasked Exception Support
 *   _anon11 (size 53, offset 11):	 MBZ	  _
 */

static inline uint64_t __DP(cr4_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(cr4_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x548));
}

static inline amd_vmcb_cr4_t __DP(cr4_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_cr4_t __DP(cr4_rd)( __DN(t) * _dev )
{
    amd_vmcb_cr4_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x548));
    return u.val;
}

static inline void __DP(cr4_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(cr4_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x548),val);
}

static inline void __DP(cr4_wr)( __DN(t) * _dev, amd_vmcb_cr4_t val ) __attribute__ ((always_inline));
static inline void __DP(cr4_wr)( __DN(t) * _dev, amd_vmcb_cr4_t val )
{
    amd_vmcb_cr4_un  u;
    u.val = val;
    u.val._anon11 	= 0;
    mackerel_write_addr_64(_dev->base,(0x548),u.raw);
}

static inline void __DP(cr4_vme_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr4_vme_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr4_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x548));
    u.val._anon11 	= 0;
    u.val.vme = val;
    mackerel_write_addr_64(_dev->base,(0x548),u.raw);
}

static inline void __DP(cr4_pvi_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr4_pvi_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr4_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x548));
    u.val._anon11 	= 0;
    u.val.pvi = val;
    mackerel_write_addr_64(_dev->base,(0x548),u.raw);
}

static inline void __DP(cr4_tsd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr4_tsd_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr4_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x548));
    u.val._anon11 	= 0;
    u.val.tsd = val;
    mackerel_write_addr_64(_dev->base,(0x548),u.raw);
}

static inline void __DP(cr4_de_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr4_de_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr4_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x548));
    u.val._anon11 	= 0;
    u.val.de = val;
    mackerel_write_addr_64(_dev->base,(0x548),u.raw);
}

static inline void __DP(cr4_pse_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr4_pse_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr4_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x548));
    u.val._anon11 	= 0;
    u.val.pse = val;
    mackerel_write_addr_64(_dev->base,(0x548),u.raw);
}

static inline void __DP(cr4_pae_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr4_pae_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr4_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x548));
    u.val._anon11 	= 0;
    u.val.pae = val;
    mackerel_write_addr_64(_dev->base,(0x548),u.raw);
}

static inline void __DP(cr4_mce_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr4_mce_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr4_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x548));
    u.val._anon11 	= 0;
    u.val.mce = val;
    mackerel_write_addr_64(_dev->base,(0x548),u.raw);
}

static inline void __DP(cr4_pge_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr4_pge_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr4_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x548));
    u.val._anon11 	= 0;
    u.val.pge = val;
    mackerel_write_addr_64(_dev->base,(0x548),u.raw);
}

static inline void __DP(cr4_pce_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr4_pce_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr4_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x548));
    u.val._anon11 	= 0;
    u.val.pce = val;
    mackerel_write_addr_64(_dev->base,(0x548),u.raw);
}

static inline void __DP(cr4_osfxsr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr4_osfxsr_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr4_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x548));
    u.val._anon11 	= 0;
    u.val.osfxsr = val;
    mackerel_write_addr_64(_dev->base,(0x548),u.raw);
}

static inline void __DP(cr4_osxmmecept_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr4_osxmmecept_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr4_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x548));
    u.val._anon11 	= 0;
    u.val.osxmmecept = val;
    mackerel_write_addr_64(_dev->base,(0x548),u.raw);
}


static inline int __DP(cr4_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cr4_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_cr4_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x548));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cr4 (Guest CR4):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.vme;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vme =\t0x%"PRIx8" (Virtual-8086 Mode Extensions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pvi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pvi =\t0x%"PRIx8" (Protected-Mode Virtual Interrupts", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tsd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tsd =\t0x%"PRIx8" (Time Stamp Disable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.de;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " de =\t0x%"PRIx8" (Debugging Extensions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pse;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pse =\t0x%"PRIx8" (Page Size Extensions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pae;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pae =\t0x%"PRIx8" (Physical-Address Extension", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mce;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mce =\t0x%"PRIx8" (Machine Check Enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pge;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pge =\t0x%"PRIx8" (Page-Global Enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pce;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pce =\t0x%"PRIx8" (Performance-Monitoring Counter Enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.osfxsr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " osfxsr =\t0x%"PRIx8" (Operating System FXSAVE/FXRSTOR Support", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.osxmmecept;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " osxmmecept =\t0x%"PRIx8" (Operating System Unmasked Exception Support", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register cr3 (Guest CR3); type amd_vmcb.uint64
 */

static inline uint64_t __DP(cr3_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(cr3_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x550));
}

static inline uint64_t __DP(cr3_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(cr3_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x550));
}

static inline void __DP(cr3_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(cr3_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x550),val);
}

static inline void __DP(cr3_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(cr3_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x550),val);
}


static inline int __DP(cr3_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cr3_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cr3 (Guest CR3):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x550)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register cr0 (Guest CR0); type amd_vmcb.cr0 (Implicit type of Guest CR0 register)
 */

/*
 * Dump of fields for register: cr0
 *   pe (size 1, offset 0):	 RW	  Protection Enabled
 *   mp (size 1, offset 1):	 RW	  Monitor Coprocessor
 *   em (size 1, offset 2):	 RW	  Emulation
 *   ts (size 1, offset 3):	 RW	  Task Switched
 *   et (size 1, offset 4):	 RO	  Extension Type
 *   ne (size 1, offset 5):	 RW	  Numeric Error
 *   _anon6 (size 10, offset 6):	 RSVD	  _
 *   wp (size 1, offset 16):	 RW	  Write Protect
 *   _anon17 (size 1, offset 17):	 RSVD	  _
 *   am (size 1, offset 18):	 RW	  Alignment Mask
 *   _anon19 (size 10, offset 19):	 RSVD	  _
 *   nw (size 1, offset 29):	 RW	  Not Writethrough
 *   cd (size 1, offset 30):	 RW	  Cache Disable
 *   pg (size 1, offset 31):	 RW	  Paging
 *   _anon32 (size 32, offset 32):	 MBZ	  _
 */

static inline uint64_t __DP(cr0_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(cr0_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x558));
}

static inline amd_vmcb_cr0_t __DP(cr0_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_cr0_t __DP(cr0_rd)( __DN(t) * _dev )
{
    amd_vmcb_cr0_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x558));
    return u.val;
}

static inline void __DP(cr0_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(cr0_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x558),val);
}

static inline void __DP(cr0_wr)( __DN(t) * _dev, amd_vmcb_cr0_t val ) __attribute__ ((always_inline));
static inline void __DP(cr0_wr)( __DN(t) * _dev, amd_vmcb_cr0_t val )
{
    amd_vmcb_cr0_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x558));
    u.val.pe 	= val.pe;
    u.val.mp 	= val.mp;
    u.val.em 	= val.em;
    u.val.ts 	= val.ts;
    u.val.et 	= val.et;
    u.val.ne 	= val.ne;
    u.val.wp 	= val.wp;
    u.val.am 	= val.am;
    u.val.nw 	= val.nw;
    u.val.cd 	= val.cd;
    u.val.pg 	= val.pg;
    u.val._anon32 	= val._anon32;
    u.val._anon32 	= 0;
    mackerel_write_addr_64(_dev->base,(0x558),u.raw);
}

static inline void __DP(cr0_pe_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr0_pe_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr0_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x558));
    u.val._anon32 	= 0;
    u.val.pe = val;
    mackerel_write_addr_64(_dev->base,(0x558),u.raw);
}

static inline void __DP(cr0_mp_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr0_mp_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr0_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x558));
    u.val._anon32 	= 0;
    u.val.mp = val;
    mackerel_write_addr_64(_dev->base,(0x558),u.raw);
}

static inline void __DP(cr0_em_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr0_em_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr0_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x558));
    u.val._anon32 	= 0;
    u.val.em = val;
    mackerel_write_addr_64(_dev->base,(0x558),u.raw);
}

static inline void __DP(cr0_ts_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr0_ts_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr0_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x558));
    u.val._anon32 	= 0;
    u.val.ts = val;
    mackerel_write_addr_64(_dev->base,(0x558),u.raw);
}

static inline void __DP(cr0_ne_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr0_ne_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr0_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x558));
    u.val._anon32 	= 0;
    u.val.ne = val;
    mackerel_write_addr_64(_dev->base,(0x558),u.raw);
}

static inline void __DP(cr0_wp_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr0_wp_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr0_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x558));
    u.val._anon32 	= 0;
    u.val.wp = val;
    mackerel_write_addr_64(_dev->base,(0x558),u.raw);
}

static inline void __DP(cr0_am_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr0_am_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr0_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x558));
    u.val._anon32 	= 0;
    u.val.am = val;
    mackerel_write_addr_64(_dev->base,(0x558),u.raw);
}

static inline void __DP(cr0_nw_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr0_nw_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr0_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x558));
    u.val._anon32 	= 0;
    u.val.nw = val;
    mackerel_write_addr_64(_dev->base,(0x558),u.raw);
}

static inline void __DP(cr0_cd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr0_cd_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr0_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x558));
    u.val._anon32 	= 0;
    u.val.cd = val;
    mackerel_write_addr_64(_dev->base,(0x558),u.raw);
}

static inline void __DP(cr0_pg_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cr0_pg_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_cr0_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x558));
    u.val._anon32 	= 0;
    u.val.pg = val;
    mackerel_write_addr_64(_dev->base,(0x558),u.raw);
}


static inline int __DP(cr0_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cr0_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_cr0_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x558));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cr0 (Guest CR0):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.pe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pe =\t0x%"PRIx8" (Protection Enabled", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mp =\t0x%"PRIx8" (Monitor Coprocessor", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.em;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " em =\t0x%"PRIx8" (Emulation", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ts;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ts =\t0x%"PRIx8" (Task Switched", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.et;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " et =\t0x%"PRIx8" (Extension Type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ne;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ne =\t0x%"PRIx8" (Numeric Error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.wp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wp =\t0x%"PRIx8" (Write Protect", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.am;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " am =\t0x%"PRIx8" (Alignment Mask", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.nw;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " nw =\t0x%"PRIx8" (Not Writethrough", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cd =\t0x%"PRIx8" (Cache Disable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pg;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pg =\t0x%"PRIx8" (Paging", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register dr7 (Guest DR7); type amd_vmcb.uint64
 */

static inline uint64_t __DP(dr7_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(dr7_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x560));
}

static inline uint64_t __DP(dr7_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(dr7_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x560));
}

static inline void __DP(dr7_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(dr7_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x560),val);
}

static inline void __DP(dr7_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(dr7_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x560),val);
}


static inline int __DP(dr7_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(dr7_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register dr7 (Guest DR7):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x560)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register dr6 (Guest DR6); type amd_vmcb.uint64
 */

static inline uint64_t __DP(dr6_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(dr6_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x568));
}

static inline uint64_t __DP(dr6_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(dr6_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x568));
}

static inline void __DP(dr6_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(dr6_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x568),val);
}

static inline void __DP(dr6_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(dr6_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x568),val);
}


static inline int __DP(dr6_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(dr6_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register dr6 (Guest DR6):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x568)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rflags (Guest RFLAGS); type amd_vmcb.rflags (Implicit type of Guest RFLAGS register)
 */

/*
 * Dump of fields for register: rflags
 *   cf (size 1, offset 0):	 RW	  Carry Flag
 *   _anon1 (size 1, offset 1):	 RSVD	  _
 *   pf (size 1, offset 2):	 RW	  Parity Flag
 *   _anon3 (size 1, offset 3):	 RSVD	  _
 *   af (size 1, offset 4):	 RW	  Auxiliary Flag
 *   _anon5 (size 1, offset 5):	 RSVD	  _
 *   zf (size 1, offset 6):	 RW	  Zero Flag
 *   sf (size 1, offset 7):	 RW	  Sign Flag
 *   tf (size 1, offset 8):	 RW	  Trap Flag
 *   intrf (size 1, offset 9):	 RW	  Interrupt Flag
 *   df (size 1, offset 10):	 RW	  Direction Flag
 *   of (size 1, offset 11):	 RW	  Overflow Flag
 *   iopl (size 2, offset 12):	 RW	  I/O Privilege Level
 *   nt (size 1, offset 14):	 RW	  Nested Task
 *   _anon15 (size 1, offset 15):	 RSVD	  _
 *   rf (size 1, offset 16):	 RW	  Resume Flag
 *   vm (size 1, offset 17):	 RW	  Virtual-8086 Mode
 *   ac (size 1, offset 18):	 RW	  Alignment Check
 *   vif (size 1, offset 19):	 RW	  Virtual Interrupt Flag
 *   vip (size 1, offset 20):	 RW	  Virtual Interrupt Pending
 *   id (size 1, offset 21):	 RW	  ID Flag
 *   _anon22 (size 42, offset 22):	 RSVD	  _
 */

static inline uint64_t __DP(rflags_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(rflags_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x570));
}

static inline amd_vmcb_rflags_t __DP(rflags_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline amd_vmcb_rflags_t __DP(rflags_rd)( __DN(t) * _dev )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    return u.val;
}

static inline void __DP(rflags_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x570),val);
}

static inline void __DP(rflags_wr)( __DN(t) * _dev, amd_vmcb_rflags_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_wr)( __DN(t) * _dev, amd_vmcb_rflags_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.cf 	= val.cf;
    u.val.pf 	= val.pf;
    u.val.af 	= val.af;
    u.val.zf 	= val.zf;
    u.val.sf 	= val.sf;
    u.val.tf 	= val.tf;
    u.val.intrf 	= val.intrf;
    u.val.df 	= val.df;
    u.val.of 	= val.of;
    u.val.iopl 	= val.iopl;
    u.val.nt 	= val.nt;
    u.val.rf 	= val.rf;
    u.val.vm 	= val.vm;
    u.val.ac 	= val.ac;
    u.val.vif 	= val.vif;
    u.val.vip 	= val.vip;
    u.val.id 	= val.id;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_cf_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_cf_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.cf = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_pf_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_pf_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.pf = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_af_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_af_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.af = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_zf_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_zf_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.zf = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_sf_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_sf_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.sf = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_tf_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_tf_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.tf = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_intrf_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_intrf_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.intrf = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_df_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_df_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.df = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_of_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_of_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.of = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_iopl_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_iopl_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.iopl = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_nt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_nt_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.nt = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_rf_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_rf_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.rf = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_vm_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_vm_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.vm = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_ac_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_ac_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.ac = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_vif_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_vif_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.vif = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_vip_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_vip_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.vip = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}

static inline void __DP(rflags_id_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rflags_id_wrf)( __DN(t) * _dev, uint8_t val )
{
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    u.val.id = val;
    mackerel_write_addr_64(_dev->base,(0x570),u.raw);
}


static inline int __DP(rflags_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rflags_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    amd_vmcb_rflags_un  u;
    u.raw = mackerel_read_addr_64(_dev->base,(0x570));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rflags (Guest RFLAGS):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.cf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cf =\t0x%"PRIx8" (Carry Flag", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.pf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pf =\t0x%"PRIx8" (Parity Flag", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.af;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " af =\t0x%"PRIx8" (Auxiliary Flag", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.zf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " zf =\t0x%"PRIx8" (Zero Flag", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sf =\t0x%"PRIx8" (Sign Flag", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tf =\t0x%"PRIx8" (Trap Flag", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.intrf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " intrf =\t0x%"PRIx8" (Interrupt Flag", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.df;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " df =\t0x%"PRIx8" (Direction Flag", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.of;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " of =\t0x%"PRIx8" (Overflow Flag", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.iopl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " iopl =\t0x%"PRIx8" (I/O Privilege Level", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.nt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " nt =\t0x%"PRIx8" (Nested Task", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.rf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rf =\t0x%"PRIx8" (Resume Flag", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vm;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vm =\t0x%"PRIx8" (Virtual-8086 Mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ac;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ac =\t0x%"PRIx8" (Alignment Check", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vif;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vif =\t0x%"PRIx8" (Virtual Interrupt Flag", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vip;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vip =\t0x%"PRIx8" (Virtual Interrupt Pending", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.id;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " id =\t0x%"PRIx8" (ID Flag", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register rip (Guest RIP); type amd_vmcb.uint64
 */

static inline uint64_t __DP(rip_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(rip_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x578));
}

static inline uint64_t __DP(rip_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(rip_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x578));
}

static inline void __DP(rip_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(rip_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x578),val);
}

static inline void __DP(rip_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(rip_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x578),val);
}


static inline int __DP(rip_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rip_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rip (Guest RIP):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x578)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rsp (Guest RSP); type amd_vmcb.uint64
 */

static inline uint64_t __DP(rsp_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(rsp_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x5d8));
}

static inline uint64_t __DP(rsp_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(rsp_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x5d8));
}

static inline void __DP(rsp_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(rsp_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x5d8),val);
}

static inline void __DP(rsp_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(rsp_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x5d8),val);
}


static inline int __DP(rsp_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rsp_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rsp (Guest RSP):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x5d8)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rax (Guest RAX); type amd_vmcb.uint64
 */

static inline uint64_t __DP(rax_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(rax_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x5f8));
}

static inline uint64_t __DP(rax_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(rax_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x5f8));
}

static inline void __DP(rax_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(rax_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x5f8),val);
}

static inline void __DP(rax_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(rax_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x5f8),val);
}


static inline int __DP(rax_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rax_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rax (Guest RAX):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x5f8)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register star (Guest STAR); type amd_vmcb.uint64
 */

static inline uint64_t __DP(star_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(star_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x600));
}

static inline uint64_t __DP(star_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(star_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x600));
}

static inline void __DP(star_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(star_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x600),val);
}

static inline void __DP(star_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(star_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x600),val);
}


static inline int __DP(star_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(star_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register star (Guest STAR):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x600)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register lstar (Guest LSTAR); type amd_vmcb.uint64
 */

static inline uint64_t __DP(lstar_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(lstar_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x608));
}

static inline uint64_t __DP(lstar_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(lstar_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x608));
}

static inline void __DP(lstar_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(lstar_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x608),val);
}

static inline void __DP(lstar_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(lstar_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x608),val);
}


static inline int __DP(lstar_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(lstar_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register lstar (Guest LSTAR):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x608)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register cstar (Guest CSTAR); type amd_vmcb.uint64
 */

static inline uint64_t __DP(cstar_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(cstar_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x610));
}

static inline uint64_t __DP(cstar_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(cstar_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x610));
}

static inline void __DP(cstar_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(cstar_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x610),val);
}

static inline void __DP(cstar_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(cstar_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x610),val);
}


static inline int __DP(cstar_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cstar_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cstar (Guest CSTAR):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x610)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register sfmask (Guest SFMASK); type amd_vmcb.uint64
 */

static inline uint64_t __DP(sfmask_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(sfmask_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x618));
}

static inline uint64_t __DP(sfmask_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(sfmask_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x618));
}

static inline void __DP(sfmask_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(sfmask_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x618),val);
}

static inline void __DP(sfmask_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(sfmask_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x618),val);
}


static inline int __DP(sfmask_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(sfmask_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register sfmask (Guest SFMASK):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x618)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register kernel_gs_base (Guest KernelGsBase); type amd_vmcb.uint64
 */

static inline uint64_t __DP(kernel_gs_base_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(kernel_gs_base_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x620));
}

static inline uint64_t __DP(kernel_gs_base_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(kernel_gs_base_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x620));
}

static inline void __DP(kernel_gs_base_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(kernel_gs_base_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x620),val);
}

static inline void __DP(kernel_gs_base_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(kernel_gs_base_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x620),val);
}


static inline int __DP(kernel_gs_base_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(kernel_gs_base_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register kernel_gs_base (Guest KernelGsBase):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x620)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register sysenter_cs (Guest SYSENTER_CS); type amd_vmcb.uint64
 */

static inline uint64_t __DP(sysenter_cs_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(sysenter_cs_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x628));
}

static inline uint64_t __DP(sysenter_cs_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(sysenter_cs_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x628));
}

static inline void __DP(sysenter_cs_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(sysenter_cs_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x628),val);
}

static inline void __DP(sysenter_cs_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(sysenter_cs_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x628),val);
}


static inline int __DP(sysenter_cs_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(sysenter_cs_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register sysenter_cs (Guest SYSENTER_CS):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x628)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register sysenter_esp (Guest SYSENTER_ESP); type amd_vmcb.uint64
 */

static inline uint64_t __DP(sysenter_esp_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(sysenter_esp_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x630));
}

static inline uint64_t __DP(sysenter_esp_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(sysenter_esp_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x630));
}

static inline void __DP(sysenter_esp_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(sysenter_esp_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x630),val);
}

static inline void __DP(sysenter_esp_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(sysenter_esp_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x630),val);
}


static inline int __DP(sysenter_esp_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(sysenter_esp_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register sysenter_esp (Guest SYSENTER_ESP):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x630)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register sysenter_eip (Guest SYSENTER_EIP); type amd_vmcb.uint64
 */

static inline uint64_t __DP(sysenter_eip_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(sysenter_eip_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x638));
}

static inline uint64_t __DP(sysenter_eip_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(sysenter_eip_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x638));
}

static inline void __DP(sysenter_eip_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(sysenter_eip_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x638),val);
}

static inline void __DP(sysenter_eip_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(sysenter_eip_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x638),val);
}


static inline int __DP(sysenter_eip_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(sysenter_eip_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register sysenter_eip (Guest SYSENTER_EIP):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x638)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register cr2 (Guest CR2); type amd_vmcb.uint64
 */

static inline uint64_t __DP(cr2_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(cr2_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x640));
}

static inline uint64_t __DP(cr2_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(cr2_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x640));
}

static inline void __DP(cr2_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(cr2_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x640),val);
}

static inline void __DP(cr2_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(cr2_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x640),val);
}


static inline int __DP(cr2_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cr2_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cr2 (Guest CR2):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x640)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register gpat (Guest PAT); type amd_vmcb.uint64
 */

static inline uint64_t __DP(gpat_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(gpat_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x668));
}

static inline uint64_t __DP(gpat_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(gpat_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x668));
}

static inline void __DP(gpat_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(gpat_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x668),val);
}

static inline void __DP(gpat_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(gpat_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x668),val);
}


static inline int __DP(gpat_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(gpat_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register gpat (Guest PAT):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x668)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register dbgctl (Guest DBGCTL MSR); type amd_vmcb.uint64
 */

static inline uint64_t __DP(dbgctl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(dbgctl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x670));
}

static inline uint64_t __DP(dbgctl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(dbgctl_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x670));
}

static inline void __DP(dbgctl_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(dbgctl_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x670),val);
}

static inline void __DP(dbgctl_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(dbgctl_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x670),val);
}


static inline int __DP(dbgctl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(dbgctl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register dbgctl (Guest DBGCTL MSR):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x670)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register br_from (Guest LastBranchFromIP MSR); type amd_vmcb.uint64
 */

static inline uint64_t __DP(br_from_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(br_from_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x678));
}

static inline uint64_t __DP(br_from_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(br_from_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x678));
}

static inline void __DP(br_from_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(br_from_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x678),val);
}

static inline void __DP(br_from_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(br_from_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x678),val);
}


static inline int __DP(br_from_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(br_from_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register br_from (Guest LastBranchFromIP MSR):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x678)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register br_to (Guest LastBranchToIP MSR); type amd_vmcb.uint64
 */

static inline uint64_t __DP(br_to_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(br_to_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x680));
}

static inline uint64_t __DP(br_to_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(br_to_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x680));
}

static inline void __DP(br_to_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(br_to_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x680),val);
}

static inline void __DP(br_to_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(br_to_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x680),val);
}


static inline int __DP(br_to_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(br_to_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register br_to (Guest LastBranchToIP MSR):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x680)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register lastexcpfrom (Guest LastExceptionFromIP MSR); type amd_vmcb.uint64
 */

static inline uint64_t __DP(lastexcpfrom_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(lastexcpfrom_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x688));
}

static inline uint64_t __DP(lastexcpfrom_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(lastexcpfrom_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x688));
}

static inline void __DP(lastexcpfrom_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(lastexcpfrom_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x688),val);
}

static inline void __DP(lastexcpfrom_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(lastexcpfrom_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x688),val);
}


static inline int __DP(lastexcpfrom_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(lastexcpfrom_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register lastexcpfrom (Guest LastExceptionFromIP MSR):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x688)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register lastexcpto (Guest LastExceptionToIP MSR); type amd_vmcb.uint64
 */

static inline uint64_t __DP(lastexcpto_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(lastexcpto_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x690));
}

static inline uint64_t __DP(lastexcpto_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(lastexcpto_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0x690));
}

static inline void __DP(lastexcpto_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(lastexcpto_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x690),val);
}

static inline void __DP(lastexcpto_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(lastexcpto_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0x690),val);
}


static inline int __DP(lastexcpto_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(lastexcpto_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register lastexcpto (Guest LastExceptionToIP MSR):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0x690)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Dump of device amd_vmcb (AMD Virtual Machine Control Block):\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cr_access_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(dr_access_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(exceptions_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(intercepts_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(iopm_base_pa_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(msrpm_base_pa_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tsc_offset_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tlb_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(vintr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(intr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(exitcode_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(exitinfo1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(exitinfo2_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(exitintinfo_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(np_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eventinj_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ncr3_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(lbr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(es_selector_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(es_attrib_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(es_limit_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(es_base_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cs_selector_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cs_attrib_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cs_limit_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cs_base_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ss_selector_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ss_attrib_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ss_limit_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ss_base_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ds_selector_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ds_attrib_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ds_limit_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ds_base_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(fs_selector_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(fs_attrib_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(fs_limit_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(fs_base_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gs_selector_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gs_attrib_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gs_limit_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gs_base_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gdtr_selector_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gdtr_attrib_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gdtr_limit_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gdtr_base_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ldtr_selector_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ldtr_attrib_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ldtr_limit_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ldtr_base_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(idtr_selector_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(idtr_attrib_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(idtr_limit_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(idtr_base_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tr_selector_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tr_attrib_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tr_limit_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tr_base_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cpl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(efer_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cr4_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cr3_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cr0_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(dr7_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(dr6_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rflags_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rip_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rsp_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rax_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(star_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(lstar_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cstar_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(sfmask_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(kernel_gs_base_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(sysenter_cs_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(sysenter_esp_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(sysenter_eip_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cr2_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(gpat_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(dbgctl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(br_from_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(br_to_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(lastexcpfrom_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(lastexcpto_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "End of dump of device amd_vmcb\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR


#endif // __amd_vmcb_H
