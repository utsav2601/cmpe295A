#ifndef __lpc_rtc_DEV_H
#define __lpc_rtc_DEV_H 1
/*
 * DEVICE DEFINITION: LPC Real-Time Clock and CMOS RAM
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) lpc_rtc ## _ ## x
/*
 * Constants defn: lpc_rtc.sndx (Standard index values)
 *  - no width specified
 */
typedef uint8_t lpc_rtc_sndx_t;
#define lpc_rtc_seconds ((lpc_rtc_sndx_t)0x0)
#define lpc_rtc_al_seconds ((lpc_rtc_sndx_t)0x1)
#define lpc_rtc_minutes ((lpc_rtc_sndx_t)0x2)
#define lpc_rtc_al_minutes ((lpc_rtc_sndx_t)0x3)
#define lpc_rtc_hours ((lpc_rtc_sndx_t)0x4)
#define lpc_rtc_al_hours ((lpc_rtc_sndx_t)0x5)
#define lpc_rtc_weekday ((lpc_rtc_sndx_t)0x6)
#define lpc_rtc_date ((lpc_rtc_sndx_t)0x7)
#define lpc_rtc_month ((lpc_rtc_sndx_t)0x8)
#define lpc_rtc_year ((lpc_rtc_sndx_t)0x9)
#define lpc_rtc_rega ((lpc_rtc_sndx_t)0xa)
#define lpc_rtc_regb ((lpc_rtc_sndx_t)0xb)
#define lpc_rtc_regc ((lpc_rtc_sndx_t)0xc)
#define lpc_rtc_regd ((lpc_rtc_sndx_t)0xd)

static inline char *lpc_rtc_sndx_describe(lpc_rtc_sndx_t _e) __attribute__ ((always_inline));
static inline char *lpc_rtc_sndx_describe(lpc_rtc_sndx_t _e)
{
    switch (_e) {
    case lpc_rtc_seconds:
        return("seconds: Seconds");
    case lpc_rtc_al_seconds:
        return("al_seconds: Seconds alarm");
    case lpc_rtc_minutes:
        return("minutes: Minutes");
    case lpc_rtc_al_minutes:
        return("al_minutes: Minutes Alarm");
    case lpc_rtc_hours:
        return("hours: Hours");
    case lpc_rtc_al_hours:
        return("al_hours: Hours Alarm");
    case lpc_rtc_weekday:
        return("weekday: Day of Week");
    case lpc_rtc_date:
        return("date: Day of Month");
    case lpc_rtc_month:
        return("month: Month");
    case lpc_rtc_year:
        return("year: Year");
    case lpc_rtc_rega:
        return("rega: Register A");
    case lpc_rtc_regb:
        return("regb: Register B");
    case lpc_rtc_regc:
        return("regc: Register C");
    case lpc_rtc_regd:
        return("regd: Register D");
    default:
        return(NULL);
    }
}

static inline int lpc_rtc_sndx_prtval(char *_s, size_t _size, lpc_rtc_sndx_t _e) __attribute__ ((always_inline));
static inline int lpc_rtc_sndx_prtval(char *_s, size_t _size, lpc_rtc_sndx_t _e)
{
    char *d = lpc_rtc_sndx_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "lpc_rtc_sndx_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: lpc_rtc.dcs (Division chain select)
 *  - no width specified
 */
typedef uint8_t lpc_rtc_dcs_t;
#define lpc_rtc_normal ((lpc_rtc_dcs_t)0x2)
#define lpc_rtc_divreset ((lpc_rtc_dcs_t)0x6)
#define lpc_rtc_divreset2 ((lpc_rtc_dcs_t)0x7)
#define lpc_rtc_bypass15 ((lpc_rtc_dcs_t)0x5)
#define lpc_rtc_bypass10 ((lpc_rtc_dcs_t)0x4)
#define lpc_rtc_bypass5 ((lpc_rtc_dcs_t)0x3)

static inline char *lpc_rtc_dcs_describe(lpc_rtc_dcs_t _e) __attribute__ ((always_inline));
static inline char *lpc_rtc_dcs_describe(lpc_rtc_dcs_t _e)
{
    switch (_e) {
    case lpc_rtc_normal:
        return("normal: Normal operation");
    case lpc_rtc_divreset:
        return("divreset: Divider reset");
    case lpc_rtc_divreset2:
        return("divreset2: Divider reset");
    case lpc_rtc_bypass15:
        return("bypass15: Bypass 15 stages");
    case lpc_rtc_bypass10:
        return("bypass10: Bypass 10 stages");
    case lpc_rtc_bypass5:
        return("bypass5: Bypass 5 stages");
    default:
        return(NULL);
    }
}

static inline int lpc_rtc_dcs_prtval(char *_s, size_t _size, lpc_rtc_dcs_t _e) __attribute__ ((always_inline));
static inline int lpc_rtc_dcs_prtval(char *_s, size_t _size, lpc_rtc_dcs_t _e)
{
    char *d = lpc_rtc_dcs_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "lpc_rtc_dcs_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: lpc_rtc.rate (Rate select)
 *  - no width specified
 */
typedef uint8_t lpc_rtc_rate_t;
#define lpc_rtc_never ((lpc_rtc_rate_t)0x0)
#define lpc_rtc_ms3_90625_ ((lpc_rtc_rate_t)0x1)
#define lpc_rtc_ms7_8125_ ((lpc_rtc_rate_t)0x2)
#define lpc_rtc_us122_070 ((lpc_rtc_rate_t)0x3)
#define lpc_rtc_us244_141 ((lpc_rtc_rate_t)0x4)
#define lpc_rtc_us488_281 ((lpc_rtc_rate_t)0x5)
#define lpc_rtc_us976_5625 ((lpc_rtc_rate_t)0x6)
#define lpc_rtc_ms1_953125 ((lpc_rtc_rate_t)0x7)
#define lpc_rtc_ms3_906251 ((lpc_rtc_rate_t)0x8)
#define lpc_rtc_ms7_8125 ((lpc_rtc_rate_t)0x9)
#define lpc_rtc_ms15_625 ((lpc_rtc_rate_t)0xa)
#define lpc_rtc_ms31_25 ((lpc_rtc_rate_t)0xb)
#define lpc_rtc_ms62_5 ((lpc_rtc_rate_t)0xc)
#define lpc_rtc_ms125 ((lpc_rtc_rate_t)0xd)
#define lpc_rtc_ms250 ((lpc_rtc_rate_t)0xe)
#define lpc_rtc_ms500 ((lpc_rtc_rate_t)0xf)

static inline char *lpc_rtc_rate_describe(lpc_rtc_rate_t _e) __attribute__ ((always_inline));
static inline char *lpc_rtc_rate_describe(lpc_rtc_rate_t _e)
{
    switch (_e) {
    case lpc_rtc_never:
        return("never: Interrupt never toggles");
    case lpc_rtc_ms3_90625_:
        return("ms3_90625_: 3.90625 ms (duplicate)");
    case lpc_rtc_ms7_8125_:
        return("ms7_8125_: 7.8125 ms (duplicate)");
    case lpc_rtc_us122_070:
        return("us122_070: 122.070 us");
    case lpc_rtc_us244_141:
        return("us244_141: 244.141 us");
    case lpc_rtc_us488_281:
        return("us488_281: 488.281 us");
    case lpc_rtc_us976_5625:
        return("us976_5625: 976.5625 us");
    case lpc_rtc_ms1_953125:
        return("ms1_953125: 1.953125 ms");
    case lpc_rtc_ms3_906251:
        return("ms3_906251: 3.906251 ms");
    case lpc_rtc_ms7_8125:
        return("ms7_8125: 7.8125 ms");
    case lpc_rtc_ms15_625:
        return("ms15_625: 15.625 ms");
    case lpc_rtc_ms31_25:
        return("ms31_25: 31.25 ms");
    case lpc_rtc_ms62_5:
        return("ms62_5: 62.5 ms");
    case lpc_rtc_ms125:
        return("ms125: 125 ms");
    case lpc_rtc_ms250:
        return("ms250: 250 ms");
    case lpc_rtc_ms500:
        return("ms500: 500 ms");
    default:
        return(NULL);
    }
}

static inline int lpc_rtc_rate_prtval(char *_s, size_t _size, lpc_rtc_rate_t _e) __attribute__ ((always_inline));
static inline int lpc_rtc_rate_prtval(char *_s, size_t _size, lpc_rtc_rate_t _e)
{
    char *d = lpc_rtc_rate_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "lpc_rtc_rate_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: lpc_rtc_rega_t
 * Description: Implicit type of Register A register
 * Fields:
 *   rs	(size 4, offset 0, init 0):	RW	Rate select
 *   dv	(size 3, offset 4, init 0):	RW	Divisioin chain select
 *   uip	(size 1, offset 7, init 0):	RW	Update in progress
 */
typedef uint8_t lpc_rtc_rega_t;
#define lpc_rtc_rega_default 0x0
static inline lpc_rtc_rate_t lpc_rtc_rega_rs_extract(lpc_rtc_rega_t _regval) __attribute__ ((always_inline));
static inline lpc_rtc_rate_t lpc_rtc_rega_rs_extract(lpc_rtc_rega_t _regval)
{
    return((lpc_rtc_rate_t )((_regval & 0xf) >> 0));
}

static inline lpc_rtc_rega_t lpc_rtc_rega_rs_insert(lpc_rtc_rega_t _regval, lpc_rtc_rate_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_rega_t lpc_rtc_rega_rs_insert(lpc_rtc_rega_t _regval, lpc_rtc_rate_t _fieldval)
{
    return((_regval & 0xf0) | (0xf & (((lpc_rtc_rega_t )(_fieldval)) << 0)));
}

static inline lpc_rtc_dcs_t lpc_rtc_rega_dv_extract(lpc_rtc_rega_t _regval) __attribute__ ((always_inline));
static inline lpc_rtc_dcs_t lpc_rtc_rega_dv_extract(lpc_rtc_rega_t _regval)
{
    return((lpc_rtc_dcs_t )((_regval & 0x70) >> 4));
}

static inline lpc_rtc_rega_t lpc_rtc_rega_dv_insert(lpc_rtc_rega_t _regval, lpc_rtc_dcs_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_rega_t lpc_rtc_rega_dv_insert(lpc_rtc_rega_t _regval, lpc_rtc_dcs_t _fieldval)
{
    return((_regval & 0x8f) | (0x70 & (((lpc_rtc_rega_t )(_fieldval)) << 4)));
}

static inline uint8_t lpc_rtc_rega_uip_extract(lpc_rtc_rega_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_rega_uip_extract(lpc_rtc_rega_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline lpc_rtc_rega_t lpc_rtc_rega_uip_insert(lpc_rtc_rega_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_rega_t lpc_rtc_rega_uip_insert(lpc_rtc_rega_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7f) | (0x80 & (((lpc_rtc_rega_t )(_fieldval)) << 7)));
}

static inline int lpc_rtc_rega_prtval(char *_s, size_t _size, lpc_rtc_rega_t _regval) __attribute__ ((always_inline));
static inline int lpc_rtc_rega_prtval(char *_s, size_t _size, lpc_rtc_rega_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rs =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_rtc_rate_prtval(_s + _r, _avail, lpc_rtc_rega_rs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Rate select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dv =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_rtc_dcs_prtval(_s + _r, _avail, lpc_rtc_rega_dv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Divisioin chain select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " uip =\t%" PRIx8 "\t(Update in progress)\n", lpc_rtc_rega_uip_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: lpc_rtc_regb_t
 * Description: Implicit type of General configuration register
 * Fields:
 *   dse	(size 1, offset 0, init 0):	RW	Daylight savings enable
 *   hourform	(size 1, offset 1, init 0):	RW	Hour format
 *   dm	(size 1, offset 2, init 0):	RW	Data mode (BCD/binary)
 *   sqwe	(size 1, offset 3, init 0):	RW	Square wave enable
 *   uie	(size 1, offset 4, init 0):	RW	Update-ended interrupt enable
 *   aie	(size 1, offset 5, init 0):	RW	Alarm interrupt enable
 *   pie	(size 1, offset 6, init 0):	RW	Periodic interrupt enable
 *   set	(size 1, offset 7, init 0):	RW	Update cycle inhibit
 */
typedef uint8_t lpc_rtc_regb_t;
#define lpc_rtc_regb_default 0x0
static inline uint8_t lpc_rtc_regb_dse_extract(lpc_rtc_regb_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regb_dse_extract(lpc_rtc_regb_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline lpc_rtc_regb_t lpc_rtc_regb_dse_insert(lpc_rtc_regb_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_regb_t lpc_rtc_regb_dse_insert(lpc_rtc_regb_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((lpc_rtc_regb_t )(_fieldval)) << 0)));
}

static inline uint8_t lpc_rtc_regb_hourform_extract(lpc_rtc_regb_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regb_hourform_extract(lpc_rtc_regb_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline lpc_rtc_regb_t lpc_rtc_regb_hourform_insert(lpc_rtc_regb_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_regb_t lpc_rtc_regb_hourform_insert(lpc_rtc_regb_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((lpc_rtc_regb_t )(_fieldval)) << 1)));
}

static inline uint8_t lpc_rtc_regb_dm_extract(lpc_rtc_regb_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regb_dm_extract(lpc_rtc_regb_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline lpc_rtc_regb_t lpc_rtc_regb_dm_insert(lpc_rtc_regb_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_regb_t lpc_rtc_regb_dm_insert(lpc_rtc_regb_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((lpc_rtc_regb_t )(_fieldval)) << 2)));
}

static inline uint8_t lpc_rtc_regb_sqwe_extract(lpc_rtc_regb_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regb_sqwe_extract(lpc_rtc_regb_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline lpc_rtc_regb_t lpc_rtc_regb_sqwe_insert(lpc_rtc_regb_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_regb_t lpc_rtc_regb_sqwe_insert(lpc_rtc_regb_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((lpc_rtc_regb_t )(_fieldval)) << 3)));
}

static inline uint8_t lpc_rtc_regb_uie_extract(lpc_rtc_regb_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regb_uie_extract(lpc_rtc_regb_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline lpc_rtc_regb_t lpc_rtc_regb_uie_insert(lpc_rtc_regb_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_regb_t lpc_rtc_regb_uie_insert(lpc_rtc_regb_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((lpc_rtc_regb_t )(_fieldval)) << 4)));
}

static inline uint8_t lpc_rtc_regb_aie_extract(lpc_rtc_regb_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regb_aie_extract(lpc_rtc_regb_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline lpc_rtc_regb_t lpc_rtc_regb_aie_insert(lpc_rtc_regb_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_regb_t lpc_rtc_regb_aie_insert(lpc_rtc_regb_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdf) | (0x20 & (((lpc_rtc_regb_t )(_fieldval)) << 5)));
}

static inline uint8_t lpc_rtc_regb_pie_extract(lpc_rtc_regb_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regb_pie_extract(lpc_rtc_regb_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline lpc_rtc_regb_t lpc_rtc_regb_pie_insert(lpc_rtc_regb_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_regb_t lpc_rtc_regb_pie_insert(lpc_rtc_regb_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbf) | (0x40 & (((lpc_rtc_regb_t )(_fieldval)) << 6)));
}

static inline uint8_t lpc_rtc_regb_set_extract(lpc_rtc_regb_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regb_set_extract(lpc_rtc_regb_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline lpc_rtc_regb_t lpc_rtc_regb_set_insert(lpc_rtc_regb_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_regb_t lpc_rtc_regb_set_insert(lpc_rtc_regb_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7f) | (0x80 & (((lpc_rtc_regb_t )(_fieldval)) << 7)));
}

static inline int lpc_rtc_regb_prtval(char *_s, size_t _size, lpc_rtc_regb_t _regval) __attribute__ ((always_inline));
static inline int lpc_rtc_regb_prtval(char *_s, size_t _size, lpc_rtc_regb_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dse =\t%" PRIx8 "\t(Daylight savings enable)\n", lpc_rtc_regb_dse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hourform =\t%" PRIx8 "\t(Hour format)\n", lpc_rtc_regb_hourform_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dm =\t%" PRIx8 "\t(Data mode (BCD/binary))\n", lpc_rtc_regb_dm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sqwe =\t%" PRIx8 "\t(Square wave enable)\n", lpc_rtc_regb_sqwe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " uie =\t%" PRIx8 "\t(Update-ended interrupt enable)\n", lpc_rtc_regb_uie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aie =\t%" PRIx8 "\t(Alarm interrupt enable)\n", lpc_rtc_regb_aie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pie =\t%" PRIx8 "\t(Periodic interrupt enable)\n", lpc_rtc_regb_pie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " set =\t%" PRIx8 "\t(Update cycle inhibit)\n", lpc_rtc_regb_set_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: lpc_rtc_regc_t
 * Description: Implicit type of Flag register C register
 * Fields:
 *   _anon0	(size 4, offset 0, init 0):	RSVD	_
 *   uf	(size 1, offset 4, init 0):	RO	Update-ended
 *   af	(size 1, offset 5, init 0):	RO	Alarm
 *   pf	(size 1, offset 6, init 0):	RO	Periodic interrupt
 *   irqf	(size 1, offset 7, init 0):	RO	Interrupt request flag
 */
typedef uint8_t lpc_rtc_regc_t;
#define lpc_rtc_regc_default 0x0
static inline uint8_t lpc_rtc_regc_uf_extract(lpc_rtc_regc_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regc_uf_extract(lpc_rtc_regc_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline lpc_rtc_regc_t lpc_rtc_regc_uf_insert(lpc_rtc_regc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_regc_t lpc_rtc_regc_uf_insert(lpc_rtc_regc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((lpc_rtc_regc_t )(_fieldval)) << 4)));
}

static inline uint8_t lpc_rtc_regc_af_extract(lpc_rtc_regc_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regc_af_extract(lpc_rtc_regc_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline lpc_rtc_regc_t lpc_rtc_regc_af_insert(lpc_rtc_regc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_regc_t lpc_rtc_regc_af_insert(lpc_rtc_regc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdf) | (0x20 & (((lpc_rtc_regc_t )(_fieldval)) << 5)));
}

static inline uint8_t lpc_rtc_regc_pf_extract(lpc_rtc_regc_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regc_pf_extract(lpc_rtc_regc_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline lpc_rtc_regc_t lpc_rtc_regc_pf_insert(lpc_rtc_regc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_regc_t lpc_rtc_regc_pf_insert(lpc_rtc_regc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbf) | (0x40 & (((lpc_rtc_regc_t )(_fieldval)) << 6)));
}

static inline uint8_t lpc_rtc_regc_irqf_extract(lpc_rtc_regc_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regc_irqf_extract(lpc_rtc_regc_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline lpc_rtc_regc_t lpc_rtc_regc_irqf_insert(lpc_rtc_regc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_regc_t lpc_rtc_regc_irqf_insert(lpc_rtc_regc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7f) | (0x80 & (((lpc_rtc_regc_t )(_fieldval)) << 7)));
}

static inline int lpc_rtc_regc_prtval(char *_s, size_t _size, lpc_rtc_regc_t _regval) __attribute__ ((always_inline));
static inline int lpc_rtc_regc_prtval(char *_s, size_t _size, lpc_rtc_regc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " uf =\t%" PRIx8 "\t(Update-ended)\n", lpc_rtc_regc_uf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " af =\t%" PRIx8 "\t(Alarm)\n", lpc_rtc_regc_af_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pf =\t%" PRIx8 "\t(Periodic interrupt)\n", lpc_rtc_regc_pf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " irqf =\t%" PRIx8 "\t(Interrupt request flag)\n", lpc_rtc_regc_irqf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: lpc_rtc_regd_t
 * Description: Implicit type of Flag register D register
 * Fields:
 *   al_date	(size 6, offset 0, init 0):	RW	Date alarm
 *   _anon6	(size 1, offset 6, init 0):	RSVD	_
 *   vrt	(size 1, offset 7, init 0):	MBZ	Valid RAM and time
 */
typedef uint8_t lpc_rtc_regd_t;
#define lpc_rtc_regd_default 0x0
static inline uint8_t lpc_rtc_regd_al_date_extract(lpc_rtc_regd_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regd_al_date_extract(lpc_rtc_regd_t _regval)
{
    return((uint8_t )((_regval & 0x3f) >> 0));
}

static inline lpc_rtc_regd_t lpc_rtc_regd_al_date_insert(lpc_rtc_regd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_regd_t lpc_rtc_regd_al_date_insert(lpc_rtc_regd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xc0) | (0x3f & (((lpc_rtc_regd_t )(_fieldval)) << 0)));
}

static inline uint8_t lpc_rtc_regd_vrt_extract(lpc_rtc_regd_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regd_vrt_extract(lpc_rtc_regd_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline lpc_rtc_regd_t lpc_rtc_regd_vrt_insert(lpc_rtc_regd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_rtc_regd_t lpc_rtc_regd_vrt_insert(lpc_rtc_regd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7f) | (0x80 & (((lpc_rtc_regd_t )(_fieldval)) << 7)));
}

static inline int lpc_rtc_regd_prtval(char *_s, size_t _size, lpc_rtc_regd_t _regval) __attribute__ ((always_inline));
static inline int lpc_rtc_regd_prtval(char *_s, size_t _size, lpc_rtc_regd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " al_date =\t%" PRIx8 "\t(Date alarm)\n", lpc_rtc_regd_al_date_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vrt =\t%" PRIx8 "\t(Valid RAM and time)\n", lpc_rtc_regd_vrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_io_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum lpc_rtc_initials {
    lpc_rtc_ndx_initial = 0x0,
    lpc_rtc_target_initial = 0x0,
    lpc_rtc_endx_initial = 0x0,
    lpc_rtc_etarget_initial = 0x0,
    lpc_rtc_rega_initial = 0x0,
    lpc_rtc_regb_initial = 0x0,
    lpc_rtc_regc_initial = 0x0,
    lpc_rtc_regd_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void lpc_rtc_initialize(__DN(t) *_dev, mackerel_io_t base) __attribute__ ((always_inline));
static inline void lpc_rtc_initialize(__DN(t) *_dev, mackerel_io_t base)
{
    _dev->base = base;
}

/*
 * Register ndx: Standard index
 * Type: lpc_rtc.uint8 (primitive type)
 */
static inline uint8_t lpc_rtc_ndx_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_ndx_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x70));
}

static inline uint8_t lpc_rtc_ndx_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_ndx_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x70));
}

static inline void lpc_rtc_ndx_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void lpc_rtc_ndx_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x70, _regval);
}

static inline void lpc_rtc_ndx_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void lpc_rtc_ndx_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->base, 0x70, _regval);
}

static inline int lpc_rtc_ndx_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int lpc_rtc_ndx_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_io_8(_dev->base, 0x70);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ndx (Standard index): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register target: Standard target
 * Type: lpc_rtc.uint8 (primitive type)
 */
static inline uint8_t lpc_rtc_target_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_target_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x71));
}

static inline uint8_t lpc_rtc_target_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_target_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x71));
}

static inline void lpc_rtc_target_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void lpc_rtc_target_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x71, _regval);
}

static inline void lpc_rtc_target_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void lpc_rtc_target_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->base, 0x71, _regval);
}

static inline int lpc_rtc_target_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int lpc_rtc_target_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register target (Standard target): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register endx: Extended index
 * Type: lpc_rtc.uint8 (primitive type)
 */
static inline uint8_t lpc_rtc_endx_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_endx_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x72));
}

static inline uint8_t lpc_rtc_endx_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_endx_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x72));
}

static inline void lpc_rtc_endx_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void lpc_rtc_endx_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x72, _regval);
}

static inline void lpc_rtc_endx_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void lpc_rtc_endx_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->base, 0x72, _regval);
}

static inline int lpc_rtc_endx_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int lpc_rtc_endx_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_io_8(_dev->base, 0x72);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register endx (Extended index): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register etarget: Extended target
 * Type: lpc_rtc.uint8 (primitive type)
 */
static inline uint8_t lpc_rtc_etarget_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_etarget_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x73));
}

static inline uint8_t lpc_rtc_etarget_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_etarget_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x73));
}

static inline void lpc_rtc_etarget_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void lpc_rtc_etarget_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x73, _regval);
}

static inline void lpc_rtc_etarget_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void lpc_rtc_etarget_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->base, 0x73, _regval);
}

static inline int lpc_rtc_etarget_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int lpc_rtc_etarget_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_io_8(_dev->base, 0x73);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register etarget (Extended target): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rega: Register A
 * Type: lpc_rtc.rega (Implicit type of Register A register)
 *   rs	(size 4, offset 0, init 0):	RW	Rate select
 *   dv	(size 3, offset 4, init 0):	RW	Divisioin chain select
 *   uip	(size 1, offset 7, init 0):	RW	Update in progress
 */
static inline lpc_rtc_rega_t lpc_rtc_rega_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline lpc_rtc_rega_t lpc_rtc_rega_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x71));
}

static inline lpc_rtc_rega_t lpc_rtc_rega_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline lpc_rtc_rega_t lpc_rtc_rega_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x71));
}

static inline void lpc_rtc_rega_rawwr(__DN(t) *_dev, lpc_rtc_rega_t _regval) __attribute__ ((always_inline));
static inline void lpc_rtc_rega_rawwr(__DN(t) *_dev, lpc_rtc_rega_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x71, _regval);
}

static inline void lpc_rtc_rega_wr(__DN(t) *_dev, lpc_rtc_rega_t _regval) __attribute__ ((always_inline));
static inline void lpc_rtc_rega_wr(__DN(t) *_dev, lpc_rtc_rega_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->base, 0x71, _regval);
}

static inline int lpc_rtc_rega_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int lpc_rtc_rega_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    lpc_rtc_rega_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rega (Register A): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rs =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_rtc_rate_prtval(_s + _r, _avail, lpc_rtc_rega_rs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Rate select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dv =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_rtc_dcs_prtval(_s + _r, _avail, lpc_rtc_rega_dv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Divisioin chain select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " uip =\t%" PRIx8 "\t(Update in progress)\n", lpc_rtc_rega_uip_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline lpc_rtc_rate_t lpc_rtc_rega_rs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline lpc_rtc_rate_t lpc_rtc_rega_rs_rdf(__DN(t) *_dev)
{
    lpc_rtc_rega_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    return(lpc_rtc_rega_rs_extract(_regval));
}

static inline lpc_rtc_dcs_t lpc_rtc_rega_dv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline lpc_rtc_dcs_t lpc_rtc_rega_dv_rdf(__DN(t) *_dev)
{
    lpc_rtc_rega_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    return(lpc_rtc_rega_dv_extract(_regval));
}

static inline uint8_t lpc_rtc_rega_uip_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_rega_uip_rdf(__DN(t) *_dev)
{
    lpc_rtc_rega_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    return(lpc_rtc_rega_uip_extract(_regval));
}

static inline void lpc_rtc_rega_rs_wrf(__DN(t) *_dev, lpc_rtc_rate_t _fieldval) __attribute__ ((always_inline));
static inline void lpc_rtc_rega_rs_wrf(__DN(t) *_dev, lpc_rtc_rate_t _fieldval)
{
    lpc_rtc_rega_t _regval = 0xf & (((lpc_rtc_rega_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf0 & mackerel_read_io_8(_dev->base, 0x71)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x71, _regval);
    // No shadow register to write to
}

static inline void lpc_rtc_rega_dv_wrf(__DN(t) *_dev, lpc_rtc_dcs_t _fieldval) __attribute__ ((always_inline));
static inline void lpc_rtc_rega_dv_wrf(__DN(t) *_dev, lpc_rtc_dcs_t _fieldval)
{
    lpc_rtc_rega_t _regval = 0x70 & (((lpc_rtc_rega_t )(_fieldval)) << 4);
    _regval = (_regval | (0x8f & mackerel_read_io_8(_dev->base, 0x71)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x71, _regval);
    // No shadow register to write to
}

static inline void lpc_rtc_rega_uip_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void lpc_rtc_rega_uip_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    lpc_rtc_rega_t _regval = 0x80 & (((lpc_rtc_rega_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7f & mackerel_read_io_8(_dev->base, 0x71)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x71, _regval);
    // No shadow register to write to
}

/*
 * Register regb: General configuration
 * Type: lpc_rtc.regb (Implicit type of General configuration register)
 *   dse	(size 1, offset 0, init 0):	RW	Daylight savings enable
 *   hourform	(size 1, offset 1, init 0):	RW	Hour format
 *   dm	(size 1, offset 2, init 0):	RW	Data mode (BCD/binary)
 *   sqwe	(size 1, offset 3, init 0):	RW	Square wave enable
 *   uie	(size 1, offset 4, init 0):	RW	Update-ended interrupt enable
 *   aie	(size 1, offset 5, init 0):	RW	Alarm interrupt enable
 *   pie	(size 1, offset 6, init 0):	RW	Periodic interrupt enable
 *   set	(size 1, offset 7, init 0):	RW	Update cycle inhibit
 */
static inline lpc_rtc_regb_t lpc_rtc_regb_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline lpc_rtc_regb_t lpc_rtc_regb_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x71));
}

static inline lpc_rtc_regb_t lpc_rtc_regb_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline lpc_rtc_regb_t lpc_rtc_regb_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x71));
}

static inline void lpc_rtc_regb_rawwr(__DN(t) *_dev, lpc_rtc_regb_t _regval) __attribute__ ((always_inline));
static inline void lpc_rtc_regb_rawwr(__DN(t) *_dev, lpc_rtc_regb_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x71, _regval);
}

static inline void lpc_rtc_regb_wr(__DN(t) *_dev, lpc_rtc_regb_t _regval) __attribute__ ((always_inline));
static inline void lpc_rtc_regb_wr(__DN(t) *_dev, lpc_rtc_regb_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->base, 0x71, _regval);
}

static inline int lpc_rtc_regb_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int lpc_rtc_regb_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    lpc_rtc_regb_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register regb (General configuration): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dse =\t%" PRIx8 "\t(Daylight savings enable)\n", lpc_rtc_regb_dse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hourform =\t%" PRIx8 "\t(Hour format)\n", lpc_rtc_regb_hourform_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dm =\t%" PRIx8 "\t(Data mode (BCD/binary))\n", lpc_rtc_regb_dm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sqwe =\t%" PRIx8 "\t(Square wave enable)\n", lpc_rtc_regb_sqwe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " uie =\t%" PRIx8 "\t(Update-ended interrupt enable)\n", lpc_rtc_regb_uie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aie =\t%" PRIx8 "\t(Alarm interrupt enable)\n", lpc_rtc_regb_aie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pie =\t%" PRIx8 "\t(Periodic interrupt enable)\n", lpc_rtc_regb_pie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " set =\t%" PRIx8 "\t(Update cycle inhibit)\n", lpc_rtc_regb_set_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t lpc_rtc_regb_dse_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regb_dse_rdf(__DN(t) *_dev)
{
    lpc_rtc_regb_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    return(lpc_rtc_regb_dse_extract(_regval));
}

static inline uint8_t lpc_rtc_regb_hourform_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regb_hourform_rdf(__DN(t) *_dev)
{
    lpc_rtc_regb_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    return(lpc_rtc_regb_hourform_extract(_regval));
}

static inline uint8_t lpc_rtc_regb_dm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regb_dm_rdf(__DN(t) *_dev)
{
    lpc_rtc_regb_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    return(lpc_rtc_regb_dm_extract(_regval));
}

static inline uint8_t lpc_rtc_regb_sqwe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regb_sqwe_rdf(__DN(t) *_dev)
{
    lpc_rtc_regb_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    return(lpc_rtc_regb_sqwe_extract(_regval));
}

static inline uint8_t lpc_rtc_regb_uie_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regb_uie_rdf(__DN(t) *_dev)
{
    lpc_rtc_regb_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    return(lpc_rtc_regb_uie_extract(_regval));
}

static inline uint8_t lpc_rtc_regb_aie_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regb_aie_rdf(__DN(t) *_dev)
{
    lpc_rtc_regb_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    return(lpc_rtc_regb_aie_extract(_regval));
}

static inline uint8_t lpc_rtc_regb_pie_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regb_pie_rdf(__DN(t) *_dev)
{
    lpc_rtc_regb_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    return(lpc_rtc_regb_pie_extract(_regval));
}

static inline uint8_t lpc_rtc_regb_set_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regb_set_rdf(__DN(t) *_dev)
{
    lpc_rtc_regb_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    return(lpc_rtc_regb_set_extract(_regval));
}

static inline void lpc_rtc_regb_dse_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void lpc_rtc_regb_dse_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    lpc_rtc_regb_t _regval = 0x1 & (((lpc_rtc_regb_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfe & mackerel_read_io_8(_dev->base, 0x71)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x71, _regval);
    // No shadow register to write to
}

static inline void lpc_rtc_regb_hourform_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void lpc_rtc_regb_hourform_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    lpc_rtc_regb_t _regval = 0x2 & (((lpc_rtc_regb_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfd & mackerel_read_io_8(_dev->base, 0x71)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x71, _regval);
    // No shadow register to write to
}

static inline void lpc_rtc_regb_dm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void lpc_rtc_regb_dm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    lpc_rtc_regb_t _regval = 0x4 & (((lpc_rtc_regb_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfb & mackerel_read_io_8(_dev->base, 0x71)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x71, _regval);
    // No shadow register to write to
}

static inline void lpc_rtc_regb_sqwe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void lpc_rtc_regb_sqwe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    lpc_rtc_regb_t _regval = 0x8 & (((lpc_rtc_regb_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf7 & mackerel_read_io_8(_dev->base, 0x71)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x71, _regval);
    // No shadow register to write to
}

static inline void lpc_rtc_regb_uie_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void lpc_rtc_regb_uie_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    lpc_rtc_regb_t _regval = 0x10 & (((lpc_rtc_regb_t )(_fieldval)) << 4);
    _regval = (_regval | (0xef & mackerel_read_io_8(_dev->base, 0x71)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x71, _regval);
    // No shadow register to write to
}

static inline void lpc_rtc_regb_aie_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void lpc_rtc_regb_aie_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    lpc_rtc_regb_t _regval = 0x20 & (((lpc_rtc_regb_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdf & mackerel_read_io_8(_dev->base, 0x71)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x71, _regval);
    // No shadow register to write to
}

static inline void lpc_rtc_regb_pie_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void lpc_rtc_regb_pie_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    lpc_rtc_regb_t _regval = 0x40 & (((lpc_rtc_regb_t )(_fieldval)) << 6);
    _regval = (_regval | (0xbf & mackerel_read_io_8(_dev->base, 0x71)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x71, _regval);
    // No shadow register to write to
}

static inline void lpc_rtc_regb_set_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void lpc_rtc_regb_set_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    lpc_rtc_regb_t _regval = 0x80 & (((lpc_rtc_regb_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7f & mackerel_read_io_8(_dev->base, 0x71)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x71, _regval);
    // No shadow register to write to
}

/*
 * Register regc: Flag register C
 * Type: lpc_rtc.regc (Implicit type of Flag register C register)
 *   _anon0	(size 4, offset 0, init 0):	RSVD	_
 *   uf	(size 1, offset 4, init 0):	RO	Update-ended
 *   af	(size 1, offset 5, init 0):	RO	Alarm
 *   pf	(size 1, offset 6, init 0):	RO	Periodic interrupt
 *   irqf	(size 1, offset 7, init 0):	RO	Interrupt request flag
 */
static inline lpc_rtc_regc_t lpc_rtc_regc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline lpc_rtc_regc_t lpc_rtc_regc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x71));
}

static inline lpc_rtc_regc_t lpc_rtc_regc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline lpc_rtc_regc_t lpc_rtc_regc_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x71));
}

static inline void lpc_rtc_regc_rawwr(__DN(t) *_dev, lpc_rtc_regc_t _regval) __attribute__ ((always_inline));
static inline void lpc_rtc_regc_rawwr(__DN(t) *_dev, lpc_rtc_regc_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x71, _regval);
}

// Register regc is not writeable
static inline int lpc_rtc_regc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int lpc_rtc_regc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    lpc_rtc_regc_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register regc (Flag register C): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " uf =\t%" PRIx8 "\t(Update-ended)\n", lpc_rtc_regc_uf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " af =\t%" PRIx8 "\t(Alarm)\n", lpc_rtc_regc_af_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pf =\t%" PRIx8 "\t(Periodic interrupt)\n", lpc_rtc_regc_pf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " irqf =\t%" PRIx8 "\t(Interrupt request flag)\n", lpc_rtc_regc_irqf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t lpc_rtc_regc_uf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regc_uf_rdf(__DN(t) *_dev)
{
    lpc_rtc_regc_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    return(lpc_rtc_regc_uf_extract(_regval));
}

static inline uint8_t lpc_rtc_regc_af_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regc_af_rdf(__DN(t) *_dev)
{
    lpc_rtc_regc_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    return(lpc_rtc_regc_af_extract(_regval));
}

static inline uint8_t lpc_rtc_regc_pf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regc_pf_rdf(__DN(t) *_dev)
{
    lpc_rtc_regc_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    return(lpc_rtc_regc_pf_extract(_regval));
}

static inline uint8_t lpc_rtc_regc_irqf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regc_irqf_rdf(__DN(t) *_dev)
{
    lpc_rtc_regc_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    return(lpc_rtc_regc_irqf_extract(_regval));
}

/*
 * Register regd: Flag register D
 * Type: lpc_rtc.regd (Implicit type of Flag register D register)
 *   al_date	(size 6, offset 0, init 0):	RW	Date alarm
 *   _anon6	(size 1, offset 6, init 0):	RSVD	_
 *   vrt	(size 1, offset 7, init 0):	MBZ	Valid RAM and time
 */
static inline lpc_rtc_regd_t lpc_rtc_regd_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline lpc_rtc_regd_t lpc_rtc_regd_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x71));
}

static inline lpc_rtc_regd_t lpc_rtc_regd_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline lpc_rtc_regd_t lpc_rtc_regd_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x71));
}

static inline void lpc_rtc_regd_rawwr(__DN(t) *_dev, lpc_rtc_regd_t _regval) __attribute__ ((always_inline));
static inline void lpc_rtc_regd_rawwr(__DN(t) *_dev, lpc_rtc_regd_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x71, _regval);
}

static inline void lpc_rtc_regd_wr(__DN(t) *_dev, lpc_rtc_regd_t _regval) __attribute__ ((always_inline));
static inline void lpc_rtc_regd_wr(__DN(t) *_dev, lpc_rtc_regd_t _regval)
{
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    _regval = (_regval | (0x40 & mackerel_read_io_8(_dev->base, 0x71)));
    mackerel_write_io_8(_dev->base, 0x71, _regval);
}

static inline int lpc_rtc_regd_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int lpc_rtc_regd_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    lpc_rtc_regd_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register regd (Flag register D): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " al_date =\t%" PRIx8 "\t(Date alarm)\n", lpc_rtc_regd_al_date_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vrt =\t%" PRIx8 "\t(Valid RAM and time)\n", lpc_rtc_regd_vrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t lpc_rtc_regd_al_date_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_rtc_regd_al_date_rdf(__DN(t) *_dev)
{
    lpc_rtc_regd_t _regval = mackerel_read_io_8(_dev->base, 0x71);
    return(lpc_rtc_regd_al_date_extract(_regval));
}

static inline void lpc_rtc_regd_al_date_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void lpc_rtc_regd_al_date_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    lpc_rtc_regd_t _regval = 0x3f & (((lpc_rtc_regd_t )(_fieldval)) << 0);
    _regval = (_regval | (0x40 & mackerel_read_io_8(_dev->base, 0x71)));
    // No read of register shadow required
    _regval = (_regval & 0x7f);
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x71, _regval);
    // No shadow register to write to
}

static inline int lpc_rtc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int lpc_rtc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device lpc_rtc (LPC Real-Time Clock and CMOS RAM):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_rtc_ndx_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_rtc_target_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_rtc_endx_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_rtc_etarget_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_rtc_rega_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_rtc_regb_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_rtc_regc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_rtc_regd_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device lpc_rtc\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __lpc_rtc_DEV_H
