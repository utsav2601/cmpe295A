#ifndef __ahci_hba_DEV_H
#define __ahci_hba_DEV_H 1
/*
 * DEVICE DEFINITION: AHCI generic
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) ahci_hba ## _ ## x
/*
 * Constants defn: ahci_hba.speed (Interface speed)
 *  - no width specified
 */
typedef uint8_t ahci_hba_speed_t;
#define ahci_hba_gen1 ((ahci_hba_speed_t)0x1)
#define ahci_hba_gen2 ((ahci_hba_speed_t)0x2)
#define ahci_hba_gen3 ((ahci_hba_speed_t)0x3)

static inline char *ahci_hba_speed_describe(ahci_hba_speed_t _e) __attribute__ ((always_inline));
static inline char *ahci_hba_speed_describe(ahci_hba_speed_t _e)
{
    switch (_e) {
    case ahci_hba_gen1:
        return("gen1: Gen 1 (1.5 Gbps)");
    case ahci_hba_gen2:
        return("gen2: Gen 2 (3 Gbps)");
    case ahci_hba_gen3:
        return("gen3: Gen 3 (6 Gbps)");
    default:
        return(NULL);
    }
}

static inline int ahci_hba_speed_prtval(char *_s, size_t _size, ahci_hba_speed_t _e) __attribute__ ((always_inline));
static inline int ahci_hba_speed_prtval(char *_s, size_t _size, ahci_hba_speed_t _e)
{
    char *d = ahci_hba_speed_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ahci_hba_speed_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: ahci_hba_cap_t
 * Description: Implicit type of HBA capabilities register
 * Fields:
 *   np	(size 5, offset 0, init 0):	RO	Number of ports
 *   sxs	(size 1, offset 5, init 0):	RO	Supports external SATA
 *   ems	(size 1, offset 6, init 0):	RO	Enclosure management supported
 *   cccs	(size 1, offset 7, init 0):	RO	Command completion coalescing supported
 *   ncs	(size 5, offset 8, init 0):	RO	Number of command slots
 *   psc	(size 1, offset 13, init 0):	RO	Partial state capable
 *   ssc	(size 1, offset 14, init 0):	RO	Slumber state capable
 *   pmd	(size 1, offset 15, init 0):	RO	PIO multiple DRQ block
 *   fbss	(size 1, offset 16, init 0):	RO	FIS-based switching supported
 *   spm	(size 1, offset 17, init 0):	RO	Supports port multiplier
 *   sam	(size 1, offset 18, init 0):	RO	Supports AHCI mode only
 *   _anon19	(size 1, offset 19, init 0):	RSVD	_
 *   iss	(size 4, offset 20, init 0):	RO	Interface speed support
 *   sclo	(size 1, offset 24, init 0):	RO	Supports command list override
 *   sal	(size 1, offset 25, init 0):	RO	Supports activity LED
 *   salp	(size 1, offset 26, init 0):	RO	Supports aggressive link power management
 *   sss	(size 1, offset 27, init 0):	RO	Supports staggered spin-up
 *   smps	(size 1, offset 28, init 0):	RO	Supports mechanical presence switch
 *   ssntf	(size 1, offset 29, init 0):	RO	Supports SNotification register
 *   sncq	(size 1, offset 30, init 0):	RO	Supports native command queueing
 *   s64a	(size 1, offset 31, init 0):	RO	Supports 64-bit addressing
 */
typedef uint32_t ahci_hba_cap_t;
#define ahci_hba_cap_default 0x0
static inline uint8_t ahci_hba_cap_np_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_np_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x1f) >> 0));
}

static inline ahci_hba_cap_t ahci_hba_cap_np_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_np_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((ahci_hba_cap_t )(_fieldval)) << 0)));
}

static inline uint8_t ahci_hba_cap_sxs_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_sxs_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ahci_hba_cap_t ahci_hba_cap_sxs_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_sxs_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((ahci_hba_cap_t )(_fieldval)) << 5)));
}

static inline uint8_t ahci_hba_cap_ems_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_ems_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline ahci_hba_cap_t ahci_hba_cap_ems_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_ems_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((ahci_hba_cap_t )(_fieldval)) << 6)));
}

static inline uint8_t ahci_hba_cap_cccs_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_cccs_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline ahci_hba_cap_t ahci_hba_cap_cccs_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_cccs_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((ahci_hba_cap_t )(_fieldval)) << 7)));
}

static inline uint8_t ahci_hba_cap_ncs_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_ncs_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x1f00) >> 8));
}

static inline ahci_hba_cap_t ahci_hba_cap_ncs_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_ncs_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffe0ff) | (0x1f00 & (((ahci_hba_cap_t )(_fieldval)) << 8)));
}

static inline uint8_t ahci_hba_cap_psc_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_psc_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline ahci_hba_cap_t ahci_hba_cap_psc_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_psc_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((ahci_hba_cap_t )(_fieldval)) << 13)));
}

static inline uint8_t ahci_hba_cap_ssc_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_ssc_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline ahci_hba_cap_t ahci_hba_cap_ssc_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_ssc_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((ahci_hba_cap_t )(_fieldval)) << 14)));
}

static inline uint8_t ahci_hba_cap_pmd_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_pmd_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline ahci_hba_cap_t ahci_hba_cap_pmd_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_pmd_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((ahci_hba_cap_t )(_fieldval)) << 15)));
}

static inline uint8_t ahci_hba_cap_fbss_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_fbss_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline ahci_hba_cap_t ahci_hba_cap_fbss_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_fbss_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((ahci_hba_cap_t )(_fieldval)) << 16)));
}

static inline uint8_t ahci_hba_cap_spm_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_spm_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline ahci_hba_cap_t ahci_hba_cap_spm_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_spm_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((ahci_hba_cap_t )(_fieldval)) << 17)));
}

static inline uint8_t ahci_hba_cap_sam_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_sam_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline ahci_hba_cap_t ahci_hba_cap_sam_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_sam_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((ahci_hba_cap_t )(_fieldval)) << 18)));
}

static inline ahci_hba_speed_t ahci_hba_cap_iss_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline ahci_hba_speed_t ahci_hba_cap_iss_extract(ahci_hba_cap_t _regval)
{
    return((ahci_hba_speed_t )((_regval & 0xf00000) >> 20));
}

static inline ahci_hba_cap_t ahci_hba_cap_iss_insert(ahci_hba_cap_t _regval, ahci_hba_speed_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_iss_insert(ahci_hba_cap_t _regval, ahci_hba_speed_t _fieldval)
{
    return((_regval & 0xff0fffff) | (0xf00000 & (((ahci_hba_cap_t )(_fieldval)) << 20)));
}

static inline uint8_t ahci_hba_cap_sclo_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_sclo_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline ahci_hba_cap_t ahci_hba_cap_sclo_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_sclo_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((ahci_hba_cap_t )(_fieldval)) << 24)));
}

static inline uint8_t ahci_hba_cap_sal_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_sal_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline ahci_hba_cap_t ahci_hba_cap_sal_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_sal_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((ahci_hba_cap_t )(_fieldval)) << 25)));
}

static inline uint8_t ahci_hba_cap_salp_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_salp_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline ahci_hba_cap_t ahci_hba_cap_salp_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_salp_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((ahci_hba_cap_t )(_fieldval)) << 26)));
}

static inline uint8_t ahci_hba_cap_sss_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_sss_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline ahci_hba_cap_t ahci_hba_cap_sss_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_sss_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((ahci_hba_cap_t )(_fieldval)) << 27)));
}

static inline uint8_t ahci_hba_cap_smps_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_smps_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline ahci_hba_cap_t ahci_hba_cap_smps_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_smps_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((ahci_hba_cap_t )(_fieldval)) << 28)));
}

static inline uint8_t ahci_hba_cap_ssntf_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_ssntf_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline ahci_hba_cap_t ahci_hba_cap_ssntf_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_ssntf_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((ahci_hba_cap_t )(_fieldval)) << 29)));
}

static inline uint8_t ahci_hba_cap_sncq_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_sncq_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline ahci_hba_cap_t ahci_hba_cap_sncq_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_sncq_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((ahci_hba_cap_t )(_fieldval)) << 30)));
}

static inline uint8_t ahci_hba_cap_s64a_extract(ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_s64a_extract(ahci_hba_cap_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline ahci_hba_cap_t ahci_hba_cap_s64a_insert(ahci_hba_cap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_s64a_insert(ahci_hba_cap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((ahci_hba_cap_t )(_fieldval)) << 31)));
}

static inline int ahci_hba_cap_prtval(char *_s, size_t _size, ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline int ahci_hba_cap_prtval(char *_s, size_t _size, ahci_hba_cap_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " np =\t%" PRIx8 "\t(Number of ports)\n", ahci_hba_cap_np_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sxs =\t%" PRIx8 "\t(Supports external SATA)\n", ahci_hba_cap_sxs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ems =\t%" PRIx8 "\t(Enclosure management supported)\n", ahci_hba_cap_ems_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cccs =\t%" PRIx8 "\t(Command completion coalescing supported)\n", ahci_hba_cap_cccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ncs =\t%" PRIx8 "\t(Number of command slots)\n", ahci_hba_cap_ncs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " psc =\t%" PRIx8 "\t(Partial state capable)\n", ahci_hba_cap_psc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ssc =\t%" PRIx8 "\t(Slumber state capable)\n", ahci_hba_cap_ssc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmd =\t%" PRIx8 "\t(PIO multiple DRQ block)\n", ahci_hba_cap_pmd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fbss =\t%" PRIx8 "\t(FIS-based switching supported)\n", ahci_hba_cap_fbss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spm =\t%" PRIx8 "\t(Supports port multiplier)\n", ahci_hba_cap_spm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sam =\t%" PRIx8 "\t(Supports AHCI mode only)\n", ahci_hba_cap_sam_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iss =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_hba_speed_prtval(_s + _r, _avail, ahci_hba_cap_iss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interface speed support)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sclo =\t%" PRIx8 "\t(Supports command list override)\n", ahci_hba_cap_sclo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sal =\t%" PRIx8 "\t(Supports activity LED)\n", ahci_hba_cap_sal_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " salp =\t%" PRIx8 "\t(Supports aggressive link power management)\n", ahci_hba_cap_salp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sss =\t%" PRIx8 "\t(Supports staggered spin-up)\n", ahci_hba_cap_sss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smps =\t%" PRIx8 "\t(Supports mechanical presence switch)\n", ahci_hba_cap_smps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ssntf =\t%" PRIx8 "\t(Supports SNotification register)\n", ahci_hba_cap_ssntf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sncq =\t%" PRIx8 "\t(Supports native command queueing)\n", ahci_hba_cap_sncq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " s64a =\t%" PRIx8 "\t(Supports 64-bit addressing)\n", ahci_hba_cap_s64a_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ahci_hba_ghc_t
 * Description: Implicit type of Global HBA control register
 * Fields:
 *   hr	(size 1, offset 0, init 0):	RW	HBA reset
 *   ie	(size 1, offset 1, init 0):	RW	Interrupt enable
 *   mrsm	(size 1, offset 2, init 0):	RO	MSI revert to single message
 *   _anon3	(size 28, offset 3, init 0):	RSVD	_
 *   ae	(size 1, offset 31, init 0):	RW	AHCI enable
 */
typedef uint32_t ahci_hba_ghc_t;
#define ahci_hba_ghc_default 0x0
static inline uint8_t ahci_hba_ghc_hr_extract(ahci_hba_ghc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_ghc_hr_extract(ahci_hba_ghc_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ahci_hba_ghc_t ahci_hba_ghc_hr_insert(ahci_hba_ghc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_ghc_t ahci_hba_ghc_hr_insert(ahci_hba_ghc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ahci_hba_ghc_t )(_fieldval)) << 0)));
}

static inline uint8_t ahci_hba_ghc_ie_extract(ahci_hba_ghc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_ghc_ie_extract(ahci_hba_ghc_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ahci_hba_ghc_t ahci_hba_ghc_ie_insert(ahci_hba_ghc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_ghc_t ahci_hba_ghc_ie_insert(ahci_hba_ghc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ahci_hba_ghc_t )(_fieldval)) << 1)));
}

static inline uint8_t ahci_hba_ghc_mrsm_extract(ahci_hba_ghc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_ghc_mrsm_extract(ahci_hba_ghc_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ahci_hba_ghc_t ahci_hba_ghc_mrsm_insert(ahci_hba_ghc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_ghc_t ahci_hba_ghc_mrsm_insert(ahci_hba_ghc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ahci_hba_ghc_t )(_fieldval)) << 2)));
}

static inline uint8_t ahci_hba_ghc_ae_extract(ahci_hba_ghc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_ghc_ae_extract(ahci_hba_ghc_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline ahci_hba_ghc_t ahci_hba_ghc_ae_insert(ahci_hba_ghc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_ghc_t ahci_hba_ghc_ae_insert(ahci_hba_ghc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((ahci_hba_ghc_t )(_fieldval)) << 31)));
}

static inline int ahci_hba_ghc_prtval(char *_s, size_t _size, ahci_hba_ghc_t _regval) __attribute__ ((always_inline));
static inline int ahci_hba_ghc_prtval(char *_s, size_t _size, ahci_hba_ghc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hr =\t%" PRIx8 "\t(HBA reset)\n", ahci_hba_ghc_hr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ie =\t%" PRIx8 "\t(Interrupt enable)\n", ahci_hba_ghc_ie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mrsm =\t%" PRIx8 "\t(MSI revert to single message)\n", ahci_hba_ghc_mrsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ae =\t%" PRIx8 "\t(AHCI enable)\n", ahci_hba_ghc_ae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ahci_hba_vs_t
 * Description: Implicit type of AHCI version register
 * Fields:
 *   minor	(size 16, offset 0, init 0):	RO	Minor version
 *   major	(size 16, offset 16, init 0):	RO	Major version
 */
typedef uint32_t ahci_hba_vs_t;
#define ahci_hba_vs_default 0x0
static inline uint16_t ahci_hba_vs_minor_extract(ahci_hba_vs_t _regval) __attribute__ ((always_inline));
static inline uint16_t ahci_hba_vs_minor_extract(ahci_hba_vs_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline ahci_hba_vs_t ahci_hba_vs_minor_insert(ahci_hba_vs_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_vs_t ahci_hba_vs_minor_insert(ahci_hba_vs_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((ahci_hba_vs_t )(_fieldval)) << 0)));
}

static inline uint16_t ahci_hba_vs_major_extract(ahci_hba_vs_t _regval) __attribute__ ((always_inline));
static inline uint16_t ahci_hba_vs_major_extract(ahci_hba_vs_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline ahci_hba_vs_t ahci_hba_vs_major_insert(ahci_hba_vs_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_vs_t ahci_hba_vs_major_insert(ahci_hba_vs_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((ahci_hba_vs_t )(_fieldval)) << 16)));
}

static inline int ahci_hba_vs_prtval(char *_s, size_t _size, ahci_hba_vs_t _regval) __attribute__ ((always_inline));
static inline int ahci_hba_vs_prtval(char *_s, size_t _size, ahci_hba_vs_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " minor =\t%" PRIx16 "\t(Minor version)\n", ahci_hba_vs_minor_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " major =\t%" PRIx16 "\t(Major version)\n", ahci_hba_vs_major_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ahci_hba_ccc_ctl_t
 * Description: Implicit type of Command completion coalescing control register
 * Fields:
 *   en	(size 1, offset 0, init 0):	RW	Enable
 *   _anon1	(size 2, offset 1, init 0):	RSVD	_
 *   intr	(size 5, offset 3, init 0):	RO	Interrupt
 *   cc	(size 8, offset 8, init 0):	RW	Command completions
 *   tv	(size 16, offset 16, init 0):	RW	Timeout value
 */
typedef uint32_t ahci_hba_ccc_ctl_t;
#define ahci_hba_ccc_ctl_default 0x0
static inline uint8_t ahci_hba_ccc_ctl_en_extract(ahci_hba_ccc_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_ccc_ctl_en_extract(ahci_hba_ccc_ctl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ahci_hba_ccc_ctl_t ahci_hba_ccc_ctl_en_insert(ahci_hba_ccc_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_ccc_ctl_t ahci_hba_ccc_ctl_en_insert(ahci_hba_ccc_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ahci_hba_ccc_ctl_t )(_fieldval)) << 0)));
}

static inline uint8_t ahci_hba_ccc_ctl_intr_extract(ahci_hba_ccc_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_ccc_ctl_intr_extract(ahci_hba_ccc_ctl_t _regval)
{
    return((uint8_t )((_regval & 0xf8) >> 3));
}

static inline ahci_hba_ccc_ctl_t ahci_hba_ccc_ctl_intr_insert(ahci_hba_ccc_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_ccc_ctl_t ahci_hba_ccc_ctl_intr_insert(ahci_hba_ccc_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff07) | (0xf8 & (((ahci_hba_ccc_ctl_t )(_fieldval)) << 3)));
}

static inline uint8_t ahci_hba_ccc_ctl_cc_extract(ahci_hba_ccc_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_ccc_ctl_cc_extract(ahci_hba_ccc_ctl_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline ahci_hba_ccc_ctl_t ahci_hba_ccc_ctl_cc_insert(ahci_hba_ccc_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_ccc_ctl_t ahci_hba_ccc_ctl_cc_insert(ahci_hba_ccc_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((ahci_hba_ccc_ctl_t )(_fieldval)) << 8)));
}

static inline uint16_t ahci_hba_ccc_ctl_tv_extract(ahci_hba_ccc_ctl_t _regval) __attribute__ ((always_inline));
static inline uint16_t ahci_hba_ccc_ctl_tv_extract(ahci_hba_ccc_ctl_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline ahci_hba_ccc_ctl_t ahci_hba_ccc_ctl_tv_insert(ahci_hba_ccc_ctl_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_ccc_ctl_t ahci_hba_ccc_ctl_tv_insert(ahci_hba_ccc_ctl_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((ahci_hba_ccc_ctl_t )(_fieldval)) << 16)));
}

static inline int ahci_hba_ccc_ctl_prtval(char *_s, size_t _size, ahci_hba_ccc_ctl_t _regval) __attribute__ ((always_inline));
static inline int ahci_hba_ccc_ctl_prtval(char *_s, size_t _size, ahci_hba_ccc_ctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en =\t%" PRIx8 "\t(Enable)\n", ahci_hba_ccc_ctl_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " intr =\t%" PRIx8 "\t(Interrupt)\n", ahci_hba_ccc_ctl_intr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cc =\t%" PRIx8 "\t(Command completions)\n", ahci_hba_ccc_ctl_cc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tv =\t%" PRIx16 "\t(Timeout value)\n", ahci_hba_ccc_ctl_tv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ahci_hba_em_loc_t
 * Description: Implicit type of Enclosure management location register
 * Fields:
 *   sz	(size 16, offset 0, init 0):	RO	Bufer size
 *   ofst	(size 16, offset 16, init 0):	RO	Offset
 */
typedef uint32_t ahci_hba_em_loc_t;
#define ahci_hba_em_loc_default 0x0
static inline uint16_t ahci_hba_em_loc_sz_extract(ahci_hba_em_loc_t _regval) __attribute__ ((always_inline));
static inline uint16_t ahci_hba_em_loc_sz_extract(ahci_hba_em_loc_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline ahci_hba_em_loc_t ahci_hba_em_loc_sz_insert(ahci_hba_em_loc_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_em_loc_t ahci_hba_em_loc_sz_insert(ahci_hba_em_loc_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((ahci_hba_em_loc_t )(_fieldval)) << 0)));
}

static inline uint16_t ahci_hba_em_loc_ofst_extract(ahci_hba_em_loc_t _regval) __attribute__ ((always_inline));
static inline uint16_t ahci_hba_em_loc_ofst_extract(ahci_hba_em_loc_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline ahci_hba_em_loc_t ahci_hba_em_loc_ofst_insert(ahci_hba_em_loc_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_em_loc_t ahci_hba_em_loc_ofst_insert(ahci_hba_em_loc_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((ahci_hba_em_loc_t )(_fieldval)) << 16)));
}

static inline int ahci_hba_em_loc_prtval(char *_s, size_t _size, ahci_hba_em_loc_t _regval) __attribute__ ((always_inline));
static inline int ahci_hba_em_loc_prtval(char *_s, size_t _size, ahci_hba_em_loc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sz =\t%" PRIx16 "\t(Bufer size)\n", ahci_hba_em_loc_sz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ofst =\t%" PRIx16 "\t(Offset)\n", ahci_hba_em_loc_ofst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ahci_hba_em_ctl_t
 * Description: Implicit type of Enclosure management control register
 * Fields:
 *   mr	(size 1, offset 0, init 0):	RWC	Message received
 *   _anon1	(size 7, offset 1, init 0):	RSVD	_
 *   tm	(size 1, offset 8, init 0):	RW	Transmit message
 *   rst	(size 1, offset 9, init 0):	RW	Reset
 *   _anon10	(size 6, offset 10, init 0):	RSVD	_
 *   led	(size 1, offset 16, init 0):	RO	LED message types
 *   safte	(size 1, offset 17, init 0):	RO	SAF-TE enclosure management messages
 *   ses2	(size 1, offset 18, init 0):	RO	SES-2 enclosure management messages
 *   sgpio	(size 1, offset 19, init 0):	RO	SGPIO enclosure management messages
 *   _anon20	(size 4, offset 20, init 0):	RSVD	_
 *   smb	(size 1, offset 24, init 0):	RO	Single message buffer
 *   xmt	(size 1, offset 25, init 0):	RO	Transmit only
 *   alhd	(size 1, offset 26, init 0):	RO	Activity LED hardware driven
 *   pm	(size 1, offset 27, init 0):	RO	Port multiplier support
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
typedef uint32_t ahci_hba_em_ctl_t;
#define ahci_hba_em_ctl_default 0x0
static inline uint8_t ahci_hba_em_ctl_mr_extract(ahci_hba_em_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_mr_extract(ahci_hba_em_ctl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_mr_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_mr_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ahci_hba_em_ctl_t )(_fieldval)) << 0)));
}

static inline uint8_t ahci_hba_em_ctl_tm_extract(ahci_hba_em_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_tm_extract(ahci_hba_em_ctl_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_tm_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_tm_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((ahci_hba_em_ctl_t )(_fieldval)) << 8)));
}

static inline uint8_t ahci_hba_em_ctl_rst_extract(ahci_hba_em_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_rst_extract(ahci_hba_em_ctl_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_rst_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_rst_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((ahci_hba_em_ctl_t )(_fieldval)) << 9)));
}

static inline uint8_t ahci_hba_em_ctl_led_extract(ahci_hba_em_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_led_extract(ahci_hba_em_ctl_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_led_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_led_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((ahci_hba_em_ctl_t )(_fieldval)) << 16)));
}

static inline uint8_t ahci_hba_em_ctl_safte_extract(ahci_hba_em_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_safte_extract(ahci_hba_em_ctl_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_safte_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_safte_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((ahci_hba_em_ctl_t )(_fieldval)) << 17)));
}

static inline uint8_t ahci_hba_em_ctl_ses2_extract(ahci_hba_em_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_ses2_extract(ahci_hba_em_ctl_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_ses2_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_ses2_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((ahci_hba_em_ctl_t )(_fieldval)) << 18)));
}

static inline uint8_t ahci_hba_em_ctl_sgpio_extract(ahci_hba_em_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_sgpio_extract(ahci_hba_em_ctl_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_sgpio_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_sgpio_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((ahci_hba_em_ctl_t )(_fieldval)) << 19)));
}

static inline uint8_t ahci_hba_em_ctl_smb_extract(ahci_hba_em_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_smb_extract(ahci_hba_em_ctl_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_smb_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_smb_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((ahci_hba_em_ctl_t )(_fieldval)) << 24)));
}

static inline uint8_t ahci_hba_em_ctl_xmt_extract(ahci_hba_em_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_xmt_extract(ahci_hba_em_ctl_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_xmt_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_xmt_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((ahci_hba_em_ctl_t )(_fieldval)) << 25)));
}

static inline uint8_t ahci_hba_em_ctl_alhd_extract(ahci_hba_em_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_alhd_extract(ahci_hba_em_ctl_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_alhd_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_alhd_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((ahci_hba_em_ctl_t )(_fieldval)) << 26)));
}

static inline uint8_t ahci_hba_em_ctl_pm_extract(ahci_hba_em_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_pm_extract(ahci_hba_em_ctl_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_pm_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_pm_insert(ahci_hba_em_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((ahci_hba_em_ctl_t )(_fieldval)) << 27)));
}

static inline int ahci_hba_em_ctl_prtval(char *_s, size_t _size, ahci_hba_em_ctl_t _regval) __attribute__ ((always_inline));
static inline int ahci_hba_em_ctl_prtval(char *_s, size_t _size, ahci_hba_em_ctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mr =\t%" PRIx8 "\t(Message received)\n", ahci_hba_em_ctl_mr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tm =\t%" PRIx8 "\t(Transmit message)\n", ahci_hba_em_ctl_tm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rst =\t%" PRIx8 "\t(Reset)\n", ahci_hba_em_ctl_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led =\t%" PRIx8 "\t(LED message types)\n", ahci_hba_em_ctl_led_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " safte =\t%" PRIx8 "\t(SAF-TE enclosure management messages)\n", ahci_hba_em_ctl_safte_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ses2 =\t%" PRIx8 "\t(SES-2 enclosure management messages)\n", ahci_hba_em_ctl_ses2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sgpio =\t%" PRIx8 "\t(SGPIO enclosure management messages)\n", ahci_hba_em_ctl_sgpio_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smb =\t%" PRIx8 "\t(Single message buffer)\n", ahci_hba_em_ctl_smb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xmt =\t%" PRIx8 "\t(Transmit only)\n", ahci_hba_em_ctl_xmt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " alhd =\t%" PRIx8 "\t(Activity LED hardware driven)\n", ahci_hba_em_ctl_alhd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pm =\t%" PRIx8 "\t(Port multiplier support)\n", ahci_hba_em_ctl_pm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ahci_hba_cap2_t
 * Description: Implicit type of HBA capabilities extended register
 * Fields:
 *   boh	(size 1, offset 0, init 0):	RO	BIOS/OS handoff
 *   nvmp	(size 1, offset 1, init 0):	RO	NVMHCI present
 *   apst	(size 1, offset 2, init 0):	RO	Automatic partial to slumber transitions
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
typedef uint32_t ahci_hba_cap2_t;
#define ahci_hba_cap2_default 0x0
static inline uint8_t ahci_hba_cap2_boh_extract(ahci_hba_cap2_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap2_boh_extract(ahci_hba_cap2_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ahci_hba_cap2_t ahci_hba_cap2_boh_insert(ahci_hba_cap2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap2_t ahci_hba_cap2_boh_insert(ahci_hba_cap2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ahci_hba_cap2_t )(_fieldval)) << 0)));
}

static inline uint8_t ahci_hba_cap2_nvmp_extract(ahci_hba_cap2_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap2_nvmp_extract(ahci_hba_cap2_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ahci_hba_cap2_t ahci_hba_cap2_nvmp_insert(ahci_hba_cap2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap2_t ahci_hba_cap2_nvmp_insert(ahci_hba_cap2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ahci_hba_cap2_t )(_fieldval)) << 1)));
}

static inline uint8_t ahci_hba_cap2_apst_extract(ahci_hba_cap2_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap2_apst_extract(ahci_hba_cap2_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ahci_hba_cap2_t ahci_hba_cap2_apst_insert(ahci_hba_cap2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_cap2_t ahci_hba_cap2_apst_insert(ahci_hba_cap2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ahci_hba_cap2_t )(_fieldval)) << 2)));
}

static inline int ahci_hba_cap2_prtval(char *_s, size_t _size, ahci_hba_cap2_t _regval) __attribute__ ((always_inline));
static inline int ahci_hba_cap2_prtval(char *_s, size_t _size, ahci_hba_cap2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " boh =\t%" PRIx8 "\t(BIOS/OS handoff)\n", ahci_hba_cap2_boh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nvmp =\t%" PRIx8 "\t(NVMHCI present)\n", ahci_hba_cap2_nvmp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apst =\t%" PRIx8 "\t(Automatic partial to slumber transitions)\n", ahci_hba_cap2_apst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ahci_hba_bohc_t
 * Description: Implicit type of BIOS/OS handoff control and status register
 * Fields:
 *   bos	(size 1, offset 0, init 0):	RW	BIOS owned semaphore
 *   oos	(size 1, offset 1, init 0):	RW	OS owned semaphore
 *   sooe	(size 1, offset 2, init 0):	RW	SMI on OS ownership change enable
 *   ooc	(size 1, offset 3, init 0):	RWC	OS ownership change
 *   bb	(size 1, offset 4, init 0):	RW	BIOS busy
 *   _anon5	(size 27, offset 5, init 0):	RSVD	_
 */
typedef uint32_t ahci_hba_bohc_t;
#define ahci_hba_bohc_default 0x0
static inline uint8_t ahci_hba_bohc_bos_extract(ahci_hba_bohc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_bohc_bos_extract(ahci_hba_bohc_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ahci_hba_bohc_t ahci_hba_bohc_bos_insert(ahci_hba_bohc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_bohc_t ahci_hba_bohc_bos_insert(ahci_hba_bohc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ahci_hba_bohc_t )(_fieldval)) << 0)));
}

static inline uint8_t ahci_hba_bohc_oos_extract(ahci_hba_bohc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_bohc_oos_extract(ahci_hba_bohc_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ahci_hba_bohc_t ahci_hba_bohc_oos_insert(ahci_hba_bohc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_bohc_t ahci_hba_bohc_oos_insert(ahci_hba_bohc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ahci_hba_bohc_t )(_fieldval)) << 1)));
}

static inline uint8_t ahci_hba_bohc_sooe_extract(ahci_hba_bohc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_bohc_sooe_extract(ahci_hba_bohc_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ahci_hba_bohc_t ahci_hba_bohc_sooe_insert(ahci_hba_bohc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_bohc_t ahci_hba_bohc_sooe_insert(ahci_hba_bohc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ahci_hba_bohc_t )(_fieldval)) << 2)));
}

static inline uint8_t ahci_hba_bohc_ooc_extract(ahci_hba_bohc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_bohc_ooc_extract(ahci_hba_bohc_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ahci_hba_bohc_t ahci_hba_bohc_ooc_insert(ahci_hba_bohc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_bohc_t ahci_hba_bohc_ooc_insert(ahci_hba_bohc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ahci_hba_bohc_t )(_fieldval)) << 3)));
}

static inline uint8_t ahci_hba_bohc_bb_extract(ahci_hba_bohc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_bohc_bb_extract(ahci_hba_bohc_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ahci_hba_bohc_t ahci_hba_bohc_bb_insert(ahci_hba_bohc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_hba_bohc_t ahci_hba_bohc_bb_insert(ahci_hba_bohc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ahci_hba_bohc_t )(_fieldval)) << 4)));
}

static inline int ahci_hba_bohc_prtval(char *_s, size_t _size, ahci_hba_bohc_t _regval) __attribute__ ((always_inline));
static inline int ahci_hba_bohc_prtval(char *_s, size_t _size, ahci_hba_bohc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bos =\t%" PRIx8 "\t(BIOS owned semaphore)\n", ahci_hba_bohc_bos_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oos =\t%" PRIx8 "\t(OS owned semaphore)\n", ahci_hba_bohc_oos_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sooe =\t%" PRIx8 "\t(SMI on OS ownership change enable)\n", ahci_hba_bohc_sooe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ooc =\t%" PRIx8 "\t(OS ownership change)\n", ahci_hba_bohc_ooc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bb =\t%" PRIx8 "\t(BIOS busy)\n", ahci_hba_bohc_bb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t b;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum ahci_hba_initials {
    ahci_hba_cap_initial = 0x0,
    ahci_hba_ghc_initial = 0x0,
    ahci_hba_is_initial = 0x0,
    ahci_hba_pi_initial = 0x0,
    ahci_hba_vs_initial = 0x0,
    ahci_hba_ccc_ctl_initial = 0x0,
    ahci_hba_ccc_ports_initial = 0x0,
    ahci_hba_em_loc_initial = 0x0,
    ahci_hba_em_ctl_initial = 0x0,
    ahci_hba_cap2_initial = 0x0,
    ahci_hba_bohc_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void ahci_hba_initialize(__DN(t) *_dev, mackerel_addr_t b) __attribute__ ((always_inline));
static inline void ahci_hba_initialize(__DN(t) *_dev, mackerel_addr_t b)
{
    _dev->b = b;
}

/*
 * Register cap: HBA capabilities
 * Type: ahci_hba.cap (Implicit type of HBA capabilities register)
 *   np	(size 5, offset 0, init 0):	RO	Number of ports
 *   sxs	(size 1, offset 5, init 0):	RO	Supports external SATA
 *   ems	(size 1, offset 6, init 0):	RO	Enclosure management supported
 *   cccs	(size 1, offset 7, init 0):	RO	Command completion coalescing supported
 *   ncs	(size 5, offset 8, init 0):	RO	Number of command slots
 *   psc	(size 1, offset 13, init 0):	RO	Partial state capable
 *   ssc	(size 1, offset 14, init 0):	RO	Slumber state capable
 *   pmd	(size 1, offset 15, init 0):	RO	PIO multiple DRQ block
 *   fbss	(size 1, offset 16, init 0):	RO	FIS-based switching supported
 *   spm	(size 1, offset 17, init 0):	RO	Supports port multiplier
 *   sam	(size 1, offset 18, init 0):	RO	Supports AHCI mode only
 *   _anon19	(size 1, offset 19, init 0):	RSVD	_
 *   iss	(size 4, offset 20, init 0):	RO	Interface speed support
 *   sclo	(size 1, offset 24, init 0):	RO	Supports command list override
 *   sal	(size 1, offset 25, init 0):	RO	Supports activity LED
 *   salp	(size 1, offset 26, init 0):	RO	Supports aggressive link power management
 *   sss	(size 1, offset 27, init 0):	RO	Supports staggered spin-up
 *   smps	(size 1, offset 28, init 0):	RO	Supports mechanical presence switch
 *   ssntf	(size 1, offset 29, init 0):	RO	Supports SNotification register
 *   sncq	(size 1, offset 30, init 0):	RO	Supports native command queueing
 *   s64a	(size 1, offset 31, init 0):	RO	Supports 64-bit addressing
 */
static inline ahci_hba_cap_t ahci_hba_cap_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x0));
}

static inline ahci_hba_cap_t ahci_hba_cap_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_cap_t ahci_hba_cap_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x0));
}

static inline void ahci_hba_cap_rawwr(__DN(t) *_dev, ahci_hba_cap_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_cap_rawwr(__DN(t) *_dev, ahci_hba_cap_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x0, _regval);
}

// Register cap is not writeable
static inline int ahci_hba_cap_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_hba_cap_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cap (HBA capabilities): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " np =\t%" PRIx8 "\t(Number of ports)\n", ahci_hba_cap_np_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sxs =\t%" PRIx8 "\t(Supports external SATA)\n", ahci_hba_cap_sxs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ems =\t%" PRIx8 "\t(Enclosure management supported)\n", ahci_hba_cap_ems_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cccs =\t%" PRIx8 "\t(Command completion coalescing supported)\n", ahci_hba_cap_cccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ncs =\t%" PRIx8 "\t(Number of command slots)\n", ahci_hba_cap_ncs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " psc =\t%" PRIx8 "\t(Partial state capable)\n", ahci_hba_cap_psc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ssc =\t%" PRIx8 "\t(Slumber state capable)\n", ahci_hba_cap_ssc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmd =\t%" PRIx8 "\t(PIO multiple DRQ block)\n", ahci_hba_cap_pmd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fbss =\t%" PRIx8 "\t(FIS-based switching supported)\n", ahci_hba_cap_fbss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spm =\t%" PRIx8 "\t(Supports port multiplier)\n", ahci_hba_cap_spm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sam =\t%" PRIx8 "\t(Supports AHCI mode only)\n", ahci_hba_cap_sam_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iss =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_hba_speed_prtval(_s + _r, _avail, ahci_hba_cap_iss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interface speed support)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sclo =\t%" PRIx8 "\t(Supports command list override)\n", ahci_hba_cap_sclo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sal =\t%" PRIx8 "\t(Supports activity LED)\n", ahci_hba_cap_sal_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " salp =\t%" PRIx8 "\t(Supports aggressive link power management)\n", ahci_hba_cap_salp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sss =\t%" PRIx8 "\t(Supports staggered spin-up)\n", ahci_hba_cap_sss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smps =\t%" PRIx8 "\t(Supports mechanical presence switch)\n", ahci_hba_cap_smps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ssntf =\t%" PRIx8 "\t(Supports SNotification register)\n", ahci_hba_cap_ssntf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sncq =\t%" PRIx8 "\t(Supports native command queueing)\n", ahci_hba_cap_sncq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " s64a =\t%" PRIx8 "\t(Supports 64-bit addressing)\n", ahci_hba_cap_s64a_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t ahci_hba_cap_np_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_np_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_np_extract(_regval));
}

static inline uint8_t ahci_hba_cap_sxs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_sxs_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_sxs_extract(_regval));
}

static inline uint8_t ahci_hba_cap_ems_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_ems_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_ems_extract(_regval));
}

static inline uint8_t ahci_hba_cap_cccs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_cccs_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_cccs_extract(_regval));
}

static inline uint8_t ahci_hba_cap_ncs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_ncs_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_ncs_extract(_regval));
}

static inline uint8_t ahci_hba_cap_psc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_psc_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_psc_extract(_regval));
}

static inline uint8_t ahci_hba_cap_ssc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_ssc_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_ssc_extract(_regval));
}

static inline uint8_t ahci_hba_cap_pmd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_pmd_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_pmd_extract(_regval));
}

static inline uint8_t ahci_hba_cap_fbss_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_fbss_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_fbss_extract(_regval));
}

static inline uint8_t ahci_hba_cap_spm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_spm_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_spm_extract(_regval));
}

static inline uint8_t ahci_hba_cap_sam_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_sam_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_sam_extract(_regval));
}

static inline ahci_hba_speed_t ahci_hba_cap_iss_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_speed_t ahci_hba_cap_iss_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_iss_extract(_regval));
}

static inline uint8_t ahci_hba_cap_sclo_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_sclo_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_sclo_extract(_regval));
}

static inline uint8_t ahci_hba_cap_sal_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_sal_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_sal_extract(_regval));
}

static inline uint8_t ahci_hba_cap_salp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_salp_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_salp_extract(_regval));
}

static inline uint8_t ahci_hba_cap_sss_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_sss_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_sss_extract(_regval));
}

static inline uint8_t ahci_hba_cap_smps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_smps_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_smps_extract(_regval));
}

static inline uint8_t ahci_hba_cap_ssntf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_ssntf_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_ssntf_extract(_regval));
}

static inline uint8_t ahci_hba_cap_sncq_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_sncq_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_sncq_extract(_regval));
}

static inline uint8_t ahci_hba_cap_s64a_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap_s64a_rdf(__DN(t) *_dev)
{
    ahci_hba_cap_t _regval = mackerel_read_addr_32(_dev->b, 0x0);
    return(ahci_hba_cap_s64a_extract(_regval));
}

/*
 * Register ghc: Global HBA control
 * Type: ahci_hba.ghc (Implicit type of Global HBA control register)
 *   hr	(size 1, offset 0, init 0):	RW	HBA reset
 *   ie	(size 1, offset 1, init 0):	RW	Interrupt enable
 *   mrsm	(size 1, offset 2, init 0):	RO	MSI revert to single message
 *   _anon3	(size 28, offset 3, init 0):	RSVD	_
 *   ae	(size 1, offset 31, init 0):	RW	AHCI enable
 */
static inline ahci_hba_ghc_t ahci_hba_ghc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_ghc_t ahci_hba_ghc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x4));
}

static inline ahci_hba_ghc_t ahci_hba_ghc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_ghc_t ahci_hba_ghc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x4));
}

static inline void ahci_hba_ghc_rawwr(__DN(t) *_dev, ahci_hba_ghc_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_ghc_rawwr(__DN(t) *_dev, ahci_hba_ghc_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x4, _regval);
}

static inline void ahci_hba_ghc_wr(__DN(t) *_dev, ahci_hba_ghc_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_ghc_wr(__DN(t) *_dev, ahci_hba_ghc_t _regval)
{
    _regval = (_regval & 0x80000007);
    // No MB1 fields present
    _regval = (_regval | (0x7ffffff8 & mackerel_read_addr_32(_dev->b, 0x4)));
    mackerel_write_addr_32(_dev->b, 0x4, _regval);
}

static inline int ahci_hba_ghc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_hba_ghc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_hba_ghc_t _regval = mackerel_read_addr_32(_dev->b, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ghc (Global HBA control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hr =\t%" PRIx8 "\t(HBA reset)\n", ahci_hba_ghc_hr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ie =\t%" PRIx8 "\t(Interrupt enable)\n", ahci_hba_ghc_ie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mrsm =\t%" PRIx8 "\t(MSI revert to single message)\n", ahci_hba_ghc_mrsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ae =\t%" PRIx8 "\t(AHCI enable)\n", ahci_hba_ghc_ae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t ahci_hba_ghc_hr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_ghc_hr_rdf(__DN(t) *_dev)
{
    ahci_hba_ghc_t _regval = mackerel_read_addr_32(_dev->b, 0x4);
    return(ahci_hba_ghc_hr_extract(_regval));
}

static inline uint8_t ahci_hba_ghc_ie_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_ghc_ie_rdf(__DN(t) *_dev)
{
    ahci_hba_ghc_t _regval = mackerel_read_addr_32(_dev->b, 0x4);
    return(ahci_hba_ghc_ie_extract(_regval));
}

static inline uint8_t ahci_hba_ghc_mrsm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_ghc_mrsm_rdf(__DN(t) *_dev)
{
    ahci_hba_ghc_t _regval = mackerel_read_addr_32(_dev->b, 0x4);
    return(ahci_hba_ghc_mrsm_extract(_regval));
}

static inline uint8_t ahci_hba_ghc_ae_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_ghc_ae_rdf(__DN(t) *_dev)
{
    ahci_hba_ghc_t _regval = mackerel_read_addr_32(_dev->b, 0x4);
    return(ahci_hba_ghc_ae_extract(_regval));
}

static inline void ahci_hba_ghc_hr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_hba_ghc_hr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_hba_ghc_t _regval = 0x1 & (((ahci_hba_ghc_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffa & mackerel_read_addr_32(_dev->b, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x4, _regval);
    // No shadow register to write to
}

static inline void ahci_hba_ghc_ie_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_hba_ghc_ie_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_hba_ghc_t _regval = 0x2 & (((ahci_hba_ghc_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffff9 & mackerel_read_addr_32(_dev->b, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x4, _regval);
    // No shadow register to write to
}

static inline void ahci_hba_ghc_ae_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_hba_ghc_ae_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_hba_ghc_t _regval = 0x80000000 & (((ahci_hba_ghc_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7ffffffb & mackerel_read_addr_32(_dev->b, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x4, _regval);
    // No shadow register to write to
}

/*
 * Register is: Interrupt status
 * Type: ahci_hba.uint32 (primitive type)
 */
static inline uint32_t ahci_hba_is_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ahci_hba_is_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x8));
}

static inline uint32_t ahci_hba_is_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ahci_hba_is_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x8));
}

static inline void ahci_hba_is_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_is_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x8, _regval);
}

static inline void ahci_hba_is_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_is_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->b, 0x8, _regval);
}

static inline int ahci_hba_is_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_hba_is_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->b, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register is (Interrupt status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register pi: Ports implemented
 * Type: ahci_hba.uint32 (primitive type)
 */
static inline uint32_t ahci_hba_pi_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ahci_hba_pi_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0xc));
}

static inline uint32_t ahci_hba_pi_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ahci_hba_pi_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0xc));
}

static inline void ahci_hba_pi_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_pi_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0xc, _regval);
}

// Register pi is not writeable
static inline int ahci_hba_pi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_hba_pi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->b, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pi (Ports implemented): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register vs: AHCI version
 * Type: ahci_hba.vs (Implicit type of AHCI version register)
 *   minor	(size 16, offset 0, init 0):	RO	Minor version
 *   major	(size 16, offset 16, init 0):	RO	Major version
 */
static inline ahci_hba_vs_t ahci_hba_vs_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_vs_t ahci_hba_vs_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x10));
}

static inline ahci_hba_vs_t ahci_hba_vs_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_vs_t ahci_hba_vs_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x10));
}

static inline void ahci_hba_vs_rawwr(__DN(t) *_dev, ahci_hba_vs_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_vs_rawwr(__DN(t) *_dev, ahci_hba_vs_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
}

// Register vs is not writeable
static inline int ahci_hba_vs_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_hba_vs_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_hba_vs_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vs (AHCI version): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " minor =\t%" PRIx16 "\t(Minor version)\n", ahci_hba_vs_minor_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " major =\t%" PRIx16 "\t(Major version)\n", ahci_hba_vs_major_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t ahci_hba_vs_minor_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ahci_hba_vs_minor_rdf(__DN(t) *_dev)
{
    ahci_hba_vs_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_hba_vs_minor_extract(_regval));
}

static inline uint16_t ahci_hba_vs_major_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ahci_hba_vs_major_rdf(__DN(t) *_dev)
{
    ahci_hba_vs_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_hba_vs_major_extract(_regval));
}

/*
 * Register ccc_ctl: Command completion coalescing control
 * Type: ahci_hba.ccc_ctl (Implicit type of Command completion coalescing control register)
 *   en	(size 1, offset 0, init 0):	RW	Enable
 *   _anon1	(size 2, offset 1, init 0):	RSVD	_
 *   intr	(size 5, offset 3, init 0):	RO	Interrupt
 *   cc	(size 8, offset 8, init 0):	RW	Command completions
 *   tv	(size 16, offset 16, init 0):	RW	Timeout value
 */
static inline ahci_hba_ccc_ctl_t ahci_hba_ccc_ctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_ccc_ctl_t ahci_hba_ccc_ctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x14));
}

static inline ahci_hba_ccc_ctl_t ahci_hba_ccc_ctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_ccc_ctl_t ahci_hba_ccc_ctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x14));
}

static inline void ahci_hba_ccc_ctl_rawwr(__DN(t) *_dev, ahci_hba_ccc_ctl_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_ccc_ctl_rawwr(__DN(t) *_dev, ahci_hba_ccc_ctl_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
}

static inline void ahci_hba_ccc_ctl_wr(__DN(t) *_dev, ahci_hba_ccc_ctl_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_ccc_ctl_wr(__DN(t) *_dev, ahci_hba_ccc_ctl_t _regval)
{
    _regval = (_regval & 0xfffffff9);
    // No MB1 fields present
    _regval = (_regval | (0x6 & mackerel_read_addr_32(_dev->b, 0x14)));
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
}

static inline int ahci_hba_ccc_ctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_hba_ccc_ctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_hba_ccc_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ccc_ctl (Command completion coalescing control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en =\t%" PRIx8 "\t(Enable)\n", ahci_hba_ccc_ctl_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " intr =\t%" PRIx8 "\t(Interrupt)\n", ahci_hba_ccc_ctl_intr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cc =\t%" PRIx8 "\t(Command completions)\n", ahci_hba_ccc_ctl_cc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tv =\t%" PRIx16 "\t(Timeout value)\n", ahci_hba_ccc_ctl_tv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t ahci_hba_ccc_ctl_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_ccc_ctl_en_rdf(__DN(t) *_dev)
{
    ahci_hba_ccc_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_hba_ccc_ctl_en_extract(_regval));
}

static inline uint8_t ahci_hba_ccc_ctl_intr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_ccc_ctl_intr_rdf(__DN(t) *_dev)
{
    ahci_hba_ccc_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_hba_ccc_ctl_intr_extract(_regval));
}

static inline uint8_t ahci_hba_ccc_ctl_cc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_ccc_ctl_cc_rdf(__DN(t) *_dev)
{
    ahci_hba_ccc_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_hba_ccc_ctl_cc_extract(_regval));
}

static inline uint16_t ahci_hba_ccc_ctl_tv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ahci_hba_ccc_ctl_tv_rdf(__DN(t) *_dev)
{
    ahci_hba_ccc_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_hba_ccc_ctl_tv_extract(_regval));
}

static inline void ahci_hba_ccc_ctl_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_hba_ccc_ctl_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_hba_ccc_ctl_t _regval = 0x1 & (((ahci_hba_ccc_ctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff06 & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

static inline void ahci_hba_ccc_ctl_cc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_hba_ccc_ctl_cc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_hba_ccc_ctl_t _regval = 0xff00 & (((ahci_hba_ccc_ctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff0007 & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

static inline void ahci_hba_ccc_ctl_tv_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_hba_ccc_ctl_tv_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    ahci_hba_ccc_ctl_t _regval = 0xffff0000 & (((ahci_hba_ccc_ctl_t )(_fieldval)) << 16);
    _regval = (_regval | (0xff07 & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

/*
 * Register ccc_ports: Command completions coalescing ports
 * Type: ahci_hba.uint32 (primitive type)
 */
static inline uint32_t ahci_hba_ccc_ports_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ahci_hba_ccc_ports_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x18));
}

static inline uint32_t ahci_hba_ccc_ports_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ahci_hba_ccc_ports_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x18));
}

static inline void ahci_hba_ccc_ports_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_ccc_ports_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x18, _regval);
}

static inline void ahci_hba_ccc_ports_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_ccc_ports_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->b, 0x18, _regval);
}

static inline int ahci_hba_ccc_ports_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_hba_ccc_ports_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ccc_ports (Command completions coalescing ports): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register em_loc: Enclosure management location
 * Type: ahci_hba.em_loc (Implicit type of Enclosure management location register)
 *   sz	(size 16, offset 0, init 0):	RO	Bufer size
 *   ofst	(size 16, offset 16, init 0):	RO	Offset
 */
static inline ahci_hba_em_loc_t ahci_hba_em_loc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_em_loc_t ahci_hba_em_loc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x1c));
}

static inline ahci_hba_em_loc_t ahci_hba_em_loc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_em_loc_t ahci_hba_em_loc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x1c));
}

static inline void ahci_hba_em_loc_rawwr(__DN(t) *_dev, ahci_hba_em_loc_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_em_loc_rawwr(__DN(t) *_dev, ahci_hba_em_loc_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x1c, _regval);
}

// Register em_loc is not writeable
static inline int ahci_hba_em_loc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_hba_em_loc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_hba_em_loc_t _regval = mackerel_read_addr_32(_dev->b, 0x1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register em_loc (Enclosure management location): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sz =\t%" PRIx16 "\t(Bufer size)\n", ahci_hba_em_loc_sz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ofst =\t%" PRIx16 "\t(Offset)\n", ahci_hba_em_loc_ofst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t ahci_hba_em_loc_sz_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ahci_hba_em_loc_sz_rdf(__DN(t) *_dev)
{
    ahci_hba_em_loc_t _regval = mackerel_read_addr_32(_dev->b, 0x1c);
    return(ahci_hba_em_loc_sz_extract(_regval));
}

static inline uint16_t ahci_hba_em_loc_ofst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ahci_hba_em_loc_ofst_rdf(__DN(t) *_dev)
{
    ahci_hba_em_loc_t _regval = mackerel_read_addr_32(_dev->b, 0x1c);
    return(ahci_hba_em_loc_ofst_extract(_regval));
}

/*
 * Register em_ctl: Enclosure management control
 * Type: ahci_hba.em_ctl (Implicit type of Enclosure management control register)
 *   mr	(size 1, offset 0, init 0):	RWC	Message received
 *   _anon1	(size 7, offset 1, init 0):	RSVD	_
 *   tm	(size 1, offset 8, init 0):	RW	Transmit message
 *   rst	(size 1, offset 9, init 0):	RW	Reset
 *   _anon10	(size 6, offset 10, init 0):	RSVD	_
 *   led	(size 1, offset 16, init 0):	RO	LED message types
 *   safte	(size 1, offset 17, init 0):	RO	SAF-TE enclosure management messages
 *   ses2	(size 1, offset 18, init 0):	RO	SES-2 enclosure management messages
 *   sgpio	(size 1, offset 19, init 0):	RO	SGPIO enclosure management messages
 *   _anon20	(size 4, offset 20, init 0):	RSVD	_
 *   smb	(size 1, offset 24, init 0):	RO	Single message buffer
 *   xmt	(size 1, offset 25, init 0):	RO	Transmit only
 *   alhd	(size 1, offset 26, init 0):	RO	Activity LED hardware driven
 *   pm	(size 1, offset 27, init 0):	RO	Port multiplier support
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x20));
}

static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_em_ctl_t ahci_hba_em_ctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x20));
}

static inline void ahci_hba_em_ctl_rawwr(__DN(t) *_dev, ahci_hba_em_ctl_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_em_ctl_rawwr(__DN(t) *_dev, ahci_hba_em_ctl_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x20, _regval);
}

static inline void ahci_hba_em_ctl_wr(__DN(t) *_dev, ahci_hba_em_ctl_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_em_ctl_wr(__DN(t) *_dev, ahci_hba_em_ctl_t _regval)
{
    _regval = (_regval & 0xf0f0301);
    // No MB1 fields present
    _regval = (_regval | (0xf0f0fcfe & mackerel_read_addr_32(_dev->b, 0x20)));
    mackerel_write_addr_32(_dev->b, 0x20, _regval);
}

static inline int ahci_hba_em_ctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_hba_em_ctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_hba_em_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register em_ctl (Enclosure management control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mr =\t%" PRIx8 "\t(Message received)\n", ahci_hba_em_ctl_mr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tm =\t%" PRIx8 "\t(Transmit message)\n", ahci_hba_em_ctl_tm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rst =\t%" PRIx8 "\t(Reset)\n", ahci_hba_em_ctl_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led =\t%" PRIx8 "\t(LED message types)\n", ahci_hba_em_ctl_led_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " safte =\t%" PRIx8 "\t(SAF-TE enclosure management messages)\n", ahci_hba_em_ctl_safte_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ses2 =\t%" PRIx8 "\t(SES-2 enclosure management messages)\n", ahci_hba_em_ctl_ses2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sgpio =\t%" PRIx8 "\t(SGPIO enclosure management messages)\n", ahci_hba_em_ctl_sgpio_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smb =\t%" PRIx8 "\t(Single message buffer)\n", ahci_hba_em_ctl_smb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xmt =\t%" PRIx8 "\t(Transmit only)\n", ahci_hba_em_ctl_xmt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " alhd =\t%" PRIx8 "\t(Activity LED hardware driven)\n", ahci_hba_em_ctl_alhd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pm =\t%" PRIx8 "\t(Port multiplier support)\n", ahci_hba_em_ctl_pm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    return(_r);
}

static inline uint8_t ahci_hba_em_ctl_mr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_mr_rdf(__DN(t) *_dev)
{
    ahci_hba_em_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x20);
    return(ahci_hba_em_ctl_mr_extract(_regval));
}

static inline uint8_t ahci_hba_em_ctl_tm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_tm_rdf(__DN(t) *_dev)
{
    ahci_hba_em_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x20);
    return(ahci_hba_em_ctl_tm_extract(_regval));
}

static inline uint8_t ahci_hba_em_ctl_rst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_rst_rdf(__DN(t) *_dev)
{
    ahci_hba_em_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x20);
    return(ahci_hba_em_ctl_rst_extract(_regval));
}

static inline uint8_t ahci_hba_em_ctl_led_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_led_rdf(__DN(t) *_dev)
{
    ahci_hba_em_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x20);
    return(ahci_hba_em_ctl_led_extract(_regval));
}

static inline uint8_t ahci_hba_em_ctl_safte_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_safte_rdf(__DN(t) *_dev)
{
    ahci_hba_em_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x20);
    return(ahci_hba_em_ctl_safte_extract(_regval));
}

static inline uint8_t ahci_hba_em_ctl_ses2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_ses2_rdf(__DN(t) *_dev)
{
    ahci_hba_em_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x20);
    return(ahci_hba_em_ctl_ses2_extract(_regval));
}

static inline uint8_t ahci_hba_em_ctl_sgpio_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_sgpio_rdf(__DN(t) *_dev)
{
    ahci_hba_em_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x20);
    return(ahci_hba_em_ctl_sgpio_extract(_regval));
}

static inline uint8_t ahci_hba_em_ctl_smb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_smb_rdf(__DN(t) *_dev)
{
    ahci_hba_em_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x20);
    return(ahci_hba_em_ctl_smb_extract(_regval));
}

static inline uint8_t ahci_hba_em_ctl_xmt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_xmt_rdf(__DN(t) *_dev)
{
    ahci_hba_em_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x20);
    return(ahci_hba_em_ctl_xmt_extract(_regval));
}

static inline uint8_t ahci_hba_em_ctl_alhd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_alhd_rdf(__DN(t) *_dev)
{
    ahci_hba_em_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x20);
    return(ahci_hba_em_ctl_alhd_extract(_regval));
}

static inline uint8_t ahci_hba_em_ctl_pm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_em_ctl_pm_rdf(__DN(t) *_dev)
{
    ahci_hba_em_ctl_t _regval = mackerel_read_addr_32(_dev->b, 0x20);
    return(ahci_hba_em_ctl_pm_extract(_regval));
}

static inline void ahci_hba_em_ctl_mr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_hba_em_ctl_mr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_hba_em_ctl_t _regval = 0x1 & (((ahci_hba_em_ctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf0f0fffe & mackerel_read_addr_32(_dev->b, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x20, _regval);
    // No shadow register to write to
}

static inline void ahci_hba_em_ctl_tm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_hba_em_ctl_tm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_hba_em_ctl_t _regval = 0x100 & (((ahci_hba_em_ctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xf0f0fefe & mackerel_read_addr_32(_dev->b, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x20, _regval);
    // No shadow register to write to
}

static inline void ahci_hba_em_ctl_rst_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_hba_em_ctl_rst_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_hba_em_ctl_t _regval = 0x200 & (((ahci_hba_em_ctl_t )(_fieldval)) << 9);
    _regval = (_regval | (0xf0f0fdfe & mackerel_read_addr_32(_dev->b, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x20, _regval);
    // No shadow register to write to
}

/*
 * Register cap2: HBA capabilities extended
 * Type: ahci_hba.cap2 (Implicit type of HBA capabilities extended register)
 *   boh	(size 1, offset 0, init 0):	RO	BIOS/OS handoff
 *   nvmp	(size 1, offset 1, init 0):	RO	NVMHCI present
 *   apst	(size 1, offset 2, init 0):	RO	Automatic partial to slumber transitions
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
static inline ahci_hba_cap2_t ahci_hba_cap2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_cap2_t ahci_hba_cap2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x24));
}

static inline ahci_hba_cap2_t ahci_hba_cap2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_cap2_t ahci_hba_cap2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x24));
}

static inline void ahci_hba_cap2_rawwr(__DN(t) *_dev, ahci_hba_cap2_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_cap2_rawwr(__DN(t) *_dev, ahci_hba_cap2_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x24, _regval);
}

// Register cap2 is not writeable
static inline int ahci_hba_cap2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_hba_cap2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_hba_cap2_t _regval = mackerel_read_addr_32(_dev->b, 0x24);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cap2 (HBA capabilities extended): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " boh =\t%" PRIx8 "\t(BIOS/OS handoff)\n", ahci_hba_cap2_boh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nvmp =\t%" PRIx8 "\t(NVMHCI present)\n", ahci_hba_cap2_nvmp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apst =\t%" PRIx8 "\t(Automatic partial to slumber transitions)\n", ahci_hba_cap2_apst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t ahci_hba_cap2_boh_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap2_boh_rdf(__DN(t) *_dev)
{
    ahci_hba_cap2_t _regval = mackerel_read_addr_32(_dev->b, 0x24);
    return(ahci_hba_cap2_boh_extract(_regval));
}

static inline uint8_t ahci_hba_cap2_nvmp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap2_nvmp_rdf(__DN(t) *_dev)
{
    ahci_hba_cap2_t _regval = mackerel_read_addr_32(_dev->b, 0x24);
    return(ahci_hba_cap2_nvmp_extract(_regval));
}

static inline uint8_t ahci_hba_cap2_apst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_cap2_apst_rdf(__DN(t) *_dev)
{
    ahci_hba_cap2_t _regval = mackerel_read_addr_32(_dev->b, 0x24);
    return(ahci_hba_cap2_apst_extract(_regval));
}

/*
 * Register bohc: BIOS/OS handoff control and status
 * Type: ahci_hba.bohc (Implicit type of BIOS/OS handoff control and status register)
 *   bos	(size 1, offset 0, init 0):	RW	BIOS owned semaphore
 *   oos	(size 1, offset 1, init 0):	RW	OS owned semaphore
 *   sooe	(size 1, offset 2, init 0):	RW	SMI on OS ownership change enable
 *   ooc	(size 1, offset 3, init 0):	RWC	OS ownership change
 *   bb	(size 1, offset 4, init 0):	RW	BIOS busy
 *   _anon5	(size 27, offset 5, init 0):	RSVD	_
 */
static inline ahci_hba_bohc_t ahci_hba_bohc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_bohc_t ahci_hba_bohc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x28));
}

static inline ahci_hba_bohc_t ahci_hba_bohc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_hba_bohc_t ahci_hba_bohc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x28));
}

static inline void ahci_hba_bohc_rawwr(__DN(t) *_dev, ahci_hba_bohc_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_bohc_rawwr(__DN(t) *_dev, ahci_hba_bohc_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x28, _regval);
}

static inline void ahci_hba_bohc_wr(__DN(t) *_dev, ahci_hba_bohc_t _regval) __attribute__ ((always_inline));
static inline void ahci_hba_bohc_wr(__DN(t) *_dev, ahci_hba_bohc_t _regval)
{
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    _regval = (_regval | (0xffffffe0 & mackerel_read_addr_32(_dev->b, 0x28)));
    mackerel_write_addr_32(_dev->b, 0x28, _regval);
}

static inline int ahci_hba_bohc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_hba_bohc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_hba_bohc_t _regval = mackerel_read_addr_32(_dev->b, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register bohc (BIOS/OS handoff control and status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bos =\t%" PRIx8 "\t(BIOS owned semaphore)\n", ahci_hba_bohc_bos_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oos =\t%" PRIx8 "\t(OS owned semaphore)\n", ahci_hba_bohc_oos_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sooe =\t%" PRIx8 "\t(SMI on OS ownership change enable)\n", ahci_hba_bohc_sooe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ooc =\t%" PRIx8 "\t(OS ownership change)\n", ahci_hba_bohc_ooc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bb =\t%" PRIx8 "\t(BIOS busy)\n", ahci_hba_bohc_bb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline uint8_t ahci_hba_bohc_bos_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_bohc_bos_rdf(__DN(t) *_dev)
{
    ahci_hba_bohc_t _regval = mackerel_read_addr_32(_dev->b, 0x28);
    return(ahci_hba_bohc_bos_extract(_regval));
}

static inline uint8_t ahci_hba_bohc_oos_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_bohc_oos_rdf(__DN(t) *_dev)
{
    ahci_hba_bohc_t _regval = mackerel_read_addr_32(_dev->b, 0x28);
    return(ahci_hba_bohc_oos_extract(_regval));
}

static inline uint8_t ahci_hba_bohc_sooe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_bohc_sooe_rdf(__DN(t) *_dev)
{
    ahci_hba_bohc_t _regval = mackerel_read_addr_32(_dev->b, 0x28);
    return(ahci_hba_bohc_sooe_extract(_regval));
}

static inline uint8_t ahci_hba_bohc_ooc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_bohc_ooc_rdf(__DN(t) *_dev)
{
    ahci_hba_bohc_t _regval = mackerel_read_addr_32(_dev->b, 0x28);
    return(ahci_hba_bohc_ooc_extract(_regval));
}

static inline uint8_t ahci_hba_bohc_bb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_hba_bohc_bb_rdf(__DN(t) *_dev)
{
    ahci_hba_bohc_t _regval = mackerel_read_addr_32(_dev->b, 0x28);
    return(ahci_hba_bohc_bb_extract(_regval));
}

static inline void ahci_hba_bohc_bos_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_hba_bohc_bos_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_hba_bohc_t _regval = 0x1 & (((ahci_hba_bohc_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff6 & mackerel_read_addr_32(_dev->b, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x28, _regval);
    // No shadow register to write to
}

static inline void ahci_hba_bohc_oos_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_hba_bohc_oos_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_hba_bohc_t _regval = 0x2 & (((ahci_hba_bohc_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffff5 & mackerel_read_addr_32(_dev->b, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x28, _regval);
    // No shadow register to write to
}

static inline void ahci_hba_bohc_sooe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_hba_bohc_sooe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_hba_bohc_t _regval = 0x4 & (((ahci_hba_bohc_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffff3 & mackerel_read_addr_32(_dev->b, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x28, _regval);
    // No shadow register to write to
}

static inline void ahci_hba_bohc_ooc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_hba_bohc_ooc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_hba_bohc_t _regval = 0x8 & (((ahci_hba_bohc_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->b, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x28, _regval);
    // No shadow register to write to
}

static inline void ahci_hba_bohc_bb_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_hba_bohc_bb_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_hba_bohc_t _regval = 0x10 & (((ahci_hba_bohc_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffe7 & mackerel_read_addr_32(_dev->b, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x28, _regval);
    // No shadow register to write to
}

static inline int ahci_hba_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_hba_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device ahci_hba (AHCI generic):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_hba_cap_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_hba_ghc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_hba_is_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_hba_pi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_hba_vs_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_hba_ccc_ctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_hba_ccc_ports_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_hba_em_loc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_hba_em_ctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_hba_cap2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_hba_bohc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device ahci_hba\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __ahci_hba_DEV_H
