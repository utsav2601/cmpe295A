#ifndef __xeon_phi_apic_DEV_H
#define __xeon_phi_apic_DEV_H 1
/*
 * DEVICE DEFINITION: Intel Xeon Phi APIC register
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) xeon_phi_apic ## _ ## x
/*
 * Constants defn: xeon_phi_apic.irq_vec (Interupt Vectors)
 *  - width 32 bits
 */
typedef uint32_t xeon_phi_apic_irq_vec_t;
#define xeon_phi_apic_vec_bsp ((xeon_phi_apic_irq_vec_t)0xe5)

static inline char *xeon_phi_apic_irq_vec_describe(xeon_phi_apic_irq_vec_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_apic_irq_vec_describe(xeon_phi_apic_irq_vec_t _e)
{
    switch (_e) {
    case xeon_phi_apic_vec_bsp:
        return("vec_bsp: vec_bsp");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_apic_irq_vec_prtval(char *_s, size_t _size, xeon_phi_apic_irq_vec_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_apic_irq_vec_prtval(char *_s, size_t _size, xeon_phi_apic_irq_vec_t _e)
{
    char *d = xeon_phi_apic_irq_vec_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_apic_irq_vec_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xeon_phi_apic.irq_idx (Interrupt Register Index)
 *  - width 3 bits
 */
typedef uint8_t xeon_phi_apic_irq_idx_t;
#define xeon_phi_apic_vnet ((xeon_phi_apic_irq_idx_t)0x0)
#define xeon_phi_apic_sht ((xeon_phi_apic_irq_idx_t)0x1)
#define xeon_phi_apic_hvc ((xeon_phi_apic_irq_idx_t)0x2)
#define xeon_phi_apic_virtio ((xeon_phi_apic_irq_idx_t)0x3)
#define xeon_phi_apic_pm ((xeon_phi_apic_irq_idx_t)0x4)
#define xeon_phi_apic_unused ((xeon_phi_apic_irq_idx_t)0x5)
#define xeon_phi_apic_unused2 ((xeon_phi_apic_irq_idx_t)0x6)
#define xeon_phi_apic_bootstrap ((xeon_phi_apic_irq_idx_t)0x7)

static inline char *xeon_phi_apic_irq_idx_describe(xeon_phi_apic_irq_idx_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_apic_irq_idx_describe(xeon_phi_apic_irq_idx_t _e)
{
    switch (_e) {
    case xeon_phi_apic_vnet:
        return("vnet: vnet");
    case xeon_phi_apic_sht:
        return("sht: sht");
    case xeon_phi_apic_hvc:
        return("hvc: hvc");
    case xeon_phi_apic_virtio:
        return("virtio: virtio");
    case xeon_phi_apic_pm:
        return("pm: pm");
    case xeon_phi_apic_unused:
        return("unused: unused");
    case xeon_phi_apic_unused2:
        return("unused2: unused2");
    case xeon_phi_apic_bootstrap:
        return("bootstrap: bootstrap");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_apic_irq_idx_prtval(char *_s, size_t _size, xeon_phi_apic_irq_idx_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_apic_irq_idx_prtval(char *_s, size_t _size, xeon_phi_apic_irq_idx_t _e)
{
    char *d = xeon_phi_apic_irq_idx_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_apic_irq_idx_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xeon_phi_apic.dst_shorthand (Destination shorthand)
 *  - no width specified
 */
typedef uint8_t xeon_phi_apic_dst_shorthand_t;
#define xeon_phi_apic_none ((xeon_phi_apic_dst_shorthand_t)0x0)
#define xeon_phi_apic_self ((xeon_phi_apic_dst_shorthand_t)0x1)
#define xeon_phi_apic_all_inc ((xeon_phi_apic_dst_shorthand_t)0x2)
#define xeon_phi_apic_all_exc ((xeon_phi_apic_dst_shorthand_t)0x3)

static inline char *xeon_phi_apic_dst_shorthand_describe(xeon_phi_apic_dst_shorthand_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_apic_dst_shorthand_describe(xeon_phi_apic_dst_shorthand_t _e)
{
    switch (_e) {
    case xeon_phi_apic_none:
        return("none: No shorthand");
    case xeon_phi_apic_self:
        return("self: Self");
    case xeon_phi_apic_all_inc:
        return("all_inc: All including self");
    case xeon_phi_apic_all_exc:
        return("all_exc: All excluding self");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_apic_dst_shorthand_prtval(char *_s, size_t _size, xeon_phi_apic_dst_shorthand_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_apic_dst_shorthand_prtval(char *_s, size_t _size, xeon_phi_apic_dst_shorthand_t _e)
{
    char *d = xeon_phi_apic_dst_shorthand_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_apic_dst_shorthand_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xeon_phi_apic.dst_mode (Destination mode)
 *  - no width specified
 */
typedef uint8_t xeon_phi_apic_dst_mode_t;
#define xeon_phi_apic_dst_phys ((xeon_phi_apic_dst_mode_t)0x0)
#define xeon_phi_apic_dst_log ((xeon_phi_apic_dst_mode_t)0x1)

static inline char *xeon_phi_apic_dst_mode_describe(xeon_phi_apic_dst_mode_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_apic_dst_mode_describe(xeon_phi_apic_dst_mode_t _e)
{
    switch (_e) {
    case xeon_phi_apic_dst_phys:
        return("dst_phys: Physical");
    case xeon_phi_apic_dst_log:
        return("dst_log: Logical");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_apic_dst_mode_prtval(char *_s, size_t _size, xeon_phi_apic_dst_mode_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_apic_dst_mode_prtval(char *_s, size_t _size, xeon_phi_apic_dst_mode_t _e)
{
    char *d = xeon_phi_apic_dst_mode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_apic_dst_mode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xeon_phi_apic.int_level (Interrupt level)
 *  - no width specified
 */
typedef uint8_t xeon_phi_apic_int_level_t;
#define xeon_phi_apic_lvl_clr ((xeon_phi_apic_int_level_t)0x0)
#define xeon_phi_apic_lvl_set ((xeon_phi_apic_int_level_t)0x1)

static inline char *xeon_phi_apic_int_level_describe(xeon_phi_apic_int_level_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_apic_int_level_describe(xeon_phi_apic_int_level_t _e)
{
    switch (_e) {
    case xeon_phi_apic_lvl_clr:
        return("lvl_clr: Clear");
    case xeon_phi_apic_lvl_set:
        return("lvl_set: Set");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_apic_int_level_prtval(char *_s, size_t _size, xeon_phi_apic_int_level_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_apic_int_level_prtval(char *_s, size_t _size, xeon_phi_apic_int_level_t _e)
{
    char *d = xeon_phi_apic_int_level_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_apic_int_level_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xeon_phi_apic.vdm (Vector delivery mode)
 *  - no width specified
 */
typedef uint8_t xeon_phi_apic_vdm_t;
#define xeon_phi_apic_fixed ((xeon_phi_apic_vdm_t)0x0)
#define xeon_phi_apic_lowest ((xeon_phi_apic_vdm_t)0x1)
#define xeon_phi_apic_smi ((xeon_phi_apic_vdm_t)0x2)
#define xeon_phi_apic_nmi ((xeon_phi_apic_vdm_t)0x4)
#define xeon_phi_apic_init ((xeon_phi_apic_vdm_t)0x5)
#define xeon_phi_apic_startup ((xeon_phi_apic_vdm_t)0x6)
#define xeon_phi_apic_extint ((xeon_phi_apic_vdm_t)0x7)

static inline char *xeon_phi_apic_vdm_describe(xeon_phi_apic_vdm_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_apic_vdm_describe(xeon_phi_apic_vdm_t _e)
{
    switch (_e) {
    case xeon_phi_apic_fixed:
        return("fixed: Fixed");
    case xeon_phi_apic_lowest:
        return("lowest: Lowest priority");
    case xeon_phi_apic_smi:
        return("smi: SMI");
    case xeon_phi_apic_nmi:
        return("nmi: NMI");
    case xeon_phi_apic_init:
        return("init: INIT");
    case xeon_phi_apic_startup:
        return("startup: Start Up");
    case xeon_phi_apic_extint:
        return("extint: ExtINT");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_apic_vdm_prtval(char *_s, size_t _size, xeon_phi_apic_vdm_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_apic_vdm_prtval(char *_s, size_t _size, xeon_phi_apic_vdm_t _e)
{
    char *d = xeon_phi_apic_vdm_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_apic_vdm_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xeon_phi_apic.trigm (Trigger mode)
 *  - no width specified
 */
typedef uint8_t xeon_phi_apic_trigm_t;
#define xeon_phi_apic_edge ((xeon_phi_apic_trigm_t)0x0)
#define xeon_phi_apic_level ((xeon_phi_apic_trigm_t)0x1)

static inline char *xeon_phi_apic_trigm_describe(xeon_phi_apic_trigm_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_apic_trigm_describe(xeon_phi_apic_trigm_t _e)
{
    switch (_e) {
    case xeon_phi_apic_edge:
        return("edge: Edge");
    case xeon_phi_apic_level:
        return("level: Level");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_apic_trigm_prtval(char *_s, size_t _size, xeon_phi_apic_trigm_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_apic_trigm_prtval(char *_s, size_t _size, xeon_phi_apic_trigm_t _e)
{
    char *d = xeon_phi_apic_trigm_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_apic_trigm_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: xeon_phi_apic_id_t
 * Description: Implicit type of APIC Identification Register register
 * Fields:
 *   _anon0	(size 23, offset 0, init 0):	RSVD	_
 *   id	(size 9, offset 23, init 0):	RW	apic id
 */
typedef uint32_t xeon_phi_apic_id_t;
#define xeon_phi_apic_id_default 0x0
static inline uint16_t xeon_phi_apic_id_id_extract(xeon_phi_apic_id_t _regval) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_apic_id_id_extract(xeon_phi_apic_id_t _regval)
{
    return((uint16_t )((_regval & 0xff800000) >> 23));
}

static inline xeon_phi_apic_id_t xeon_phi_apic_id_id_insert(xeon_phi_apic_id_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_apic_id_t xeon_phi_apic_id_id_insert(xeon_phi_apic_id_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x7fffff) | (0xff800000 & (((xeon_phi_apic_id_t )(_fieldval)) << 23)));
}

static inline int xeon_phi_apic_id_prtval(char *_s, size_t _size, xeon_phi_apic_id_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_apic_id_prtval(char *_s, size_t _size, xeon_phi_apic_id_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " id =\t%" PRIx16 "\t(apic id)\n", xeon_phi_apic_id_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_apic_version_t
 * Description: Implicit type of APIC Version Register register
 * Fields:
 *   ver	(size 8, offset 0, init 0):	RW	version
 *   _anon8	(size 8, offset 8, init 0):	RSVD	_
 *   max_lvt	(size 8, offset 16, init 0):	RW	max LVT entry
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_apic_version_t;
#define xeon_phi_apic_version_default 0x0
static inline uint8_t xeon_phi_apic_version_ver_extract(xeon_phi_apic_version_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_apic_version_ver_extract(xeon_phi_apic_version_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline xeon_phi_apic_version_t xeon_phi_apic_version_ver_insert(xeon_phi_apic_version_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_apic_version_t xeon_phi_apic_version_ver_insert(xeon_phi_apic_version_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((xeon_phi_apic_version_t )(_fieldval)) << 0)));
}

static inline uint8_t xeon_phi_apic_version_max_lvt_extract(xeon_phi_apic_version_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_apic_version_max_lvt_extract(xeon_phi_apic_version_t _regval)
{
    return((uint8_t )((_regval & 0xff0000) >> 16));
}

static inline xeon_phi_apic_version_t xeon_phi_apic_version_max_lvt_insert(xeon_phi_apic_version_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_apic_version_t xeon_phi_apic_version_max_lvt_insert(xeon_phi_apic_version_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((xeon_phi_apic_version_t )(_fieldval)) << 16)));
}

static inline int xeon_phi_apic_version_prtval(char *_s, size_t _size, xeon_phi_apic_version_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_apic_version_prtval(char *_s, size_t _size, xeon_phi_apic_version_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ver =\t%" PRIx8 "\t(version)\n", xeon_phi_apic_version_ver_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " max_lvt =\t%" PRIx8 "\t(max LVT entry)\n", xeon_phi_apic_version_max_lvt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_apic_pr_t
 * Description: Implicit type of APIC Priority Register register
 * Fields:
 *   value	(size 32, offset 0, init 0):	RW	Value
 */
typedef uint32_t xeon_phi_apic_pr_t;
#define xeon_phi_apic_pr_default 0x0
static inline uint32_t xeon_phi_apic_pr_value_extract(xeon_phi_apic_pr_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_apic_pr_value_extract(xeon_phi_apic_pr_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_apic_pr_t xeon_phi_apic_pr_value_insert(xeon_phi_apic_pr_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_apic_pr_t xeon_phi_apic_pr_value_insert(xeon_phi_apic_pr_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_apic_pr_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_apic_pr_prtval(char *_s, size_t _size, xeon_phi_apic_pr_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_apic_pr_prtval(char *_s, size_t _size, xeon_phi_apic_pr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " value =\t%" PRIx32 "\t(Value)\n", xeon_phi_apic_pr_value_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_apic_rt_t
 * Description: Implicit type of APIC Redirection Table register array
 * Fields:
 *   value	(size 64, offset 0, init 0):	NOATTR	Value
 */
typedef uint64_t xeon_phi_apic_rt_t;
#define xeon_phi_apic_rt_default 0x0
static inline uint64_t xeon_phi_apic_rt_value_extract(xeon_phi_apic_rt_t _regval) __attribute__ ((always_inline));
static inline uint64_t xeon_phi_apic_rt_value_extract(xeon_phi_apic_rt_t _regval)
{
    return((uint64_t )((_regval & 0xffffffffffffffff) >> 0));
}

static inline xeon_phi_apic_rt_t xeon_phi_apic_rt_value_insert(xeon_phi_apic_rt_t _regval, uint64_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_apic_rt_t xeon_phi_apic_rt_value_insert(xeon_phi_apic_rt_t _regval, uint64_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffffffffffff & (((xeon_phi_apic_rt_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_apic_rt_prtval(char *_s, size_t _size, xeon_phi_apic_rt_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_apic_rt_prtval(char *_s, size_t _size, xeon_phi_apic_rt_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " value =\t%" PRIx64 "\t(Value)\n", xeon_phi_apic_rt_value_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_apic_icr_lo_t
 * Description: Implicit type of APIC Interrupt Command Register 0 to 7 register array
 * Fields:
 *   vector	(size 8, offset 0, init 0):	NOATTR	Vector
 *   dlv_mode	(size 3, offset 8, init 0):	NOATTR	Delivery mode
 *   dst_mode	(size 1, offset 11, init 0):	NOATTR	Destination mode
 *   dlv_stat	(size 1, offset 12, init 0):	RO	Delivery status
 *   boot_notify	(size 1, offset 13, init 0):	NOATTR	Boot notify bit
 *   level	(size 1, offset 14, init 0):	NOATTR	Level
 *   trig_mode	(size 1, offset 15, init 0):	NOATTR	Trigger mode
 *   _anon16	(size 2, offset 16, init 0):	RSVD	_
 *   dst_short	(size 2, offset 18, init 0):	NOATTR	Destination shorthand
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_apic_icr_lo_t;
#define xeon_phi_apic_icr_lo_default 0x0
static inline uint8_t xeon_phi_apic_icr_lo_vector_extract(xeon_phi_apic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_apic_icr_lo_vector_extract(xeon_phi_apic_icr_lo_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_vector_insert(xeon_phi_apic_icr_lo_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_vector_insert(xeon_phi_apic_icr_lo_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((xeon_phi_apic_icr_lo_t )(_fieldval)) << 0)));
}

static inline xeon_phi_apic_vdm_t xeon_phi_apic_icr_lo_dlv_mode_extract(xeon_phi_apic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline xeon_phi_apic_vdm_t xeon_phi_apic_icr_lo_dlv_mode_extract(xeon_phi_apic_icr_lo_t _regval)
{
    return((xeon_phi_apic_vdm_t )((_regval & 0x700) >> 8));
}

static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_dlv_mode_insert(xeon_phi_apic_icr_lo_t _regval, xeon_phi_apic_vdm_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_dlv_mode_insert(xeon_phi_apic_icr_lo_t _regval, xeon_phi_apic_vdm_t _fieldval)
{
    return((_regval & 0xfffff8ff) | (0x700 & (((xeon_phi_apic_icr_lo_t )(_fieldval)) << 8)));
}

static inline xeon_phi_apic_dst_mode_t xeon_phi_apic_icr_lo_dst_mode_extract(xeon_phi_apic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline xeon_phi_apic_dst_mode_t xeon_phi_apic_icr_lo_dst_mode_extract(xeon_phi_apic_icr_lo_t _regval)
{
    return((xeon_phi_apic_dst_mode_t )((_regval & 0x800) >> 11));
}

static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_dst_mode_insert(xeon_phi_apic_icr_lo_t _regval, xeon_phi_apic_dst_mode_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_dst_mode_insert(xeon_phi_apic_icr_lo_t _regval, xeon_phi_apic_dst_mode_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((xeon_phi_apic_icr_lo_t )(_fieldval)) << 11)));
}

static inline uint8_t xeon_phi_apic_icr_lo_dlv_stat_extract(xeon_phi_apic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_apic_icr_lo_dlv_stat_extract(xeon_phi_apic_icr_lo_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_dlv_stat_insert(xeon_phi_apic_icr_lo_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_dlv_stat_insert(xeon_phi_apic_icr_lo_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((xeon_phi_apic_icr_lo_t )(_fieldval)) << 12)));
}

static inline uint8_t xeon_phi_apic_icr_lo_boot_notify_extract(xeon_phi_apic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_apic_icr_lo_boot_notify_extract(xeon_phi_apic_icr_lo_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_boot_notify_insert(xeon_phi_apic_icr_lo_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_boot_notify_insert(xeon_phi_apic_icr_lo_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((xeon_phi_apic_icr_lo_t )(_fieldval)) << 13)));
}

static inline xeon_phi_apic_int_level_t xeon_phi_apic_icr_lo_level_extract(xeon_phi_apic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline xeon_phi_apic_int_level_t xeon_phi_apic_icr_lo_level_extract(xeon_phi_apic_icr_lo_t _regval)
{
    return((xeon_phi_apic_int_level_t )((_regval & 0x4000) >> 14));
}

static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_level_insert(xeon_phi_apic_icr_lo_t _regval, xeon_phi_apic_int_level_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_level_insert(xeon_phi_apic_icr_lo_t _regval, xeon_phi_apic_int_level_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((xeon_phi_apic_icr_lo_t )(_fieldval)) << 14)));
}

static inline xeon_phi_apic_trigm_t xeon_phi_apic_icr_lo_trig_mode_extract(xeon_phi_apic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline xeon_phi_apic_trigm_t xeon_phi_apic_icr_lo_trig_mode_extract(xeon_phi_apic_icr_lo_t _regval)
{
    return((xeon_phi_apic_trigm_t )((_regval & 0x8000) >> 15));
}

static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_trig_mode_insert(xeon_phi_apic_icr_lo_t _regval, xeon_phi_apic_trigm_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_trig_mode_insert(xeon_phi_apic_icr_lo_t _regval, xeon_phi_apic_trigm_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((xeon_phi_apic_icr_lo_t )(_fieldval)) << 15)));
}

static inline xeon_phi_apic_dst_shorthand_t xeon_phi_apic_icr_lo_dst_short_extract(xeon_phi_apic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline xeon_phi_apic_dst_shorthand_t xeon_phi_apic_icr_lo_dst_short_extract(xeon_phi_apic_icr_lo_t _regval)
{
    return((xeon_phi_apic_dst_shorthand_t )((_regval & 0xc0000) >> 18));
}

static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_dst_short_insert(xeon_phi_apic_icr_lo_t _regval, xeon_phi_apic_dst_shorthand_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_dst_short_insert(xeon_phi_apic_icr_lo_t _regval, xeon_phi_apic_dst_shorthand_t _fieldval)
{
    return((_regval & 0xfff3ffff) | (0xc0000 & (((xeon_phi_apic_icr_lo_t )(_fieldval)) << 18)));
}

static inline int xeon_phi_apic_icr_lo_prtval(char *_s, size_t _size, xeon_phi_apic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_apic_icr_lo_prtval(char *_s, size_t _size, xeon_phi_apic_icr_lo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xeon_phi_apic_icr_lo_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlv_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_apic_vdm_prtval(_s + _r, _avail, xeon_phi_apic_icr_lo_dlv_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Delivery mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dst_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_apic_dst_mode_prtval(_s + _r, _avail, xeon_phi_apic_icr_lo_dst_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Destination mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlv_stat =\t%" PRIx8 "\t(Delivery status)\n", xeon_phi_apic_icr_lo_dlv_stat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " boot_notify =\t%" PRIx8 "\t(Boot notify bit)\n", xeon_phi_apic_icr_lo_boot_notify_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " level =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_apic_int_level_prtval(_s + _r, _avail, xeon_phi_apic_icr_lo_level_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Level)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " trig_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_apic_trigm_prtval(_s + _r, _avail, xeon_phi_apic_icr_lo_trig_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Trigger mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dst_short =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_apic_dst_shorthand_prtval(_s + _r, _avail, xeon_phi_apic_icr_lo_dst_short_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Destination shorthand)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_apic_icr_hi_t
 * Description: Implicit type of APIC Interrupt Command Register 0 to 7 register array
 * Fields:
 *   dest	(size 32, offset 0, init 0):	NOATTR	Destination field
 */
typedef uint32_t xeon_phi_apic_icr_hi_t;
#define xeon_phi_apic_icr_hi_default 0x0
static inline uint32_t xeon_phi_apic_icr_hi_dest_extract(xeon_phi_apic_icr_hi_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_apic_icr_hi_dest_extract(xeon_phi_apic_icr_hi_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_apic_icr_hi_t xeon_phi_apic_icr_hi_dest_insert(xeon_phi_apic_icr_hi_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_apic_icr_hi_t xeon_phi_apic_icr_hi_dest_insert(xeon_phi_apic_icr_hi_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_apic_icr_hi_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_apic_icr_hi_prtval(char *_s, size_t _size, xeon_phi_apic_icr_hi_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_apic_icr_hi_prtval(char *_s, size_t _size, xeon_phi_apic_icr_hi_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dest =\t%" PRIx32 "\t(Destination field)\n", xeon_phi_apic_icr_hi_dest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum xeon_phi_apic_initials {
    xeon_phi_apic_id_initial = 0x0,
    xeon_phi_apic_version_initial = 0x0,
    xeon_phi_apic_pr_initial = 0x0,
    xeon_phi_apic_rt_initial = 0x0,
    xeon_phi_apic_icr_lo_initial = 0x0,
    xeon_phi_apic_icr_hi_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void xeon_phi_apic_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void xeon_phi_apic_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register id: APIC Identification Register
 * Type: xeon_phi_apic.id (Implicit type of APIC Identification Register register)
 *   _anon0	(size 23, offset 0, init 0):	RSVD	_
 *   id	(size 9, offset 23, init 0):	RW	apic id
 */
static inline xeon_phi_apic_id_t xeon_phi_apic_id_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_apic_id_t xeon_phi_apic_id_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa800));
}

static inline xeon_phi_apic_id_t xeon_phi_apic_id_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_apic_id_t xeon_phi_apic_id_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa800));
}

static inline void xeon_phi_apic_id_rawwr(__DN(t) *_dev, xeon_phi_apic_id_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_id_rawwr(__DN(t) *_dev, xeon_phi_apic_id_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa800, _regval);
}

static inline void xeon_phi_apic_id_wr(__DN(t) *_dev, xeon_phi_apic_id_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_id_wr(__DN(t) *_dev, xeon_phi_apic_id_t _regval)
{
    _regval = (_regval & 0xff800000);
    // No MB1 fields present
    _regval = (_regval | (0x7fffff & mackerel_read_addr_32(_dev->base, 0xa800)));
    mackerel_write_addr_32(_dev->base, 0xa800, _regval);
}

static inline int xeon_phi_apic_id_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_apic_id_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_apic_id_t _regval = mackerel_read_addr_32(_dev->base, 0xa800);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register id (APIC Identification Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " id =\t%" PRIx16 "\t(apic id)\n", xeon_phi_apic_id_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t xeon_phi_apic_id_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_apic_id_id_rdf(__DN(t) *_dev)
{
    xeon_phi_apic_id_t _regval = mackerel_read_addr_32(_dev->base, 0xa800);
    return(xeon_phi_apic_id_id_extract(_regval));
}

static inline void xeon_phi_apic_id_id_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_id_id_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    xeon_phi_apic_id_t _regval = 0xff800000 & (((xeon_phi_apic_id_t )(_fieldval)) << 23);
    _regval = (_regval | (0x7fffff & mackerel_read_addr_32(_dev->base, 0xa800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa800, _regval);
    // No shadow register to write to
}

/*
 * Register version: APIC Version Register
 * Type: xeon_phi_apic.version (Implicit type of APIC Version Register register)
 *   ver	(size 8, offset 0, init 0):	RW	version
 *   _anon8	(size 8, offset 8, init 0):	RSVD	_
 *   max_lvt	(size 8, offset 16, init 0):	RW	max LVT entry
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
static inline xeon_phi_apic_version_t xeon_phi_apic_version_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_apic_version_t xeon_phi_apic_version_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa804));
}

static inline xeon_phi_apic_version_t xeon_phi_apic_version_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_apic_version_t xeon_phi_apic_version_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa804));
}

static inline void xeon_phi_apic_version_rawwr(__DN(t) *_dev, xeon_phi_apic_version_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_version_rawwr(__DN(t) *_dev, xeon_phi_apic_version_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa804, _regval);
}

static inline void xeon_phi_apic_version_wr(__DN(t) *_dev, xeon_phi_apic_version_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_version_wr(__DN(t) *_dev, xeon_phi_apic_version_t _regval)
{
    _regval = (_regval & 0xff00ff);
    // No MB1 fields present
    _regval = (_regval | (0xff00ff00 & mackerel_read_addr_32(_dev->base, 0xa804)));
    mackerel_write_addr_32(_dev->base, 0xa804, _regval);
}

static inline int xeon_phi_apic_version_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_apic_version_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_apic_version_t _regval = mackerel_read_addr_32(_dev->base, 0xa804);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register version (APIC Version Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ver =\t%" PRIx8 "\t(version)\n", xeon_phi_apic_version_ver_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " max_lvt =\t%" PRIx8 "\t(max LVT entry)\n", xeon_phi_apic_version_max_lvt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    return(_r);
}

static inline uint8_t xeon_phi_apic_version_ver_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_apic_version_ver_rdf(__DN(t) *_dev)
{
    xeon_phi_apic_version_t _regval = mackerel_read_addr_32(_dev->base, 0xa804);
    return(xeon_phi_apic_version_ver_extract(_regval));
}

static inline uint8_t xeon_phi_apic_version_max_lvt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_apic_version_max_lvt_rdf(__DN(t) *_dev)
{
    xeon_phi_apic_version_t _regval = mackerel_read_addr_32(_dev->base, 0xa804);
    return(xeon_phi_apic_version_max_lvt_extract(_regval));
}

static inline void xeon_phi_apic_version_ver_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_version_ver_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_apic_version_t _regval = 0xff & (((xeon_phi_apic_version_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0xa804)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa804, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_apic_version_max_lvt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_version_max_lvt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_apic_version_t _regval = 0xff0000 & (((xeon_phi_apic_version_t )(_fieldval)) << 16);
    _regval = (_regval | (0xff00ffff & mackerel_read_addr_32(_dev->base, 0xa804)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa804, _regval);
    // No shadow register to write to
}

/*
 * Register pr: APIC Priority Register
 * Type: xeon_phi_apic.pr (Implicit type of APIC Priority Register register)
 *   value	(size 32, offset 0, init 0):	RW	Value
 */
static inline xeon_phi_apic_pr_t xeon_phi_apic_pr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_apic_pr_t xeon_phi_apic_pr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa808));
}

static inline xeon_phi_apic_pr_t xeon_phi_apic_pr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_apic_pr_t xeon_phi_apic_pr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa808));
}

static inline void xeon_phi_apic_pr_rawwr(__DN(t) *_dev, xeon_phi_apic_pr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_pr_rawwr(__DN(t) *_dev, xeon_phi_apic_pr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa808, _regval);
}

static inline void xeon_phi_apic_pr_wr(__DN(t) *_dev, xeon_phi_apic_pr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_pr_wr(__DN(t) *_dev, xeon_phi_apic_pr_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa808, _regval);
}

static inline int xeon_phi_apic_pr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_apic_pr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_apic_pr_t _regval = mackerel_read_addr_32(_dev->base, 0xa808);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pr (APIC Priority Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " value =\t%" PRIx32 "\t(Value)\n", xeon_phi_apic_pr_value_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_apic_pr_value_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_apic_pr_value_rdf(__DN(t) *_dev)
{
    xeon_phi_apic_pr_t _regval = mackerel_read_addr_32(_dev->base, 0xa808);
    return(xeon_phi_apic_pr_value_extract(_regval));
}

static inline void xeon_phi_apic_pr_value_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_pr_value_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_apic_pr_t _regval = 0xffffffff & (((xeon_phi_apic_pr_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa808, _regval);
    // No shadow register to write to
}

/*
 * Register array rt: APIC Redirection Table
 * Type: xeon_phi_apic.rt (Implicit type of APIC Redirection Table register array)
 *   value	(size 64, offset 0, init 0):	RW	Value
 */
static const size_t xeon_phi_apic_rt_length = 26;
static inline xeon_phi_apic_rt_t xeon_phi_apic_rt_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_apic_rt_t xeon_phi_apic_rt_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_64(_dev->base, 0xa840 + (_i * (64 / 8))));
}

static inline xeon_phi_apic_rt_t xeon_phi_apic_rt_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_apic_rt_t xeon_phi_apic_rt_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_64(_dev->base, 0xa840 + (_i * (64 / 8))));
}

static inline void xeon_phi_apic_rt_rawwr(__DN(t) *_dev, int _i, xeon_phi_apic_rt_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_rt_rawwr(__DN(t) *_dev, int _i, xeon_phi_apic_rt_t _regval)
{
    mackerel_write_addr_64(_dev->base, 0xa840 + (_i * (64 / 8)), _regval);
}

static inline void xeon_phi_apic_rt_wr(__DN(t) *_dev, int _i, xeon_phi_apic_rt_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_rt_wr(__DN(t) *_dev, int _i, xeon_phi_apic_rt_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_64(_dev->base, 0xa840 + (_i * (64 / 8)), _regval);
}

static inline int xeon_phi_apic_rt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_apic_rt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_apic_rt_t _regval = mackerel_read_addr_64(_dev->base, 0xa840 + (_i * (64 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rt", _i, "APIC Redirection Table");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " value =\t%" PRIx64 "\t(Value)\n", xeon_phi_apic_rt_value_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int xeon_phi_apic_rt_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_apic_rt_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 26; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_apic_rt_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint64_t xeon_phi_apic_rt_value_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint64_t xeon_phi_apic_rt_value_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_apic_rt_t _regval = mackerel_read_addr_64(_dev->base, 0xa840 + (_i * (64 / 8)));
    return(xeon_phi_apic_rt_value_extract(_regval));
}

static inline void xeon_phi_apic_rt_value_wrf(__DN(t) *_dev, int _i, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_rt_value_wrf(__DN(t) *_dev, int _i, uint64_t _fieldval)
{
    xeon_phi_apic_rt_t _regval = 0xffffffffffffffff & (((xeon_phi_apic_rt_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_64(_dev->base, 0xa840 + (_i * (64 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array icr_lo: APIC Interrupt Command Register 0 to 7
 * Type: xeon_phi_apic.icr_lo (Implicit type of APIC Interrupt Command Register 0 to 7 register array)
 *   vector	(size 8, offset 0, init 0):	RW	Vector
 *   dlv_mode	(size 3, offset 8, init 0):	RW	Delivery mode
 *   dst_mode	(size 1, offset 11, init 0):	RW	Destination mode
 *   dlv_stat	(size 1, offset 12, init 0):	RO	Delivery status
 *   boot_notify	(size 1, offset 13, init 0):	RW	Boot notify bit
 *   level	(size 1, offset 14, init 0):	RW	Level
 *   trig_mode	(size 1, offset 15, init 0):	RW	Trigger mode
 *   _anon16	(size 2, offset 16, init 0):	RSVD	_
 *   dst_short	(size 2, offset 18, init 0):	RW	Destination shorthand
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
static const size_t xeon_phi_apic_icr_lo_length = 8;
static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8)));
}

static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_apic_icr_lo_t xeon_phi_apic_icr_lo_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8)));
}

static inline void xeon_phi_apic_icr_lo_rawwr(__DN(t) *_dev, int _i, xeon_phi_apic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_icr_lo_rawwr(__DN(t) *_dev, int _i, xeon_phi_apic_icr_lo_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa9d0 + (_i * 8), _regval);
}

static inline void xeon_phi_apic_icr_lo_wr(__DN(t) *_dev, int _i, xeon_phi_apic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_icr_lo_wr(__DN(t) *_dev, int _i, xeon_phi_apic_icr_lo_t _regval)
{
    _regval = (_regval & 0xcffff);
    // No MB1 fields present
    _regval = (_regval | (0xfff30000 & mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8))));
    mackerel_write_addr_32(_dev->base, 0xa9d0 + (_i * 8), _regval);
}

static inline int xeon_phi_apic_icr_lo_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_apic_icr_lo_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_apic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "icr_lo", _i, "APIC Interrupt Command Register 0 to 7");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xeon_phi_apic_icr_lo_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlv_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_apic_vdm_prtval(_s + _r, _avail, xeon_phi_apic_icr_lo_dlv_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Delivery mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dst_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_apic_dst_mode_prtval(_s + _r, _avail, xeon_phi_apic_icr_lo_dst_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Destination mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlv_stat =\t%" PRIx8 "\t(Delivery status)\n", xeon_phi_apic_icr_lo_dlv_stat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " boot_notify =\t%" PRIx8 "\t(Boot notify bit)\n", xeon_phi_apic_icr_lo_boot_notify_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " level =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_apic_int_level_prtval(_s + _r, _avail, xeon_phi_apic_icr_lo_level_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Level)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " trig_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_apic_trigm_prtval(_s + _r, _avail, xeon_phi_apic_icr_lo_trig_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Trigger mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dst_short =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_apic_dst_shorthand_prtval(_s + _r, _avail, xeon_phi_apic_icr_lo_dst_short_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Destination shorthand)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline int xeon_phi_apic_icr_lo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_apic_icr_lo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_apic_icr_lo_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t xeon_phi_apic_icr_lo_vector_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_apic_icr_lo_vector_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_apic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8));
    return(xeon_phi_apic_icr_lo_vector_extract(_regval));
}

static inline xeon_phi_apic_vdm_t xeon_phi_apic_icr_lo_dlv_mode_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_apic_vdm_t xeon_phi_apic_icr_lo_dlv_mode_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_apic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8));
    return(xeon_phi_apic_icr_lo_dlv_mode_extract(_regval));
}

static inline xeon_phi_apic_dst_mode_t xeon_phi_apic_icr_lo_dst_mode_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_apic_dst_mode_t xeon_phi_apic_icr_lo_dst_mode_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_apic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8));
    return(xeon_phi_apic_icr_lo_dst_mode_extract(_regval));
}

static inline uint8_t xeon_phi_apic_icr_lo_dlv_stat_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_apic_icr_lo_dlv_stat_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_apic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8));
    return(xeon_phi_apic_icr_lo_dlv_stat_extract(_regval));
}

static inline uint8_t xeon_phi_apic_icr_lo_boot_notify_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_apic_icr_lo_boot_notify_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_apic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8));
    return(xeon_phi_apic_icr_lo_boot_notify_extract(_regval));
}

static inline xeon_phi_apic_int_level_t xeon_phi_apic_icr_lo_level_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_apic_int_level_t xeon_phi_apic_icr_lo_level_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_apic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8));
    return(xeon_phi_apic_icr_lo_level_extract(_regval));
}

static inline xeon_phi_apic_trigm_t xeon_phi_apic_icr_lo_trig_mode_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_apic_trigm_t xeon_phi_apic_icr_lo_trig_mode_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_apic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8));
    return(xeon_phi_apic_icr_lo_trig_mode_extract(_regval));
}

static inline xeon_phi_apic_dst_shorthand_t xeon_phi_apic_icr_lo_dst_short_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_apic_dst_shorthand_t xeon_phi_apic_icr_lo_dst_short_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_apic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8));
    return(xeon_phi_apic_icr_lo_dst_short_extract(_regval));
}

static inline void xeon_phi_apic_icr_lo_vector_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_icr_lo_vector_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    xeon_phi_apic_icr_lo_t _regval = 0xff & (((xeon_phi_apic_icr_lo_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffef00 & mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa9d0 + (_i * 8), _regval);
    // No shadow register to write to
}

static inline void xeon_phi_apic_icr_lo_dlv_mode_wrf(__DN(t) *_dev, int _i, xeon_phi_apic_vdm_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_icr_lo_dlv_mode_wrf(__DN(t) *_dev, int _i, xeon_phi_apic_vdm_t _fieldval)
{
    xeon_phi_apic_icr_lo_t _regval = 0x700 & (((xeon_phi_apic_icr_lo_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffffe8ff & mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa9d0 + (_i * 8), _regval);
    // No shadow register to write to
}

static inline void xeon_phi_apic_icr_lo_dst_mode_wrf(__DN(t) *_dev, int _i, xeon_phi_apic_dst_mode_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_icr_lo_dst_mode_wrf(__DN(t) *_dev, int _i, xeon_phi_apic_dst_mode_t _fieldval)
{
    xeon_phi_apic_icr_lo_t _regval = 0x800 & (((xeon_phi_apic_icr_lo_t )(_fieldval)) << 11);
    _regval = (_regval | (0xffffe7ff & mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa9d0 + (_i * 8), _regval);
    // No shadow register to write to
}

static inline void xeon_phi_apic_icr_lo_boot_notify_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_icr_lo_boot_notify_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    xeon_phi_apic_icr_lo_t _regval = 0x2000 & (((xeon_phi_apic_icr_lo_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffcfff & mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa9d0 + (_i * 8), _regval);
    // No shadow register to write to
}

static inline void xeon_phi_apic_icr_lo_level_wrf(__DN(t) *_dev, int _i, xeon_phi_apic_int_level_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_icr_lo_level_wrf(__DN(t) *_dev, int _i, xeon_phi_apic_int_level_t _fieldval)
{
    xeon_phi_apic_icr_lo_t _regval = 0x4000 & (((xeon_phi_apic_icr_lo_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffffafff & mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa9d0 + (_i * 8), _regval);
    // No shadow register to write to
}

static inline void xeon_phi_apic_icr_lo_trig_mode_wrf(__DN(t) *_dev, int _i, xeon_phi_apic_trigm_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_icr_lo_trig_mode_wrf(__DN(t) *_dev, int _i, xeon_phi_apic_trigm_t _fieldval)
{
    xeon_phi_apic_icr_lo_t _regval = 0x8000 & (((xeon_phi_apic_icr_lo_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff6fff & mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa9d0 + (_i * 8), _regval);
    // No shadow register to write to
}

static inline void xeon_phi_apic_icr_lo_dst_short_wrf(__DN(t) *_dev, int _i, xeon_phi_apic_dst_shorthand_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_icr_lo_dst_short_wrf(__DN(t) *_dev, int _i, xeon_phi_apic_dst_shorthand_t _fieldval)
{
    xeon_phi_apic_icr_lo_t _regval = 0xc0000 & (((xeon_phi_apic_icr_lo_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfff3efff & mackerel_read_addr_32(_dev->base, 0xa9d0 + (_i * 8))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa9d0 + (_i * 8), _regval);
    // No shadow register to write to
}

/*
 * Register array icr_hi: APIC Interrupt Command Register 0 to 7
 * Type: xeon_phi_apic.icr_hi (Implicit type of APIC Interrupt Command Register 0 to 7 register array)
 *   dest	(size 32, offset 0, init 0):	RW	Destination field
 */
static const size_t xeon_phi_apic_icr_hi_length = 8;
static inline xeon_phi_apic_icr_hi_t xeon_phi_apic_icr_hi_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_apic_icr_hi_t xeon_phi_apic_icr_hi_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa9d4 + (_i * 8)));
}

static inline xeon_phi_apic_icr_hi_t xeon_phi_apic_icr_hi_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_apic_icr_hi_t xeon_phi_apic_icr_hi_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa9d4 + (_i * 8)));
}

static inline void xeon_phi_apic_icr_hi_rawwr(__DN(t) *_dev, int _i, xeon_phi_apic_icr_hi_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_icr_hi_rawwr(__DN(t) *_dev, int _i, xeon_phi_apic_icr_hi_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa9d4 + (_i * 8), _regval);
}

static inline void xeon_phi_apic_icr_hi_wr(__DN(t) *_dev, int _i, xeon_phi_apic_icr_hi_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_icr_hi_wr(__DN(t) *_dev, int _i, xeon_phi_apic_icr_hi_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa9d4 + (_i * 8), _regval);
}

static inline int xeon_phi_apic_icr_hi_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_apic_icr_hi_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_apic_icr_hi_t _regval = mackerel_read_addr_32(_dev->base, 0xa9d4 + (_i * 8));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "icr_hi", _i, "APIC Interrupt Command Register 0 to 7");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dest =\t%" PRIx32 "\t(Destination field)\n", xeon_phi_apic_icr_hi_dest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int xeon_phi_apic_icr_hi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_apic_icr_hi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_apic_icr_hi_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t xeon_phi_apic_icr_hi_dest_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_apic_icr_hi_dest_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_apic_icr_hi_t _regval = mackerel_read_addr_32(_dev->base, 0xa9d4 + (_i * 8));
    return(xeon_phi_apic_icr_hi_dest_extract(_regval));
}

static inline void xeon_phi_apic_icr_hi_dest_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_apic_icr_hi_dest_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    xeon_phi_apic_icr_hi_t _regval = 0xffffffff & (((xeon_phi_apic_icr_hi_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa9d4 + (_i * 8), _regval);
    // No shadow register to write to
}

static inline int xeon_phi_apic_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_apic_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device xeon_phi_apic (Intel Xeon Phi APIC register):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_apic_id_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_apic_version_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_apic_pr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_apic_rt_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_apic_icr_lo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_apic_icr_hi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device xeon_phi_apic\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __xeon_phi_apic_DEV_H
