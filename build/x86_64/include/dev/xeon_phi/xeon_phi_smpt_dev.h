#ifndef __xeon_phi_smpt_DEV_H
#define __xeon_phi_smpt_DEV_H 1
/*
 * DEVICE DEFINITION: Intel Xeon Phi System Memory Page Tables
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) xeon_phi_smpt ## _ ## x
/*
 * Constants defn: xeon_phi_smpt.snooping (System Snooping Control)
 *  - no width specified
 */
typedef uint8_t xeon_phi_smpt_snooping_t;
#define xeon_phi_smpt_snooping_enabled ((xeon_phi_smpt_snooping_t)0x0)
#define xeon_phi_smpt_snooping_disabled ((xeon_phi_smpt_snooping_t)0x1)

static inline char *xeon_phi_smpt_snooping_describe(xeon_phi_smpt_snooping_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_smpt_snooping_describe(xeon_phi_smpt_snooping_t _e)
{
    switch (_e) {
    case xeon_phi_smpt_snooping_enabled:
        return("snooping_enabled: Enable Snooping");
    case xeon_phi_smpt_snooping_disabled:
        return("snooping_disabled: Disabled Snooping");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_smpt_snooping_prtval(char *_s, size_t _size, xeon_phi_smpt_snooping_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_smpt_snooping_prtval(char *_s, size_t _size, xeon_phi_smpt_snooping_t _e)
{
    char *d = xeon_phi_smpt_snooping_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_smpt_snooping_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xeon_phi_smpt.system_page (System Page Constants)
 *  - no width specified
 */
typedef uint64_t xeon_phi_smpt_system_page_t;
#define xeon_phi_smpt_system_page_size ((xeon_phi_smpt_system_page_t)0x400000000)
#define xeon_phi_smpt_system_page_num ((xeon_phi_smpt_system_page_t)0x20)
#define xeon_phi_smpt_system_page_shift ((xeon_phi_smpt_system_page_t)0x22)
#define xeon_phi_smpt_system_page_mask ((xeon_phi_smpt_system_page_t)0x1f)

static inline char *xeon_phi_smpt_system_page_describe(xeon_phi_smpt_system_page_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_smpt_system_page_describe(xeon_phi_smpt_system_page_t _e)
{
    switch (_e) {
    case xeon_phi_smpt_system_page_size:
        return("system_page_size: Size of a System Memory Page (16GB)");
    case xeon_phi_smpt_system_page_num:
        return("system_page_num: The number of system memory pages");
    case xeon_phi_smpt_system_page_shift:
        return("system_page_shift: The amount of bits to shift");
    case xeon_phi_smpt_system_page_mask:
        return("system_page_mask: System memory page mask");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_smpt_system_page_prtval(char *_s, size_t _size, xeon_phi_smpt_system_page_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_smpt_system_page_prtval(char *_s, size_t _size, xeon_phi_smpt_system_page_t _e)
{
    char *d = xeon_phi_smpt_system_page_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_smpt_system_page_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: xeon_phi_smpt_entry_t
 * Description: Implicit type of System Memory Page Table Entry register array
 * Fields:
 *   snoop_disabled	(size 1, offset 0, init 0):	NOATTR	Disable snooping
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   host_address	(size 30, offset 2, init 0):	NOATTR	High 32bit of the host address
 */
typedef uint32_t xeon_phi_smpt_entry_t;
#define xeon_phi_smpt_entry_default 0x0
static inline xeon_phi_smpt_snooping_t xeon_phi_smpt_entry_snoop_disabled_extract(xeon_phi_smpt_entry_t _regval) __attribute__ ((always_inline));
static inline xeon_phi_smpt_snooping_t xeon_phi_smpt_entry_snoop_disabled_extract(xeon_phi_smpt_entry_t _regval)
{
    return((xeon_phi_smpt_snooping_t )((_regval & 0x1) >> 0));
}

static inline xeon_phi_smpt_entry_t xeon_phi_smpt_entry_snoop_disabled_insert(xeon_phi_smpt_entry_t _regval, xeon_phi_smpt_snooping_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_smpt_entry_t xeon_phi_smpt_entry_snoop_disabled_insert(xeon_phi_smpt_entry_t _regval, xeon_phi_smpt_snooping_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((xeon_phi_smpt_entry_t )(_fieldval)) << 0)));
}

static inline uint32_t xeon_phi_smpt_entry_host_address_extract(xeon_phi_smpt_entry_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_smpt_entry_host_address_extract(xeon_phi_smpt_entry_t _regval)
{
    return((uint32_t )((_regval & 0xfffffffc) >> 2));
}

static inline xeon_phi_smpt_entry_t xeon_phi_smpt_entry_host_address_insert(xeon_phi_smpt_entry_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_smpt_entry_t xeon_phi_smpt_entry_host_address_insert(xeon_phi_smpt_entry_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x3) | (0xfffffffc & (((xeon_phi_smpt_entry_t )(_fieldval)) << 2)));
}

static inline int xeon_phi_smpt_entry_prtval(char *_s, size_t _size, xeon_phi_smpt_entry_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_smpt_entry_prtval(char *_s, size_t _size, xeon_phi_smpt_entry_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " snoop_disabled =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_smpt_snooping_prtval(_s + _r, _avail, xeon_phi_smpt_entry_snoop_disabled_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Disable snooping)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " host_address =\t%" PRIx32 "\t(High 32bit of the host address)\n", xeon_phi_smpt_entry_host_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum xeon_phi_smpt_initials {
    xeon_phi_smpt_entry_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void xeon_phi_smpt_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void xeon_phi_smpt_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register array entry: System Memory Page Table Entry
 * Type: xeon_phi_smpt.entry (Implicit type of System Memory Page Table Entry register array)
 *   snoop_disabled	(size 1, offset 0, init 0):	RW	Disable snooping
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   host_address	(size 30, offset 2, init 0):	RW	High 32bit of the host address
 */
static const size_t xeon_phi_smpt_entry_length = 32;
static inline xeon_phi_smpt_entry_t xeon_phi_smpt_entry_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_smpt_entry_t xeon_phi_smpt_entry_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3100 + (_i * (32 / 8))));
}

static inline xeon_phi_smpt_entry_t xeon_phi_smpt_entry_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_smpt_entry_t xeon_phi_smpt_entry_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3100 + (_i * (32 / 8))));
}

static inline void xeon_phi_smpt_entry_rawwr(__DN(t) *_dev, int _i, xeon_phi_smpt_entry_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_smpt_entry_rawwr(__DN(t) *_dev, int _i, xeon_phi_smpt_entry_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3100 + (_i * (32 / 8)), _regval);
}

static inline void xeon_phi_smpt_entry_wr(__DN(t) *_dev, int _i, xeon_phi_smpt_entry_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_smpt_entry_wr(__DN(t) *_dev, int _i, xeon_phi_smpt_entry_t _regval)
{
    _regval = (_regval & 0xfffffffd);
    // No MB1 fields present
    _regval = (_regval | (0x2 & mackerel_read_addr_32(_dev->base, 0x3100 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x3100 + (_i * (32 / 8)), _regval);
}

static inline int xeon_phi_smpt_entry_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_smpt_entry_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_smpt_entry_t _regval = mackerel_read_addr_32(_dev->base, 0x3100 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "entry", _i, "System Memory Page Table Entry");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " snoop_disabled =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_smpt_snooping_prtval(_s + _r, _avail, xeon_phi_smpt_entry_snoop_disabled_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Disable snooping)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " host_address =\t%" PRIx32 "\t(High 32bit of the host address)\n", xeon_phi_smpt_entry_host_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int xeon_phi_smpt_entry_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_smpt_entry_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 32; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_smpt_entry_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline xeon_phi_smpt_snooping_t xeon_phi_smpt_entry_snoop_disabled_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_smpt_snooping_t xeon_phi_smpt_entry_snoop_disabled_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_smpt_entry_t _regval = mackerel_read_addr_32(_dev->base, 0x3100 + (_i * (32 / 8)));
    return(xeon_phi_smpt_entry_snoop_disabled_extract(_regval));
}

static inline uint32_t xeon_phi_smpt_entry_host_address_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_smpt_entry_host_address_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_smpt_entry_t _regval = mackerel_read_addr_32(_dev->base, 0x3100 + (_i * (32 / 8)));
    return(xeon_phi_smpt_entry_host_address_extract(_regval));
}

static inline void xeon_phi_smpt_entry_snoop_disabled_wrf(__DN(t) *_dev, int _i, xeon_phi_smpt_snooping_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_smpt_entry_snoop_disabled_wrf(__DN(t) *_dev, int _i, xeon_phi_smpt_snooping_t _fieldval)
{
    xeon_phi_smpt_entry_t _regval = 0x1 & (((xeon_phi_smpt_entry_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x3100 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3100 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void xeon_phi_smpt_entry_host_address_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_smpt_entry_host_address_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    xeon_phi_smpt_entry_t _regval = 0xfffffffc & (((xeon_phi_smpt_entry_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x3100 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3100 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline int xeon_phi_smpt_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_smpt_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device xeon_phi_smpt (Intel Xeon Phi System Memory Page Tables):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_smpt_entry_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device xeon_phi_smpt\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __xeon_phi_smpt_DEV_H
