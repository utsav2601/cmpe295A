#ifndef __xeon_phi_dma_DEV_H
#define __xeon_phi_dma_DEV_H 1
/*
 * DEVICE DEFINITION: Intel Xeon Phi DMA System
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) xeon_phi_dma ## _ ## x
/*
 * Constants defn: xeon_phi_dma.drar_shifts (Shift amounts for the field values)
 *  - no width specified
 */
typedef uint8_t xeon_phi_dma_drar_shifts_t;
#define xeon_phi_dma_drar_size_shift ((xeon_phi_dma_drar_shifts_t)0x2)
#define xeon_phi_dma_drar_base_shift ((xeon_phi_dma_drar_shifts_t)0x6)

static inline char *xeon_phi_dma_drar_shifts_describe(xeon_phi_dma_drar_shifts_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_dma_drar_shifts_describe(xeon_phi_dma_drar_shifts_t _e)
{
    switch (_e) {
    case xeon_phi_dma_drar_size_shift:
        return("drar_size_shift: drar_size_shift");
    case xeon_phi_dma_drar_base_shift:
        return("drar_base_shift: drar_base_shift");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_dma_drar_shifts_prtval(char *_s, size_t _size, xeon_phi_dma_drar_shifts_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_dma_drar_shifts_prtval(char *_s, size_t _size, xeon_phi_dma_drar_shifts_t _e)
{
    char *d = xeon_phi_dma_drar_shifts_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_dma_drar_shifts_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xeon_phi_dma.descriptor_type ()
 *  - width 4 bits
 */
typedef uint8_t xeon_phi_dma_descriptor_type_t;
#define xeon_phi_dma_desc_nop ((xeon_phi_dma_descriptor_type_t)0x0)
#define xeon_phi_dma_desc_memcpy ((xeon_phi_dma_descriptor_type_t)0x1)
#define xeon_phi_dma_desc_status ((xeon_phi_dma_descriptor_type_t)0x2)
#define xeon_phi_dma_desc_general ((xeon_phi_dma_descriptor_type_t)0x3)
#define xeon_phi_dma_desc_keynoncecent ((xeon_phi_dma_descriptor_type_t)0x4)
#define xeon_phi_dma_desc_key ((xeon_phi_dma_descriptor_type_t)0x5)

static inline char *xeon_phi_dma_descriptor_type_describe(xeon_phi_dma_descriptor_type_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_dma_descriptor_type_describe(xeon_phi_dma_descriptor_type_t _e)
{
    switch (_e) {
    case xeon_phi_dma_desc_nop:
        return("desc_nop: desc_nop");
    case xeon_phi_dma_desc_memcpy:
        return("desc_memcpy: desc_memcpy");
    case xeon_phi_dma_desc_status:
        return("desc_status: desc_status");
    case xeon_phi_dma_desc_general:
        return("desc_general: desc_general");
    case xeon_phi_dma_desc_keynoncecent:
        return("desc_keynoncecent: desc_keynoncecent");
    case xeon_phi_dma_desc_key:
        return("desc_key: desc_key");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_dma_descriptor_type_prtval(char *_s, size_t _size, xeon_phi_dma_descriptor_type_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_dma_descriptor_type_prtval(char *_s, size_t _size, xeon_phi_dma_descriptor_type_t _e)
{
    char *d = xeon_phi_dma_descriptor_type_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_dma_descriptor_type_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: xeon_phi_dma_dcar_t
 * Description: Implicit type of DMA Channel Attribute Register register array
 * Fields:
 *   _anon0	(size 23, offset 0, init 0):	RSVD	_
 *   apic_irq	(size 1, offset 23, init 0):	NOATTR	APIC Interrupt mask bit
 *   msix_irq	(size 1, offset 24, init 0):	NOATTR	MSI-X Interrupt mask bit
 *   irq_status	(size 1, offset 25, init 0):	NOATTR	Interrupt status
 *   _anon26	(size 6, offset 26, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_dma_dcar_t;
#define xeon_phi_dma_dcar_default 0x0
static inline uint8_t xeon_phi_dma_dcar_apic_irq_extract(xeon_phi_dma_dcar_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcar_apic_irq_extract(xeon_phi_dma_dcar_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline xeon_phi_dma_dcar_t xeon_phi_dma_dcar_apic_irq_insert(xeon_phi_dma_dcar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcar_t xeon_phi_dma_dcar_apic_irq_insert(xeon_phi_dma_dcar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((xeon_phi_dma_dcar_t )(_fieldval)) << 23)));
}

static inline uint8_t xeon_phi_dma_dcar_msix_irq_extract(xeon_phi_dma_dcar_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcar_msix_irq_extract(xeon_phi_dma_dcar_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline xeon_phi_dma_dcar_t xeon_phi_dma_dcar_msix_irq_insert(xeon_phi_dma_dcar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcar_t xeon_phi_dma_dcar_msix_irq_insert(xeon_phi_dma_dcar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((xeon_phi_dma_dcar_t )(_fieldval)) << 24)));
}

static inline uint8_t xeon_phi_dma_dcar_irq_status_extract(xeon_phi_dma_dcar_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcar_irq_status_extract(xeon_phi_dma_dcar_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline xeon_phi_dma_dcar_t xeon_phi_dma_dcar_irq_status_insert(xeon_phi_dma_dcar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcar_t xeon_phi_dma_dcar_irq_status_insert(xeon_phi_dma_dcar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((xeon_phi_dma_dcar_t )(_fieldval)) << 25)));
}

static inline int xeon_phi_dma_dcar_prtval(char *_s, size_t _size, xeon_phi_dma_dcar_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dcar_prtval(char *_s, size_t _size, xeon_phi_dma_dcar_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apic_irq =\t%" PRIx8 "\t(APIC Interrupt mask bit)\n", xeon_phi_dma_dcar_apic_irq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msix_irq =\t%" PRIx8 "\t(MSI-X Interrupt mask bit)\n", xeon_phi_dma_dcar_msix_irq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " irq_status =\t%" PRIx8 "\t(Interrupt status)\n", xeon_phi_dma_dcar_irq_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_dhpr_t
 * Description: Implicit type of DMA Descriptor Head Pointer Register register array
 * Fields:
 *   index	(size 16, offset 0, init 0):	NOATTR	Index of the head pointer
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_dma_dhpr_t;
#define xeon_phi_dma_dhpr_default 0x0
static inline uint16_t xeon_phi_dma_dhpr_index_extract(xeon_phi_dma_dhpr_t _regval) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_dhpr_index_extract(xeon_phi_dma_dhpr_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline xeon_phi_dma_dhpr_t xeon_phi_dma_dhpr_index_insert(xeon_phi_dma_dhpr_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dhpr_t xeon_phi_dma_dhpr_index_insert(xeon_phi_dma_dhpr_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((xeon_phi_dma_dhpr_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_dhpr_prtval(char *_s, size_t _size, xeon_phi_dma_dhpr_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dhpr_prtval(char *_s, size_t _size, xeon_phi_dma_dhpr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " index =\t%" PRIx16 "\t(Index of the head pointer)\n", xeon_phi_dma_dhpr_index_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_dtpr_t
 * Description: Implicit type of DMA Descriptor Tail Pointer Register register array
 * Fields:
 *   index	(size 16, offset 0, init 0):	NOATTR	Index of the head pointer
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_dma_dtpr_t;
#define xeon_phi_dma_dtpr_default 0x0
static inline uint16_t xeon_phi_dma_dtpr_index_extract(xeon_phi_dma_dtpr_t _regval) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_dtpr_index_extract(xeon_phi_dma_dtpr_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline xeon_phi_dma_dtpr_t xeon_phi_dma_dtpr_index_insert(xeon_phi_dma_dtpr_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dtpr_t xeon_phi_dma_dtpr_index_insert(xeon_phi_dma_dtpr_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((xeon_phi_dma_dtpr_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_dtpr_prtval(char *_s, size_t _size, xeon_phi_dma_dtpr_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dtpr_prtval(char *_s, size_t _size, xeon_phi_dma_dtpr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " index =\t%" PRIx16 "\t(Index of the head pointer)\n", xeon_phi_dma_dtpr_index_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_aux_lo_t
 * Description: Implicit type of DMA Auxiliary Register 0 Lo register array
 * Fields:
 *   r	(size 32, offset 0, init 0):	NOATTR	
 */
typedef uint32_t xeon_phi_dma_aux_lo_t;
#define xeon_phi_dma_aux_lo_default 0x0
static inline uint32_t xeon_phi_dma_aux_lo_r_extract(xeon_phi_dma_aux_lo_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_aux_lo_r_extract(xeon_phi_dma_aux_lo_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_aux_lo_t xeon_phi_dma_aux_lo_r_insert(xeon_phi_dma_aux_lo_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_aux_lo_t xeon_phi_dma_aux_lo_r_insert(xeon_phi_dma_aux_lo_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_aux_lo_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_aux_lo_prtval(char *_s, size_t _size, xeon_phi_dma_aux_lo_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_aux_lo_prtval(char *_s, size_t _size, xeon_phi_dma_aux_lo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_aux_lo_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_aux_hi_t
 * Description: Implicit type of DMA Auxiliary Register 0 Hi register array
 * Fields:
 *   r	(size 32, offset 0, init 0):	NOATTR	
 */
typedef uint32_t xeon_phi_dma_aux_hi_t;
#define xeon_phi_dma_aux_hi_default 0x0
static inline uint32_t xeon_phi_dma_aux_hi_r_extract(xeon_phi_dma_aux_hi_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_aux_hi_r_extract(xeon_phi_dma_aux_hi_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_aux_hi_t xeon_phi_dma_aux_hi_r_insert(xeon_phi_dma_aux_hi_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_aux_hi_t xeon_phi_dma_aux_hi_r_insert(xeon_phi_dma_aux_hi_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_aux_hi_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_aux_hi_prtval(char *_s, size_t _size, xeon_phi_dma_aux_hi_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_aux_hi_prtval(char *_s, size_t _size, xeon_phi_dma_aux_hi_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_aux_hi_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_drar_hi_t
 * Description: Implicit type of DMA Descriptor Ring Attributes Register Lo register array
 * Fields:
 *   base	(size 4, offset 0, init 0):	NOATTR	base address hi part
 *   _anon4	(size 2, offset 4, init 0):	RSVD	_
 *   size	(size 15, offset 6, init 0):	NOATTR	size of the descriptor ring
 *   page	(size 5, offset 21, init 0):	NOATTR	
 *   sysbit	(size 1, offset 26, init 0):	NOATTR	
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_dma_drar_hi_t;
#define xeon_phi_dma_drar_hi_default 0x0
static inline uint8_t xeon_phi_dma_drar_hi_base_extract(xeon_phi_dma_drar_hi_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_drar_hi_base_extract(xeon_phi_dma_drar_hi_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline xeon_phi_dma_drar_hi_t xeon_phi_dma_drar_hi_base_insert(xeon_phi_dma_drar_hi_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_drar_hi_t xeon_phi_dma_drar_hi_base_insert(xeon_phi_dma_drar_hi_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((xeon_phi_dma_drar_hi_t )(_fieldval)) << 0)));
}

static inline uint16_t xeon_phi_dma_drar_hi_size_extract(xeon_phi_dma_drar_hi_t _regval) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_drar_hi_size_extract(xeon_phi_dma_drar_hi_t _regval)
{
    return((uint16_t )((_regval & 0x1fffc0) >> 6));
}

static inline xeon_phi_dma_drar_hi_t xeon_phi_dma_drar_hi_size_insert(xeon_phi_dma_drar_hi_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_drar_hi_t xeon_phi_dma_drar_hi_size_insert(xeon_phi_dma_drar_hi_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffe0003f) | (0x1fffc0 & (((xeon_phi_dma_drar_hi_t )(_fieldval)) << 6)));
}

static inline uint8_t xeon_phi_dma_drar_hi_page_extract(xeon_phi_dma_drar_hi_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_drar_hi_page_extract(xeon_phi_dma_drar_hi_t _regval)
{
    return((uint8_t )((_regval & 0x3e00000) >> 21));
}

static inline xeon_phi_dma_drar_hi_t xeon_phi_dma_drar_hi_page_insert(xeon_phi_dma_drar_hi_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_drar_hi_t xeon_phi_dma_drar_hi_page_insert(xeon_phi_dma_drar_hi_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfc1fffff) | (0x3e00000 & (((xeon_phi_dma_drar_hi_t )(_fieldval)) << 21)));
}

static inline uint8_t xeon_phi_dma_drar_hi_sysbit_extract(xeon_phi_dma_drar_hi_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_drar_hi_sysbit_extract(xeon_phi_dma_drar_hi_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline xeon_phi_dma_drar_hi_t xeon_phi_dma_drar_hi_sysbit_insert(xeon_phi_dma_drar_hi_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_drar_hi_t xeon_phi_dma_drar_hi_sysbit_insert(xeon_phi_dma_drar_hi_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((xeon_phi_dma_drar_hi_t )(_fieldval)) << 26)));
}

static inline int xeon_phi_dma_drar_hi_prtval(char *_s, size_t _size, xeon_phi_dma_drar_hi_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_drar_hi_prtval(char *_s, size_t _size, xeon_phi_dma_drar_hi_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " base =\t%" PRIx8 "\t(base address hi part)\n", xeon_phi_dma_drar_hi_base_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx16 "\t(size of the descriptor ring)\n", xeon_phi_dma_drar_hi_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " page =\t%" PRIx8 "\t()\n", xeon_phi_dma_drar_hi_page_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sysbit =\t%" PRIx8 "\t()\n", xeon_phi_dma_drar_hi_sysbit_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_drar_lo_t
 * Description: Implicit type of DMA Descriptor Ring Attributes Register Lo register array
 * Fields:
 *   _anon0	(size 6, offset 0, init 0):	RSVD	_
 *   base	(size 26, offset 6, init 0):	NOATTR	base address lo part
 */
typedef uint32_t xeon_phi_dma_drar_lo_t;
#define xeon_phi_dma_drar_lo_default 0x0
static inline uint32_t xeon_phi_dma_drar_lo_base_extract(xeon_phi_dma_drar_lo_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_drar_lo_base_extract(xeon_phi_dma_drar_lo_t _regval)
{
    return((uint32_t )((_regval & 0xffffffc0) >> 6));
}

static inline xeon_phi_dma_drar_lo_t xeon_phi_dma_drar_lo_base_insert(xeon_phi_dma_drar_lo_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_drar_lo_t xeon_phi_dma_drar_lo_base_insert(xeon_phi_dma_drar_lo_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x3f) | (0xffffffc0 & (((xeon_phi_dma_drar_lo_t )(_fieldval)) << 6)));
}

static inline int xeon_phi_dma_drar_lo_prtval(char *_s, size_t _size, xeon_phi_dma_drar_lo_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_drar_lo_prtval(char *_s, size_t _size, xeon_phi_dma_drar_lo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " base =\t%" PRIx32 "\t(base address lo part)\n", xeon_phi_dma_drar_lo_base_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_ditr_t
 * Description: Implicit type of DMA Interrupt Timer Register register array
 * Fields:
 *   r	(size 32, offset 0, init 0):	NOATTR	
 */
typedef uint32_t xeon_phi_dma_ditr_t;
#define xeon_phi_dma_ditr_default 0x0
static inline uint32_t xeon_phi_dma_ditr_r_extract(xeon_phi_dma_ditr_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_ditr_r_extract(xeon_phi_dma_ditr_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_ditr_t xeon_phi_dma_ditr_r_insert(xeon_phi_dma_ditr_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_ditr_t xeon_phi_dma_ditr_r_insert(xeon_phi_dma_ditr_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_ditr_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_ditr_prtval(char *_s, size_t _size, xeon_phi_dma_ditr_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_ditr_prtval(char *_s, size_t _size, xeon_phi_dma_ditr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_ditr_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_dstat_t
 * Description: Implicit type of DMA Status Channel Register register array
 * Fields:
 *   completions	(size 16, offset 0, init 0):	NOATTR	Completition count
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_dma_dstat_t;
#define xeon_phi_dma_dstat_default 0x0
static inline uint16_t xeon_phi_dma_dstat_completions_extract(xeon_phi_dma_dstat_t _regval) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_dstat_completions_extract(xeon_phi_dma_dstat_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline xeon_phi_dma_dstat_t xeon_phi_dma_dstat_completions_insert(xeon_phi_dma_dstat_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dstat_t xeon_phi_dma_dstat_completions_insert(xeon_phi_dma_dstat_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((xeon_phi_dma_dstat_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_dstat_prtval(char *_s, size_t _size, xeon_phi_dma_dstat_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dstat_prtval(char *_s, size_t _size, xeon_phi_dma_dstat_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " completions =\t%" PRIx16 "\t(Completition count)\n", xeon_phi_dma_dstat_completions_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_dstatwb_lo_t
 * Description: Implicit type of DMA Tail Pointer Write Back Register Lo register array
 * Fields:
 *   r	(size 32, offset 0, init 0):	NOATTR	
 */
typedef uint32_t xeon_phi_dma_dstatwb_lo_t;
#define xeon_phi_dma_dstatwb_lo_default 0x0
static inline uint32_t xeon_phi_dma_dstatwb_lo_r_extract(xeon_phi_dma_dstatwb_lo_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dstatwb_lo_r_extract(xeon_phi_dma_dstatwb_lo_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_dstatwb_lo_t xeon_phi_dma_dstatwb_lo_r_insert(xeon_phi_dma_dstatwb_lo_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dstatwb_lo_t xeon_phi_dma_dstatwb_lo_r_insert(xeon_phi_dma_dstatwb_lo_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_dstatwb_lo_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_dstatwb_lo_prtval(char *_s, size_t _size, xeon_phi_dma_dstatwb_lo_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dstatwb_lo_prtval(char *_s, size_t _size, xeon_phi_dma_dstatwb_lo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dstatwb_lo_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_dstatwb_hi_t
 * Description: Implicit type of DMA Tail Pointer Write Back Register Hi register array
 * Fields:
 *   r	(size 32, offset 0, init 0):	NOATTR	
 */
typedef uint32_t xeon_phi_dma_dstatwb_hi_t;
#define xeon_phi_dma_dstatwb_hi_default 0x0
static inline uint32_t xeon_phi_dma_dstatwb_hi_r_extract(xeon_phi_dma_dstatwb_hi_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dstatwb_hi_r_extract(xeon_phi_dma_dstatwb_hi_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_dstatwb_hi_t xeon_phi_dma_dstatwb_hi_r_insert(xeon_phi_dma_dstatwb_hi_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dstatwb_hi_t xeon_phi_dma_dstatwb_hi_r_insert(xeon_phi_dma_dstatwb_hi_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_dstatwb_hi_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_dstatwb_hi_prtval(char *_s, size_t _size, xeon_phi_dma_dstatwb_hi_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dstatwb_hi_prtval(char *_s, size_t _size, xeon_phi_dma_dstatwb_hi_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dstatwb_hi_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_dcherr_t
 * Description: Implicit type of DMA Channel Error Register register array
 * Fields:
 *   r	(size 32, offset 0, init 0):	NOATTR	
 */
typedef uint32_t xeon_phi_dma_dcherr_t;
#define xeon_phi_dma_dcherr_default 0x0
static inline uint32_t xeon_phi_dma_dcherr_r_extract(xeon_phi_dma_dcherr_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dcherr_r_extract(xeon_phi_dma_dcherr_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_dcherr_t xeon_phi_dma_dcherr_r_insert(xeon_phi_dma_dcherr_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcherr_t xeon_phi_dma_dcherr_r_insert(xeon_phi_dma_dcherr_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_dcherr_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_dcherr_prtval(char *_s, size_t _size, xeon_phi_dma_dcherr_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dcherr_prtval(char *_s, size_t _size, xeon_phi_dma_dcherr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dcherr_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_dcherrmsk_t
 * Description: Implicit type of DMA Channel Error Register Mask register array
 * Fields:
 *   r	(size 32, offset 0, init 0):	NOATTR	
 */
typedef uint32_t xeon_phi_dma_dcherrmsk_t;
#define xeon_phi_dma_dcherrmsk_default 0x0
static inline uint32_t xeon_phi_dma_dcherrmsk_r_extract(xeon_phi_dma_dcherrmsk_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dcherrmsk_r_extract(xeon_phi_dma_dcherrmsk_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_dcherrmsk_t xeon_phi_dma_dcherrmsk_r_insert(xeon_phi_dma_dcherrmsk_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcherrmsk_t xeon_phi_dma_dcherrmsk_r_insert(xeon_phi_dma_dcherrmsk_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_dcherrmsk_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_dcherrmsk_prtval(char *_s, size_t _size, xeon_phi_dma_dcherrmsk_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dcherrmsk_prtval(char *_s, size_t _size, xeon_phi_dma_dcherrmsk_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dcherrmsk_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_dcr_t
 * Description: Implicit type of DMA Configuration Register register
 * Fields:
 *   co0	(size 1, offset 0, init 0):	RW	DMA Channel 0 Owner
 *   ce0	(size 1, offset 1, init 0):	RW	DMA Channel 0 Enable
 *   co1	(size 1, offset 2, init 0):	RW	DMA Channel 1 Owner
 *   ce1	(size 1, offset 3, init 0):	RW	DMA Channel 1 Enable
 *   co2	(size 1, offset 4, init 0):	RW	DMA Channel 2 Owner
 *   ce2	(size 1, offset 5, init 0):	RW	DMA Channel 2 Enable
 *   co3	(size 1, offset 6, init 0):	RW	DMA Channel 3 Owner
 *   ce3	(size 1, offset 7, init 0):	RW	DMA Channel 3 Enable
 *   co4	(size 1, offset 8, init 0):	RW	DMA Channel 4 Owner
 *   ce4	(size 1, offset 9, init 0):	RW	DMA Channel 4 Enable
 *   co5	(size 1, offset 10, init 0):	RW	DMA Channel 5 Owner
 *   ce5	(size 1, offset 11, init 0):	RW	DMA Channel 5 Enable
 *   co6	(size 1, offset 12, init 0):	RW	DMA Channel 6 Owner
 *   ce6	(size 1, offset 13, init 0):	RW	DMA Channel 6 Enable
 *   co7	(size 1, offset 14, init 0):	RW	DMA Channel 7 Owner
 *   ce7	(size 1, offset 15, init 0):	RW	DMA Channel 7 Enable
 *   arb_h	(size 8, offset 16, init 0):	RW	Arb H
 *   arb_l	(size 7, offset 24, init 0):	RW	Arb L
 *   p	(size 1, offset 31, init 0):	RW	Priority EN
 */
typedef uint32_t xeon_phi_dma_dcr_t;
#define xeon_phi_dma_dcr_default 0x0
static inline uint8_t xeon_phi_dma_dcr_co0_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_co0_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_co0_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_co0_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 0)));
}

static inline uint8_t xeon_phi_dma_dcr_ce0_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_ce0_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_ce0_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_ce0_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 1)));
}

static inline uint8_t xeon_phi_dma_dcr_co1_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_co1_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_co1_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_co1_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 2)));
}

static inline uint8_t xeon_phi_dma_dcr_ce1_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_ce1_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_ce1_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_ce1_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 3)));
}

static inline uint8_t xeon_phi_dma_dcr_co2_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_co2_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_co2_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_co2_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 4)));
}

static inline uint8_t xeon_phi_dma_dcr_ce2_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_ce2_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_ce2_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_ce2_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 5)));
}

static inline uint8_t xeon_phi_dma_dcr_co3_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_co3_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_co3_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_co3_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 6)));
}

static inline uint8_t xeon_phi_dma_dcr_ce3_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_ce3_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_ce3_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_ce3_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 7)));
}

static inline uint8_t xeon_phi_dma_dcr_co4_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_co4_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_co4_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_co4_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 8)));
}

static inline uint8_t xeon_phi_dma_dcr_ce4_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_ce4_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_ce4_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_ce4_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 9)));
}

static inline uint8_t xeon_phi_dma_dcr_co5_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_co5_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_co5_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_co5_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 10)));
}

static inline uint8_t xeon_phi_dma_dcr_ce5_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_ce5_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_ce5_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_ce5_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 11)));
}

static inline uint8_t xeon_phi_dma_dcr_co6_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_co6_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_co6_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_co6_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 12)));
}

static inline uint8_t xeon_phi_dma_dcr_ce6_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_ce6_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_ce6_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_ce6_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 13)));
}

static inline uint8_t xeon_phi_dma_dcr_co7_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_co7_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_co7_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_co7_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 14)));
}

static inline uint8_t xeon_phi_dma_dcr_ce7_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_ce7_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_ce7_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_ce7_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 15)));
}

static inline uint8_t xeon_phi_dma_dcr_arb_h_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_arb_h_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0xff0000) >> 16));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_arb_h_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_arb_h_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 16)));
}

static inline uint8_t xeon_phi_dma_dcr_arb_l_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_arb_l_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x7f000000) >> 24));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_arb_l_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_arb_l_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x80ffffff) | (0x7f000000 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 24)));
}

static inline uint8_t xeon_phi_dma_dcr_p_extract(xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_p_extract(xeon_phi_dma_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_p_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_p_insert(xeon_phi_dma_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 31)));
}

static inline int xeon_phi_dma_dcr_prtval(char *_s, size_t _size, xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dcr_prtval(char *_s, size_t _size, xeon_phi_dma_dcr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co0 =\t%" PRIx8 "\t(DMA Channel 0 Owner)\n", xeon_phi_dma_dcr_co0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce0 =\t%" PRIx8 "\t(DMA Channel 0 Enable)\n", xeon_phi_dma_dcr_ce0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co1 =\t%" PRIx8 "\t(DMA Channel 1 Owner)\n", xeon_phi_dma_dcr_co1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce1 =\t%" PRIx8 "\t(DMA Channel 1 Enable)\n", xeon_phi_dma_dcr_ce1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co2 =\t%" PRIx8 "\t(DMA Channel 2 Owner)\n", xeon_phi_dma_dcr_co2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce2 =\t%" PRIx8 "\t(DMA Channel 2 Enable)\n", xeon_phi_dma_dcr_ce2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co3 =\t%" PRIx8 "\t(DMA Channel 3 Owner)\n", xeon_phi_dma_dcr_co3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce3 =\t%" PRIx8 "\t(DMA Channel 3 Enable)\n", xeon_phi_dma_dcr_ce3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co4 =\t%" PRIx8 "\t(DMA Channel 4 Owner)\n", xeon_phi_dma_dcr_co4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce4 =\t%" PRIx8 "\t(DMA Channel 4 Enable)\n", xeon_phi_dma_dcr_ce4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co5 =\t%" PRIx8 "\t(DMA Channel 5 Owner)\n", xeon_phi_dma_dcr_co5_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce5 =\t%" PRIx8 "\t(DMA Channel 5 Enable)\n", xeon_phi_dma_dcr_ce5_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co6 =\t%" PRIx8 "\t(DMA Channel 6 Owner)\n", xeon_phi_dma_dcr_co6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce6 =\t%" PRIx8 "\t(DMA Channel 6 Enable)\n", xeon_phi_dma_dcr_ce6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co7 =\t%" PRIx8 "\t(DMA Channel 7 Owner)\n", xeon_phi_dma_dcr_co7_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce7 =\t%" PRIx8 "\t(DMA Channel 7 Enable)\n", xeon_phi_dma_dcr_ce7_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arb_h =\t%" PRIx8 "\t(Arb H)\n", xeon_phi_dma_dcr_arb_h_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arb_l =\t%" PRIx8 "\t(Arb L)\n", xeon_phi_dma_dcr_arb_l_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx8 "\t(Priority EN)\n", xeon_phi_dma_dcr_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_dqar_t
 * Description: Implicit type of Descriptor Queue Access Register register
 * Fields:
 *   r	(size 32, offset 0, init 0):	RW	
 */
typedef uint32_t xeon_phi_dma_dqar_t;
#define xeon_phi_dma_dqar_default 0x0
static inline uint32_t xeon_phi_dma_dqar_r_extract(xeon_phi_dma_dqar_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dqar_r_extract(xeon_phi_dma_dqar_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_dqar_t xeon_phi_dma_dqar_r_insert(xeon_phi_dma_dqar_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dqar_t xeon_phi_dma_dqar_r_insert(xeon_phi_dma_dqar_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_dqar_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_dqar_prtval(char *_s, size_t _size, xeon_phi_dma_dqar_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dqar_prtval(char *_s, size_t _size, xeon_phi_dma_dqar_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dqar_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_dqdr_tl_t
 * Description: Implicit type of Descriptor Queue Data Register Top Left register
 * Fields:
 *   r	(size 32, offset 0, init 0):	RW	
 */
typedef uint32_t xeon_phi_dma_dqdr_tl_t;
#define xeon_phi_dma_dqdr_tl_default 0x0
static inline uint32_t xeon_phi_dma_dqdr_tl_r_extract(xeon_phi_dma_dqdr_tl_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dqdr_tl_r_extract(xeon_phi_dma_dqdr_tl_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_dqdr_tl_t xeon_phi_dma_dqdr_tl_r_insert(xeon_phi_dma_dqdr_tl_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dqdr_tl_t xeon_phi_dma_dqdr_tl_r_insert(xeon_phi_dma_dqdr_tl_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_dqdr_tl_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_dqdr_tl_prtval(char *_s, size_t _size, xeon_phi_dma_dqdr_tl_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dqdr_tl_prtval(char *_s, size_t _size, xeon_phi_dma_dqdr_tl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dqdr_tl_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_dqdr_tr_t
 * Description: Implicit type of Descriptor Queue Data Register Top Right register
 * Fields:
 *   r	(size 32, offset 0, init 0):	RW	
 */
typedef uint32_t xeon_phi_dma_dqdr_tr_t;
#define xeon_phi_dma_dqdr_tr_default 0x0
static inline uint32_t xeon_phi_dma_dqdr_tr_r_extract(xeon_phi_dma_dqdr_tr_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dqdr_tr_r_extract(xeon_phi_dma_dqdr_tr_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_dqdr_tr_t xeon_phi_dma_dqdr_tr_r_insert(xeon_phi_dma_dqdr_tr_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dqdr_tr_t xeon_phi_dma_dqdr_tr_r_insert(xeon_phi_dma_dqdr_tr_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_dqdr_tr_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_dqdr_tr_prtval(char *_s, size_t _size, xeon_phi_dma_dqdr_tr_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dqdr_tr_prtval(char *_s, size_t _size, xeon_phi_dma_dqdr_tr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dqdr_tr_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_dqdr_bl_t
 * Description: Implicit type of Descriptor Queue Data Register Bottom Left register
 * Fields:
 *   r	(size 32, offset 0, init 0):	RW	
 */
typedef uint32_t xeon_phi_dma_dqdr_bl_t;
#define xeon_phi_dma_dqdr_bl_default 0x0
static inline uint32_t xeon_phi_dma_dqdr_bl_r_extract(xeon_phi_dma_dqdr_bl_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dqdr_bl_r_extract(xeon_phi_dma_dqdr_bl_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_dqdr_bl_t xeon_phi_dma_dqdr_bl_r_insert(xeon_phi_dma_dqdr_bl_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dqdr_bl_t xeon_phi_dma_dqdr_bl_r_insert(xeon_phi_dma_dqdr_bl_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_dqdr_bl_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_dqdr_bl_prtval(char *_s, size_t _size, xeon_phi_dma_dqdr_bl_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dqdr_bl_prtval(char *_s, size_t _size, xeon_phi_dma_dqdr_bl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dqdr_bl_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_dqdr_br_t
 * Description: Implicit type of Descriptor Queue Data Register Bottom Right register
 * Fields:
 *   r	(size 32, offset 0, init 0):	RW	
 */
typedef uint32_t xeon_phi_dma_dqdr_br_t;
#define xeon_phi_dma_dqdr_br_default 0x0
static inline uint32_t xeon_phi_dma_dqdr_br_r_extract(xeon_phi_dma_dqdr_br_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dqdr_br_r_extract(xeon_phi_dma_dqdr_br_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_dqdr_br_t xeon_phi_dma_dqdr_br_r_insert(xeon_phi_dma_dqdr_br_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_dqdr_br_t xeon_phi_dma_dqdr_br_r_insert(xeon_phi_dma_dqdr_br_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_dqdr_br_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_dqdr_br_prtval(char *_s, size_t _size, xeon_phi_dma_dqdr_br_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dqdr_br_prtval(char *_s, size_t _size, xeon_phi_dma_dqdr_br_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dqdr_br_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_misc_t
 * Description: Implicit type of Misc DMA Bits register
 * Fields:
 *   r	(size 32, offset 0, init 0):	RW	
 */
typedef uint32_t xeon_phi_dma_misc_t;
#define xeon_phi_dma_misc_default 0x0
static inline uint32_t xeon_phi_dma_misc_r_extract(xeon_phi_dma_misc_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_misc_r_extract(xeon_phi_dma_misc_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_misc_t xeon_phi_dma_misc_r_insert(xeon_phi_dma_misc_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_misc_t xeon_phi_dma_misc_r_insert(xeon_phi_dma_misc_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_misc_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_misc_prtval(char *_s, size_t _size, xeon_phi_dma_misc_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_misc_prtval(char *_s, size_t _size, xeon_phi_dma_misc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_misc_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_lock_t
 * Description: Implicit type of Master Lock Register register
 * Fields:
 *   r	(size 32, offset 0, init 0):	RW	
 */
typedef uint32_t xeon_phi_dma_lock_t;
#define xeon_phi_dma_lock_default 0x0
static inline uint32_t xeon_phi_dma_lock_r_extract(xeon_phi_dma_lock_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_lock_r_extract(xeon_phi_dma_lock_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_lock_t xeon_phi_dma_lock_r_insert(xeon_phi_dma_lock_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_lock_t xeon_phi_dma_lock_r_insert(xeon_phi_dma_lock_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_lock_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_lock_prtval(char *_s, size_t _size, xeon_phi_dma_lock_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_lock_prtval(char *_s, size_t _size, xeon_phi_dma_lock_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_lock_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: xeon_phi_dma_desc_nop_t
 * Description: No-Op descriptor type
 * Fields:
 *   _anon0	(size 124, offset 0, init 0):	RSVD	_
 *   dtype	(size 4, offset 124, init 0):	RW	Descriptor type
 */
typedef uint8_t *xeon_phi_dma_desc_nop_t;
typedef uint8_t xeon_phi_dma_desc_nop_array_t[16];
static const size_t xeon_phi_dma_desc_nop_size = sizeof(xeon_phi_dma_desc_nop_array_t );
static inline uint8_t xeon_phi_dma_desc_nop_dtype_extract(xeon_phi_dma_desc_nop_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_nop_dtype_extract(xeon_phi_dma_desc_nop_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0xf0) >> 4);
}

static inline void xeon_phi_dma_desc_nop_dtype_insert(xeon_phi_dma_desc_nop_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_nop_dtype_insert(xeon_phi_dma_desc_nop_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0xf) | (0xf0 & (_fieldval << 4)));
}

static inline int xeon_phi_dma_desc_nop_prtval(char *_s, size_t _size, xeon_phi_dma_desc_nop_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_desc_nop_prtval(char *_s, size_t _size, xeon_phi_dma_desc_nop_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dtype =\t%" PRIx8 "\t(Descriptor type)\n", xeon_phi_dma_desc_nop_dtype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: xeon_phi_dma_desc_memcpy_t
 * Description: Memory Copy descriptor type
 * Fields:
 *   src	(size 40, offset 0, init 0):	RW	Source address
 *   index	(size 3, offset 40, init 0):	RW	
 *   _anon43	(size 3, offset 43, init 0):	RSVD	_
 *   length	(size 14, offset 46, init 0):	RW	
 *   _anon60	(size 4, offset 60, init 0):	RSVD	_
 *   dst	(size 40, offset 64, init 0):	RW	Destination address
 *   resd	(size 15, offset 104, init 0):	RW	
 *   twb	(size 1, offset 119, init 0):	RW	
 *   intr	(size 1, offset 120, init 0):	RW	
 *   c	(size 1, offset 121, init 0):	RW	
 *   co	(size 1, offset 122, init 0):	RW	
 *   ecy	(size 1, offset 123, init 0):	RW	
 *   dtype	(size 4, offset 124, init 0):	RW	
 */
typedef uint8_t *xeon_phi_dma_desc_memcpy_t;
typedef uint8_t xeon_phi_dma_desc_memcpy_array_t[16];
static const size_t xeon_phi_dma_desc_memcpy_size = sizeof(xeon_phi_dma_desc_memcpy_array_t );
static inline uint64_t xeon_phi_dma_desc_memcpy_src_extract(xeon_phi_dma_desc_memcpy_t _dtptr) __attribute__ ((always_inline));
static inline uint64_t xeon_phi_dma_desc_memcpy_src_extract(xeon_phi_dma_desc_memcpy_t _dtptr)
{
    return(((*((uint64_t *)(0 + _dtptr))) & 0xffffffffff) >> 0);
}

static inline void xeon_phi_dma_desc_memcpy_src_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_memcpy_src_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint64_t _fieldval)
{
    *((uint64_t *)(0 + _dtptr)) = (((*((uint64_t *)(0 + _dtptr))) & 0xffffff0000000000) | (0xffffffffff & (_fieldval << 0)));
}

static inline uint8_t xeon_phi_dma_desc_memcpy_index_extract(xeon_phi_dma_desc_memcpy_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_memcpy_index_extract(xeon_phi_dma_desc_memcpy_t _dtptr)
{
    return(((*((uint8_t *)(5 + _dtptr))) & 0x7) >> 0);
}

static inline void xeon_phi_dma_desc_memcpy_index_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_memcpy_index_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(5 + _dtptr)) = (((*((uint8_t *)(5 + _dtptr))) & 0xf8) | (0x7 & (_fieldval << 0)));
}

static inline uint16_t xeon_phi_dma_desc_memcpy_length_extract(xeon_phi_dma_desc_memcpy_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_desc_memcpy_length_extract(xeon_phi_dma_desc_memcpy_t _dtptr)
{
    return(((*((uint32_t *)(4 + _dtptr))) & 0xfffc000) >> 14);
}

static inline void xeon_phi_dma_desc_memcpy_length_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_memcpy_length_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint16_t _fieldval)
{
    *((uint32_t *)(4 + _dtptr)) = (((*((uint32_t *)(4 + _dtptr))) & 0xf0003fff) | (0xfffc000 & (_fieldval << 14)));
}

static inline uint64_t xeon_phi_dma_desc_memcpy_dst_extract(xeon_phi_dma_desc_memcpy_t _dtptr) __attribute__ ((always_inline));
static inline uint64_t xeon_phi_dma_desc_memcpy_dst_extract(xeon_phi_dma_desc_memcpy_t _dtptr)
{
    return(((*((uint64_t *)(8 + _dtptr))) & 0xffffffffff) >> 0);
}

static inline void xeon_phi_dma_desc_memcpy_dst_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_memcpy_dst_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint64_t _fieldval)
{
    *((uint64_t *)(8 + _dtptr)) = (((*((uint64_t *)(8 + _dtptr))) & 0xffffff0000000000) | (0xffffffffff & (_fieldval << 0)));
}

static inline uint16_t xeon_phi_dma_desc_memcpy_resd_extract(xeon_phi_dma_desc_memcpy_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_desc_memcpy_resd_extract(xeon_phi_dma_desc_memcpy_t _dtptr)
{
    return(((*((uint32_t *)(12 + _dtptr))) & 0x7fff00) >> 8);
}

static inline void xeon_phi_dma_desc_memcpy_resd_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_memcpy_resd_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint16_t _fieldval)
{
    *((uint32_t *)(12 + _dtptr)) = (((*((uint32_t *)(12 + _dtptr))) & 0xff8000ff) | (0x7fff00 & (_fieldval << 8)));
}

static inline uint8_t xeon_phi_dma_desc_memcpy_twb_extract(xeon_phi_dma_desc_memcpy_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_memcpy_twb_extract(xeon_phi_dma_desc_memcpy_t _dtptr)
{
    return(((*((uint8_t *)(14 + _dtptr))) & 0x80) >> 7);
}

static inline void xeon_phi_dma_desc_memcpy_twb_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_memcpy_twb_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(14 + _dtptr)) = (((*((uint8_t *)(14 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint8_t xeon_phi_dma_desc_memcpy_intr_extract(xeon_phi_dma_desc_memcpy_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_memcpy_intr_extract(xeon_phi_dma_desc_memcpy_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0x1) >> 0);
}

static inline void xeon_phi_dma_desc_memcpy_intr_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_memcpy_intr_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t xeon_phi_dma_desc_memcpy_c_extract(xeon_phi_dma_desc_memcpy_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_memcpy_c_extract(xeon_phi_dma_desc_memcpy_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0x2) >> 1);
}

static inline void xeon_phi_dma_desc_memcpy_c_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_memcpy_c_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t xeon_phi_dma_desc_memcpy_co_extract(xeon_phi_dma_desc_memcpy_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_memcpy_co_extract(xeon_phi_dma_desc_memcpy_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0x4) >> 2);
}

static inline void xeon_phi_dma_desc_memcpy_co_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_memcpy_co_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t xeon_phi_dma_desc_memcpy_ecy_extract(xeon_phi_dma_desc_memcpy_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_memcpy_ecy_extract(xeon_phi_dma_desc_memcpy_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0x8) >> 3);
}

static inline void xeon_phi_dma_desc_memcpy_ecy_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_memcpy_ecy_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0xf7) | (0x8 & (_fieldval << 3)));
}

static inline uint8_t xeon_phi_dma_desc_memcpy_dtype_extract(xeon_phi_dma_desc_memcpy_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_memcpy_dtype_extract(xeon_phi_dma_desc_memcpy_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0xf0) >> 4);
}

static inline void xeon_phi_dma_desc_memcpy_dtype_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_memcpy_dtype_insert(xeon_phi_dma_desc_memcpy_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0xf) | (0xf0 & (_fieldval << 4)));
}

static inline int xeon_phi_dma_desc_memcpy_prtval(char *_s, size_t _size, xeon_phi_dma_desc_memcpy_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_desc_memcpy_prtval(char *_s, size_t _size, xeon_phi_dma_desc_memcpy_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " src =\t%" PRIx64 "\t(Source address)\n", xeon_phi_dma_desc_memcpy_src_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " index =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_memcpy_index_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " length =\t%" PRIx16 "\t()\n", xeon_phi_dma_desc_memcpy_length_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dst =\t%" PRIx64 "\t(Destination address)\n", xeon_phi_dma_desc_memcpy_dst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " resd =\t%" PRIx16 "\t()\n", xeon_phi_dma_desc_memcpy_resd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " twb =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_memcpy_twb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " intr =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_memcpy_intr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " c =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_memcpy_c_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_memcpy_co_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ecy =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_memcpy_ecy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dtype =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_memcpy_dtype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: xeon_phi_dma_desc_status_t
 * Description: Status request descritpor type
 * Fields:
 *   data	(size 64, offset 0, init 0):	RW	
 *   dst	(size 40, offset 64, init 0):	RW	
 *   resvdr	(size 19, offset 104, init 0):	RW	
 *   intr	(size 1, offset 123, init 0):	RW	
 *   dtype	(size 4, offset 124, init 0):	RW	
 */
typedef uint8_t *xeon_phi_dma_desc_status_t;
typedef uint8_t xeon_phi_dma_desc_status_array_t[16];
static const size_t xeon_phi_dma_desc_status_size = sizeof(xeon_phi_dma_desc_status_array_t );
static inline uint64_t xeon_phi_dma_desc_status_data_extract(xeon_phi_dma_desc_status_t _dtptr) __attribute__ ((always_inline));
static inline uint64_t xeon_phi_dma_desc_status_data_extract(xeon_phi_dma_desc_status_t _dtptr)
{
    return(((*((uint64_t *)(0 + _dtptr))) & 0xffffffffffffffff) >> 0);
}

static inline void xeon_phi_dma_desc_status_data_insert(xeon_phi_dma_desc_status_t _dtptr, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_status_data_insert(xeon_phi_dma_desc_status_t _dtptr, uint64_t _fieldval)
{
    *((uint64_t *)(0 + _dtptr)) = (((*((uint64_t *)(0 + _dtptr))) & 0x0) | (0xffffffffffffffff & (_fieldval << 0)));
}

static inline uint64_t xeon_phi_dma_desc_status_dst_extract(xeon_phi_dma_desc_status_t _dtptr) __attribute__ ((always_inline));
static inline uint64_t xeon_phi_dma_desc_status_dst_extract(xeon_phi_dma_desc_status_t _dtptr)
{
    return(((*((uint64_t *)(8 + _dtptr))) & 0xffffffffff) >> 0);
}

static inline void xeon_phi_dma_desc_status_dst_insert(xeon_phi_dma_desc_status_t _dtptr, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_status_dst_insert(xeon_phi_dma_desc_status_t _dtptr, uint64_t _fieldval)
{
    *((uint64_t *)(8 + _dtptr)) = (((*((uint64_t *)(8 + _dtptr))) & 0xffffff0000000000) | (0xffffffffff & (_fieldval << 0)));
}

static inline uint32_t xeon_phi_dma_desc_status_resvdr_extract(xeon_phi_dma_desc_status_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_desc_status_resvdr_extract(xeon_phi_dma_desc_status_t _dtptr)
{
    return(((*((uint32_t *)(12 + _dtptr))) & 0x7ffff00) >> 8);
}

static inline void xeon_phi_dma_desc_status_resvdr_insert(xeon_phi_dma_desc_status_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_status_resvdr_insert(xeon_phi_dma_desc_status_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(12 + _dtptr)) = (((*((uint32_t *)(12 + _dtptr))) & 0xf80000ff) | (0x7ffff00 & (_fieldval << 8)));
}

static inline uint8_t xeon_phi_dma_desc_status_intr_extract(xeon_phi_dma_desc_status_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_status_intr_extract(xeon_phi_dma_desc_status_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0x8) >> 3);
}

static inline void xeon_phi_dma_desc_status_intr_insert(xeon_phi_dma_desc_status_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_status_intr_insert(xeon_phi_dma_desc_status_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0xf7) | (0x8 & (_fieldval << 3)));
}

static inline uint8_t xeon_phi_dma_desc_status_dtype_extract(xeon_phi_dma_desc_status_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_status_dtype_extract(xeon_phi_dma_desc_status_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0xf0) >> 4);
}

static inline void xeon_phi_dma_desc_status_dtype_insert(xeon_phi_dma_desc_status_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_status_dtype_insert(xeon_phi_dma_desc_status_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0xf) | (0xf0 & (_fieldval << 4)));
}

static inline int xeon_phi_dma_desc_status_prtval(char *_s, size_t _size, xeon_phi_dma_desc_status_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_desc_status_prtval(char *_s, size_t _size, xeon_phi_dma_desc_status_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx64 "\t()\n", xeon_phi_dma_desc_status_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dst =\t%" PRIx64 "\t()\n", xeon_phi_dma_desc_status_dst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " resvdr =\t%" PRIx32 "\t()\n", xeon_phi_dma_desc_status_resvdr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " intr =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_status_intr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dtype =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_status_dtype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: xeon_phi_dma_desc_general_t
 * Description: General descriptor type
 * Fields:
 *   data	(size 32, offset 0, init 0):	RW	
 *   _anon32	(size 32, offset 32, init 0):	RSVD	_
 *   dst	(size 40, offset 64, init 0):	RW	
 *   _anon104	(size 20, offset 104, init 0):	RSVD	_
 *   dtype	(size 4, offset 124, init 0):	RW	
 */
typedef uint8_t *xeon_phi_dma_desc_general_t;
typedef uint8_t xeon_phi_dma_desc_general_array_t[16];
static const size_t xeon_phi_dma_desc_general_size = sizeof(xeon_phi_dma_desc_general_array_t );
static inline uint32_t xeon_phi_dma_desc_general_data_extract(xeon_phi_dma_desc_general_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_desc_general_data_extract(xeon_phi_dma_desc_general_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void xeon_phi_dma_desc_general_data_insert(xeon_phi_dma_desc_general_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_general_data_insert(xeon_phi_dma_desc_general_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline uint64_t xeon_phi_dma_desc_general_dst_extract(xeon_phi_dma_desc_general_t _dtptr) __attribute__ ((always_inline));
static inline uint64_t xeon_phi_dma_desc_general_dst_extract(xeon_phi_dma_desc_general_t _dtptr)
{
    return(((*((uint64_t *)(8 + _dtptr))) & 0xffffffffff) >> 0);
}

static inline void xeon_phi_dma_desc_general_dst_insert(xeon_phi_dma_desc_general_t _dtptr, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_general_dst_insert(xeon_phi_dma_desc_general_t _dtptr, uint64_t _fieldval)
{
    *((uint64_t *)(8 + _dtptr)) = (((*((uint64_t *)(8 + _dtptr))) & 0xffffff0000000000) | (0xffffffffff & (_fieldval << 0)));
}

static inline uint8_t xeon_phi_dma_desc_general_dtype_extract(xeon_phi_dma_desc_general_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_general_dtype_extract(xeon_phi_dma_desc_general_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0xf0) >> 4);
}

static inline void xeon_phi_dma_desc_general_dtype_insert(xeon_phi_dma_desc_general_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_general_dtype_insert(xeon_phi_dma_desc_general_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0xf) | (0xf0 & (_fieldval << 4)));
}

static inline int xeon_phi_dma_desc_general_prtval(char *_s, size_t _size, xeon_phi_dma_desc_general_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_desc_general_prtval(char *_s, size_t _size, xeon_phi_dma_desc_general_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx32 "\t()\n", xeon_phi_dma_desc_general_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dst =\t%" PRIx64 "\t()\n", xeon_phi_dma_desc_general_dst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dtype =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_general_dtype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: xeon_phi_dma_desc_keynoncecent_t
 * Description: 
 * Fields:
 *   data	(size 64, offset 0, init 0):	RW	
 *   _anon64	(size 53, offset 64, init 0):	RSVD	_
 *   cs	(size 1, offset 117, init 0):	RW	
 *   index	(size 3, offset 118, init 0):	RW	
 *   h	(size 1, offset 121, init 0):	RW	
 *   sel	(size 2, offset 122, init 0):	RW	
 *   dtype	(size 4, offset 124, init 0):	RW	
 */
typedef uint8_t *xeon_phi_dma_desc_keynoncecent_t;
typedef uint8_t xeon_phi_dma_desc_keynoncecent_array_t[16];
static const size_t xeon_phi_dma_desc_keynoncecent_size = sizeof(xeon_phi_dma_desc_keynoncecent_array_t );
static inline uint64_t xeon_phi_dma_desc_keynoncecent_data_extract(xeon_phi_dma_desc_keynoncecent_t _dtptr) __attribute__ ((always_inline));
static inline uint64_t xeon_phi_dma_desc_keynoncecent_data_extract(xeon_phi_dma_desc_keynoncecent_t _dtptr)
{
    return(((*((uint64_t *)(0 + _dtptr))) & 0xffffffffffffffff) >> 0);
}

static inline void xeon_phi_dma_desc_keynoncecent_data_insert(xeon_phi_dma_desc_keynoncecent_t _dtptr, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_keynoncecent_data_insert(xeon_phi_dma_desc_keynoncecent_t _dtptr, uint64_t _fieldval)
{
    *((uint64_t *)(0 + _dtptr)) = (((*((uint64_t *)(0 + _dtptr))) & 0x0) | (0xffffffffffffffff & (_fieldval << 0)));
}

static inline uint8_t xeon_phi_dma_desc_keynoncecent_cs_extract(xeon_phi_dma_desc_keynoncecent_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_keynoncecent_cs_extract(xeon_phi_dma_desc_keynoncecent_t _dtptr)
{
    return(((*((uint8_t *)(14 + _dtptr))) & 0x20) >> 5);
}

static inline void xeon_phi_dma_desc_keynoncecent_cs_insert(xeon_phi_dma_desc_keynoncecent_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_keynoncecent_cs_insert(xeon_phi_dma_desc_keynoncecent_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(14 + _dtptr)) = (((*((uint8_t *)(14 + _dtptr))) & 0xdf) | (0x20 & (_fieldval << 5)));
}

static inline uint8_t xeon_phi_dma_desc_keynoncecent_index_extract(xeon_phi_dma_desc_keynoncecent_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_keynoncecent_index_extract(xeon_phi_dma_desc_keynoncecent_t _dtptr)
{
    return(((*((uint16_t *)(14 + _dtptr))) & 0x1c0) >> 6);
}

static inline void xeon_phi_dma_desc_keynoncecent_index_insert(xeon_phi_dma_desc_keynoncecent_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_keynoncecent_index_insert(xeon_phi_dma_desc_keynoncecent_t _dtptr, uint8_t _fieldval)
{
    *((uint16_t *)(14 + _dtptr)) = (((*((uint16_t *)(14 + _dtptr))) & 0xfe3f) | (0x1c0 & (_fieldval << 6)));
}

static inline uint8_t xeon_phi_dma_desc_keynoncecent_h_extract(xeon_phi_dma_desc_keynoncecent_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_keynoncecent_h_extract(xeon_phi_dma_desc_keynoncecent_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0x2) >> 1);
}

static inline void xeon_phi_dma_desc_keynoncecent_h_insert(xeon_phi_dma_desc_keynoncecent_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_keynoncecent_h_insert(xeon_phi_dma_desc_keynoncecent_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t xeon_phi_dma_desc_keynoncecent_sel_extract(xeon_phi_dma_desc_keynoncecent_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_keynoncecent_sel_extract(xeon_phi_dma_desc_keynoncecent_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0xc) >> 2);
}

static inline void xeon_phi_dma_desc_keynoncecent_sel_insert(xeon_phi_dma_desc_keynoncecent_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_keynoncecent_sel_insert(xeon_phi_dma_desc_keynoncecent_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0xf3) | (0xc & (_fieldval << 2)));
}

static inline uint8_t xeon_phi_dma_desc_keynoncecent_dtype_extract(xeon_phi_dma_desc_keynoncecent_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_keynoncecent_dtype_extract(xeon_phi_dma_desc_keynoncecent_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0xf0) >> 4);
}

static inline void xeon_phi_dma_desc_keynoncecent_dtype_insert(xeon_phi_dma_desc_keynoncecent_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_keynoncecent_dtype_insert(xeon_phi_dma_desc_keynoncecent_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0xf) | (0xf0 & (_fieldval << 4)));
}

static inline int xeon_phi_dma_desc_keynoncecent_prtval(char *_s, size_t _size, xeon_phi_dma_desc_keynoncecent_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_desc_keynoncecent_prtval(char *_s, size_t _size, xeon_phi_dma_desc_keynoncecent_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx64 "\t()\n", xeon_phi_dma_desc_keynoncecent_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cs =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_keynoncecent_cs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " index =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_keynoncecent_index_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " h =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_keynoncecent_h_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sel =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_keynoncecent_sel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dtype =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_keynoncecent_dtype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: xeon_phi_dma_desc_key_t
 * Description: 
 * Fields:
 *   skap	(size 40, offset 0, init 0):	RW	
 *   ski	(size 3, offset 40, init 0):	RW	
 *   _anon43	(size 72, offset 43, init 0):	RSVD	_
 *   di	(size 3, offset 115, init 0):	RW	
 *   _anon118	(size 6, offset 118, init 0):	RSVD	_
 *   dtype	(size 4, offset 124, init 0):	RW	
 */
typedef uint8_t *xeon_phi_dma_desc_key_t;
typedef uint8_t xeon_phi_dma_desc_key_array_t[16];
static const size_t xeon_phi_dma_desc_key_size = sizeof(xeon_phi_dma_desc_key_array_t );
static inline uint64_t xeon_phi_dma_desc_key_skap_extract(xeon_phi_dma_desc_key_t _dtptr) __attribute__ ((always_inline));
static inline uint64_t xeon_phi_dma_desc_key_skap_extract(xeon_phi_dma_desc_key_t _dtptr)
{
    return(((*((uint64_t *)(0 + _dtptr))) & 0xffffffffff) >> 0);
}

static inline void xeon_phi_dma_desc_key_skap_insert(xeon_phi_dma_desc_key_t _dtptr, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_key_skap_insert(xeon_phi_dma_desc_key_t _dtptr, uint64_t _fieldval)
{
    *((uint64_t *)(0 + _dtptr)) = (((*((uint64_t *)(0 + _dtptr))) & 0xffffff0000000000) | (0xffffffffff & (_fieldval << 0)));
}

static inline uint8_t xeon_phi_dma_desc_key_ski_extract(xeon_phi_dma_desc_key_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_key_ski_extract(xeon_phi_dma_desc_key_t _dtptr)
{
    return(((*((uint8_t *)(5 + _dtptr))) & 0x7) >> 0);
}

static inline void xeon_phi_dma_desc_key_ski_insert(xeon_phi_dma_desc_key_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_key_ski_insert(xeon_phi_dma_desc_key_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(5 + _dtptr)) = (((*((uint8_t *)(5 + _dtptr))) & 0xf8) | (0x7 & (_fieldval << 0)));
}

static inline uint8_t xeon_phi_dma_desc_key_di_extract(xeon_phi_dma_desc_key_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_key_di_extract(xeon_phi_dma_desc_key_t _dtptr)
{
    return(((*((uint8_t *)(14 + _dtptr))) & 0x38) >> 3);
}

static inline void xeon_phi_dma_desc_key_di_insert(xeon_phi_dma_desc_key_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_key_di_insert(xeon_phi_dma_desc_key_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(14 + _dtptr)) = (((*((uint8_t *)(14 + _dtptr))) & 0xc7) | (0x38 & (_fieldval << 3)));
}

static inline uint8_t xeon_phi_dma_desc_key_dtype_extract(xeon_phi_dma_desc_key_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_desc_key_dtype_extract(xeon_phi_dma_desc_key_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0xf0) >> 4);
}

static inline void xeon_phi_dma_desc_key_dtype_insert(xeon_phi_dma_desc_key_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_desc_key_dtype_insert(xeon_phi_dma_desc_key_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0xf) | (0xf0 & (_fieldval << 4)));
}

static inline int xeon_phi_dma_desc_key_prtval(char *_s, size_t _size, xeon_phi_dma_desc_key_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_desc_key_prtval(char *_s, size_t _size, xeon_phi_dma_desc_key_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " skap =\t%" PRIx64 "\t()\n", xeon_phi_dma_desc_key_skap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ski =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_key_ski_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " di =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_key_di_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dtype =\t%" PRIx8 "\t()\n", xeon_phi_dma_desc_key_dtype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum xeon_phi_dma_initials {
    xeon_phi_dma_dcar_initial = 0x0,
    xeon_phi_dma_dhpr_initial = 0x0,
    xeon_phi_dma_dtpr_initial = 0x0,
    xeon_phi_dma_aux_lo_initial = 0x0,
    xeon_phi_dma_aux_hi_initial = 0x0,
    xeon_phi_dma_drar_hi_initial = 0x0,
    xeon_phi_dma_drar_lo_initial = 0x0,
    xeon_phi_dma_ditr_initial = 0x0,
    xeon_phi_dma_dstat_initial = 0x0,
    xeon_phi_dma_dstatwb_lo_initial = 0x0,
    xeon_phi_dma_dstatwb_hi_initial = 0x0,
    xeon_phi_dma_dcherr_initial = 0x0,
    xeon_phi_dma_dcherrmsk_initial = 0x0,
    xeon_phi_dma_dcr_initial = 0x0,
    xeon_phi_dma_dqar_initial = 0x0,
    xeon_phi_dma_dqdr_tl_initial = 0x0,
    xeon_phi_dma_dqdr_tr_initial = 0x0,
    xeon_phi_dma_dqdr_bl_initial = 0x0,
    xeon_phi_dma_dqdr_br_initial = 0x0,
    xeon_phi_dma_misc_initial = 0x0,
    xeon_phi_dma_lock_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void xeon_phi_dma_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void xeon_phi_dma_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register array dcar: DMA Channel Attribute Register
 * Type: xeon_phi_dma.dcar (Implicit type of DMA Channel Attribute Register register array)
 *   _anon0	(size 23, offset 0, init 0):	RSVD	_
 *   apic_irq	(size 1, offset 23, init 0):	RW	APIC Interrupt mask bit
 *   msix_irq	(size 1, offset 24, init 0):	RW	MSI-X Interrupt mask bit
 *   irq_status	(size 1, offset 25, init 0):	RW	Interrupt status
 *   _anon26	(size 6, offset 26, init 0):	RSVD	_
 */
static const size_t xeon_phi_dma_dcar_length = 8;
static inline xeon_phi_dma_dcar_t xeon_phi_dma_dcar_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcar_t xeon_phi_dma_dcar_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa000 + (_i * 64)));
}

static inline xeon_phi_dma_dcar_t xeon_phi_dma_dcar_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcar_t xeon_phi_dma_dcar_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa000 + (_i * 64)));
}

static inline void xeon_phi_dma_dcar_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_dcar_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcar_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_dcar_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa000 + (_i * 64), _regval);
}

static inline void xeon_phi_dma_dcar_wr(__DN(t) *_dev, int _i, xeon_phi_dma_dcar_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcar_wr(__DN(t) *_dev, int _i, xeon_phi_dma_dcar_t _regval)
{
    _regval = (_regval & 0x3800000);
    // No MB1 fields present
    _regval = (_regval | (0xfc7fffff & mackerel_read_addr_32(_dev->base, 0xa000 + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0xa000 + (_i * 64), _regval);
}

static inline int xeon_phi_dma_dcar_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dcar_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_dcar_t _regval = mackerel_read_addr_32(_dev->base, 0xa000 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "dcar", _i, "DMA Channel Attribute Register");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apic_irq =\t%" PRIx8 "\t(APIC Interrupt mask bit)\n", xeon_phi_dma_dcar_apic_irq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msix_irq =\t%" PRIx8 "\t(MSI-X Interrupt mask bit)\n", xeon_phi_dma_dcar_msix_irq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " irq_status =\t%" PRIx8 "\t(Interrupt status)\n", xeon_phi_dma_dcar_irq_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    return(_r);
}

static inline int xeon_phi_dma_dcar_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dcar_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_dma_dcar_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t xeon_phi_dma_dcar_apic_irq_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcar_apic_irq_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_dcar_t _regval = mackerel_read_addr_32(_dev->base, 0xa000 + (_i * 64));
    return(xeon_phi_dma_dcar_apic_irq_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcar_msix_irq_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcar_msix_irq_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_dcar_t _regval = mackerel_read_addr_32(_dev->base, 0xa000 + (_i * 64));
    return(xeon_phi_dma_dcar_msix_irq_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcar_irq_status_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcar_irq_status_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_dcar_t _regval = mackerel_read_addr_32(_dev->base, 0xa000 + (_i * 64));
    return(xeon_phi_dma_dcar_irq_status_extract(_regval));
}

static inline void xeon_phi_dma_dcar_apic_irq_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcar_apic_irq_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    xeon_phi_dma_dcar_t _regval = 0x800000 & (((xeon_phi_dma_dcar_t )(_fieldval)) << 23);
    _regval = (_regval | (0xff7fffff & mackerel_read_addr_32(_dev->base, 0xa000 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa000 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcar_msix_irq_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcar_msix_irq_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    xeon_phi_dma_dcar_t _regval = 0x1000000 & (((xeon_phi_dma_dcar_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfeffffff & mackerel_read_addr_32(_dev->base, 0xa000 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa000 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcar_irq_status_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcar_irq_status_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    xeon_phi_dma_dcar_t _regval = 0x2000000 & (((xeon_phi_dma_dcar_t )(_fieldval)) << 25);
    _regval = (_regval | (0xfdffffff & mackerel_read_addr_32(_dev->base, 0xa000 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa000 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array dhpr: DMA Descriptor Head Pointer Register
 * Type: xeon_phi_dma.dhpr (Implicit type of DMA Descriptor Head Pointer Register register array)
 *   index	(size 16, offset 0, init 0):	RW	Index of the head pointer
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static const size_t xeon_phi_dma_dhpr_length = 8;
static inline xeon_phi_dma_dhpr_t xeon_phi_dma_dhpr_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_dhpr_t xeon_phi_dma_dhpr_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa004 + (_i * 64)));
}

static inline xeon_phi_dma_dhpr_t xeon_phi_dma_dhpr_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_dhpr_t xeon_phi_dma_dhpr_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa004 + (_i * 64)));
}

static inline void xeon_phi_dma_dhpr_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_dhpr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dhpr_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_dhpr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa004 + (_i * 64), _regval);
}

static inline void xeon_phi_dma_dhpr_wr(__DN(t) *_dev, int _i, xeon_phi_dma_dhpr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dhpr_wr(__DN(t) *_dev, int _i, xeon_phi_dma_dhpr_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0xa004 + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0xa004 + (_i * 64), _regval);
}

static inline int xeon_phi_dma_dhpr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dhpr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_dhpr_t _regval = mackerel_read_addr_32(_dev->base, 0xa004 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "dhpr", _i, "DMA Descriptor Head Pointer Register");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " index =\t%" PRIx16 "\t(Index of the head pointer)\n", xeon_phi_dma_dhpr_index_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline int xeon_phi_dma_dhpr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dhpr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_dma_dhpr_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t xeon_phi_dma_dhpr_index_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_dhpr_index_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_dhpr_t _regval = mackerel_read_addr_32(_dev->base, 0xa004 + (_i * 64));
    return(xeon_phi_dma_dhpr_index_extract(_regval));
}

static inline void xeon_phi_dma_dhpr_index_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dhpr_index_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    xeon_phi_dma_dhpr_t _regval = 0xffff & (((xeon_phi_dma_dhpr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0xa004 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa004 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array dtpr: DMA Descriptor Tail Pointer Register
 * Type: xeon_phi_dma.dtpr (Implicit type of DMA Descriptor Tail Pointer Register register array)
 *   index	(size 16, offset 0, init 0):	RW	Index of the head pointer
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static const size_t xeon_phi_dma_dtpr_length = 8;
static inline xeon_phi_dma_dtpr_t xeon_phi_dma_dtpr_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_dtpr_t xeon_phi_dma_dtpr_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa008 + (_i * 64)));
}

static inline xeon_phi_dma_dtpr_t xeon_phi_dma_dtpr_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_dtpr_t xeon_phi_dma_dtpr_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa008 + (_i * 64)));
}

static inline void xeon_phi_dma_dtpr_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_dtpr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dtpr_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_dtpr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa008 + (_i * 64), _regval);
}

static inline void xeon_phi_dma_dtpr_wr(__DN(t) *_dev, int _i, xeon_phi_dma_dtpr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dtpr_wr(__DN(t) *_dev, int _i, xeon_phi_dma_dtpr_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0xa008 + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0xa008 + (_i * 64), _regval);
}

static inline int xeon_phi_dma_dtpr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dtpr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_dtpr_t _regval = mackerel_read_addr_32(_dev->base, 0xa008 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "dtpr", _i, "DMA Descriptor Tail Pointer Register");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " index =\t%" PRIx16 "\t(Index of the head pointer)\n", xeon_phi_dma_dtpr_index_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline int xeon_phi_dma_dtpr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dtpr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_dma_dtpr_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t xeon_phi_dma_dtpr_index_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_dtpr_index_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_dtpr_t _regval = mackerel_read_addr_32(_dev->base, 0xa008 + (_i * 64));
    return(xeon_phi_dma_dtpr_index_extract(_regval));
}

static inline void xeon_phi_dma_dtpr_index_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dtpr_index_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    xeon_phi_dma_dtpr_t _regval = 0xffff & (((xeon_phi_dma_dtpr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0xa008 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa008 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array aux_lo: DMA Auxiliary Register 0 Lo
 * Type: xeon_phi_dma.aux_lo (Implicit type of DMA Auxiliary Register 0 Lo register array)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static const size_t xeon_phi_dma_aux_lo_length = 8;
static inline xeon_phi_dma_aux_lo_t xeon_phi_dma_aux_lo_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_aux_lo_t xeon_phi_dma_aux_lo_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa00c + (_i * 64)));
}

static inline xeon_phi_dma_aux_lo_t xeon_phi_dma_aux_lo_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_aux_lo_t xeon_phi_dma_aux_lo_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa00c + (_i * 64)));
}

static inline void xeon_phi_dma_aux_lo_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_aux_lo_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_aux_lo_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_aux_lo_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa00c + (_i * 64), _regval);
}

static inline void xeon_phi_dma_aux_lo_wr(__DN(t) *_dev, int _i, xeon_phi_dma_aux_lo_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_aux_lo_wr(__DN(t) *_dev, int _i, xeon_phi_dma_aux_lo_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa00c + (_i * 64), _regval);
}

static inline int xeon_phi_dma_aux_lo_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_dma_aux_lo_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_aux_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa00c + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "aux_lo", _i, "DMA Auxiliary Register 0 Lo");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_aux_lo_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int xeon_phi_dma_aux_lo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_aux_lo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_dma_aux_lo_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_aux_lo_r_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_aux_lo_r_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_aux_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa00c + (_i * 64));
    return(xeon_phi_dma_aux_lo_r_extract(_regval));
}

static inline void xeon_phi_dma_aux_lo_r_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_aux_lo_r_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    xeon_phi_dma_aux_lo_t _regval = 0xffffffff & (((xeon_phi_dma_aux_lo_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa00c + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array aux_hi: DMA Auxiliary Register 0 Hi
 * Type: xeon_phi_dma.aux_hi (Implicit type of DMA Auxiliary Register 0 Hi register array)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static const size_t xeon_phi_dma_aux_hi_length = 8;
static inline xeon_phi_dma_aux_hi_t xeon_phi_dma_aux_hi_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_aux_hi_t xeon_phi_dma_aux_hi_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa010 + (_i * 64)));
}

static inline xeon_phi_dma_aux_hi_t xeon_phi_dma_aux_hi_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_aux_hi_t xeon_phi_dma_aux_hi_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa010 + (_i * 64)));
}

static inline void xeon_phi_dma_aux_hi_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_aux_hi_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_aux_hi_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_aux_hi_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa010 + (_i * 64), _regval);
}

static inline void xeon_phi_dma_aux_hi_wr(__DN(t) *_dev, int _i, xeon_phi_dma_aux_hi_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_aux_hi_wr(__DN(t) *_dev, int _i, xeon_phi_dma_aux_hi_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa010 + (_i * 64), _regval);
}

static inline int xeon_phi_dma_aux_hi_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_dma_aux_hi_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_aux_hi_t _regval = mackerel_read_addr_32(_dev->base, 0xa010 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "aux_hi", _i, "DMA Auxiliary Register 0 Hi");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_aux_hi_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int xeon_phi_dma_aux_hi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_aux_hi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_dma_aux_hi_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_aux_hi_r_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_aux_hi_r_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_aux_hi_t _regval = mackerel_read_addr_32(_dev->base, 0xa010 + (_i * 64));
    return(xeon_phi_dma_aux_hi_r_extract(_regval));
}

static inline void xeon_phi_dma_aux_hi_r_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_aux_hi_r_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    xeon_phi_dma_aux_hi_t _regval = 0xffffffff & (((xeon_phi_dma_aux_hi_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa010 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array drar_hi: DMA Descriptor Ring Attributes Register Lo
 * Type: xeon_phi_dma.drar_hi (Implicit type of DMA Descriptor Ring Attributes Register Lo register array)
 *   base	(size 4, offset 0, init 0):	RW	base address hi part
 *   _anon4	(size 2, offset 4, init 0):	RSVD	_
 *   size	(size 15, offset 6, init 0):	RW	size of the descriptor ring
 *   page	(size 5, offset 21, init 0):	RW	
 *   sysbit	(size 1, offset 26, init 0):	RW	
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
static const size_t xeon_phi_dma_drar_hi_length = 8;
static inline xeon_phi_dma_drar_hi_t xeon_phi_dma_drar_hi_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_drar_hi_t xeon_phi_dma_drar_hi_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa018 + (_i * 64)));
}

static inline xeon_phi_dma_drar_hi_t xeon_phi_dma_drar_hi_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_drar_hi_t xeon_phi_dma_drar_hi_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa018 + (_i * 64)));
}

static inline void xeon_phi_dma_drar_hi_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_drar_hi_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_drar_hi_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_drar_hi_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa018 + (_i * 64), _regval);
}

static inline void xeon_phi_dma_drar_hi_wr(__DN(t) *_dev, int _i, xeon_phi_dma_drar_hi_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_drar_hi_wr(__DN(t) *_dev, int _i, xeon_phi_dma_drar_hi_t _regval)
{
    _regval = (_regval & 0x7ffffcf);
    // No MB1 fields present
    _regval = (_regval | (0xf8000030 & mackerel_read_addr_32(_dev->base, 0xa018 + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0xa018 + (_i * 64), _regval);
}

static inline int xeon_phi_dma_drar_hi_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_dma_drar_hi_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_drar_hi_t _regval = mackerel_read_addr_32(_dev->base, 0xa018 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "drar_hi", _i, "DMA Descriptor Ring Attributes Register Lo");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " base =\t%" PRIx8 "\t(base address hi part)\n", xeon_phi_dma_drar_hi_base_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx16 "\t(size of the descriptor ring)\n", xeon_phi_dma_drar_hi_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " page =\t%" PRIx8 "\t()\n", xeon_phi_dma_drar_hi_page_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sysbit =\t%" PRIx8 "\t()\n", xeon_phi_dma_drar_hi_sysbit_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon27 is anonymous
    return(_r);
}

static inline int xeon_phi_dma_drar_hi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_drar_hi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_dma_drar_hi_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t xeon_phi_dma_drar_hi_base_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_drar_hi_base_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_drar_hi_t _regval = mackerel_read_addr_32(_dev->base, 0xa018 + (_i * 64));
    return(xeon_phi_dma_drar_hi_base_extract(_regval));
}

static inline uint16_t xeon_phi_dma_drar_hi_size_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_drar_hi_size_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_drar_hi_t _regval = mackerel_read_addr_32(_dev->base, 0xa018 + (_i * 64));
    return(xeon_phi_dma_drar_hi_size_extract(_regval));
}

static inline uint8_t xeon_phi_dma_drar_hi_page_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_drar_hi_page_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_drar_hi_t _regval = mackerel_read_addr_32(_dev->base, 0xa018 + (_i * 64));
    return(xeon_phi_dma_drar_hi_page_extract(_regval));
}

static inline uint8_t xeon_phi_dma_drar_hi_sysbit_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_drar_hi_sysbit_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_drar_hi_t _regval = mackerel_read_addr_32(_dev->base, 0xa018 + (_i * 64));
    return(xeon_phi_dma_drar_hi_sysbit_extract(_regval));
}

static inline void xeon_phi_dma_drar_hi_base_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_drar_hi_base_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    xeon_phi_dma_drar_hi_t _regval = 0xf & (((xeon_phi_dma_drar_hi_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0xa018 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa018 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_drar_hi_size_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_drar_hi_size_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    xeon_phi_dma_drar_hi_t _regval = 0x1fffc0 & (((xeon_phi_dma_drar_hi_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffe0003f & mackerel_read_addr_32(_dev->base, 0xa018 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa018 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_drar_hi_page_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_drar_hi_page_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    xeon_phi_dma_drar_hi_t _regval = 0x3e00000 & (((xeon_phi_dma_drar_hi_t )(_fieldval)) << 21);
    _regval = (_regval | (0xfc1fffff & mackerel_read_addr_32(_dev->base, 0xa018 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa018 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_drar_hi_sysbit_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_drar_hi_sysbit_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    xeon_phi_dma_drar_hi_t _regval = 0x4000000 & (((xeon_phi_dma_drar_hi_t )(_fieldval)) << 26);
    _regval = (_regval | (0xfbffffff & mackerel_read_addr_32(_dev->base, 0xa018 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa018 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array drar_lo: DMA Descriptor Ring Attributes Register Lo
 * Type: xeon_phi_dma.drar_lo (Implicit type of DMA Descriptor Ring Attributes Register Lo register array)
 *   _anon0	(size 6, offset 0, init 0):	RSVD	_
 *   base	(size 26, offset 6, init 0):	RW	base address lo part
 */
static const size_t xeon_phi_dma_drar_lo_length = 8;
static inline xeon_phi_dma_drar_lo_t xeon_phi_dma_drar_lo_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_drar_lo_t xeon_phi_dma_drar_lo_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa014 + (_i * 64)));
}

static inline xeon_phi_dma_drar_lo_t xeon_phi_dma_drar_lo_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_drar_lo_t xeon_phi_dma_drar_lo_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa014 + (_i * 64)));
}

static inline void xeon_phi_dma_drar_lo_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_drar_lo_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_drar_lo_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_drar_lo_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa014 + (_i * 64), _regval);
}

static inline void xeon_phi_dma_drar_lo_wr(__DN(t) *_dev, int _i, xeon_phi_dma_drar_lo_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_drar_lo_wr(__DN(t) *_dev, int _i, xeon_phi_dma_drar_lo_t _regval)
{
    _regval = (_regval & 0xffffffc0);
    // No MB1 fields present
    _regval = (_regval | (0x3f & mackerel_read_addr_32(_dev->base, 0xa014 + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0xa014 + (_i * 64), _regval);
}

static inline int xeon_phi_dma_drar_lo_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_dma_drar_lo_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_drar_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa014 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "drar_lo", _i, "DMA Descriptor Ring Attributes Register Lo");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " base =\t%" PRIx32 "\t(base address lo part)\n", xeon_phi_dma_drar_lo_base_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int xeon_phi_dma_drar_lo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_drar_lo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_dma_drar_lo_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_drar_lo_base_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_drar_lo_base_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_drar_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa014 + (_i * 64));
    return(xeon_phi_dma_drar_lo_base_extract(_regval));
}

static inline void xeon_phi_dma_drar_lo_base_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_drar_lo_base_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    xeon_phi_dma_drar_lo_t _regval = 0xffffffc0 & (((xeon_phi_dma_drar_lo_t )(_fieldval)) << 6);
    _regval = (_regval | (0x3f & mackerel_read_addr_32(_dev->base, 0xa014 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa014 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array ditr: DMA Interrupt Timer Register
 * Type: xeon_phi_dma.ditr (Implicit type of DMA Interrupt Timer Register register array)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static const size_t xeon_phi_dma_ditr_length = 8;
static inline xeon_phi_dma_ditr_t xeon_phi_dma_ditr_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_ditr_t xeon_phi_dma_ditr_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa01c + (_i * 64)));
}

static inline xeon_phi_dma_ditr_t xeon_phi_dma_ditr_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_ditr_t xeon_phi_dma_ditr_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa01c + (_i * 64)));
}

static inline void xeon_phi_dma_ditr_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_ditr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_ditr_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_ditr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa01c + (_i * 64), _regval);
}

static inline void xeon_phi_dma_ditr_wr(__DN(t) *_dev, int _i, xeon_phi_dma_ditr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_ditr_wr(__DN(t) *_dev, int _i, xeon_phi_dma_ditr_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa01c + (_i * 64), _regval);
}

static inline int xeon_phi_dma_ditr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_dma_ditr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_ditr_t _regval = mackerel_read_addr_32(_dev->base, 0xa01c + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ditr", _i, "DMA Interrupt Timer Register");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_ditr_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int xeon_phi_dma_ditr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_ditr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_dma_ditr_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_ditr_r_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_ditr_r_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_ditr_t _regval = mackerel_read_addr_32(_dev->base, 0xa01c + (_i * 64));
    return(xeon_phi_dma_ditr_r_extract(_regval));
}

static inline void xeon_phi_dma_ditr_r_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_ditr_r_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    xeon_phi_dma_ditr_t _regval = 0xffffffff & (((xeon_phi_dma_ditr_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa01c + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array dstat: DMA Status Channel Register
 * Type: xeon_phi_dma.dstat (Implicit type of DMA Status Channel Register register array)
 *   completions	(size 16, offset 0, init 0):	RW	Completition count
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static const size_t xeon_phi_dma_dstat_length = 8;
static inline xeon_phi_dma_dstat_t xeon_phi_dma_dstat_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_dstat_t xeon_phi_dma_dstat_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa020 + (_i * 64)));
}

static inline xeon_phi_dma_dstat_t xeon_phi_dma_dstat_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_dstat_t xeon_phi_dma_dstat_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa020 + (_i * 64)));
}

static inline void xeon_phi_dma_dstat_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_dstat_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dstat_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_dstat_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa020 + (_i * 64), _regval);
}

static inline void xeon_phi_dma_dstat_wr(__DN(t) *_dev, int _i, xeon_phi_dma_dstat_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dstat_wr(__DN(t) *_dev, int _i, xeon_phi_dma_dstat_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0xa020 + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0xa020 + (_i * 64), _regval);
}

static inline int xeon_phi_dma_dstat_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dstat_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_dstat_t _regval = mackerel_read_addr_32(_dev->base, 0xa020 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "dstat", _i, "DMA Status Channel Register");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " completions =\t%" PRIx16 "\t(Completition count)\n", xeon_phi_dma_dstat_completions_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline int xeon_phi_dma_dstat_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dstat_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_dma_dstat_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t xeon_phi_dma_dstat_completions_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_dstat_completions_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_dstat_t _regval = mackerel_read_addr_32(_dev->base, 0xa020 + (_i * 64));
    return(xeon_phi_dma_dstat_completions_extract(_regval));
}

static inline void xeon_phi_dma_dstat_completions_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dstat_completions_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    xeon_phi_dma_dstat_t _regval = 0xffff & (((xeon_phi_dma_dstat_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0xa020 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa020 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array dstatwb_lo: DMA Tail Pointer Write Back Register Lo
 * Type: xeon_phi_dma.dstatwb_lo (Implicit type of DMA Tail Pointer Write Back Register Lo register array)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static const size_t xeon_phi_dma_dstatwb_lo_length = 8;
static inline xeon_phi_dma_dstatwb_lo_t xeon_phi_dma_dstatwb_lo_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_dstatwb_lo_t xeon_phi_dma_dstatwb_lo_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa024 + (_i * 64)));
}

static inline xeon_phi_dma_dstatwb_lo_t xeon_phi_dma_dstatwb_lo_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_dstatwb_lo_t xeon_phi_dma_dstatwb_lo_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa024 + (_i * 64)));
}

static inline void xeon_phi_dma_dstatwb_lo_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_dstatwb_lo_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dstatwb_lo_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_dstatwb_lo_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa024 + (_i * 64), _regval);
}

static inline void xeon_phi_dma_dstatwb_lo_wr(__DN(t) *_dev, int _i, xeon_phi_dma_dstatwb_lo_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dstatwb_lo_wr(__DN(t) *_dev, int _i, xeon_phi_dma_dstatwb_lo_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa024 + (_i * 64), _regval);
}

static inline int xeon_phi_dma_dstatwb_lo_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dstatwb_lo_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_dstatwb_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa024 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "dstatwb_lo", _i, "DMA Tail Pointer Write Back Register Lo");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dstatwb_lo_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int xeon_phi_dma_dstatwb_lo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dstatwb_lo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_dma_dstatwb_lo_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_dstatwb_lo_r_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dstatwb_lo_r_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_dstatwb_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa024 + (_i * 64));
    return(xeon_phi_dma_dstatwb_lo_r_extract(_regval));
}

static inline void xeon_phi_dma_dstatwb_lo_r_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dstatwb_lo_r_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    xeon_phi_dma_dstatwb_lo_t _regval = 0xffffffff & (((xeon_phi_dma_dstatwb_lo_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa024 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array dstatwb_hi: DMA Tail Pointer Write Back Register Hi
 * Type: xeon_phi_dma.dstatwb_hi (Implicit type of DMA Tail Pointer Write Back Register Hi register array)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static const size_t xeon_phi_dma_dstatwb_hi_length = 8;
static inline xeon_phi_dma_dstatwb_hi_t xeon_phi_dma_dstatwb_hi_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_dstatwb_hi_t xeon_phi_dma_dstatwb_hi_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa028 + (_i * 64)));
}

static inline xeon_phi_dma_dstatwb_hi_t xeon_phi_dma_dstatwb_hi_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_dstatwb_hi_t xeon_phi_dma_dstatwb_hi_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa028 + (_i * 64)));
}

static inline void xeon_phi_dma_dstatwb_hi_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_dstatwb_hi_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dstatwb_hi_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_dstatwb_hi_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa028 + (_i * 64), _regval);
}

static inline void xeon_phi_dma_dstatwb_hi_wr(__DN(t) *_dev, int _i, xeon_phi_dma_dstatwb_hi_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dstatwb_hi_wr(__DN(t) *_dev, int _i, xeon_phi_dma_dstatwb_hi_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa028 + (_i * 64), _regval);
}

static inline int xeon_phi_dma_dstatwb_hi_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dstatwb_hi_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_dstatwb_hi_t _regval = mackerel_read_addr_32(_dev->base, 0xa028 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "dstatwb_hi", _i, "DMA Tail Pointer Write Back Register Hi");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dstatwb_hi_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int xeon_phi_dma_dstatwb_hi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dstatwb_hi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_dma_dstatwb_hi_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_dstatwb_hi_r_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dstatwb_hi_r_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_dstatwb_hi_t _regval = mackerel_read_addr_32(_dev->base, 0xa028 + (_i * 64));
    return(xeon_phi_dma_dstatwb_hi_r_extract(_regval));
}

static inline void xeon_phi_dma_dstatwb_hi_r_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dstatwb_hi_r_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    xeon_phi_dma_dstatwb_hi_t _regval = 0xffffffff & (((xeon_phi_dma_dstatwb_hi_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa028 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array dcherr: DMA Channel Error Register
 * Type: xeon_phi_dma.dcherr (Implicit type of DMA Channel Error Register register array)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static const size_t xeon_phi_dma_dcherr_length = 8;
static inline xeon_phi_dma_dcherr_t xeon_phi_dma_dcherr_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcherr_t xeon_phi_dma_dcherr_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa02c + (_i * 64)));
}

static inline xeon_phi_dma_dcherr_t xeon_phi_dma_dcherr_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcherr_t xeon_phi_dma_dcherr_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa02c + (_i * 64)));
}

static inline void xeon_phi_dma_dcherr_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_dcherr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcherr_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_dcherr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa02c + (_i * 64), _regval);
}

static inline void xeon_phi_dma_dcherr_wr(__DN(t) *_dev, int _i, xeon_phi_dma_dcherr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcherr_wr(__DN(t) *_dev, int _i, xeon_phi_dma_dcherr_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa02c + (_i * 64), _regval);
}

static inline int xeon_phi_dma_dcherr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dcherr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_dcherr_t _regval = mackerel_read_addr_32(_dev->base, 0xa02c + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "dcherr", _i, "DMA Channel Error Register");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dcherr_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int xeon_phi_dma_dcherr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dcherr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_dma_dcherr_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_dcherr_r_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dcherr_r_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_dcherr_t _regval = mackerel_read_addr_32(_dev->base, 0xa02c + (_i * 64));
    return(xeon_phi_dma_dcherr_r_extract(_regval));
}

static inline void xeon_phi_dma_dcherr_r_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcherr_r_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    xeon_phi_dma_dcherr_t _regval = 0xffffffff & (((xeon_phi_dma_dcherr_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa02c + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array dcherrmsk: DMA Channel Error Register Mask
 * Type: xeon_phi_dma.dcherrmsk (Implicit type of DMA Channel Error Register Mask register array)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static const size_t xeon_phi_dma_dcherrmsk_length = 8;
static inline xeon_phi_dma_dcherrmsk_t xeon_phi_dma_dcherrmsk_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcherrmsk_t xeon_phi_dma_dcherrmsk_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa030 + (_i * 64)));
}

static inline xeon_phi_dma_dcherrmsk_t xeon_phi_dma_dcherrmsk_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcherrmsk_t xeon_phi_dma_dcherrmsk_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa030 + (_i * 64)));
}

static inline void xeon_phi_dma_dcherrmsk_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_dcherrmsk_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcherrmsk_rawwr(__DN(t) *_dev, int _i, xeon_phi_dma_dcherrmsk_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa030 + (_i * 64), _regval);
}

static inline void xeon_phi_dma_dcherrmsk_wr(__DN(t) *_dev, int _i, xeon_phi_dma_dcherrmsk_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcherrmsk_wr(__DN(t) *_dev, int _i, xeon_phi_dma_dcherrmsk_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa030 + (_i * 64), _regval);
}

static inline int xeon_phi_dma_dcherrmsk_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dcherrmsk_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_dcherrmsk_t _regval = mackerel_read_addr_32(_dev->base, 0xa030 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "dcherrmsk", _i, "DMA Channel Error Register Mask");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dcherrmsk_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int xeon_phi_dma_dcherrmsk_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dcherrmsk_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_dma_dcherrmsk_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_dcherrmsk_r_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dcherrmsk_r_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_dma_dcherrmsk_t _regval = mackerel_read_addr_32(_dev->base, 0xa030 + (_i * 64));
    return(xeon_phi_dma_dcherrmsk_r_extract(_regval));
}

static inline void xeon_phi_dma_dcherrmsk_r_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcherrmsk_r_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    xeon_phi_dma_dcherrmsk_t _regval = 0xffffffff & (((xeon_phi_dma_dcherrmsk_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa030 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register dcr: DMA Configuration Register
 * Type: xeon_phi_dma.dcr (Implicit type of DMA Configuration Register register)
 *   co0	(size 1, offset 0, init 0):	RW	DMA Channel 0 Owner
 *   ce0	(size 1, offset 1, init 0):	RW	DMA Channel 0 Enable
 *   co1	(size 1, offset 2, init 0):	RW	DMA Channel 1 Owner
 *   ce1	(size 1, offset 3, init 0):	RW	DMA Channel 1 Enable
 *   co2	(size 1, offset 4, init 0):	RW	DMA Channel 2 Owner
 *   ce2	(size 1, offset 5, init 0):	RW	DMA Channel 2 Enable
 *   co3	(size 1, offset 6, init 0):	RW	DMA Channel 3 Owner
 *   ce3	(size 1, offset 7, init 0):	RW	DMA Channel 3 Enable
 *   co4	(size 1, offset 8, init 0):	RW	DMA Channel 4 Owner
 *   ce4	(size 1, offset 9, init 0):	RW	DMA Channel 4 Enable
 *   co5	(size 1, offset 10, init 0):	RW	DMA Channel 5 Owner
 *   ce5	(size 1, offset 11, init 0):	RW	DMA Channel 5 Enable
 *   co6	(size 1, offset 12, init 0):	RW	DMA Channel 6 Owner
 *   ce6	(size 1, offset 13, init 0):	RW	DMA Channel 6 Enable
 *   co7	(size 1, offset 14, init 0):	RW	DMA Channel 7 Owner
 *   ce7	(size 1, offset 15, init 0):	RW	DMA Channel 7 Enable
 *   arb_h	(size 8, offset 16, init 0):	RW	Arb H
 *   arb_l	(size 7, offset 24, init 0):	RW	Arb L
 *   p	(size 1, offset 31, init 0):	RW	Priority EN
 */
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa280));
}

static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_dcr_t xeon_phi_dma_dcr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa280));
}

static inline void xeon_phi_dma_dcr_rawwr(__DN(t) *_dev, xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_rawwr(__DN(t) *_dev, xeon_phi_dma_dcr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
}

static inline void xeon_phi_dma_dcr_wr(__DN(t) *_dev, xeon_phi_dma_dcr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_wr(__DN(t) *_dev, xeon_phi_dma_dcr_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
}

static inline int xeon_phi_dma_dcr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dcr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dcr (DMA Configuration Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co0 =\t%" PRIx8 "\t(DMA Channel 0 Owner)\n", xeon_phi_dma_dcr_co0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce0 =\t%" PRIx8 "\t(DMA Channel 0 Enable)\n", xeon_phi_dma_dcr_ce0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co1 =\t%" PRIx8 "\t(DMA Channel 1 Owner)\n", xeon_phi_dma_dcr_co1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce1 =\t%" PRIx8 "\t(DMA Channel 1 Enable)\n", xeon_phi_dma_dcr_ce1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co2 =\t%" PRIx8 "\t(DMA Channel 2 Owner)\n", xeon_phi_dma_dcr_co2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce2 =\t%" PRIx8 "\t(DMA Channel 2 Enable)\n", xeon_phi_dma_dcr_ce2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co3 =\t%" PRIx8 "\t(DMA Channel 3 Owner)\n", xeon_phi_dma_dcr_co3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce3 =\t%" PRIx8 "\t(DMA Channel 3 Enable)\n", xeon_phi_dma_dcr_ce3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co4 =\t%" PRIx8 "\t(DMA Channel 4 Owner)\n", xeon_phi_dma_dcr_co4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce4 =\t%" PRIx8 "\t(DMA Channel 4 Enable)\n", xeon_phi_dma_dcr_ce4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co5 =\t%" PRIx8 "\t(DMA Channel 5 Owner)\n", xeon_phi_dma_dcr_co5_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce5 =\t%" PRIx8 "\t(DMA Channel 5 Enable)\n", xeon_phi_dma_dcr_ce5_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co6 =\t%" PRIx8 "\t(DMA Channel 6 Owner)\n", xeon_phi_dma_dcr_co6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce6 =\t%" PRIx8 "\t(DMA Channel 6 Enable)\n", xeon_phi_dma_dcr_ce6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " co7 =\t%" PRIx8 "\t(DMA Channel 7 Owner)\n", xeon_phi_dma_dcr_co7_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce7 =\t%" PRIx8 "\t(DMA Channel 7 Enable)\n", xeon_phi_dma_dcr_ce7_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arb_h =\t%" PRIx8 "\t(Arb H)\n", xeon_phi_dma_dcr_arb_h_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arb_l =\t%" PRIx8 "\t(Arb L)\n", xeon_phi_dma_dcr_arb_l_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx8 "\t(Priority EN)\n", xeon_phi_dma_dcr_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t xeon_phi_dma_dcr_co0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_co0_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_co0_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_ce0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_ce0_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_ce0_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_co1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_co1_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_co1_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_ce1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_ce1_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_ce1_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_co2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_co2_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_co2_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_ce2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_ce2_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_ce2_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_co3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_co3_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_co3_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_ce3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_ce3_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_ce3_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_co4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_co4_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_co4_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_ce4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_ce4_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_ce4_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_co5_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_co5_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_co5_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_ce5_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_ce5_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_ce5_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_co6_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_co6_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_co6_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_ce6_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_ce6_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_ce6_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_co7_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_co7_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_co7_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_ce7_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_ce7_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_ce7_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_arb_h_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_arb_h_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_arb_h_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_arb_l_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_arb_l_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_arb_l_extract(_regval));
}

static inline uint8_t xeon_phi_dma_dcr_p_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_dcr_p_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0xa280);
    return(xeon_phi_dma_dcr_p_extract(_regval));
}

static inline void xeon_phi_dma_dcr_co0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_co0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x1 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_ce0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_ce0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x2 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_co1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_co1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x4 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_ce1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_ce1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x8 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_co2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_co2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x10 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_ce2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_ce2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x20 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_co3_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_co3_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x40 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_ce3_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_ce3_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x80 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_co4_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_co4_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x100 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffffeff & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_ce4_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_ce4_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x200 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_co5_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_co5_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x400 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfffffbff & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_ce5_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_ce5_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x800 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfffff7ff & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_co6_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_co6_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x1000 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffffefff & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_ce6_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_ce6_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x2000 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffdfff & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_co7_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_co7_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x4000 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffffbfff & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_ce7_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_ce7_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x8000 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_arb_h_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_arb_h_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0xff0000 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 16);
    _regval = (_regval | (0xff00ffff & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_arb_l_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_arb_l_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x7f000000 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 24);
    _regval = (_regval | (0x80ffffff & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_dcr_p_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dcr_p_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_dcr_t _regval = 0x80000000 & (((xeon_phi_dma_dcr_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0xa280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa280, _regval);
    // No shadow register to write to
}

/*
 * Register dqar: Descriptor Queue Access Register
 * Type: xeon_phi_dma.dqar (Implicit type of Descriptor Queue Access Register register)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static inline xeon_phi_dma_dqar_t xeon_phi_dma_dqar_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_dqar_t xeon_phi_dma_dqar_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa284));
}

static inline xeon_phi_dma_dqar_t xeon_phi_dma_dqar_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_dqar_t xeon_phi_dma_dqar_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa284));
}

static inline void xeon_phi_dma_dqar_rawwr(__DN(t) *_dev, xeon_phi_dma_dqar_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dqar_rawwr(__DN(t) *_dev, xeon_phi_dma_dqar_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa284, _regval);
}

static inline void xeon_phi_dma_dqar_wr(__DN(t) *_dev, xeon_phi_dma_dqar_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dqar_wr(__DN(t) *_dev, xeon_phi_dma_dqar_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa284, _regval);
}

static inline int xeon_phi_dma_dqar_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dqar_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_dqar_t _regval = mackerel_read_addr_32(_dev->base, 0xa284);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dqar (Descriptor Queue Access Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dqar_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_dqar_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dqar_r_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dqar_t _regval = mackerel_read_addr_32(_dev->base, 0xa284);
    return(xeon_phi_dma_dqar_r_extract(_regval));
}

static inline void xeon_phi_dma_dqar_r_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dqar_r_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_dma_dqar_t _regval = 0xffffffff & (((xeon_phi_dma_dqar_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa284, _regval);
    // No shadow register to write to
}

/*
 * Register dqdr_tl: Descriptor Queue Data Register Top Left
 * Type: xeon_phi_dma.dqdr_tl (Implicit type of Descriptor Queue Data Register Top Left register)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static inline xeon_phi_dma_dqdr_tl_t xeon_phi_dma_dqdr_tl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_dqdr_tl_t xeon_phi_dma_dqdr_tl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa288));
}

static inline xeon_phi_dma_dqdr_tl_t xeon_phi_dma_dqdr_tl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_dqdr_tl_t xeon_phi_dma_dqdr_tl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa288));
}

static inline void xeon_phi_dma_dqdr_tl_rawwr(__DN(t) *_dev, xeon_phi_dma_dqdr_tl_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dqdr_tl_rawwr(__DN(t) *_dev, xeon_phi_dma_dqdr_tl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa288, _regval);
}

static inline void xeon_phi_dma_dqdr_tl_wr(__DN(t) *_dev, xeon_phi_dma_dqdr_tl_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dqdr_tl_wr(__DN(t) *_dev, xeon_phi_dma_dqdr_tl_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa288, _regval);
}

static inline int xeon_phi_dma_dqdr_tl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dqdr_tl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_dqdr_tl_t _regval = mackerel_read_addr_32(_dev->base, 0xa288);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dqdr_tl (Descriptor Queue Data Register Top Left): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dqdr_tl_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_dqdr_tl_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dqdr_tl_r_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dqdr_tl_t _regval = mackerel_read_addr_32(_dev->base, 0xa288);
    return(xeon_phi_dma_dqdr_tl_r_extract(_regval));
}

static inline void xeon_phi_dma_dqdr_tl_r_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dqdr_tl_r_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_dma_dqdr_tl_t _regval = 0xffffffff & (((xeon_phi_dma_dqdr_tl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa288, _regval);
    // No shadow register to write to
}

/*
 * Register dqdr_tr: Descriptor Queue Data Register Top Right
 * Type: xeon_phi_dma.dqdr_tr (Implicit type of Descriptor Queue Data Register Top Right register)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static inline xeon_phi_dma_dqdr_tr_t xeon_phi_dma_dqdr_tr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_dqdr_tr_t xeon_phi_dma_dqdr_tr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa28c));
}

static inline xeon_phi_dma_dqdr_tr_t xeon_phi_dma_dqdr_tr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_dqdr_tr_t xeon_phi_dma_dqdr_tr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa28c));
}

static inline void xeon_phi_dma_dqdr_tr_rawwr(__DN(t) *_dev, xeon_phi_dma_dqdr_tr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dqdr_tr_rawwr(__DN(t) *_dev, xeon_phi_dma_dqdr_tr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa28c, _regval);
}

static inline void xeon_phi_dma_dqdr_tr_wr(__DN(t) *_dev, xeon_phi_dma_dqdr_tr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dqdr_tr_wr(__DN(t) *_dev, xeon_phi_dma_dqdr_tr_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa28c, _regval);
}

static inline int xeon_phi_dma_dqdr_tr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dqdr_tr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_dqdr_tr_t _regval = mackerel_read_addr_32(_dev->base, 0xa28c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dqdr_tr (Descriptor Queue Data Register Top Right): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dqdr_tr_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_dqdr_tr_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dqdr_tr_r_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dqdr_tr_t _regval = mackerel_read_addr_32(_dev->base, 0xa28c);
    return(xeon_phi_dma_dqdr_tr_r_extract(_regval));
}

static inline void xeon_phi_dma_dqdr_tr_r_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dqdr_tr_r_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_dma_dqdr_tr_t _regval = 0xffffffff & (((xeon_phi_dma_dqdr_tr_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa28c, _regval);
    // No shadow register to write to
}

/*
 * Register dqdr_bl: Descriptor Queue Data Register Bottom Left
 * Type: xeon_phi_dma.dqdr_bl (Implicit type of Descriptor Queue Data Register Bottom Left register)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static inline xeon_phi_dma_dqdr_bl_t xeon_phi_dma_dqdr_bl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_dqdr_bl_t xeon_phi_dma_dqdr_bl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa290));
}

static inline xeon_phi_dma_dqdr_bl_t xeon_phi_dma_dqdr_bl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_dqdr_bl_t xeon_phi_dma_dqdr_bl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa290));
}

static inline void xeon_phi_dma_dqdr_bl_rawwr(__DN(t) *_dev, xeon_phi_dma_dqdr_bl_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dqdr_bl_rawwr(__DN(t) *_dev, xeon_phi_dma_dqdr_bl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa290, _regval);
}

static inline void xeon_phi_dma_dqdr_bl_wr(__DN(t) *_dev, xeon_phi_dma_dqdr_bl_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dqdr_bl_wr(__DN(t) *_dev, xeon_phi_dma_dqdr_bl_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa290, _regval);
}

static inline int xeon_phi_dma_dqdr_bl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dqdr_bl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_dqdr_bl_t _regval = mackerel_read_addr_32(_dev->base, 0xa290);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dqdr_bl (Descriptor Queue Data Register Bottom Left): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dqdr_bl_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_dqdr_bl_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dqdr_bl_r_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dqdr_bl_t _regval = mackerel_read_addr_32(_dev->base, 0xa290);
    return(xeon_phi_dma_dqdr_bl_r_extract(_regval));
}

static inline void xeon_phi_dma_dqdr_bl_r_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dqdr_bl_r_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_dma_dqdr_bl_t _regval = 0xffffffff & (((xeon_phi_dma_dqdr_bl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa290, _regval);
    // No shadow register to write to
}

/*
 * Register dqdr_br: Descriptor Queue Data Register Bottom Right
 * Type: xeon_phi_dma.dqdr_br (Implicit type of Descriptor Queue Data Register Bottom Right register)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static inline xeon_phi_dma_dqdr_br_t xeon_phi_dma_dqdr_br_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_dqdr_br_t xeon_phi_dma_dqdr_br_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa294));
}

static inline xeon_phi_dma_dqdr_br_t xeon_phi_dma_dqdr_br_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_dqdr_br_t xeon_phi_dma_dqdr_br_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa294));
}

static inline void xeon_phi_dma_dqdr_br_rawwr(__DN(t) *_dev, xeon_phi_dma_dqdr_br_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dqdr_br_rawwr(__DN(t) *_dev, xeon_phi_dma_dqdr_br_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa294, _regval);
}

static inline void xeon_phi_dma_dqdr_br_wr(__DN(t) *_dev, xeon_phi_dma_dqdr_br_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dqdr_br_wr(__DN(t) *_dev, xeon_phi_dma_dqdr_br_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa294, _regval);
}

static inline int xeon_phi_dma_dqdr_br_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_dqdr_br_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_dqdr_br_t _regval = mackerel_read_addr_32(_dev->base, 0xa294);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dqdr_br (Descriptor Queue Data Register Bottom Right): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_dqdr_br_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_dqdr_br_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_dqdr_br_r_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_dqdr_br_t _regval = mackerel_read_addr_32(_dev->base, 0xa294);
    return(xeon_phi_dma_dqdr_br_r_extract(_regval));
}

static inline void xeon_phi_dma_dqdr_br_r_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_dqdr_br_r_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_dma_dqdr_br_t _regval = 0xffffffff & (((xeon_phi_dma_dqdr_br_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa294, _regval);
    // No shadow register to write to
}

/*
 * Register misc: Misc DMA Bits
 * Type: xeon_phi_dma.misc (Implicit type of Misc DMA Bits register)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static inline xeon_phi_dma_misc_t xeon_phi_dma_misc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_misc_t xeon_phi_dma_misc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa2a4));
}

static inline xeon_phi_dma_misc_t xeon_phi_dma_misc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_misc_t xeon_phi_dma_misc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa2a4));
}

static inline void xeon_phi_dma_misc_rawwr(__DN(t) *_dev, xeon_phi_dma_misc_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_misc_rawwr(__DN(t) *_dev, xeon_phi_dma_misc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa2a4, _regval);
}

static inline void xeon_phi_dma_misc_wr(__DN(t) *_dev, xeon_phi_dma_misc_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_misc_wr(__DN(t) *_dev, xeon_phi_dma_misc_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa2a4, _regval);
}

static inline int xeon_phi_dma_misc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_misc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_misc_t _regval = mackerel_read_addr_32(_dev->base, 0xa2a4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register misc (Misc DMA Bits): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_misc_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_misc_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_misc_r_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_misc_t _regval = mackerel_read_addr_32(_dev->base, 0xa2a4);
    return(xeon_phi_dma_misc_r_extract(_regval));
}

static inline void xeon_phi_dma_misc_r_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_misc_r_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_dma_misc_t _regval = 0xffffffff & (((xeon_phi_dma_misc_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa2a4, _regval);
    // No shadow register to write to
}

/*
 * Register lock: Master Lock Register
 * Type: xeon_phi_dma.lock (Implicit type of Master Lock Register register)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static inline xeon_phi_dma_lock_t xeon_phi_dma_lock_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_lock_t xeon_phi_dma_lock_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa400));
}

static inline xeon_phi_dma_lock_t xeon_phi_dma_lock_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_lock_t xeon_phi_dma_lock_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa400));
}

static inline void xeon_phi_dma_lock_rawwr(__DN(t) *_dev, xeon_phi_dma_lock_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_lock_rawwr(__DN(t) *_dev, xeon_phi_dma_lock_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa400, _regval);
}

static inline void xeon_phi_dma_lock_wr(__DN(t) *_dev, xeon_phi_dma_lock_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_lock_wr(__DN(t) *_dev, xeon_phi_dma_lock_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa400, _regval);
}

static inline int xeon_phi_dma_lock_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_lock_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_lock_t _regval = mackerel_read_addr_32(_dev->base, 0xa400);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lock (Master Lock Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_lock_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_lock_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_lock_r_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_lock_t _regval = mackerel_read_addr_32(_dev->base, 0xa400);
    return(xeon_phi_dma_lock_r_extract(_regval));
}

static inline void xeon_phi_dma_lock_r_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_lock_r_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_dma_lock_t _regval = 0xffffffff & (((xeon_phi_dma_lock_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa400, _regval);
    // No shadow register to write to
}

static inline int xeon_phi_dma_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device xeon_phi_dma (Intel Xeon Phi DMA System):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_dcar_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_dhpr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_dtpr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_aux_lo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_aux_hi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_drar_hi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_drar_lo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_ditr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_dstat_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_dstatwb_lo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_dstatwb_hi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_dcherr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_dcherrmsk_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_dcr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_dqar_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_dqdr_tl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_dqdr_tr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_dqdr_bl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_dqdr_br_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_misc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_lock_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device xeon_phi_dma\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __xeon_phi_dma_DEV_H
