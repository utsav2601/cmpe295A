#ifndef __xeon_phi_dma_chan_DEV_H
#define __xeon_phi_dma_chan_DEV_H 1
/*
 * DEVICE DEFINITION: Intel Xeon Phi DMA Channel
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) xeon_phi_dma_chan ## _ ## x
/*
 * Constants defn: xeon_phi_dma_chan.drar_shifts (Shift amounts for the field values)
 *  - no width specified
 */
typedef uint8_t xeon_phi_dma_chan_drar_shifts_t;
#define xeon_phi_dma_chan_drar_size_shift ((xeon_phi_dma_chan_drar_shifts_t)0x2)
#define xeon_phi_dma_chan_drar_base_shift ((xeon_phi_dma_chan_drar_shifts_t)0x6)

static inline char *xeon_phi_dma_chan_drar_shifts_describe(xeon_phi_dma_chan_drar_shifts_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_dma_chan_drar_shifts_describe(xeon_phi_dma_chan_drar_shifts_t _e)
{
    switch (_e) {
    case xeon_phi_dma_chan_drar_size_shift:
        return("drar_size_shift: drar_size_shift");
    case xeon_phi_dma_chan_drar_base_shift:
        return("drar_base_shift: drar_base_shift");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_dma_chan_drar_shifts_prtval(char *_s, size_t _size, xeon_phi_dma_chan_drar_shifts_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_drar_shifts_prtval(char *_s, size_t _size, xeon_phi_dma_chan_drar_shifts_t _e)
{
    char *d = xeon_phi_dma_chan_drar_shifts_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_dma_chan_drar_shifts_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: xeon_phi_dma_chan_dcar_t
 * Description: Implicit type of DMA Channel Attribute Register register
 * Fields:
 *   _anon0	(size 23, offset 0, init 0):	RSVD	_
 *   apic_irq	(size 1, offset 23, init 0):	RW	APIC Interrupt mask bit
 *   msix_irq	(size 1, offset 24, init 0):	RW	MSI-X Interrupt mask bit
 *   irq_status	(size 1, offset 25, init 0):	RW	Interrupt status
 *   _anon26	(size 6, offset 26, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_dma_chan_dcar_t;
#define xeon_phi_dma_chan_dcar_default 0x0
static inline uint8_t xeon_phi_dma_chan_dcar_apic_irq_extract(xeon_phi_dma_chan_dcar_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_chan_dcar_apic_irq_extract(xeon_phi_dma_chan_dcar_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline xeon_phi_dma_chan_dcar_t xeon_phi_dma_chan_dcar_apic_irq_insert(xeon_phi_dma_chan_dcar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dcar_t xeon_phi_dma_chan_dcar_apic_irq_insert(xeon_phi_dma_chan_dcar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((xeon_phi_dma_chan_dcar_t )(_fieldval)) << 23)));
}

static inline uint8_t xeon_phi_dma_chan_dcar_msix_irq_extract(xeon_phi_dma_chan_dcar_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_chan_dcar_msix_irq_extract(xeon_phi_dma_chan_dcar_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline xeon_phi_dma_chan_dcar_t xeon_phi_dma_chan_dcar_msix_irq_insert(xeon_phi_dma_chan_dcar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dcar_t xeon_phi_dma_chan_dcar_msix_irq_insert(xeon_phi_dma_chan_dcar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((xeon_phi_dma_chan_dcar_t )(_fieldval)) << 24)));
}

static inline uint8_t xeon_phi_dma_chan_dcar_irq_status_extract(xeon_phi_dma_chan_dcar_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_chan_dcar_irq_status_extract(xeon_phi_dma_chan_dcar_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline xeon_phi_dma_chan_dcar_t xeon_phi_dma_chan_dcar_irq_status_insert(xeon_phi_dma_chan_dcar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dcar_t xeon_phi_dma_chan_dcar_irq_status_insert(xeon_phi_dma_chan_dcar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((xeon_phi_dma_chan_dcar_t )(_fieldval)) << 25)));
}

static inline int xeon_phi_dma_chan_dcar_prtval(char *_s, size_t _size, xeon_phi_dma_chan_dcar_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_dcar_prtval(char *_s, size_t _size, xeon_phi_dma_chan_dcar_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apic_irq =\t%" PRIx8 "\t(APIC Interrupt mask bit)\n", xeon_phi_dma_chan_dcar_apic_irq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msix_irq =\t%" PRIx8 "\t(MSI-X Interrupt mask bit)\n", xeon_phi_dma_chan_dcar_msix_irq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " irq_status =\t%" PRIx8 "\t(Interrupt status)\n", xeon_phi_dma_chan_dcar_irq_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_chan_dhpr_t
 * Description: Implicit type of DMA Descriptor Head Pointer Register register
 * Fields:
 *   index	(size 16, offset 0, init 0):	RW	Index of the head pointer
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_dma_chan_dhpr_t;
#define xeon_phi_dma_chan_dhpr_default 0x0
static inline uint16_t xeon_phi_dma_chan_dhpr_index_extract(xeon_phi_dma_chan_dhpr_t _regval) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_chan_dhpr_index_extract(xeon_phi_dma_chan_dhpr_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline xeon_phi_dma_chan_dhpr_t xeon_phi_dma_chan_dhpr_index_insert(xeon_phi_dma_chan_dhpr_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dhpr_t xeon_phi_dma_chan_dhpr_index_insert(xeon_phi_dma_chan_dhpr_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((xeon_phi_dma_chan_dhpr_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_chan_dhpr_prtval(char *_s, size_t _size, xeon_phi_dma_chan_dhpr_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_dhpr_prtval(char *_s, size_t _size, xeon_phi_dma_chan_dhpr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " index =\t%" PRIx16 "\t(Index of the head pointer)\n", xeon_phi_dma_chan_dhpr_index_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_chan_dtpr_t
 * Description: Implicit type of DMA Descriptor Tail Pointer Register register
 * Fields:
 *   index	(size 16, offset 0, init 0):	RW	Index of the head pointer
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_dma_chan_dtpr_t;
#define xeon_phi_dma_chan_dtpr_default 0x0
static inline uint16_t xeon_phi_dma_chan_dtpr_index_extract(xeon_phi_dma_chan_dtpr_t _regval) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_chan_dtpr_index_extract(xeon_phi_dma_chan_dtpr_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline xeon_phi_dma_chan_dtpr_t xeon_phi_dma_chan_dtpr_index_insert(xeon_phi_dma_chan_dtpr_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dtpr_t xeon_phi_dma_chan_dtpr_index_insert(xeon_phi_dma_chan_dtpr_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((xeon_phi_dma_chan_dtpr_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_chan_dtpr_prtval(char *_s, size_t _size, xeon_phi_dma_chan_dtpr_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_dtpr_prtval(char *_s, size_t _size, xeon_phi_dma_chan_dtpr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " index =\t%" PRIx16 "\t(Index of the head pointer)\n", xeon_phi_dma_chan_dtpr_index_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_chan_aux_lo_t
 * Description: Implicit type of DMA Auxiliary Register 0 Lo register
 * Fields:
 *   r	(size 32, offset 0, init 0):	RW	
 */
typedef uint32_t xeon_phi_dma_chan_aux_lo_t;
#define xeon_phi_dma_chan_aux_lo_default 0x0
static inline uint32_t xeon_phi_dma_chan_aux_lo_r_extract(xeon_phi_dma_chan_aux_lo_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_chan_aux_lo_r_extract(xeon_phi_dma_chan_aux_lo_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_chan_aux_lo_t xeon_phi_dma_chan_aux_lo_r_insert(xeon_phi_dma_chan_aux_lo_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_aux_lo_t xeon_phi_dma_chan_aux_lo_r_insert(xeon_phi_dma_chan_aux_lo_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_chan_aux_lo_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_chan_aux_lo_prtval(char *_s, size_t _size, xeon_phi_dma_chan_aux_lo_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_aux_lo_prtval(char *_s, size_t _size, xeon_phi_dma_chan_aux_lo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_chan_aux_lo_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_chan_aux_hi_t
 * Description: Implicit type of DMA Auxiliary Register 0 Hi register
 * Fields:
 *   r	(size 32, offset 0, init 0):	RW	
 */
typedef uint32_t xeon_phi_dma_chan_aux_hi_t;
#define xeon_phi_dma_chan_aux_hi_default 0x0
static inline uint32_t xeon_phi_dma_chan_aux_hi_r_extract(xeon_phi_dma_chan_aux_hi_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_chan_aux_hi_r_extract(xeon_phi_dma_chan_aux_hi_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_chan_aux_hi_t xeon_phi_dma_chan_aux_hi_r_insert(xeon_phi_dma_chan_aux_hi_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_aux_hi_t xeon_phi_dma_chan_aux_hi_r_insert(xeon_phi_dma_chan_aux_hi_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_chan_aux_hi_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_chan_aux_hi_prtval(char *_s, size_t _size, xeon_phi_dma_chan_aux_hi_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_aux_hi_prtval(char *_s, size_t _size, xeon_phi_dma_chan_aux_hi_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_chan_aux_hi_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_chan_drar_hi_t
 * Description: Implicit type of DMA Descriptor Ring Attributes Register Lo register
 * Fields:
 *   base	(size 4, offset 0, init 0):	RW	base address hi part
 *   _anon4	(size 2, offset 4, init 0):	RSVD	_
 *   size	(size 15, offset 6, init 0):	RW	size of the descriptor ring
 *   page	(size 5, offset 21, init 0):	RW	
 *   sysbit	(size 1, offset 26, init 0):	RW	
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_dma_chan_drar_hi_t;
#define xeon_phi_dma_chan_drar_hi_default 0x0
static inline uint8_t xeon_phi_dma_chan_drar_hi_base_extract(xeon_phi_dma_chan_drar_hi_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_chan_drar_hi_base_extract(xeon_phi_dma_chan_drar_hi_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline xeon_phi_dma_chan_drar_hi_t xeon_phi_dma_chan_drar_hi_base_insert(xeon_phi_dma_chan_drar_hi_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_drar_hi_t xeon_phi_dma_chan_drar_hi_base_insert(xeon_phi_dma_chan_drar_hi_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((xeon_phi_dma_chan_drar_hi_t )(_fieldval)) << 0)));
}

static inline uint16_t xeon_phi_dma_chan_drar_hi_size_extract(xeon_phi_dma_chan_drar_hi_t _regval) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_chan_drar_hi_size_extract(xeon_phi_dma_chan_drar_hi_t _regval)
{
    return((uint16_t )((_regval & 0x1fffc0) >> 6));
}

static inline xeon_phi_dma_chan_drar_hi_t xeon_phi_dma_chan_drar_hi_size_insert(xeon_phi_dma_chan_drar_hi_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_drar_hi_t xeon_phi_dma_chan_drar_hi_size_insert(xeon_phi_dma_chan_drar_hi_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffe0003f) | (0x1fffc0 & (((xeon_phi_dma_chan_drar_hi_t )(_fieldval)) << 6)));
}

static inline uint8_t xeon_phi_dma_chan_drar_hi_page_extract(xeon_phi_dma_chan_drar_hi_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_chan_drar_hi_page_extract(xeon_phi_dma_chan_drar_hi_t _regval)
{
    return((uint8_t )((_regval & 0x3e00000) >> 21));
}

static inline xeon_phi_dma_chan_drar_hi_t xeon_phi_dma_chan_drar_hi_page_insert(xeon_phi_dma_chan_drar_hi_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_drar_hi_t xeon_phi_dma_chan_drar_hi_page_insert(xeon_phi_dma_chan_drar_hi_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfc1fffff) | (0x3e00000 & (((xeon_phi_dma_chan_drar_hi_t )(_fieldval)) << 21)));
}

static inline uint8_t xeon_phi_dma_chan_drar_hi_sysbit_extract(xeon_phi_dma_chan_drar_hi_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_chan_drar_hi_sysbit_extract(xeon_phi_dma_chan_drar_hi_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline xeon_phi_dma_chan_drar_hi_t xeon_phi_dma_chan_drar_hi_sysbit_insert(xeon_phi_dma_chan_drar_hi_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_drar_hi_t xeon_phi_dma_chan_drar_hi_sysbit_insert(xeon_phi_dma_chan_drar_hi_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((xeon_phi_dma_chan_drar_hi_t )(_fieldval)) << 26)));
}

static inline int xeon_phi_dma_chan_drar_hi_prtval(char *_s, size_t _size, xeon_phi_dma_chan_drar_hi_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_drar_hi_prtval(char *_s, size_t _size, xeon_phi_dma_chan_drar_hi_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " base =\t%" PRIx8 "\t(base address hi part)\n", xeon_phi_dma_chan_drar_hi_base_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx16 "\t(size of the descriptor ring)\n", xeon_phi_dma_chan_drar_hi_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " page =\t%" PRIx8 "\t()\n", xeon_phi_dma_chan_drar_hi_page_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sysbit =\t%" PRIx8 "\t()\n", xeon_phi_dma_chan_drar_hi_sysbit_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_chan_drar_lo_t
 * Description: Implicit type of DMA Descriptor Ring Attributes Register Lo register
 * Fields:
 *   _anon0	(size 6, offset 0, init 0):	RSVD	_
 *   base	(size 26, offset 6, init 0):	RW	base address lo part
 */
typedef uint32_t xeon_phi_dma_chan_drar_lo_t;
#define xeon_phi_dma_chan_drar_lo_default 0x0
static inline uint32_t xeon_phi_dma_chan_drar_lo_base_extract(xeon_phi_dma_chan_drar_lo_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_chan_drar_lo_base_extract(xeon_phi_dma_chan_drar_lo_t _regval)
{
    return((uint32_t )((_regval & 0xffffffc0) >> 6));
}

static inline xeon_phi_dma_chan_drar_lo_t xeon_phi_dma_chan_drar_lo_base_insert(xeon_phi_dma_chan_drar_lo_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_drar_lo_t xeon_phi_dma_chan_drar_lo_base_insert(xeon_phi_dma_chan_drar_lo_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x3f) | (0xffffffc0 & (((xeon_phi_dma_chan_drar_lo_t )(_fieldval)) << 6)));
}

static inline int xeon_phi_dma_chan_drar_lo_prtval(char *_s, size_t _size, xeon_phi_dma_chan_drar_lo_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_drar_lo_prtval(char *_s, size_t _size, xeon_phi_dma_chan_drar_lo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " base =\t%" PRIx32 "\t(base address lo part)\n", xeon_phi_dma_chan_drar_lo_base_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_chan_ditr_t
 * Description: Implicit type of DMA Interrupt Timer Register register
 * Fields:
 *   r	(size 32, offset 0, init 0):	RW	
 */
typedef uint32_t xeon_phi_dma_chan_ditr_t;
#define xeon_phi_dma_chan_ditr_default 0x0
static inline uint32_t xeon_phi_dma_chan_ditr_r_extract(xeon_phi_dma_chan_ditr_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_chan_ditr_r_extract(xeon_phi_dma_chan_ditr_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_chan_ditr_t xeon_phi_dma_chan_ditr_r_insert(xeon_phi_dma_chan_ditr_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_ditr_t xeon_phi_dma_chan_ditr_r_insert(xeon_phi_dma_chan_ditr_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_chan_ditr_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_chan_ditr_prtval(char *_s, size_t _size, xeon_phi_dma_chan_ditr_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_ditr_prtval(char *_s, size_t _size, xeon_phi_dma_chan_ditr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_chan_ditr_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_chan_dstat_t
 * Description: Implicit type of DMA Status Channel Register register
 * Fields:
 *   completions	(size 16, offset 0, init 0):	RW	Completition count
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_dma_chan_dstat_t;
#define xeon_phi_dma_chan_dstat_default 0x0
static inline uint16_t xeon_phi_dma_chan_dstat_completions_extract(xeon_phi_dma_chan_dstat_t _regval) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_chan_dstat_completions_extract(xeon_phi_dma_chan_dstat_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline xeon_phi_dma_chan_dstat_t xeon_phi_dma_chan_dstat_completions_insert(xeon_phi_dma_chan_dstat_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dstat_t xeon_phi_dma_chan_dstat_completions_insert(xeon_phi_dma_chan_dstat_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((xeon_phi_dma_chan_dstat_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_chan_dstat_prtval(char *_s, size_t _size, xeon_phi_dma_chan_dstat_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_dstat_prtval(char *_s, size_t _size, xeon_phi_dma_chan_dstat_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " completions =\t%" PRIx16 "\t(Completition count)\n", xeon_phi_dma_chan_dstat_completions_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_chan_dstatwb_lo_t
 * Description: Implicit type of DMA Tail Pointer Write Back Register Lo register
 * Fields:
 *   r	(size 32, offset 0, init 0):	RW	
 */
typedef uint32_t xeon_phi_dma_chan_dstatwb_lo_t;
#define xeon_phi_dma_chan_dstatwb_lo_default 0x0
static inline uint32_t xeon_phi_dma_chan_dstatwb_lo_r_extract(xeon_phi_dma_chan_dstatwb_lo_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_chan_dstatwb_lo_r_extract(xeon_phi_dma_chan_dstatwb_lo_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_chan_dstatwb_lo_t xeon_phi_dma_chan_dstatwb_lo_r_insert(xeon_phi_dma_chan_dstatwb_lo_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dstatwb_lo_t xeon_phi_dma_chan_dstatwb_lo_r_insert(xeon_phi_dma_chan_dstatwb_lo_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_chan_dstatwb_lo_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_chan_dstatwb_lo_prtval(char *_s, size_t _size, xeon_phi_dma_chan_dstatwb_lo_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_dstatwb_lo_prtval(char *_s, size_t _size, xeon_phi_dma_chan_dstatwb_lo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_chan_dstatwb_lo_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_chan_dstatwb_hi_t
 * Description: Implicit type of DMA Tail Pointer Write Back Register Hi register
 * Fields:
 *   r	(size 32, offset 0, init 0):	RW	
 */
typedef uint32_t xeon_phi_dma_chan_dstatwb_hi_t;
#define xeon_phi_dma_chan_dstatwb_hi_default 0x0
static inline uint32_t xeon_phi_dma_chan_dstatwb_hi_r_extract(xeon_phi_dma_chan_dstatwb_hi_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_chan_dstatwb_hi_r_extract(xeon_phi_dma_chan_dstatwb_hi_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_chan_dstatwb_hi_t xeon_phi_dma_chan_dstatwb_hi_r_insert(xeon_phi_dma_chan_dstatwb_hi_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dstatwb_hi_t xeon_phi_dma_chan_dstatwb_hi_r_insert(xeon_phi_dma_chan_dstatwb_hi_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_chan_dstatwb_hi_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_chan_dstatwb_hi_prtval(char *_s, size_t _size, xeon_phi_dma_chan_dstatwb_hi_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_dstatwb_hi_prtval(char *_s, size_t _size, xeon_phi_dma_chan_dstatwb_hi_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_chan_dstatwb_hi_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_chan_dcherr_t
 * Description: Implicit type of DMA Channel Error Register register
 * Fields:
 *   r	(size 32, offset 0, init 0):	RW	
 */
typedef uint32_t xeon_phi_dma_chan_dcherr_t;
#define xeon_phi_dma_chan_dcherr_default 0x0
static inline uint32_t xeon_phi_dma_chan_dcherr_r_extract(xeon_phi_dma_chan_dcherr_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_chan_dcherr_r_extract(xeon_phi_dma_chan_dcherr_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_chan_dcherr_t xeon_phi_dma_chan_dcherr_r_insert(xeon_phi_dma_chan_dcherr_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dcherr_t xeon_phi_dma_chan_dcherr_r_insert(xeon_phi_dma_chan_dcherr_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_chan_dcherr_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_chan_dcherr_prtval(char *_s, size_t _size, xeon_phi_dma_chan_dcherr_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_dcherr_prtval(char *_s, size_t _size, xeon_phi_dma_chan_dcherr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_chan_dcherr_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_dma_chan_dcherrmsk_t
 * Description: Implicit type of DMA Channel Error Register Mask register
 * Fields:
 *   r	(size 32, offset 0, init 0):	RW	
 */
typedef uint32_t xeon_phi_dma_chan_dcherrmsk_t;
#define xeon_phi_dma_chan_dcherrmsk_default 0x0
static inline uint32_t xeon_phi_dma_chan_dcherrmsk_r_extract(xeon_phi_dma_chan_dcherrmsk_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_chan_dcherrmsk_r_extract(xeon_phi_dma_chan_dcherrmsk_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_dma_chan_dcherrmsk_t xeon_phi_dma_chan_dcherrmsk_r_insert(xeon_phi_dma_chan_dcherrmsk_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dcherrmsk_t xeon_phi_dma_chan_dcherrmsk_r_insert(xeon_phi_dma_chan_dcherrmsk_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_dma_chan_dcherrmsk_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_dma_chan_dcherrmsk_prtval(char *_s, size_t _size, xeon_phi_dma_chan_dcherrmsk_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_dcherrmsk_prtval(char *_s, size_t _size, xeon_phi_dma_chan_dcherrmsk_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_chan_dcherrmsk_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum xeon_phi_dma_chan_initials {
    xeon_phi_dma_chan_dcar_initial = 0x0,
    xeon_phi_dma_chan_dhpr_initial = 0x0,
    xeon_phi_dma_chan_dtpr_initial = 0x0,
    xeon_phi_dma_chan_aux_lo_initial = 0x0,
    xeon_phi_dma_chan_aux_hi_initial = 0x0,
    xeon_phi_dma_chan_drar_hi_initial = 0x0,
    xeon_phi_dma_chan_drar_lo_initial = 0x0,
    xeon_phi_dma_chan_ditr_initial = 0x0,
    xeon_phi_dma_chan_dstat_initial = 0x0,
    xeon_phi_dma_chan_dstatwb_lo_initial = 0x0,
    xeon_phi_dma_chan_dstatwb_hi_initial = 0x0,
    xeon_phi_dma_chan_dcherr_initial = 0x0,
    xeon_phi_dma_chan_dcherrmsk_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void xeon_phi_dma_chan_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register dcar: DMA Channel Attribute Register
 * Type: xeon_phi_dma_chan.dcar (Implicit type of DMA Channel Attribute Register register)
 *   _anon0	(size 23, offset 0, init 0):	RSVD	_
 *   apic_irq	(size 1, offset 23, init 0):	RW	APIC Interrupt mask bit
 *   msix_irq	(size 1, offset 24, init 0):	RW	MSI-X Interrupt mask bit
 *   irq_status	(size 1, offset 25, init 0):	RW	Interrupt status
 *   _anon26	(size 6, offset 26, init 0):	RSVD	_
 */
static inline xeon_phi_dma_chan_dcar_t xeon_phi_dma_chan_dcar_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dcar_t xeon_phi_dma_chan_dcar_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline xeon_phi_dma_chan_dcar_t xeon_phi_dma_chan_dcar_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dcar_t xeon_phi_dma_chan_dcar_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void xeon_phi_dma_chan_dcar_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_dcar_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dcar_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_dcar_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline void xeon_phi_dma_chan_dcar_wr(__DN(t) *_dev, xeon_phi_dma_chan_dcar_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dcar_wr(__DN(t) *_dev, xeon_phi_dma_chan_dcar_t _regval)
{
    _regval = (_regval & 0x3800000);
    // No MB1 fields present
    _regval = (_regval | (0xfc7fffff & mackerel_read_addr_32(_dev->base, 0x0)));
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline int xeon_phi_dma_chan_dcar_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_dcar_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_chan_dcar_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dcar (DMA Channel Attribute Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apic_irq =\t%" PRIx8 "\t(APIC Interrupt mask bit)\n", xeon_phi_dma_chan_dcar_apic_irq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msix_irq =\t%" PRIx8 "\t(MSI-X Interrupt mask bit)\n", xeon_phi_dma_chan_dcar_msix_irq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " irq_status =\t%" PRIx8 "\t(Interrupt status)\n", xeon_phi_dma_chan_dcar_irq_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    return(_r);
}

static inline uint8_t xeon_phi_dma_chan_dcar_apic_irq_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_chan_dcar_apic_irq_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_dcar_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(xeon_phi_dma_chan_dcar_apic_irq_extract(_regval));
}

static inline uint8_t xeon_phi_dma_chan_dcar_msix_irq_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_chan_dcar_msix_irq_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_dcar_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(xeon_phi_dma_chan_dcar_msix_irq_extract(_regval));
}

static inline uint8_t xeon_phi_dma_chan_dcar_irq_status_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_chan_dcar_irq_status_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_dcar_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(xeon_phi_dma_chan_dcar_irq_status_extract(_regval));
}

static inline void xeon_phi_dma_chan_dcar_apic_irq_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dcar_apic_irq_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_chan_dcar_t _regval = 0x800000 & (((xeon_phi_dma_chan_dcar_t )(_fieldval)) << 23);
    _regval = (_regval | (0xff7fffff & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_chan_dcar_msix_irq_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dcar_msix_irq_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_chan_dcar_t _regval = 0x1000000 & (((xeon_phi_dma_chan_dcar_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfeffffff & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_chan_dcar_irq_status_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dcar_irq_status_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_chan_dcar_t _regval = 0x2000000 & (((xeon_phi_dma_chan_dcar_t )(_fieldval)) << 25);
    _regval = (_regval | (0xfdffffff & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register dhpr: DMA Descriptor Head Pointer Register
 * Type: xeon_phi_dma_chan.dhpr (Implicit type of DMA Descriptor Head Pointer Register register)
 *   index	(size 16, offset 0, init 0):	RW	Index of the head pointer
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline xeon_phi_dma_chan_dhpr_t xeon_phi_dma_chan_dhpr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dhpr_t xeon_phi_dma_chan_dhpr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline xeon_phi_dma_chan_dhpr_t xeon_phi_dma_chan_dhpr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dhpr_t xeon_phi_dma_chan_dhpr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline void xeon_phi_dma_chan_dhpr_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_dhpr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dhpr_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_dhpr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline void xeon_phi_dma_chan_dhpr_wr(__DN(t) *_dev, xeon_phi_dma_chan_dhpr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dhpr_wr(__DN(t) *_dev, xeon_phi_dma_chan_dhpr_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x4)));
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline int xeon_phi_dma_chan_dhpr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_dhpr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_chan_dhpr_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dhpr (DMA Descriptor Head Pointer Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " index =\t%" PRIx16 "\t(Index of the head pointer)\n", xeon_phi_dma_chan_dhpr_index_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t xeon_phi_dma_chan_dhpr_index_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_chan_dhpr_index_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_dhpr_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(xeon_phi_dma_chan_dhpr_index_extract(_regval));
}

static inline void xeon_phi_dma_chan_dhpr_index_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dhpr_index_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    xeon_phi_dma_chan_dhpr_t _regval = 0xffff & (((xeon_phi_dma_chan_dhpr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

/*
 * Register dtpr: DMA Descriptor Tail Pointer Register
 * Type: xeon_phi_dma_chan.dtpr (Implicit type of DMA Descriptor Tail Pointer Register register)
 *   index	(size 16, offset 0, init 0):	RW	Index of the head pointer
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline xeon_phi_dma_chan_dtpr_t xeon_phi_dma_chan_dtpr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dtpr_t xeon_phi_dma_chan_dtpr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline xeon_phi_dma_chan_dtpr_t xeon_phi_dma_chan_dtpr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dtpr_t xeon_phi_dma_chan_dtpr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void xeon_phi_dma_chan_dtpr_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_dtpr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dtpr_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_dtpr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline void xeon_phi_dma_chan_dtpr_wr(__DN(t) *_dev, xeon_phi_dma_chan_dtpr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dtpr_wr(__DN(t) *_dev, xeon_phi_dma_chan_dtpr_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x8)));
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline int xeon_phi_dma_chan_dtpr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_dtpr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_chan_dtpr_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dtpr (DMA Descriptor Tail Pointer Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " index =\t%" PRIx16 "\t(Index of the head pointer)\n", xeon_phi_dma_chan_dtpr_index_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t xeon_phi_dma_chan_dtpr_index_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_chan_dtpr_index_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_dtpr_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(xeon_phi_dma_chan_dtpr_index_extract(_regval));
}

static inline void xeon_phi_dma_chan_dtpr_index_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dtpr_index_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    xeon_phi_dma_chan_dtpr_t _regval = 0xffff & (((xeon_phi_dma_chan_dtpr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

/*
 * Register aux_lo: DMA Auxiliary Register 0 Lo
 * Type: xeon_phi_dma_chan.aux_lo (Implicit type of DMA Auxiliary Register 0 Lo register)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static inline xeon_phi_dma_chan_aux_lo_t xeon_phi_dma_chan_aux_lo_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_aux_lo_t xeon_phi_dma_chan_aux_lo_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline xeon_phi_dma_chan_aux_lo_t xeon_phi_dma_chan_aux_lo_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_aux_lo_t xeon_phi_dma_chan_aux_lo_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline void xeon_phi_dma_chan_aux_lo_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_aux_lo_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_aux_lo_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_aux_lo_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline void xeon_phi_dma_chan_aux_lo_wr(__DN(t) *_dev, xeon_phi_dma_chan_aux_lo_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_aux_lo_wr(__DN(t) *_dev, xeon_phi_dma_chan_aux_lo_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline int xeon_phi_dma_chan_aux_lo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_aux_lo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_chan_aux_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register aux_lo (DMA Auxiliary Register 0 Lo): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_chan_aux_lo_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_chan_aux_lo_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_chan_aux_lo_r_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_aux_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(xeon_phi_dma_chan_aux_lo_r_extract(_regval));
}

static inline void xeon_phi_dma_chan_aux_lo_r_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_aux_lo_r_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_dma_chan_aux_lo_t _regval = 0xffffffff & (((xeon_phi_dma_chan_aux_lo_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

/*
 * Register aux_hi: DMA Auxiliary Register 0 Hi
 * Type: xeon_phi_dma_chan.aux_hi (Implicit type of DMA Auxiliary Register 0 Hi register)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static inline xeon_phi_dma_chan_aux_hi_t xeon_phi_dma_chan_aux_hi_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_aux_hi_t xeon_phi_dma_chan_aux_hi_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline xeon_phi_dma_chan_aux_hi_t xeon_phi_dma_chan_aux_hi_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_aux_hi_t xeon_phi_dma_chan_aux_hi_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void xeon_phi_dma_chan_aux_hi_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_aux_hi_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_aux_hi_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_aux_hi_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline void xeon_phi_dma_chan_aux_hi_wr(__DN(t) *_dev, xeon_phi_dma_chan_aux_hi_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_aux_hi_wr(__DN(t) *_dev, xeon_phi_dma_chan_aux_hi_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline int xeon_phi_dma_chan_aux_hi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_aux_hi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_chan_aux_hi_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register aux_hi (DMA Auxiliary Register 0 Hi): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_chan_aux_hi_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_chan_aux_hi_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_chan_aux_hi_r_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_aux_hi_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(xeon_phi_dma_chan_aux_hi_r_extract(_regval));
}

static inline void xeon_phi_dma_chan_aux_hi_r_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_aux_hi_r_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_dma_chan_aux_hi_t _regval = 0xffffffff & (((xeon_phi_dma_chan_aux_hi_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register drar_hi: DMA Descriptor Ring Attributes Register Lo
 * Type: xeon_phi_dma_chan.drar_hi (Implicit type of DMA Descriptor Ring Attributes Register Lo register)
 *   base	(size 4, offset 0, init 0):	RW	base address hi part
 *   _anon4	(size 2, offset 4, init 0):	RSVD	_
 *   size	(size 15, offset 6, init 0):	RW	size of the descriptor ring
 *   page	(size 5, offset 21, init 0):	RW	
 *   sysbit	(size 1, offset 26, init 0):	RW	
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
static inline xeon_phi_dma_chan_drar_hi_t xeon_phi_dma_chan_drar_hi_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_drar_hi_t xeon_phi_dma_chan_drar_hi_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline xeon_phi_dma_chan_drar_hi_t xeon_phi_dma_chan_drar_hi_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_drar_hi_t xeon_phi_dma_chan_drar_hi_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline void xeon_phi_dma_chan_drar_hi_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_drar_hi_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_drar_hi_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_drar_hi_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline void xeon_phi_dma_chan_drar_hi_wr(__DN(t) *_dev, xeon_phi_dma_chan_drar_hi_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_drar_hi_wr(__DN(t) *_dev, xeon_phi_dma_chan_drar_hi_t _regval)
{
    _regval = (_regval & 0x7ffffcf);
    // No MB1 fields present
    _regval = (_regval | (0xf8000030 & mackerel_read_addr_32(_dev->base, 0x18)));
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline int xeon_phi_dma_chan_drar_hi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_drar_hi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_chan_drar_hi_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register drar_hi (DMA Descriptor Ring Attributes Register Lo): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " base =\t%" PRIx8 "\t(base address hi part)\n", xeon_phi_dma_chan_drar_hi_base_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx16 "\t(size of the descriptor ring)\n", xeon_phi_dma_chan_drar_hi_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " page =\t%" PRIx8 "\t()\n", xeon_phi_dma_chan_drar_hi_page_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sysbit =\t%" PRIx8 "\t()\n", xeon_phi_dma_chan_drar_hi_sysbit_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon27 is anonymous
    return(_r);
}

static inline uint8_t xeon_phi_dma_chan_drar_hi_base_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_chan_drar_hi_base_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_drar_hi_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(xeon_phi_dma_chan_drar_hi_base_extract(_regval));
}

static inline uint16_t xeon_phi_dma_chan_drar_hi_size_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_chan_drar_hi_size_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_drar_hi_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(xeon_phi_dma_chan_drar_hi_size_extract(_regval));
}

static inline uint8_t xeon_phi_dma_chan_drar_hi_page_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_chan_drar_hi_page_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_drar_hi_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(xeon_phi_dma_chan_drar_hi_page_extract(_regval));
}

static inline uint8_t xeon_phi_dma_chan_drar_hi_sysbit_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_dma_chan_drar_hi_sysbit_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_drar_hi_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(xeon_phi_dma_chan_drar_hi_sysbit_extract(_regval));
}

static inline void xeon_phi_dma_chan_drar_hi_base_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_drar_hi_base_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_chan_drar_hi_t _regval = 0xf & (((xeon_phi_dma_chan_drar_hi_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_chan_drar_hi_size_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_drar_hi_size_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    xeon_phi_dma_chan_drar_hi_t _regval = 0x1fffc0 & (((xeon_phi_dma_chan_drar_hi_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffe0003f & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_chan_drar_hi_page_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_drar_hi_page_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_chan_drar_hi_t _regval = 0x3e00000 & (((xeon_phi_dma_chan_drar_hi_t )(_fieldval)) << 21);
    _regval = (_regval | (0xfc1fffff & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_dma_chan_drar_hi_sysbit_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_drar_hi_sysbit_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_dma_chan_drar_hi_t _regval = 0x4000000 & (((xeon_phi_dma_chan_drar_hi_t )(_fieldval)) << 26);
    _regval = (_regval | (0xfbffffff & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

/*
 * Register drar_lo: DMA Descriptor Ring Attributes Register Lo
 * Type: xeon_phi_dma_chan.drar_lo (Implicit type of DMA Descriptor Ring Attributes Register Lo register)
 *   _anon0	(size 6, offset 0, init 0):	RSVD	_
 *   base	(size 26, offset 6, init 0):	RW	base address lo part
 */
static inline xeon_phi_dma_chan_drar_lo_t xeon_phi_dma_chan_drar_lo_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_drar_lo_t xeon_phi_dma_chan_drar_lo_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline xeon_phi_dma_chan_drar_lo_t xeon_phi_dma_chan_drar_lo_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_drar_lo_t xeon_phi_dma_chan_drar_lo_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline void xeon_phi_dma_chan_drar_lo_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_drar_lo_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_drar_lo_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_drar_lo_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline void xeon_phi_dma_chan_drar_lo_wr(__DN(t) *_dev, xeon_phi_dma_chan_drar_lo_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_drar_lo_wr(__DN(t) *_dev, xeon_phi_dma_chan_drar_lo_t _regval)
{
    _regval = (_regval & 0xffffffc0);
    // No MB1 fields present
    _regval = (_regval | (0x3f & mackerel_read_addr_32(_dev->base, 0x14)));
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline int xeon_phi_dma_chan_drar_lo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_drar_lo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_chan_drar_lo_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register drar_lo (DMA Descriptor Ring Attributes Register Lo): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " base =\t%" PRIx32 "\t(base address lo part)\n", xeon_phi_dma_chan_drar_lo_base_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_chan_drar_lo_base_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_chan_drar_lo_base_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_drar_lo_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(xeon_phi_dma_chan_drar_lo_base_extract(_regval));
}

static inline void xeon_phi_dma_chan_drar_lo_base_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_drar_lo_base_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_dma_chan_drar_lo_t _regval = 0xffffffc0 & (((xeon_phi_dma_chan_drar_lo_t )(_fieldval)) << 6);
    _regval = (_regval | (0x3f & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

/*
 * Register ditr: DMA Interrupt Timer Register
 * Type: xeon_phi_dma_chan.ditr (Implicit type of DMA Interrupt Timer Register register)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static inline xeon_phi_dma_chan_ditr_t xeon_phi_dma_chan_ditr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_ditr_t xeon_phi_dma_chan_ditr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline xeon_phi_dma_chan_ditr_t xeon_phi_dma_chan_ditr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_ditr_t xeon_phi_dma_chan_ditr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline void xeon_phi_dma_chan_ditr_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_ditr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_ditr_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_ditr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

static inline void xeon_phi_dma_chan_ditr_wr(__DN(t) *_dev, xeon_phi_dma_chan_ditr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_ditr_wr(__DN(t) *_dev, xeon_phi_dma_chan_ditr_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

static inline int xeon_phi_dma_chan_ditr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_ditr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_chan_ditr_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ditr (DMA Interrupt Timer Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_chan_ditr_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_chan_ditr_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_chan_ditr_r_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_ditr_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(xeon_phi_dma_chan_ditr_r_extract(_regval));
}

static inline void xeon_phi_dma_chan_ditr_r_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_ditr_r_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_dma_chan_ditr_t _regval = 0xffffffff & (((xeon_phi_dma_chan_ditr_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

/*
 * Register dstat: DMA Status Channel Register
 * Type: xeon_phi_dma_chan.dstat (Implicit type of DMA Status Channel Register register)
 *   completions	(size 16, offset 0, init 0):	RW	Completition count
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline xeon_phi_dma_chan_dstat_t xeon_phi_dma_chan_dstat_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dstat_t xeon_phi_dma_chan_dstat_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline xeon_phi_dma_chan_dstat_t xeon_phi_dma_chan_dstat_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dstat_t xeon_phi_dma_chan_dstat_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline void xeon_phi_dma_chan_dstat_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_dstat_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dstat_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_dstat_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline void xeon_phi_dma_chan_dstat_wr(__DN(t) *_dev, xeon_phi_dma_chan_dstat_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dstat_wr(__DN(t) *_dev, xeon_phi_dma_chan_dstat_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x20)));
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline int xeon_phi_dma_chan_dstat_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_dstat_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_chan_dstat_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dstat (DMA Status Channel Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " completions =\t%" PRIx16 "\t(Completition count)\n", xeon_phi_dma_chan_dstat_completions_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t xeon_phi_dma_chan_dstat_completions_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_dma_chan_dstat_completions_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_dstat_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(xeon_phi_dma_chan_dstat_completions_extract(_regval));
}

static inline void xeon_phi_dma_chan_dstat_completions_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dstat_completions_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    xeon_phi_dma_chan_dstat_t _regval = 0xffff & (((xeon_phi_dma_chan_dstat_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

/*
 * Register dstatwb_lo: DMA Tail Pointer Write Back Register Lo
 * Type: xeon_phi_dma_chan.dstatwb_lo (Implicit type of DMA Tail Pointer Write Back Register Lo register)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static inline xeon_phi_dma_chan_dstatwb_lo_t xeon_phi_dma_chan_dstatwb_lo_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dstatwb_lo_t xeon_phi_dma_chan_dstatwb_lo_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline xeon_phi_dma_chan_dstatwb_lo_t xeon_phi_dma_chan_dstatwb_lo_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dstatwb_lo_t xeon_phi_dma_chan_dstatwb_lo_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline void xeon_phi_dma_chan_dstatwb_lo_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_dstatwb_lo_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dstatwb_lo_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_dstatwb_lo_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline void xeon_phi_dma_chan_dstatwb_lo_wr(__DN(t) *_dev, xeon_phi_dma_chan_dstatwb_lo_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dstatwb_lo_wr(__DN(t) *_dev, xeon_phi_dma_chan_dstatwb_lo_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline int xeon_phi_dma_chan_dstatwb_lo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_dstatwb_lo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_chan_dstatwb_lo_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dstatwb_lo (DMA Tail Pointer Write Back Register Lo): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_chan_dstatwb_lo_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_chan_dstatwb_lo_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_chan_dstatwb_lo_r_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_dstatwb_lo_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(xeon_phi_dma_chan_dstatwb_lo_r_extract(_regval));
}

static inline void xeon_phi_dma_chan_dstatwb_lo_r_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dstatwb_lo_r_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_dma_chan_dstatwb_lo_t _regval = 0xffffffff & (((xeon_phi_dma_chan_dstatwb_lo_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

/*
 * Register dstatwb_hi: DMA Tail Pointer Write Back Register Hi
 * Type: xeon_phi_dma_chan.dstatwb_hi (Implicit type of DMA Tail Pointer Write Back Register Hi register)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static inline xeon_phi_dma_chan_dstatwb_hi_t xeon_phi_dma_chan_dstatwb_hi_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dstatwb_hi_t xeon_phi_dma_chan_dstatwb_hi_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline xeon_phi_dma_chan_dstatwb_hi_t xeon_phi_dma_chan_dstatwb_hi_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dstatwb_hi_t xeon_phi_dma_chan_dstatwb_hi_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline void xeon_phi_dma_chan_dstatwb_hi_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_dstatwb_hi_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dstatwb_hi_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_dstatwb_hi_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline void xeon_phi_dma_chan_dstatwb_hi_wr(__DN(t) *_dev, xeon_phi_dma_chan_dstatwb_hi_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dstatwb_hi_wr(__DN(t) *_dev, xeon_phi_dma_chan_dstatwb_hi_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline int xeon_phi_dma_chan_dstatwb_hi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_dstatwb_hi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_chan_dstatwb_hi_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dstatwb_hi (DMA Tail Pointer Write Back Register Hi): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_chan_dstatwb_hi_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_chan_dstatwb_hi_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_chan_dstatwb_hi_r_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_dstatwb_hi_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(xeon_phi_dma_chan_dstatwb_hi_r_extract(_regval));
}

static inline void xeon_phi_dma_chan_dstatwb_hi_r_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dstatwb_hi_r_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_dma_chan_dstatwb_hi_t _regval = 0xffffffff & (((xeon_phi_dma_chan_dstatwb_hi_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

/*
 * Register dcherr: DMA Channel Error Register
 * Type: xeon_phi_dma_chan.dcherr (Implicit type of DMA Channel Error Register register)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static inline xeon_phi_dma_chan_dcherr_t xeon_phi_dma_chan_dcherr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dcherr_t xeon_phi_dma_chan_dcherr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline xeon_phi_dma_chan_dcherr_t xeon_phi_dma_chan_dcherr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dcherr_t xeon_phi_dma_chan_dcherr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline void xeon_phi_dma_chan_dcherr_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_dcherr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dcherr_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_dcherr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline void xeon_phi_dma_chan_dcherr_wr(__DN(t) *_dev, xeon_phi_dma_chan_dcherr_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dcherr_wr(__DN(t) *_dev, xeon_phi_dma_chan_dcherr_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline int xeon_phi_dma_chan_dcherr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_dcherr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_chan_dcherr_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dcherr (DMA Channel Error Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_chan_dcherr_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_chan_dcherr_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_chan_dcherr_r_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_dcherr_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(xeon_phi_dma_chan_dcherr_r_extract(_regval));
}

static inline void xeon_phi_dma_chan_dcherr_r_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dcherr_r_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_dma_chan_dcherr_t _regval = 0xffffffff & (((xeon_phi_dma_chan_dcherr_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

/*
 * Register dcherrmsk: DMA Channel Error Register Mask
 * Type: xeon_phi_dma_chan.dcherrmsk (Implicit type of DMA Channel Error Register Mask register)
 *   r	(size 32, offset 0, init 0):	RW	
 */
static inline xeon_phi_dma_chan_dcherrmsk_t xeon_phi_dma_chan_dcherrmsk_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dcherrmsk_t xeon_phi_dma_chan_dcherrmsk_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline xeon_phi_dma_chan_dcherrmsk_t xeon_phi_dma_chan_dcherrmsk_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_dma_chan_dcherrmsk_t xeon_phi_dma_chan_dcherrmsk_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline void xeon_phi_dma_chan_dcherrmsk_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_dcherrmsk_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dcherrmsk_rawwr(__DN(t) *_dev, xeon_phi_dma_chan_dcherrmsk_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline void xeon_phi_dma_chan_dcherrmsk_wr(__DN(t) *_dev, xeon_phi_dma_chan_dcherrmsk_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dcherrmsk_wr(__DN(t) *_dev, xeon_phi_dma_chan_dcherrmsk_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline int xeon_phi_dma_chan_dcherrmsk_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_dcherrmsk_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_dma_chan_dcherrmsk_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dcherrmsk (DMA Channel Error Register Mask): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx32 "\t()\n", xeon_phi_dma_chan_dcherrmsk_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_dma_chan_dcherrmsk_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_dma_chan_dcherrmsk_r_rdf(__DN(t) *_dev)
{
    xeon_phi_dma_chan_dcherrmsk_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(xeon_phi_dma_chan_dcherrmsk_r_extract(_regval));
}

static inline void xeon_phi_dma_chan_dcherrmsk_r_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_dma_chan_dcherrmsk_r_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_dma_chan_dcherrmsk_t _regval = 0xffffffff & (((xeon_phi_dma_chan_dcherrmsk_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline int xeon_phi_dma_chan_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_dma_chan_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device xeon_phi_dma_chan (Intel Xeon Phi DMA Channel):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_chan_dcar_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_chan_dhpr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_chan_dtpr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_chan_aux_lo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_chan_aux_hi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_chan_drar_hi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_chan_drar_lo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_chan_ditr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_chan_dstat_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_chan_dstatwb_lo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_chan_dstatwb_hi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_chan_dcherr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_dma_chan_dcherrmsk_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device xeon_phi_dma_chan\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __xeon_phi_dma_chan_DEV_H
