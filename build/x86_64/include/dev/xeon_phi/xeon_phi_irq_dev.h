#ifndef __xeon_phi_irq_DEV_H
#define __xeon_phi_irq_DEV_H 1
/*
 * DEVICE DEFINITION: Intel Xeon Phi Interrupts
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) xeon_phi_irq ## _ ## x
/*
 * Constants defn: xeon_phi_irq.int_en ()
 *  - no width specified
 */
typedef uint8_t xeon_phi_irq_int_en_t;
#define xeon_phi_irq_dbr_enable_all ((xeon_phi_irq_int_en_t)0xf)
#define xeon_phi_irq_dma_enable_all ((xeon_phi_irq_int_en_t)0xff)

static inline char *xeon_phi_irq_int_en_describe(xeon_phi_irq_int_en_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_irq_int_en_describe(xeon_phi_irq_int_en_t _e)
{
    switch (_e) {
    case xeon_phi_irq_dbr_enable_all:
        return("dbr_enable_all: dbr_enable_all");
    case xeon_phi_irq_dma_enable_all:
        return("dma_enable_all: dma_enable_all");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_irq_int_en_prtval(char *_s, size_t _size, xeon_phi_irq_int_en_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_irq_int_en_prtval(char *_s, size_t _size, xeon_phi_irq_int_en_t _e)
{
    char *d = xeon_phi_irq_int_en_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_irq_int_en_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: xeon_phi_irq_doorbel_t
 * Description: Implicit type of System Doorbell Interrupt Command Registe 0-3 register array
 * Fields:
 *   value	(size 32, offset 0, init 0):	NOATTR	Value
 */
typedef uint32_t xeon_phi_irq_doorbel_t;
#define xeon_phi_irq_doorbel_default 0x0
static inline uint32_t xeon_phi_irq_doorbel_value_extract(xeon_phi_irq_doorbel_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_doorbel_value_extract(xeon_phi_irq_doorbel_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_irq_doorbel_t xeon_phi_irq_doorbel_value_insert(xeon_phi_irq_doorbel_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_irq_doorbel_t xeon_phi_irq_doorbel_value_insert(xeon_phi_irq_doorbel_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_irq_doorbel_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_irq_doorbel_prtval(char *_s, size_t _size, xeon_phi_irq_doorbel_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_irq_doorbel_prtval(char *_s, size_t _size, xeon_phi_irq_doorbel_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " value =\t%" PRIx32 "\t(Value)\n", xeon_phi_irq_doorbel_value_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_irq_marker_message_disable_t
 * Description: Implicit type of 32 Bits to Disable Interrupts register
 * Fields:
 *   value	(size 32, offset 0, init 0):	RW	Value
 */
typedef uint32_t xeon_phi_irq_marker_message_disable_t;
#define xeon_phi_irq_marker_message_disable_default 0x0
static inline uint32_t xeon_phi_irq_marker_message_disable_value_extract(xeon_phi_irq_marker_message_disable_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_marker_message_disable_value_extract(xeon_phi_irq_marker_message_disable_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_irq_marker_message_disable_t xeon_phi_irq_marker_message_disable_value_insert(xeon_phi_irq_marker_message_disable_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_irq_marker_message_disable_t xeon_phi_irq_marker_message_disable_value_insert(xeon_phi_irq_marker_message_disable_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_irq_marker_message_disable_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_irq_marker_message_disable_prtval(char *_s, size_t _size, xeon_phi_irq_marker_message_disable_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_irq_marker_message_disable_prtval(char *_s, size_t _size, xeon_phi_irq_marker_message_disable_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " value =\t%" PRIx32 "\t(Value)\n", xeon_phi_irq_marker_message_disable_value_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_irq_marker_message_assert_t
 * Description: Implicit type of 32 Bits to Assert Interrupts register
 * Fields:
 *   value	(size 32, offset 0, init 0):	RW	Value
 */
typedef uint32_t xeon_phi_irq_marker_message_assert_t;
#define xeon_phi_irq_marker_message_assert_default 0x0
static inline uint32_t xeon_phi_irq_marker_message_assert_value_extract(xeon_phi_irq_marker_message_assert_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_marker_message_assert_value_extract(xeon_phi_irq_marker_message_assert_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_irq_marker_message_assert_t xeon_phi_irq_marker_message_assert_value_insert(xeon_phi_irq_marker_message_assert_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_irq_marker_message_assert_t xeon_phi_irq_marker_message_assert_value_insert(xeon_phi_irq_marker_message_assert_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_irq_marker_message_assert_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_irq_marker_message_assert_prtval(char *_s, size_t _size, xeon_phi_irq_marker_message_assert_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_irq_marker_message_assert_prtval(char *_s, size_t _size, xeon_phi_irq_marker_message_assert_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " value =\t%" PRIx32 "\t(Value)\n", xeon_phi_irq_marker_message_assert_value_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_irq_marker_message_send_t
 * Description: Implicit type of 32 Bits to log INTSCR field of Marker Message register
 * Fields:
 *   value	(size 32, offset 0, init 0):	RW	Value
 */
typedef uint32_t xeon_phi_irq_marker_message_send_t;
#define xeon_phi_irq_marker_message_send_default 0x0
static inline uint32_t xeon_phi_irq_marker_message_send_value_extract(xeon_phi_irq_marker_message_send_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_marker_message_send_value_extract(xeon_phi_irq_marker_message_send_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_irq_marker_message_send_t xeon_phi_irq_marker_message_send_value_insert(xeon_phi_irq_marker_message_send_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_irq_marker_message_send_t xeon_phi_irq_marker_message_send_value_insert(xeon_phi_irq_marker_message_send_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_irq_marker_message_send_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_irq_marker_message_send_prtval(char *_s, size_t _size, xeon_phi_irq_marker_message_send_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_irq_marker_message_send_prtval(char *_s, size_t _size, xeon_phi_irq_marker_message_send_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " value =\t%" PRIx32 "\t(Value)\n", xeon_phi_irq_marker_message_send_value_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_irq_msix_ram_t
 * Description: Implicit type of MSI-X RAM register
 * Fields:
 *   reg	(size 32, offset 0, init 0):	RW	register
 */
typedef uint32_t xeon_phi_irq_msix_ram_t;
#define xeon_phi_irq_msix_ram_default 0x0
static inline uint32_t xeon_phi_irq_msix_ram_reg_extract(xeon_phi_irq_msix_ram_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_msix_ram_reg_extract(xeon_phi_irq_msix_ram_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_irq_msix_ram_t xeon_phi_irq_msix_ram_reg_insert(xeon_phi_irq_msix_ram_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_irq_msix_ram_t xeon_phi_irq_msix_ram_reg_insert(xeon_phi_irq_msix_ram_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_irq_msix_ram_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_irq_msix_ram_prtval(char *_s, size_t _size, xeon_phi_irq_msix_ram_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_irq_msix_ram_prtval(char *_s, size_t _size, xeon_phi_irq_msix_ram_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(register)\n", xeon_phi_irq_msix_ram_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_irq_sysint_debug_t
 * Description: Implicit type of SYSINT Debug Register register
 * Fields:
 *   reg	(size 32, offset 0, init 0):	RW	register
 */
typedef uint32_t xeon_phi_irq_sysint_debug_t;
#define xeon_phi_irq_sysint_debug_default 0x0
static inline uint32_t xeon_phi_irq_sysint_debug_reg_extract(xeon_phi_irq_sysint_debug_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_sysint_debug_reg_extract(xeon_phi_irq_sysint_debug_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_irq_sysint_debug_t xeon_phi_irq_sysint_debug_reg_insert(xeon_phi_irq_sysint_debug_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_irq_sysint_debug_t xeon_phi_irq_sysint_debug_reg_insert(xeon_phi_irq_sysint_debug_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_irq_sysint_debug_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_irq_sysint_debug_prtval(char *_s, size_t _size, xeon_phi_irq_sysint_debug_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_irq_sysint_debug_prtval(char *_s, size_t _size, xeon_phi_irq_sysint_debug_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(register)\n", xeon_phi_irq_sysint_debug_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_irq_int_status_t
 * Description: Implicit type of System Interrupt Status Register register
 * Fields:
 *   reg	(size 32, offset 0, init 0):	RW	registr3
 */
typedef uint32_t xeon_phi_irq_int_status_t;
#define xeon_phi_irq_int_status_default 0x0
static inline uint32_t xeon_phi_irq_int_status_reg_extract(xeon_phi_irq_int_status_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_int_status_reg_extract(xeon_phi_irq_int_status_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_irq_int_status_t xeon_phi_irq_int_status_reg_insert(xeon_phi_irq_int_status_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_status_t xeon_phi_irq_int_status_reg_insert(xeon_phi_irq_int_status_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_irq_int_status_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_irq_int_status_prtval(char *_s, size_t _size, xeon_phi_irq_int_status_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_irq_int_status_prtval(char *_s, size_t _size, xeon_phi_irq_int_status_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(registr3)\n", xeon_phi_irq_int_status_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_irq_int_status_set_t
 * Description: Implicit type of System Interrupt Status Set Register register
 * Fields:
 *   reg	(size 32, offset 0, init 0):	RW	register
 */
typedef uint32_t xeon_phi_irq_int_status_set_t;
#define xeon_phi_irq_int_status_set_default 0x0
static inline uint32_t xeon_phi_irq_int_status_set_reg_extract(xeon_phi_irq_int_status_set_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_int_status_set_reg_extract(xeon_phi_irq_int_status_set_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_irq_int_status_set_t xeon_phi_irq_int_status_set_reg_insert(xeon_phi_irq_int_status_set_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_status_set_t xeon_phi_irq_int_status_set_reg_insert(xeon_phi_irq_int_status_set_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_irq_int_status_set_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_irq_int_status_set_prtval(char *_s, size_t _size, xeon_phi_irq_int_status_set_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_irq_int_status_set_prtval(char *_s, size_t _size, xeon_phi_irq_int_status_set_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(register)\n", xeon_phi_irq_int_status_set_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_irq_int_enable_t
 * Description: Implicit type of System Interrupt Enable Register register
 * Fields:
 *   dbr	(size 4, offset 0, init 0):	RW	
 *   _anon4	(size 4, offset 4, init 0):	RSVD	_
 *   dma	(size 8, offset 8, init 0):	RW	
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_irq_int_enable_t;
#define xeon_phi_irq_int_enable_default 0x0
static inline uint8_t xeon_phi_irq_int_enable_dbr_extract(xeon_phi_irq_int_enable_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_irq_int_enable_dbr_extract(xeon_phi_irq_int_enable_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline xeon_phi_irq_int_enable_t xeon_phi_irq_int_enable_dbr_insert(xeon_phi_irq_int_enable_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_enable_t xeon_phi_irq_int_enable_dbr_insert(xeon_phi_irq_int_enable_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((xeon_phi_irq_int_enable_t )(_fieldval)) << 0)));
}

static inline uint8_t xeon_phi_irq_int_enable_dma_extract(xeon_phi_irq_int_enable_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_irq_int_enable_dma_extract(xeon_phi_irq_int_enable_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline xeon_phi_irq_int_enable_t xeon_phi_irq_int_enable_dma_insert(xeon_phi_irq_int_enable_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_enable_t xeon_phi_irq_int_enable_dma_insert(xeon_phi_irq_int_enable_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((xeon_phi_irq_int_enable_t )(_fieldval)) << 8)));
}

static inline int xeon_phi_irq_int_enable_prtval(char *_s, size_t _size, xeon_phi_irq_int_enable_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_irq_int_enable_prtval(char *_s, size_t _size, xeon_phi_irq_int_enable_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dbr =\t%" PRIx8 "\t()\n", xeon_phi_irq_int_enable_dbr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma =\t%" PRIx8 "\t()\n", xeon_phi_irq_int_enable_dma_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_irq_int_disable_t
 * Description: Implicit type of System Interrupt Disable register
 * Fields:
 *   dbr	(size 4, offset 0, init 0):	RW	
 *   _anon4	(size 4, offset 4, init 0):	RSVD	_
 *   dma	(size 8, offset 8, init 0):	RW	
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_irq_int_disable_t;
#define xeon_phi_irq_int_disable_default 0x0
static inline uint8_t xeon_phi_irq_int_disable_dbr_extract(xeon_phi_irq_int_disable_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_irq_int_disable_dbr_extract(xeon_phi_irq_int_disable_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline xeon_phi_irq_int_disable_t xeon_phi_irq_int_disable_dbr_insert(xeon_phi_irq_int_disable_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_disable_t xeon_phi_irq_int_disable_dbr_insert(xeon_phi_irq_int_disable_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((xeon_phi_irq_int_disable_t )(_fieldval)) << 0)));
}

static inline uint8_t xeon_phi_irq_int_disable_dma_extract(xeon_phi_irq_int_disable_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_irq_int_disable_dma_extract(xeon_phi_irq_int_disable_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline xeon_phi_irq_int_disable_t xeon_phi_irq_int_disable_dma_insert(xeon_phi_irq_int_disable_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_disable_t xeon_phi_irq_int_disable_dma_insert(xeon_phi_irq_int_disable_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((xeon_phi_irq_int_disable_t )(_fieldval)) << 8)));
}

static inline int xeon_phi_irq_int_disable_prtval(char *_s, size_t _size, xeon_phi_irq_int_disable_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_irq_int_disable_prtval(char *_s, size_t _size, xeon_phi_irq_int_disable_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dbr =\t%" PRIx8 "\t()\n", xeon_phi_irq_int_disable_dbr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma =\t%" PRIx8 "\t()\n", xeon_phi_irq_int_disable_dma_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_irq_int_status_auto_clear_t
 * Description: Implicit type of System Interrupt Status Auto-Clear register
 * Fields:
 *   reg	(size 32, offset 0, init 0):	RW	ff
 */
typedef uint32_t xeon_phi_irq_int_status_auto_clear_t;
#define xeon_phi_irq_int_status_auto_clear_default 0x0
static inline uint32_t xeon_phi_irq_int_status_auto_clear_reg_extract(xeon_phi_irq_int_status_auto_clear_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_int_status_auto_clear_reg_extract(xeon_phi_irq_int_status_auto_clear_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_irq_int_status_auto_clear_t xeon_phi_irq_int_status_auto_clear_reg_insert(xeon_phi_irq_int_status_auto_clear_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_status_auto_clear_t xeon_phi_irq_int_status_auto_clear_reg_insert(xeon_phi_irq_int_status_auto_clear_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_irq_int_status_auto_clear_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_irq_int_status_auto_clear_prtval(char *_s, size_t _size, xeon_phi_irq_int_status_auto_clear_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_irq_int_status_auto_clear_prtval(char *_s, size_t _size, xeon_phi_irq_int_status_auto_clear_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(ff)\n", xeon_phi_irq_int_status_auto_clear_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_irq_itp_doorbell_t
 * Description: Implicit type of System Interrupt ITP Doorbell register
 * Fields:
 *   reg	(size 32, offset 0, init 0):	RW	ff
 */
typedef uint32_t xeon_phi_irq_itp_doorbell_t;
#define xeon_phi_irq_itp_doorbell_default 0x0
static inline uint32_t xeon_phi_irq_itp_doorbell_reg_extract(xeon_phi_irq_itp_doorbell_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_itp_doorbell_reg_extract(xeon_phi_irq_itp_doorbell_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_irq_itp_doorbell_t xeon_phi_irq_itp_doorbell_reg_insert(xeon_phi_irq_itp_doorbell_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_irq_itp_doorbell_t xeon_phi_irq_itp_doorbell_reg_insert(xeon_phi_irq_itp_doorbell_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_irq_itp_doorbell_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_irq_itp_doorbell_prtval(char *_s, size_t _size, xeon_phi_irq_itp_doorbell_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_irq_itp_doorbell_prtval(char *_s, size_t _size, xeon_phi_irq_itp_doorbell_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(ff)\n", xeon_phi_irq_itp_doorbell_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_irq_msi_vector_t
 * Description: Implicit type of MSI(-X) Vector Assignment Register 0-15 register array
 * Fields:
 *   dbr	(size 4, offset 0, init 0):	NOATTR	
 *   _anon4	(size 4, offset 4, init 0):	RSVD	_
 *   dma	(size 8, offset 8, init 0):	NOATTR	
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_irq_msi_vector_t;
#define xeon_phi_irq_msi_vector_default 0x0
static inline uint8_t xeon_phi_irq_msi_vector_dbr_extract(xeon_phi_irq_msi_vector_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_irq_msi_vector_dbr_extract(xeon_phi_irq_msi_vector_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline xeon_phi_irq_msi_vector_t xeon_phi_irq_msi_vector_dbr_insert(xeon_phi_irq_msi_vector_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_irq_msi_vector_t xeon_phi_irq_msi_vector_dbr_insert(xeon_phi_irq_msi_vector_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((xeon_phi_irq_msi_vector_t )(_fieldval)) << 0)));
}

static inline uint8_t xeon_phi_irq_msi_vector_dma_extract(xeon_phi_irq_msi_vector_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_irq_msi_vector_dma_extract(xeon_phi_irq_msi_vector_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline xeon_phi_irq_msi_vector_t xeon_phi_irq_msi_vector_dma_insert(xeon_phi_irq_msi_vector_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_irq_msi_vector_t xeon_phi_irq_msi_vector_dma_insert(xeon_phi_irq_msi_vector_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((xeon_phi_irq_msi_vector_t )(_fieldval)) << 8)));
}

static inline int xeon_phi_irq_msi_vector_prtval(char *_s, size_t _size, xeon_phi_irq_msi_vector_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_irq_msi_vector_prtval(char *_s, size_t _size, xeon_phi_irq_msi_vector_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dbr =\t%" PRIx8 "\t()\n", xeon_phi_irq_msi_vector_dbr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma =\t%" PRIx8 "\t()\n", xeon_phi_irq_msi_vector_dma_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum xeon_phi_irq_initials {
    xeon_phi_irq_doorbel_initial = 0x0,
    xeon_phi_irq_marker_message_disable_initial = 0x0,
    xeon_phi_irq_marker_message_assert_initial = 0x0,
    xeon_phi_irq_marker_message_send_initial = 0x0,
    xeon_phi_irq_msix_ram_initial = 0x0,
    xeon_phi_irq_sysint_debug_initial = 0x0,
    xeon_phi_irq_int_status_initial = 0x0,
    xeon_phi_irq_int_status_set_initial = 0x0,
    xeon_phi_irq_int_enable_initial = 0x0,
    xeon_phi_irq_int_disable_initial = 0x0,
    xeon_phi_irq_int_status_auto_clear_initial = 0x0,
    xeon_phi_irq_itp_doorbell_initial = 0x0,
    xeon_phi_irq_msi_vector_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void xeon_phi_irq_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void xeon_phi_irq_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register array doorbel: System Doorbell Interrupt Command Registe 0-3
 * Type: xeon_phi_irq.doorbel (Implicit type of System Doorbell Interrupt Command Registe 0-3 register array)
 *   value	(size 32, offset 0, init 0):	RW	Value
 */
static const size_t xeon_phi_irq_doorbel_length = 4;
static inline xeon_phi_irq_doorbel_t xeon_phi_irq_doorbel_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_irq_doorbel_t xeon_phi_irq_doorbel_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xcc90 + (_i * (32 / 8))));
}

static inline xeon_phi_irq_doorbel_t xeon_phi_irq_doorbel_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_irq_doorbel_t xeon_phi_irq_doorbel_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xcc90 + (_i * (32 / 8))));
}

static inline void xeon_phi_irq_doorbel_rawwr(__DN(t) *_dev, int _i, xeon_phi_irq_doorbel_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_doorbel_rawwr(__DN(t) *_dev, int _i, xeon_phi_irq_doorbel_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xcc90 + (_i * (32 / 8)), _regval);
}

static inline void xeon_phi_irq_doorbel_wr(__DN(t) *_dev, int _i, xeon_phi_irq_doorbel_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_doorbel_wr(__DN(t) *_dev, int _i, xeon_phi_irq_doorbel_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xcc90 + (_i * (32 / 8)), _regval);
}

static inline int xeon_phi_irq_doorbel_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_irq_doorbel_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_irq_doorbel_t _regval = mackerel_read_addr_32(_dev->base, 0xcc90 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "doorbel", _i, "System Doorbell Interrupt Command Registe 0-3");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " value =\t%" PRIx32 "\t(Value)\n", xeon_phi_irq_doorbel_value_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int xeon_phi_irq_doorbel_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_irq_doorbel_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_irq_doorbel_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t xeon_phi_irq_doorbel_value_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_doorbel_value_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_irq_doorbel_t _regval = mackerel_read_addr_32(_dev->base, 0xcc90 + (_i * (32 / 8)));
    return(xeon_phi_irq_doorbel_value_extract(_regval));
}

static inline void xeon_phi_irq_doorbel_value_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_doorbel_value_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    xeon_phi_irq_doorbel_t _regval = 0xffffffff & (((xeon_phi_irq_doorbel_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcc90 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register marker_message_disable: 32 Bits to Disable Interrupts
 * Type: xeon_phi_irq.marker_message_disable (Implicit type of 32 Bits to Disable Interrupts register)
 *   value	(size 32, offset 0, init 0):	RW	Value
 */
static inline xeon_phi_irq_marker_message_disable_t xeon_phi_irq_marker_message_disable_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_marker_message_disable_t xeon_phi_irq_marker_message_disable_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xcca0));
}

static inline xeon_phi_irq_marker_message_disable_t xeon_phi_irq_marker_message_disable_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_marker_message_disable_t xeon_phi_irq_marker_message_disable_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xcca0));
}

static inline void xeon_phi_irq_marker_message_disable_rawwr(__DN(t) *_dev, xeon_phi_irq_marker_message_disable_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_marker_message_disable_rawwr(__DN(t) *_dev, xeon_phi_irq_marker_message_disable_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xcca0, _regval);
}

static inline void xeon_phi_irq_marker_message_disable_wr(__DN(t) *_dev, xeon_phi_irq_marker_message_disable_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_marker_message_disable_wr(__DN(t) *_dev, xeon_phi_irq_marker_message_disable_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xcca0, _regval);
}

static inline int xeon_phi_irq_marker_message_disable_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_irq_marker_message_disable_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_irq_marker_message_disable_t _regval = mackerel_read_addr_32(_dev->base, 0xcca0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register marker_message_disable (32 Bits to Disable Interrupts): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " value =\t%" PRIx32 "\t(Value)\n", xeon_phi_irq_marker_message_disable_value_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_irq_marker_message_disable_value_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_marker_message_disable_value_rdf(__DN(t) *_dev)
{
    xeon_phi_irq_marker_message_disable_t _regval = mackerel_read_addr_32(_dev->base, 0xcca0);
    return(xeon_phi_irq_marker_message_disable_value_extract(_regval));
}

static inline void xeon_phi_irq_marker_message_disable_value_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_marker_message_disable_value_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_irq_marker_message_disable_t _regval = 0xffffffff & (((xeon_phi_irq_marker_message_disable_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcca0, _regval);
    // No shadow register to write to
}

/*
 * Register marker_message_assert: 32 Bits to Assert Interrupts
 * Type: xeon_phi_irq.marker_message_assert (Implicit type of 32 Bits to Assert Interrupts register)
 *   value	(size 32, offset 0, init 0):	RW	Value
 */
static inline xeon_phi_irq_marker_message_assert_t xeon_phi_irq_marker_message_assert_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_marker_message_assert_t xeon_phi_irq_marker_message_assert_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xcca4));
}

static inline xeon_phi_irq_marker_message_assert_t xeon_phi_irq_marker_message_assert_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_marker_message_assert_t xeon_phi_irq_marker_message_assert_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xcca4));
}

static inline void xeon_phi_irq_marker_message_assert_rawwr(__DN(t) *_dev, xeon_phi_irq_marker_message_assert_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_marker_message_assert_rawwr(__DN(t) *_dev, xeon_phi_irq_marker_message_assert_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xcca4, _regval);
}

static inline void xeon_phi_irq_marker_message_assert_wr(__DN(t) *_dev, xeon_phi_irq_marker_message_assert_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_marker_message_assert_wr(__DN(t) *_dev, xeon_phi_irq_marker_message_assert_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xcca4, _regval);
}

static inline int xeon_phi_irq_marker_message_assert_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_irq_marker_message_assert_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_irq_marker_message_assert_t _regval = mackerel_read_addr_32(_dev->base, 0xcca4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register marker_message_assert (32 Bits to Assert Interrupts): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " value =\t%" PRIx32 "\t(Value)\n", xeon_phi_irq_marker_message_assert_value_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_irq_marker_message_assert_value_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_marker_message_assert_value_rdf(__DN(t) *_dev)
{
    xeon_phi_irq_marker_message_assert_t _regval = mackerel_read_addr_32(_dev->base, 0xcca4);
    return(xeon_phi_irq_marker_message_assert_value_extract(_regval));
}

static inline void xeon_phi_irq_marker_message_assert_value_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_marker_message_assert_value_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_irq_marker_message_assert_t _regval = 0xffffffff & (((xeon_phi_irq_marker_message_assert_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcca4, _regval);
    // No shadow register to write to
}

/*
 * Register marker_message_send: 32 Bits to log INTSCR field of Marker Message
 * Type: xeon_phi_irq.marker_message_send (Implicit type of 32 Bits to log INTSCR field of Marker Message register)
 *   value	(size 32, offset 0, init 0):	RW	Value
 */
static inline xeon_phi_irq_marker_message_send_t xeon_phi_irq_marker_message_send_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_marker_message_send_t xeon_phi_irq_marker_message_send_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xcca8));
}

static inline xeon_phi_irq_marker_message_send_t xeon_phi_irq_marker_message_send_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_marker_message_send_t xeon_phi_irq_marker_message_send_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xcca8));
}

static inline void xeon_phi_irq_marker_message_send_rawwr(__DN(t) *_dev, xeon_phi_irq_marker_message_send_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_marker_message_send_rawwr(__DN(t) *_dev, xeon_phi_irq_marker_message_send_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xcca8, _regval);
}

static inline void xeon_phi_irq_marker_message_send_wr(__DN(t) *_dev, xeon_phi_irq_marker_message_send_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_marker_message_send_wr(__DN(t) *_dev, xeon_phi_irq_marker_message_send_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xcca8, _regval);
}

static inline int xeon_phi_irq_marker_message_send_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_irq_marker_message_send_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_irq_marker_message_send_t _regval = mackerel_read_addr_32(_dev->base, 0xcca8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register marker_message_send (32 Bits to log INTSCR field of Marker Message): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " value =\t%" PRIx32 "\t(Value)\n", xeon_phi_irq_marker_message_send_value_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_irq_marker_message_send_value_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_marker_message_send_value_rdf(__DN(t) *_dev)
{
    xeon_phi_irq_marker_message_send_t _regval = mackerel_read_addr_32(_dev->base, 0xcca8);
    return(xeon_phi_irq_marker_message_send_value_extract(_regval));
}

static inline void xeon_phi_irq_marker_message_send_value_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_marker_message_send_value_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_irq_marker_message_send_t _regval = 0xffffffff & (((xeon_phi_irq_marker_message_send_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcca8, _regval);
    // No shadow register to write to
}

/*
 * Register msix_ram: MSI-X RAM
 * Type: xeon_phi_irq.msix_ram (Implicit type of MSI-X RAM register)
 *   reg	(size 32, offset 0, init 0):	RW	register
 */
static inline xeon_phi_irq_msix_ram_t xeon_phi_irq_msix_ram_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_msix_ram_t xeon_phi_irq_msix_ram_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x7000));
}

static inline xeon_phi_irq_msix_ram_t xeon_phi_irq_msix_ram_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_msix_ram_t xeon_phi_irq_msix_ram_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x7000));
}

static inline void xeon_phi_irq_msix_ram_rawwr(__DN(t) *_dev, xeon_phi_irq_msix_ram_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_msix_ram_rawwr(__DN(t) *_dev, xeon_phi_irq_msix_ram_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x7000, _regval);
}

static inline void xeon_phi_irq_msix_ram_wr(__DN(t) *_dev, xeon_phi_irq_msix_ram_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_msix_ram_wr(__DN(t) *_dev, xeon_phi_irq_msix_ram_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x7000, _regval);
}

static inline int xeon_phi_irq_msix_ram_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_irq_msix_ram_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_irq_msix_ram_t _regval = mackerel_read_addr_32(_dev->base, 0x7000);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register msix_ram (MSI-X RAM): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(register)\n", xeon_phi_irq_msix_ram_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_irq_msix_ram_reg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_msix_ram_reg_rdf(__DN(t) *_dev)
{
    xeon_phi_irq_msix_ram_t _regval = mackerel_read_addr_32(_dev->base, 0x7000);
    return(xeon_phi_irq_msix_ram_reg_extract(_regval));
}

static inline void xeon_phi_irq_msix_ram_reg_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_msix_ram_reg_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_irq_msix_ram_t _regval = 0xffffffff & (((xeon_phi_irq_msix_ram_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x7000, _regval);
    // No shadow register to write to
}

/*
 * Register sysint_debug: SYSINT Debug Register
 * Type: xeon_phi_irq.sysint_debug (Implicit type of SYSINT Debug Register register)
 *   reg	(size 32, offset 0, init 0):	RW	register
 */
static inline xeon_phi_irq_sysint_debug_t xeon_phi_irq_sysint_debug_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_sysint_debug_t xeon_phi_irq_sysint_debug_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9000));
}

static inline xeon_phi_irq_sysint_debug_t xeon_phi_irq_sysint_debug_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_sysint_debug_t xeon_phi_irq_sysint_debug_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9000));
}

static inline void xeon_phi_irq_sysint_debug_rawwr(__DN(t) *_dev, xeon_phi_irq_sysint_debug_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_sysint_debug_rawwr(__DN(t) *_dev, xeon_phi_irq_sysint_debug_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x9000, _regval);
}

static inline void xeon_phi_irq_sysint_debug_wr(__DN(t) *_dev, xeon_phi_irq_sysint_debug_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_sysint_debug_wr(__DN(t) *_dev, xeon_phi_irq_sysint_debug_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x9000, _regval);
}

static inline int xeon_phi_irq_sysint_debug_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_irq_sysint_debug_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_irq_sysint_debug_t _regval = mackerel_read_addr_32(_dev->base, 0x9000);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sysint_debug (SYSINT Debug Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(register)\n", xeon_phi_irq_sysint_debug_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_irq_sysint_debug_reg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_sysint_debug_reg_rdf(__DN(t) *_dev)
{
    xeon_phi_irq_sysint_debug_t _regval = mackerel_read_addr_32(_dev->base, 0x9000);
    return(xeon_phi_irq_sysint_debug_reg_extract(_regval));
}

static inline void xeon_phi_irq_sysint_debug_reg_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_sysint_debug_reg_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_irq_sysint_debug_t _regval = 0xffffffff & (((xeon_phi_irq_sysint_debug_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9000, _regval);
    // No shadow register to write to
}

/*
 * Register int_status: System Interrupt Status Register
 * Type: xeon_phi_irq.int_status (Implicit type of System Interrupt Status Register register)
 *   reg	(size 32, offset 0, init 0):	RW	registr3
 */
static inline xeon_phi_irq_int_status_t xeon_phi_irq_int_status_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_status_t xeon_phi_irq_int_status_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9004));
}

static inline xeon_phi_irq_int_status_t xeon_phi_irq_int_status_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_status_t xeon_phi_irq_int_status_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9004));
}

static inline void xeon_phi_irq_int_status_rawwr(__DN(t) *_dev, xeon_phi_irq_int_status_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_status_rawwr(__DN(t) *_dev, xeon_phi_irq_int_status_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x9004, _regval);
}

static inline void xeon_phi_irq_int_status_wr(__DN(t) *_dev, xeon_phi_irq_int_status_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_status_wr(__DN(t) *_dev, xeon_phi_irq_int_status_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x9004, _regval);
}

static inline int xeon_phi_irq_int_status_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_irq_int_status_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_irq_int_status_t _regval = mackerel_read_addr_32(_dev->base, 0x9004);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register int_status (System Interrupt Status Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(registr3)\n", xeon_phi_irq_int_status_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_irq_int_status_reg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_int_status_reg_rdf(__DN(t) *_dev)
{
    xeon_phi_irq_int_status_t _regval = mackerel_read_addr_32(_dev->base, 0x9004);
    return(xeon_phi_irq_int_status_reg_extract(_regval));
}

static inline void xeon_phi_irq_int_status_reg_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_status_reg_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_irq_int_status_t _regval = 0xffffffff & (((xeon_phi_irq_int_status_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9004, _regval);
    // No shadow register to write to
}

/*
 * Register int_status_set: System Interrupt Status Set Register
 * Type: xeon_phi_irq.int_status_set (Implicit type of System Interrupt Status Set Register register)
 *   reg	(size 32, offset 0, init 0):	RW	register
 */
static inline xeon_phi_irq_int_status_set_t xeon_phi_irq_int_status_set_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_status_set_t xeon_phi_irq_int_status_set_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9008));
}

static inline xeon_phi_irq_int_status_set_t xeon_phi_irq_int_status_set_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_status_set_t xeon_phi_irq_int_status_set_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9008));
}

static inline void xeon_phi_irq_int_status_set_rawwr(__DN(t) *_dev, xeon_phi_irq_int_status_set_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_status_set_rawwr(__DN(t) *_dev, xeon_phi_irq_int_status_set_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x9008, _regval);
}

static inline void xeon_phi_irq_int_status_set_wr(__DN(t) *_dev, xeon_phi_irq_int_status_set_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_status_set_wr(__DN(t) *_dev, xeon_phi_irq_int_status_set_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x9008, _regval);
}

static inline int xeon_phi_irq_int_status_set_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_irq_int_status_set_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_irq_int_status_set_t _regval = mackerel_read_addr_32(_dev->base, 0x9008);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register int_status_set (System Interrupt Status Set Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(register)\n", xeon_phi_irq_int_status_set_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_irq_int_status_set_reg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_int_status_set_reg_rdf(__DN(t) *_dev)
{
    xeon_phi_irq_int_status_set_t _regval = mackerel_read_addr_32(_dev->base, 0x9008);
    return(xeon_phi_irq_int_status_set_reg_extract(_regval));
}

static inline void xeon_phi_irq_int_status_set_reg_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_status_set_reg_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_irq_int_status_set_t _regval = 0xffffffff & (((xeon_phi_irq_int_status_set_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9008, _regval);
    // No shadow register to write to
}

/*
 * Register int_enable: System Interrupt Enable Register
 * Type: xeon_phi_irq.int_enable (Implicit type of System Interrupt Enable Register register)
 *   dbr	(size 4, offset 0, init 0):	RW	
 *   _anon4	(size 4, offset 4, init 0):	RSVD	_
 *   dma	(size 8, offset 8, init 0):	RW	
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline xeon_phi_irq_int_enable_t xeon_phi_irq_int_enable_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_enable_t xeon_phi_irq_int_enable_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x900c));
}

static inline xeon_phi_irq_int_enable_t xeon_phi_irq_int_enable_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_enable_t xeon_phi_irq_int_enable_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x900c));
}

static inline void xeon_phi_irq_int_enable_rawwr(__DN(t) *_dev, xeon_phi_irq_int_enable_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_enable_rawwr(__DN(t) *_dev, xeon_phi_irq_int_enable_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x900c, _regval);
}

static inline void xeon_phi_irq_int_enable_wr(__DN(t) *_dev, xeon_phi_irq_int_enable_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_enable_wr(__DN(t) *_dev, xeon_phi_irq_int_enable_t _regval)
{
    _regval = (_regval & 0xff0f);
    // No MB1 fields present
    _regval = (_regval | (0xffff00f0 & mackerel_read_addr_32(_dev->base, 0x900c)));
    mackerel_write_addr_32(_dev->base, 0x900c, _regval);
}

static inline int xeon_phi_irq_int_enable_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_irq_int_enable_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_irq_int_enable_t _regval = mackerel_read_addr_32(_dev->base, 0x900c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register int_enable (System Interrupt Enable Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dbr =\t%" PRIx8 "\t()\n", xeon_phi_irq_int_enable_dbr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma =\t%" PRIx8 "\t()\n", xeon_phi_irq_int_enable_dma_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t xeon_phi_irq_int_enable_dbr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_irq_int_enable_dbr_rdf(__DN(t) *_dev)
{
    xeon_phi_irq_int_enable_t _regval = mackerel_read_addr_32(_dev->base, 0x900c);
    return(xeon_phi_irq_int_enable_dbr_extract(_regval));
}

static inline uint8_t xeon_phi_irq_int_enable_dma_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_irq_int_enable_dma_rdf(__DN(t) *_dev)
{
    xeon_phi_irq_int_enable_t _regval = mackerel_read_addr_32(_dev->base, 0x900c);
    return(xeon_phi_irq_int_enable_dma_extract(_regval));
}

static inline void xeon_phi_irq_int_enable_dbr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_enable_dbr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_irq_int_enable_t _regval = 0xf & (((xeon_phi_irq_int_enable_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x900c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x900c, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_irq_int_enable_dma_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_enable_dma_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_irq_int_enable_t _regval = 0xff00 & (((xeon_phi_irq_int_enable_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x900c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x900c, _regval);
    // No shadow register to write to
}

/*
 * Register int_disable: System Interrupt Disable
 * Type: xeon_phi_irq.int_disable (Implicit type of System Interrupt Disable register)
 *   dbr	(size 4, offset 0, init 0):	RW	
 *   _anon4	(size 4, offset 4, init 0):	RSVD	_
 *   dma	(size 8, offset 8, init 0):	RW	
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline xeon_phi_irq_int_disable_t xeon_phi_irq_int_disable_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_disable_t xeon_phi_irq_int_disable_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9010));
}

static inline xeon_phi_irq_int_disable_t xeon_phi_irq_int_disable_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_disable_t xeon_phi_irq_int_disable_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9010));
}

static inline void xeon_phi_irq_int_disable_rawwr(__DN(t) *_dev, xeon_phi_irq_int_disable_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_disable_rawwr(__DN(t) *_dev, xeon_phi_irq_int_disable_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x9010, _regval);
}

static inline void xeon_phi_irq_int_disable_wr(__DN(t) *_dev, xeon_phi_irq_int_disable_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_disable_wr(__DN(t) *_dev, xeon_phi_irq_int_disable_t _regval)
{
    _regval = (_regval & 0xff0f);
    // No MB1 fields present
    _regval = (_regval | (0xffff00f0 & mackerel_read_addr_32(_dev->base, 0x9010)));
    mackerel_write_addr_32(_dev->base, 0x9010, _regval);
}

static inline int xeon_phi_irq_int_disable_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_irq_int_disable_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_irq_int_disable_t _regval = mackerel_read_addr_32(_dev->base, 0x9010);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register int_disable (System Interrupt Disable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dbr =\t%" PRIx8 "\t()\n", xeon_phi_irq_int_disable_dbr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma =\t%" PRIx8 "\t()\n", xeon_phi_irq_int_disable_dma_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t xeon_phi_irq_int_disable_dbr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_irq_int_disable_dbr_rdf(__DN(t) *_dev)
{
    xeon_phi_irq_int_disable_t _regval = mackerel_read_addr_32(_dev->base, 0x9010);
    return(xeon_phi_irq_int_disable_dbr_extract(_regval));
}

static inline uint8_t xeon_phi_irq_int_disable_dma_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_irq_int_disable_dma_rdf(__DN(t) *_dev)
{
    xeon_phi_irq_int_disable_t _regval = mackerel_read_addr_32(_dev->base, 0x9010);
    return(xeon_phi_irq_int_disable_dma_extract(_regval));
}

static inline void xeon_phi_irq_int_disable_dbr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_disable_dbr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_irq_int_disable_t _regval = 0xf & (((xeon_phi_irq_int_disable_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x9010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9010, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_irq_int_disable_dma_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_disable_dma_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_irq_int_disable_t _regval = 0xff00 & (((xeon_phi_irq_int_disable_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x9010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9010, _regval);
    // No shadow register to write to
}

/*
 * Register int_status_auto_clear: System Interrupt Status Auto-Clear
 * Type: xeon_phi_irq.int_status_auto_clear (Implicit type of System Interrupt Status Auto-Clear register)
 *   reg	(size 32, offset 0, init 0):	RW	ff
 */
static inline xeon_phi_irq_int_status_auto_clear_t xeon_phi_irq_int_status_auto_clear_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_status_auto_clear_t xeon_phi_irq_int_status_auto_clear_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9014));
}

static inline xeon_phi_irq_int_status_auto_clear_t xeon_phi_irq_int_status_auto_clear_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_int_status_auto_clear_t xeon_phi_irq_int_status_auto_clear_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9014));
}

static inline void xeon_phi_irq_int_status_auto_clear_rawwr(__DN(t) *_dev, xeon_phi_irq_int_status_auto_clear_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_status_auto_clear_rawwr(__DN(t) *_dev, xeon_phi_irq_int_status_auto_clear_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x9014, _regval);
}

static inline void xeon_phi_irq_int_status_auto_clear_wr(__DN(t) *_dev, xeon_phi_irq_int_status_auto_clear_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_status_auto_clear_wr(__DN(t) *_dev, xeon_phi_irq_int_status_auto_clear_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x9014, _regval);
}

static inline int xeon_phi_irq_int_status_auto_clear_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_irq_int_status_auto_clear_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_irq_int_status_auto_clear_t _regval = mackerel_read_addr_32(_dev->base, 0x9014);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register int_status_auto_clear (System Interrupt Status Auto-Clear): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(ff)\n", xeon_phi_irq_int_status_auto_clear_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_irq_int_status_auto_clear_reg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_int_status_auto_clear_reg_rdf(__DN(t) *_dev)
{
    xeon_phi_irq_int_status_auto_clear_t _regval = mackerel_read_addr_32(_dev->base, 0x9014);
    return(xeon_phi_irq_int_status_auto_clear_reg_extract(_regval));
}

static inline void xeon_phi_irq_int_status_auto_clear_reg_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_int_status_auto_clear_reg_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_irq_int_status_auto_clear_t _regval = 0xffffffff & (((xeon_phi_irq_int_status_auto_clear_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9014, _regval);
    // No shadow register to write to
}

/*
 * Register itp_doorbell: System Interrupt ITP Doorbell
 * Type: xeon_phi_irq.itp_doorbell (Implicit type of System Interrupt ITP Doorbell register)
 *   reg	(size 32, offset 0, init 0):	RW	ff
 */
static inline xeon_phi_irq_itp_doorbell_t xeon_phi_irq_itp_doorbell_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_itp_doorbell_t xeon_phi_irq_itp_doorbell_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9030));
}

static inline xeon_phi_irq_itp_doorbell_t xeon_phi_irq_itp_doorbell_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_irq_itp_doorbell_t xeon_phi_irq_itp_doorbell_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x9030));
}

static inline void xeon_phi_irq_itp_doorbell_rawwr(__DN(t) *_dev, xeon_phi_irq_itp_doorbell_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_itp_doorbell_rawwr(__DN(t) *_dev, xeon_phi_irq_itp_doorbell_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x9030, _regval);
}

static inline void xeon_phi_irq_itp_doorbell_wr(__DN(t) *_dev, xeon_phi_irq_itp_doorbell_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_itp_doorbell_wr(__DN(t) *_dev, xeon_phi_irq_itp_doorbell_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x9030, _regval);
}

static inline int xeon_phi_irq_itp_doorbell_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_irq_itp_doorbell_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_irq_itp_doorbell_t _regval = mackerel_read_addr_32(_dev->base, 0x9030);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register itp_doorbell (System Interrupt ITP Doorbell): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(ff)\n", xeon_phi_irq_itp_doorbell_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_irq_itp_doorbell_reg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_irq_itp_doorbell_reg_rdf(__DN(t) *_dev)
{
    xeon_phi_irq_itp_doorbell_t _regval = mackerel_read_addr_32(_dev->base, 0x9030);
    return(xeon_phi_irq_itp_doorbell_reg_extract(_regval));
}

static inline void xeon_phi_irq_itp_doorbell_reg_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_itp_doorbell_reg_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_irq_itp_doorbell_t _regval = 0xffffffff & (((xeon_phi_irq_itp_doorbell_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9030, _regval);
    // No shadow register to write to
}

/*
 * Register array msi_vector: MSI(-X) Vector Assignment Register 0-15
 * Type: xeon_phi_irq.msi_vector (Implicit type of MSI(-X) Vector Assignment Register 0-15 register array)
 *   dbr	(size 4, offset 0, init 0):	RW	
 *   _anon4	(size 4, offset 4, init 0):	RSVD	_
 *   dma	(size 8, offset 8, init 0):	RW	
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static const size_t xeon_phi_irq_msi_vector_length = 16;
static inline xeon_phi_irq_msi_vector_t xeon_phi_irq_msi_vector_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_irq_msi_vector_t xeon_phi_irq_msi_vector_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x9044 + (_i * (32 / 8))));
}

static inline xeon_phi_irq_msi_vector_t xeon_phi_irq_msi_vector_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline xeon_phi_irq_msi_vector_t xeon_phi_irq_msi_vector_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x9044 + (_i * (32 / 8))));
}

static inline void xeon_phi_irq_msi_vector_rawwr(__DN(t) *_dev, int _i, xeon_phi_irq_msi_vector_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_msi_vector_rawwr(__DN(t) *_dev, int _i, xeon_phi_irq_msi_vector_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x9044 + (_i * (32 / 8)), _regval);
}

static inline void xeon_phi_irq_msi_vector_wr(__DN(t) *_dev, int _i, xeon_phi_irq_msi_vector_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_msi_vector_wr(__DN(t) *_dev, int _i, xeon_phi_irq_msi_vector_t _regval)
{
    _regval = (_regval & 0xff0f);
    // No MB1 fields present
    _regval = (_regval | (0xffff00f0 & mackerel_read_addr_32(_dev->base, 0x9044 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x9044 + (_i * (32 / 8)), _regval);
}

static inline int xeon_phi_irq_msi_vector_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xeon_phi_irq_msi_vector_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_irq_msi_vector_t _regval = mackerel_read_addr_32(_dev->base, 0x9044 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "msi_vector", _i, "MSI(-X) Vector Assignment Register 0-15");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dbr =\t%" PRIx8 "\t()\n", xeon_phi_irq_msi_vector_dbr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma =\t%" PRIx8 "\t()\n", xeon_phi_irq_msi_vector_dma_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline int xeon_phi_irq_msi_vector_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_irq_msi_vector_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 16; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xeon_phi_irq_msi_vector_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t xeon_phi_irq_msi_vector_dbr_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_irq_msi_vector_dbr_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_irq_msi_vector_t _regval = mackerel_read_addr_32(_dev->base, 0x9044 + (_i * (32 / 8)));
    return(xeon_phi_irq_msi_vector_dbr_extract(_regval));
}

static inline uint8_t xeon_phi_irq_msi_vector_dma_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_irq_msi_vector_dma_rdf(__DN(t) *_dev, int _i)
{
    xeon_phi_irq_msi_vector_t _regval = mackerel_read_addr_32(_dev->base, 0x9044 + (_i * (32 / 8)));
    return(xeon_phi_irq_msi_vector_dma_extract(_regval));
}

static inline void xeon_phi_irq_msi_vector_dbr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_msi_vector_dbr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    xeon_phi_irq_msi_vector_t _regval = 0xf & (((xeon_phi_irq_msi_vector_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x9044 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9044 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void xeon_phi_irq_msi_vector_dma_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_irq_msi_vector_dma_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    xeon_phi_irq_msi_vector_t _regval = 0xff00 & (((xeon_phi_irq_msi_vector_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x9044 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9044 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline int xeon_phi_irq_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_irq_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device xeon_phi_irq (Intel Xeon Phi Interrupts):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_irq_doorbel_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_irq_marker_message_disable_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_irq_marker_message_assert_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_irq_marker_message_send_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_irq_msix_ram_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_irq_sysint_debug_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_irq_int_status_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_irq_int_status_set_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_irq_int_enable_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_irq_int_disable_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_irq_int_status_auto_clear_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_irq_itp_doorbell_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_irq_msi_vector_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device xeon_phi_irq\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __xeon_phi_irq_DEV_H
