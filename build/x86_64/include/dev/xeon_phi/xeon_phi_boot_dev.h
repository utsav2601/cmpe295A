#ifndef __xeon_phi_boot_DEV_H
#define __xeon_phi_boot_DEV_H 1
/*
 * DEVICE DEFINITION: Intel Xeon Phi Boot Registers
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) xeon_phi_boot ## _ ## x
/*
 * Constants defn: xeon_phi_boot.offset ()
 *  - width 32 bits
 */
typedef uint32_t xeon_phi_boot_offset_t;
#define xeon_phi_boot_address_shift ((xeon_phi_boot_offset_t)0xc)
#define xeon_phi_boot_address_mask ((xeon_phi_boot_offset_t)0xfffff000)

static inline char *xeon_phi_boot_offset_describe(xeon_phi_boot_offset_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_boot_offset_describe(xeon_phi_boot_offset_t _e)
{
    switch (_e) {
    case xeon_phi_boot_address_shift:
        return("address_shift: address_shift");
    case xeon_phi_boot_address_mask:
        return("address_mask: address_mask");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_boot_offset_prtval(char *_s, size_t _size, xeon_phi_boot_offset_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_boot_offset_prtval(char *_s, size_t _size, xeon_phi_boot_offset_t _e)
{
    char *d = xeon_phi_boot_offset_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_boot_offset_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xeon_phi_boot.mem ()
 *  - width 2 bits
 */
typedef uint8_t xeon_phi_boot_mem_t;
#define xeon_phi_boot_mem_all ((xeon_phi_boot_mem_t)0x0)
#define xeon_phi_boot_mem_half ((xeon_phi_boot_mem_t)0x1)
#define xeon_phi_boot_mem_third ((xeon_phi_boot_mem_t)0x2)
#define xeon_phi_boot_mem_fourth ((xeon_phi_boot_mem_t)0x3)

static inline char *xeon_phi_boot_mem_describe(xeon_phi_boot_mem_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_boot_mem_describe(xeon_phi_boot_mem_t _e)
{
    switch (_e) {
    case xeon_phi_boot_mem_all:
        return("mem_all: mem_all");
    case xeon_phi_boot_mem_half:
        return("mem_half: mem_half");
    case xeon_phi_boot_mem_third:
        return("mem_third: mem_third");
    case xeon_phi_boot_mem_fourth:
        return("mem_fourth: mem_fourth");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_boot_mem_prtval(char *_s, size_t _size, xeon_phi_boot_mem_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_boot_mem_prtval(char *_s, size_t _size, xeon_phi_boot_mem_t _e)
{
    char *d = xeon_phi_boot_mem_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_boot_mem_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xeon_phi_boot.postcodes (The Xeon Phi Post codes)
 *  - width 16 bits
 */
typedef uint16_t xeon_phi_boot_postcodes_t;
#define xeon_phi_boot_postcode_lidt ((xeon_phi_boot_postcodes_t)0x3130)
#define xeon_phi_boot_postcode_sboxinit ((xeon_phi_boot_postcodes_t)0x3230)
#define xeon_phi_boot_postcode_gddrtop ((xeon_phi_boot_postcodes_t)0x3330)
#define xeon_phi_boot_postcode_memtest ((xeon_phi_boot_postcodes_t)0x3430)
#define xeon_phi_boot_postcode_e820 ((xeon_phi_boot_postcodes_t)0x3530)
#define xeon_phi_boot_postcode_dbox ((xeon_phi_boot_postcodes_t)0x3630)
#define xeon_phi_boot_postcode_cache ((xeon_phi_boot_postcodes_t)0x3930)
#define xeon_phi_boot_postcode_initap ((xeon_phi_boot_postcodes_t)0x6230)
#define xeon_phi_boot_postcode_code ((xeon_phi_boot_postcodes_t)0x6330)
#define xeon_phi_boot_postcode_mp ((xeon_phi_boot_postcodes_t)0x4530)
#define xeon_phi_boot_postcode_apwkup ((xeon_phi_boot_postcodes_t)0x4630)
#define xeon_phi_boot_postcode_apboot ((xeon_phi_boot_postcodes_t)0x3031)
#define xeon_phi_boot_postcode_sig ((xeon_phi_boot_postcodes_t)0x3131)
#define xeon_phi_boot_postcode_ready ((xeon_phi_boot_postcodes_t)0x3231)
#define xeon_phi_boot_postcode_boot ((xeon_phi_boot_postcodes_t)0x3331)
#define xeon_phi_boot_postcode_pinfo ((xeon_phi_boot_postcodes_t)0x3531)
#define xeon_phi_boot_postcode_ptable ((xeon_phi_boot_postcodes_t)0x3731)
#define xeon_phi_boot_postcode_memtrain ((xeon_phi_boot_postcodes_t)0x3033)
#define xeon_phi_boot_postcode_gddrtrain ((xeon_phi_boot_postcodes_t)0x3133)
#define xeon_phi_boot_postcode_findgddrtrain ((xeon_phi_boot_postcodes_t)0x3233)
#define xeon_phi_boot_postcode_mmiotrain ((xeon_phi_boot_postcodes_t)0x3333)
#define xeon_phi_boot_postcode_rcomptrain ((xeon_phi_boot_postcodes_t)0x3433)
#define xeon_phi_boot_postcode_dcctrain ((xeon_phi_boot_postcodes_t)0x3533)
#define xeon_phi_boot_postcode_hcktrain ((xeon_phi_boot_postcodes_t)0x3633)
#define xeon_phi_boot_postcode_ucodetrain ((xeon_phi_boot_postcodes_t)0x3733)
#define xeon_phi_boot_postcode_vendortrain ((xeon_phi_boot_postcodes_t)0x3833)
#define xeon_phi_boot_postcode_addrtrain ((xeon_phi_boot_postcodes_t)0x3933)
#define xeon_phi_boot_postcode_gddrident ((xeon_phi_boot_postcodes_t)0x4133)
#define xeon_phi_boot_postcode_wcktrain ((xeon_phi_boot_postcodes_t)0x6233)
#define xeon_phi_boot_postcode_cdrdtrain ((xeon_phi_boot_postcodes_t)0x4333)
#define xeon_phi_boot_postcode_cdretrain ((xeon_phi_boot_postcodes_t)0x6433)
#define xeon_phi_boot_postcode_wrtrain ((xeon_phi_boot_postcodes_t)0x4533)
#define xeon_phi_boot_postcode_fintrain ((xeon_phi_boot_postcodes_t)0x4633)
#define xeon_phi_boot_postcode_osauth ((xeon_phi_boot_postcodes_t)0x3034)
#define xeon_phi_boot_postcode_loading0 ((xeon_phi_boot_postcodes_t)0x3035)
#define xeon_phi_boot_postcode_loading1 ((xeon_phi_boot_postcodes_t)0x3135)
#define xeon_phi_boot_postcode_loading2 ((xeon_phi_boot_postcodes_t)0x3235)
#define xeon_phi_boot_postcode_loading3 ((xeon_phi_boot_postcodes_t)0x3335)
#define xeon_phi_boot_postcode_loading4 ((xeon_phi_boot_postcodes_t)0x3435)
#define xeon_phi_boot_postcode_loading5 ((xeon_phi_boot_postcodes_t)0x3535)
#define xeon_phi_boot_postcode_loading6 ((xeon_phi_boot_postcodes_t)0x3635)
#define xeon_phi_boot_postcode_loading7 ((xeon_phi_boot_postcodes_t)0x3735)
#define xeon_phi_boot_postcode_loading8 ((xeon_phi_boot_postcodes_t)0x3835)
#define xeon_phi_boot_postcode_loading9 ((xeon_phi_boot_postcodes_t)0x3935)
#define xeon_phi_boot_postcode_loadingb ((xeon_phi_boot_postcodes_t)0x4135)
#define xeon_phi_boot_postcode_loadinga ((xeon_phi_boot_postcodes_t)0x4235)
#define xeon_phi_boot_postcode_loadingc ((xeon_phi_boot_postcodes_t)0x4335)
#define xeon_phi_boot_postcode_loadingd ((xeon_phi_boot_postcodes_t)0x4435)
#define xeon_phi_boot_postcode_loadinge ((xeon_phi_boot_postcodes_t)0x4535)
#define xeon_phi_boot_postcode_loadingf ((xeon_phi_boot_postcodes_t)0x4635)
#define xeon_phi_boot_postcode_gp ((xeon_phi_boot_postcodes_t)0x5036)
#define xeon_phi_boot_postcode_tss ((xeon_phi_boot_postcodes_t)0x3537)
#define xeon_phi_boot_postcode_fpu ((xeon_phi_boot_postcodes_t)0x3738)
#define xeon_phi_boot_postcode_algin ((xeon_phi_boot_postcodes_t)0x4341)
#define xeon_phi_boot_postcode_bp ((xeon_phi_boot_postcodes_t)0x5062)
#define xeon_phi_boot_postcode_bound ((xeon_phi_boot_postcodes_t)0x7262)
#define xeon_phi_boot_postcode_mc ((xeon_phi_boot_postcodes_t)0x4343)
#define xeon_phi_boot_postcode_seg ((xeon_phi_boot_postcodes_t)0x6f63)
#define xeon_phi_boot_postcode_dbg ((xeon_phi_boot_postcodes_t)0x6264)
#define xeon_phi_boot_postcode_div ((xeon_phi_boot_postcodes_t)0x4564)
#define xeon_phi_boot_postcode_df ((xeon_phi_boot_postcodes_t)0x4664)
#define xeon_phi_boot_postcode_memf ((xeon_phi_boot_postcodes_t)0x4545)
#define xeon_phi_boot_postcode_pnf ((xeon_phi_boot_postcodes_t)0x3046)
#define xeon_phi_boot_postcode_pllf ((xeon_phi_boot_postcodes_t)0x3146)
#define xeon_phi_boot_postcode_memtf ((xeon_phi_boot_postcodes_t)0x3246)
#define xeon_phi_boot_postcode_memqf ((xeon_phi_boot_postcodes_t)0x3346)
#define xeon_phi_boot_postcode_mempf ((xeon_phi_boot_postcodes_t)0x3446)
#define xeon_phi_boot_postcode_sf ((xeon_phi_boot_postcodes_t)0x3546)
#define xeon_phi_boot_postcode_done ((xeon_phi_boot_postcodes_t)0x4646)
#define xeon_phi_boot_postcode_ld ((xeon_phi_boot_postcodes_t)0x644c)
#define xeon_phi_boot_postcode_authf ((xeon_phi_boot_postcodes_t)0x416e)
#define xeon_phi_boot_postcode_dna ((xeon_phi_boot_postcodes_t)0x646e)
#define xeon_phi_boot_postcode_nmi ((xeon_phi_boot_postcodes_t)0x6f6e)
#define xeon_phi_boot_postcode_snp ((xeon_phi_boot_postcodes_t)0x506e)
#define xeon_phi_boot_postcode_of ((xeon_phi_boot_postcodes_t)0x466f)
#define xeon_phi_boot_postcode_pf ((xeon_phi_boot_postcodes_t)0x4650)
#define xeon_phi_boot_postcode_rs ((xeon_phi_boot_postcodes_t)0x3572)
#define xeon_phi_boot_postcode_iop ((xeon_phi_boot_postcodes_t)0x6475)
#define xeon_phi_boot_postcode_unknownerr ((xeon_phi_boot_postcodes_t)0x3048)

static inline char *xeon_phi_boot_postcodes_describe(xeon_phi_boot_postcodes_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_boot_postcodes_describe(xeon_phi_boot_postcodes_t _e)
{
    switch (_e) {
    case xeon_phi_boot_postcode_lidt:
        return("postcode_lidt: 01 LIDT");
    case xeon_phi_boot_postcode_sboxinit:
        return("postcode_sboxinit: 02 SBOX initialization");
    case xeon_phi_boot_postcode_gddrtop:
        return("postcode_gddrtop: 03 Set GDDR Top");
    case xeon_phi_boot_postcode_memtest:
        return("postcode_memtest: 04 Begin memory test");
    case xeon_phi_boot_postcode_e820:
        return("postcode_e820: 05 Program E820 table");
    case xeon_phi_boot_postcode_dbox:
        return("postcode_dbox: 06 Initialize DBOX");
    case xeon_phi_boot_postcode_cache:
        return("postcode_cache: 09 Enable Cache");
    case xeon_phi_boot_postcode_initap:
        return("postcode_initap: 0b Pass initialization params to APs");
    case xeon_phi_boot_postcode_code:
        return("postcode_code: 0c Cache C code");
    case xeon_phi_boot_postcode_mp:
        return("postcode_mp: 0E Program MP table");
    case xeon_phi_boot_postcode_apwkup:
        return("postcode_apwkup: 0F Wake up APs");
    case xeon_phi_boot_postcode_apboot:
        return("postcode_apboot: 10 Wait for APs to boot");
    case xeon_phi_boot_postcode_sig:
        return("postcode_sig: 11 Signal host to download OS");
    case xeon_phi_boot_postcode_ready:
        return("postcode_ready: 12 Wait for download READY");
    case xeon_phi_boot_postcode_boot:
        return("postcode_boot: 13 Signal to boot received");
    case xeon_phi_boot_postcode_pinfo:
        return("postcode_pinfo: 15 Report platform information");
    case xeon_phi_boot_postcode_ptable:
        return("postcode_ptable: 17 Page table setup");
    case xeon_phi_boot_postcode_memtrain:
        return("postcode_memtrain: 30 Begin memory training");
    case xeon_phi_boot_postcode_gddrtrain:
        return("postcode_gddrtrain: 31 GDDR Training to query memory modules");
    case xeon_phi_boot_postcode_findgddrtrain:
        return("postcode_findgddrtrain: 32 Find GDDR training parameters in flash");
    case xeon_phi_boot_postcode_mmiotrain:
        return("postcode_mmiotrain: 33 MMIO training");
    case xeon_phi_boot_postcode_rcomptrain:
        return("postcode_rcomptrain: 34 RCOMP training");
    case xeon_phi_boot_postcode_dcctrain:
        return("postcode_dcctrain: 35 DCC disable training");
    case xeon_phi_boot_postcode_hcktrain:
        return("postcode_hcktrain: 36 HCK training");
    case xeon_phi_boot_postcode_ucodetrain:
        return("postcode_ucodetrain: 37 UCode Training");
    case xeon_phi_boot_postcode_vendortrain:
        return("postcode_vendortrain: 38 Vendor specific training");
    case xeon_phi_boot_postcode_addrtrain:
        return("postcode_addrtrain: 39 GDDR address training");
    case xeon_phi_boot_postcode_gddrident:
        return("postcode_gddrident: 3A GDDR memory module identification");
    case xeon_phi_boot_postcode_wcktrain:
        return("postcode_wcktrain: 3b GDDR WCK training");
    case xeon_phi_boot_postcode_cdrdtrain:
        return("postcode_cdrdtrain: 3C GDDR read training with CDR enabled");
    case xeon_phi_boot_postcode_cdretrain:
        return("postcode_cdretrain: 3d GDDR Read Training with CDR disabled");
    case xeon_phi_boot_postcode_wrtrain:
        return("postcode_wrtrain: 3E GDDR Write Training");
    case xeon_phi_boot_postcode_fintrain:
        return("postcode_fintrain: 3F Finalize GDDR Training");
    case xeon_phi_boot_postcode_osauth:
        return("postcode_osauth: 40 Begin Coprocessor OS authentification");
    case xeon_phi_boot_postcode_loading0:
        return("postcode_loading0: 50 Coprocessor OS Loading 0");
    case xeon_phi_boot_postcode_loading1:
        return("postcode_loading1: 51 Coprocessor OS Loading 1");
    case xeon_phi_boot_postcode_loading2:
        return("postcode_loading2: 52 Coprocessor OS Loading 2");
    case xeon_phi_boot_postcode_loading3:
        return("postcode_loading3: 53 Coprocessor OS Loading 3");
    case xeon_phi_boot_postcode_loading4:
        return("postcode_loading4: 54 Coprocessor OS Loading 4");
    case xeon_phi_boot_postcode_loading5:
        return("postcode_loading5: 55 Coprocessor OS Loading 5");
    case xeon_phi_boot_postcode_loading6:
        return("postcode_loading6: 56 Coprocessor OS Loading 6");
    case xeon_phi_boot_postcode_loading7:
        return("postcode_loading7: 57 Coprocessor OS Loading 7");
    case xeon_phi_boot_postcode_loading8:
        return("postcode_loading8: 58 Coprocessor OS Loading 8");
    case xeon_phi_boot_postcode_loading9:
        return("postcode_loading9: 59 Coprocessor OS Loading 9");
    case xeon_phi_boot_postcode_loadingb:
        return("postcode_loadingb: 5A Coprocessor OS Loading A");
    case xeon_phi_boot_postcode_loadinga:
        return("postcode_loadinga: 5B Coprocessor OS Loading B");
    case xeon_phi_boot_postcode_loadingc:
        return("postcode_loadingc: 5C Coprocessor OS Loading C");
    case xeon_phi_boot_postcode_loadingd:
        return("postcode_loadingd: 5D Coprocessor OS Loading D");
    case xeon_phi_boot_postcode_loadinge:
        return("postcode_loadinge: 5E Coprocessor OS Loading E");
    case xeon_phi_boot_postcode_loadingf:
        return("postcode_loadingf: 5F Coprocessor OS Loading F");
    case xeon_phi_boot_postcode_gp:
        return("postcode_gp: 6P Int 13 - General Protection Fault");
    case xeon_phi_boot_postcode_tss:
        return("postcode_tss: 75 Int 10 - Invalid TSS");
    case xeon_phi_boot_postcode_fpu:
        return("postcode_fpu: 87 Int 16 - x87 FPU Error");
    case xeon_phi_boot_postcode_algin:
        return("postcode_algin: AC INT 17 - Alignment Check");
    case xeon_phi_boot_postcode_bp:
        return("postcode_bp: bP INT 3 - Break Point");
    case xeon_phi_boot_postcode_bound:
        return("postcode_bound: br INT 5 - BOUND Range Exceeded");
    case xeon_phi_boot_postcode_mc:
        return("postcode_mc: CC INT 18 - Machine Check");
    case xeon_phi_boot_postcode_seg:
        return("postcode_seg: co INT 9 - Coprocessor Segmenet Overrun");
    case xeon_phi_boot_postcode_dbg:
        return("postcode_dbg: db INT 1 - Debug");
    case xeon_phi_boot_postcode_div:
        return("postcode_div: dE INT 0 - Divide Error");
    case xeon_phi_boot_postcode_df:
        return("postcode_df: dF INT 8 - Double Fault");
    case xeon_phi_boot_postcode_memf:
        return("postcode_memf: EE Memory Test Failed");
    case xeon_phi_boot_postcode_pnf:
        return("postcode_pnf: F0 GDDR Parameters not found");
    case xeon_phi_boot_postcode_pllf:
        return("postcode_pllf: F1 GBOX PLL lock failure");
    case xeon_phi_boot_postcode_memtf:
        return("postcode_memtf: F2 GDDR failed memory training");
    case xeon_phi_boot_postcode_memqf:
        return("postcode_memqf: F3 GDDR memory module query failed");
    case xeon_phi_boot_postcode_mempf:
        return("postcode_mempf: F4 Memory preservation failure");
    case xeon_phi_boot_postcode_sf:
        return("postcode_sf: F5 INT 12 - Stack Fault");
    case xeon_phi_boot_postcode_done:
        return("postcode_done: FF - Bootstrap finished execution");
    case xeon_phi_boot_postcode_ld:
        return("postcode_ld: Ld - Locking down hardware access");
    case xeon_phi_boot_postcode_authf:
        return("postcode_authf: nA - OS Image failed Authentification");
    case xeon_phi_boot_postcode_dna:
        return("postcode_dna: nd INT 7 - Device not Available");
    case xeon_phi_boot_postcode_nmi:
        return("postcode_nmi: no INT 2 - Non-maskable Interrupt");
    case xeon_phi_boot_postcode_snp:
        return("postcode_snp: nP INT 11 - Segment Not Present");
    case xeon_phi_boot_postcode_of:
        return("postcode_of: oF INT 4 - Overflow");
    case xeon_phi_boot_postcode_pf:
        return("postcode_pf: PF INT 14 - Pagefault");
    case xeon_phi_boot_postcode_rs:
        return("postcode_rs: r5 INT 15 - Reserved");
    case xeon_phi_boot_postcode_iop:
        return("postcode_iop: ud INT 6 - Invalid OP code");
    case xeon_phi_boot_postcode_unknownerr:
        return("postcode_unknownerr: H0 Unknown Error, HALT");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_boot_postcodes_prtval(char *_s, size_t _size, xeon_phi_boot_postcodes_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_boot_postcodes_prtval(char *_s, size_t _size, xeon_phi_boot_postcodes_t _e)
{
    char *d = xeon_phi_boot_postcodes_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_boot_postcodes_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xeon_phi_boot.postcodes_special (The Xeon Phi Post codes)
 *  - width 32 bits
 */
typedef uint32_t xeon_phi_boot_postcodes_special_t;
#define xeon_phi_boot_postcode_invalid ((xeon_phi_boot_postcodes_special_t)0x0)
#define xeon_phi_boot_postcode_fatal ((xeon_phi_boot_postcodes_special_t)0xffffffff)

static inline char *xeon_phi_boot_postcodes_special_describe(xeon_phi_boot_postcodes_special_t _e) __attribute__ ((always_inline));
static inline char *xeon_phi_boot_postcodes_special_describe(xeon_phi_boot_postcodes_special_t _e)
{
    switch (_e) {
    case xeon_phi_boot_postcode_invalid:
        return("postcode_invalid: postcode_invalid");
    case xeon_phi_boot_postcode_fatal:
        return("postcode_fatal: postcode_fatal");
    default:
        return(NULL);
    }
}

static inline int xeon_phi_boot_postcodes_special_prtval(char *_s, size_t _size, xeon_phi_boot_postcodes_special_t _e) __attribute__ ((always_inline));
static inline int xeon_phi_boot_postcodes_special_prtval(char *_s, size_t _size, xeon_phi_boot_postcodes_special_t _e)
{
    char *d = xeon_phi_boot_postcodes_special_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xeon_phi_boot_postcodes_special_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: xeon_phi_boot_flash_ctrl_t
 * Description: Implicit type of flash_ctrl register
 * Fields:
 *   percent	(size 7, offset 0, init 0):	RW	Percentage progress
 *   status	(size 4, offset 7, init 0):	RW	Status code
 *   command	(size 4, offset 11, init 0):	RW	flash command
 *   smc_status	(size 4, offset 15, init 0):	RW	SMC Status
 *   _anon19	(size 5, offset 19, init 0):	RSVD	_
 *   cmd_data	(size 7, offset 24, init 0):	RW	Command Data
 *   mm_debug	(size 1, offset 31, init 0):	RW	Memory debug
 */
typedef uint32_t xeon_phi_boot_flash_ctrl_t;
#define xeon_phi_boot_flash_ctrl_default 0x0
static inline uint8_t xeon_phi_boot_flash_ctrl_percent_extract(xeon_phi_boot_flash_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_flash_ctrl_percent_extract(xeon_phi_boot_flash_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline xeon_phi_boot_flash_ctrl_t xeon_phi_boot_flash_ctrl_percent_insert(xeon_phi_boot_flash_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_flash_ctrl_t xeon_phi_boot_flash_ctrl_percent_insert(xeon_phi_boot_flash_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff80) | (0x7f & (((xeon_phi_boot_flash_ctrl_t )(_fieldval)) << 0)));
}

static inline uint8_t xeon_phi_boot_flash_ctrl_status_extract(xeon_phi_boot_flash_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_flash_ctrl_status_extract(xeon_phi_boot_flash_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x780) >> 7));
}

static inline xeon_phi_boot_flash_ctrl_t xeon_phi_boot_flash_ctrl_status_insert(xeon_phi_boot_flash_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_flash_ctrl_t xeon_phi_boot_flash_ctrl_status_insert(xeon_phi_boot_flash_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff87f) | (0x780 & (((xeon_phi_boot_flash_ctrl_t )(_fieldval)) << 7)));
}

static inline uint8_t xeon_phi_boot_flash_ctrl_command_extract(xeon_phi_boot_flash_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_flash_ctrl_command_extract(xeon_phi_boot_flash_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x7800) >> 11));
}

static inline xeon_phi_boot_flash_ctrl_t xeon_phi_boot_flash_ctrl_command_insert(xeon_phi_boot_flash_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_flash_ctrl_t xeon_phi_boot_flash_ctrl_command_insert(xeon_phi_boot_flash_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff87ff) | (0x7800 & (((xeon_phi_boot_flash_ctrl_t )(_fieldval)) << 11)));
}

static inline uint8_t xeon_phi_boot_flash_ctrl_smc_status_extract(xeon_phi_boot_flash_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_flash_ctrl_smc_status_extract(xeon_phi_boot_flash_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x78000) >> 15));
}

static inline xeon_phi_boot_flash_ctrl_t xeon_phi_boot_flash_ctrl_smc_status_insert(xeon_phi_boot_flash_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_flash_ctrl_t xeon_phi_boot_flash_ctrl_smc_status_insert(xeon_phi_boot_flash_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff87fff) | (0x78000 & (((xeon_phi_boot_flash_ctrl_t )(_fieldval)) << 15)));
}

static inline uint8_t xeon_phi_boot_flash_ctrl_cmd_data_extract(xeon_phi_boot_flash_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_flash_ctrl_cmd_data_extract(xeon_phi_boot_flash_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x7f000000) >> 24));
}

static inline xeon_phi_boot_flash_ctrl_t xeon_phi_boot_flash_ctrl_cmd_data_insert(xeon_phi_boot_flash_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_flash_ctrl_t xeon_phi_boot_flash_ctrl_cmd_data_insert(xeon_phi_boot_flash_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x80ffffff) | (0x7f000000 & (((xeon_phi_boot_flash_ctrl_t )(_fieldval)) << 24)));
}

static inline uint8_t xeon_phi_boot_flash_ctrl_mm_debug_extract(xeon_phi_boot_flash_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_flash_ctrl_mm_debug_extract(xeon_phi_boot_flash_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline xeon_phi_boot_flash_ctrl_t xeon_phi_boot_flash_ctrl_mm_debug_insert(xeon_phi_boot_flash_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_flash_ctrl_t xeon_phi_boot_flash_ctrl_mm_debug_insert(xeon_phi_boot_flash_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((xeon_phi_boot_flash_ctrl_t )(_fieldval)) << 31)));
}

static inline int xeon_phi_boot_flash_ctrl_prtval(char *_s, size_t _size, xeon_phi_boot_flash_ctrl_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_boot_flash_ctrl_prtval(char *_s, size_t _size, xeon_phi_boot_flash_ctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " percent =\t%" PRIx8 "\t(Percentage progress)\n", xeon_phi_boot_flash_ctrl_percent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t%" PRIx8 "\t(Status code)\n", xeon_phi_boot_flash_ctrl_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " command =\t%" PRIx8 "\t(flash command)\n", xeon_phi_boot_flash_ctrl_command_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smc_status =\t%" PRIx8 "\t(SMC Status)\n", xeon_phi_boot_flash_ctrl_smc_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmd_data =\t%" PRIx8 "\t(Command Data)\n", xeon_phi_boot_flash_ctrl_cmd_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mm_debug =\t%" PRIx8 "\t(Memory debug)\n", xeon_phi_boot_flash_ctrl_mm_debug_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_boot_download_t
 * Description: Implicit type of download register
 * Fields:
 *   status	(size 1, offset 0, init 0):	RW	Download status bit
 *   apicid	(size 9, offset 1, init 0):	RW	APIC ID to send the boot interrupt
 *   _anon10	(size 2, offset 10, init 0):	RSVD	_
 *   offset	(size 20, offset 12, init 0):	RW	Load offset
 */
typedef uint32_t xeon_phi_boot_download_t;
#define xeon_phi_boot_download_default 0x0
static inline uint8_t xeon_phi_boot_download_status_extract(xeon_phi_boot_download_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_download_status_extract(xeon_phi_boot_download_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline xeon_phi_boot_download_t xeon_phi_boot_download_status_insert(xeon_phi_boot_download_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_download_t xeon_phi_boot_download_status_insert(xeon_phi_boot_download_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((xeon_phi_boot_download_t )(_fieldval)) << 0)));
}

static inline uint16_t xeon_phi_boot_download_apicid_extract(xeon_phi_boot_download_t _regval) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_boot_download_apicid_extract(xeon_phi_boot_download_t _regval)
{
    return((uint16_t )((_regval & 0x3fe) >> 1));
}

static inline xeon_phi_boot_download_t xeon_phi_boot_download_apicid_insert(xeon_phi_boot_download_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_download_t xeon_phi_boot_download_apicid_insert(xeon_phi_boot_download_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffffc01) | (0x3fe & (((xeon_phi_boot_download_t )(_fieldval)) << 1)));
}

static inline uint32_t xeon_phi_boot_download_offset_extract(xeon_phi_boot_download_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_boot_download_offset_extract(xeon_phi_boot_download_t _regval)
{
    return((uint32_t )((_regval & 0xfffff000) >> 12));
}

static inline xeon_phi_boot_download_t xeon_phi_boot_download_offset_insert(xeon_phi_boot_download_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_download_t xeon_phi_boot_download_offset_insert(xeon_phi_boot_download_t _regval, uint32_t _fieldval)
{
    return((_regval & 0xfff) | (0xfffff000 & (((xeon_phi_boot_download_t )(_fieldval)) << 12)));
}

static inline int xeon_phi_boot_download_prtval(char *_s, size_t _size, xeon_phi_boot_download_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_boot_download_prtval(char *_s, size_t _size, xeon_phi_boot_download_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t%" PRIx8 "\t(Download status bit)\n", xeon_phi_boot_download_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apicid =\t%" PRIx16 "\t(APIC ID to send the boot interrupt)\n", xeon_phi_boot_download_apicid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " offset =\t%" PRIx32 "\t(Load offset)\n", xeon_phi_boot_download_offset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_boot_res_size_t
 * Description: Implicit type of res_size register
 * Fields:
 *   os	(size 32, offset 0, init 0):	RW	Reserved size
 */
typedef uint32_t xeon_phi_boot_res_size_t;
#define xeon_phi_boot_res_size_default 0x0
static inline uint32_t xeon_phi_boot_res_size_os_extract(xeon_phi_boot_res_size_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_boot_res_size_os_extract(xeon_phi_boot_res_size_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_boot_res_size_t xeon_phi_boot_res_size_os_insert(xeon_phi_boot_res_size_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_res_size_t xeon_phi_boot_res_size_os_insert(xeon_phi_boot_res_size_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_boot_res_size_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_boot_res_size_prtval(char *_s, size_t _size, xeon_phi_boot_res_size_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_boot_res_size_prtval(char *_s, size_t _size, xeon_phi_boot_res_size_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " os =\t%" PRIx32 "\t(Reserved size)\n", xeon_phi_boot_res_size_os_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_boot_os_size_t
 * Description: Implicit type of os_size register
 * Fields:
 *   size	(size 32, offset 0, init 0):	RW	Size of the loaded image
 */
typedef uint32_t xeon_phi_boot_os_size_t;
#define xeon_phi_boot_os_size_default 0x0
static inline uint32_t xeon_phi_boot_os_size_size_extract(xeon_phi_boot_os_size_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_boot_os_size_size_extract(xeon_phi_boot_os_size_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline xeon_phi_boot_os_size_t xeon_phi_boot_os_size_size_insert(xeon_phi_boot_os_size_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_os_size_t xeon_phi_boot_os_size_size_insert(xeon_phi_boot_os_size_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((xeon_phi_boot_os_size_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_boot_os_size_prtval(char *_s, size_t _size, xeon_phi_boot_os_size_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_boot_os_size_prtval(char *_s, size_t _size, xeon_phi_boot_os_size_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx32 "\t(Size of the loaded image)\n", xeon_phi_boot_os_size_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_boot_meminfo_t
 * Description: Implicit type of meminfo register
 * Fields:
 *   test_disable	(size 1, offset 0, init 0):	RW	Memtest disable
 *   usage	(size 2, offset 1, init 0):	RW	Memory usage
 *   size_kb	(size 29, offset 3, init 0):	RW	Memory size in KB
 */
typedef uint32_t xeon_phi_boot_meminfo_t;
#define xeon_phi_boot_meminfo_default 0x0
static inline uint8_t xeon_phi_boot_meminfo_test_disable_extract(xeon_phi_boot_meminfo_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_meminfo_test_disable_extract(xeon_phi_boot_meminfo_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline xeon_phi_boot_meminfo_t xeon_phi_boot_meminfo_test_disable_insert(xeon_phi_boot_meminfo_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_meminfo_t xeon_phi_boot_meminfo_test_disable_insert(xeon_phi_boot_meminfo_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((xeon_phi_boot_meminfo_t )(_fieldval)) << 0)));
}

static inline uint8_t xeon_phi_boot_meminfo_usage_extract(xeon_phi_boot_meminfo_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_meminfo_usage_extract(xeon_phi_boot_meminfo_t _regval)
{
    return((uint8_t )((_regval & 0x6) >> 1));
}

static inline xeon_phi_boot_meminfo_t xeon_phi_boot_meminfo_usage_insert(xeon_phi_boot_meminfo_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_meminfo_t xeon_phi_boot_meminfo_usage_insert(xeon_phi_boot_meminfo_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff9) | (0x6 & (((xeon_phi_boot_meminfo_t )(_fieldval)) << 1)));
}

static inline uint32_t xeon_phi_boot_meminfo_size_kb_extract(xeon_phi_boot_meminfo_t _regval) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_boot_meminfo_size_kb_extract(xeon_phi_boot_meminfo_t _regval)
{
    return((uint32_t )((_regval & 0xfffffff8) >> 3));
}

static inline xeon_phi_boot_meminfo_t xeon_phi_boot_meminfo_size_kb_insert(xeon_phi_boot_meminfo_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_meminfo_t xeon_phi_boot_meminfo_size_kb_insert(xeon_phi_boot_meminfo_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x7) | (0xfffffff8 & (((xeon_phi_boot_meminfo_t )(_fieldval)) << 3)));
}

static inline int xeon_phi_boot_meminfo_prtval(char *_s, size_t _size, xeon_phi_boot_meminfo_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_boot_meminfo_prtval(char *_s, size_t _size, xeon_phi_boot_meminfo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " test_disable =\t%" PRIx8 "\t(Memtest disable)\n", xeon_phi_boot_meminfo_test_disable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usage =\t%" PRIx8 "\t(Memory usage)\n", xeon_phi_boot_meminfo_usage_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size_kb =\t%" PRIx32 "\t(Memory size in KB)\n", xeon_phi_boot_meminfo_size_kb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_boot_reset_t
 * Description: Implicit type of reset register
 * Fields:
 *   reset	(size 1, offset 0, init 0):	RW	Perform device rest
 *   _anon1	(size 31, offset 1, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_boot_reset_t;
#define xeon_phi_boot_reset_default 0x0
static inline uint8_t xeon_phi_boot_reset_reset_extract(xeon_phi_boot_reset_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_reset_reset_extract(xeon_phi_boot_reset_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline xeon_phi_boot_reset_t xeon_phi_boot_reset_reset_insert(xeon_phi_boot_reset_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_reset_t xeon_phi_boot_reset_reset_insert(xeon_phi_boot_reset_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((xeon_phi_boot_reset_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_boot_reset_prtval(char *_s, size_t _size, xeon_phi_boot_reset_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_boot_reset_prtval(char *_s, size_t _size, xeon_phi_boot_reset_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reset =\t%" PRIx8 "\t(Perform device rest)\n", xeon_phi_boot_reset_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_boot_postcode_t
 * Description: Implicit type of postcode register
 * Fields:
 *   code	(size 16, offset 0, init 0):	RW	code
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_boot_postcode_t;
#define xeon_phi_boot_postcode_default 0x0
static inline xeon_phi_boot_postcodes_t xeon_phi_boot_postcode_code_extract(xeon_phi_boot_postcode_t _regval) __attribute__ ((always_inline));
static inline xeon_phi_boot_postcodes_t xeon_phi_boot_postcode_code_extract(xeon_phi_boot_postcode_t _regval)
{
    return((xeon_phi_boot_postcodes_t )((_regval & 0xffff) >> 0));
}

static inline xeon_phi_boot_postcode_t xeon_phi_boot_postcode_code_insert(xeon_phi_boot_postcode_t _regval, xeon_phi_boot_postcodes_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_postcode_t xeon_phi_boot_postcode_code_insert(xeon_phi_boot_postcode_t _regval, xeon_phi_boot_postcodes_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((xeon_phi_boot_postcode_t )(_fieldval)) << 0)));
}

static inline int xeon_phi_boot_postcode_prtval(char *_s, size_t _size, xeon_phi_boot_postcode_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_boot_postcode_prtval(char *_s, size_t _size, xeon_phi_boot_postcode_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " code =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_boot_postcodes_prtval(_s + _r, _avail, xeon_phi_boot_postcode_code_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(code)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xeon_phi_boot_postcode_raw_t
 * Description: Implicit type of postcode_raw register
 * Fields:
 *   code0	(size 8, offset 0, init 0):	RW	code0
 *   code1	(size 8, offset 8, init 0):	RW	code1
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t xeon_phi_boot_postcode_raw_t;
#define xeon_phi_boot_postcode_raw_default 0x0
static inline uint8_t xeon_phi_boot_postcode_raw_code0_extract(xeon_phi_boot_postcode_raw_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_postcode_raw_code0_extract(xeon_phi_boot_postcode_raw_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline xeon_phi_boot_postcode_raw_t xeon_phi_boot_postcode_raw_code0_insert(xeon_phi_boot_postcode_raw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_postcode_raw_t xeon_phi_boot_postcode_raw_code0_insert(xeon_phi_boot_postcode_raw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((xeon_phi_boot_postcode_raw_t )(_fieldval)) << 0)));
}

static inline uint8_t xeon_phi_boot_postcode_raw_code1_extract(xeon_phi_boot_postcode_raw_t _regval) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_postcode_raw_code1_extract(xeon_phi_boot_postcode_raw_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline xeon_phi_boot_postcode_raw_t xeon_phi_boot_postcode_raw_code1_insert(xeon_phi_boot_postcode_raw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xeon_phi_boot_postcode_raw_t xeon_phi_boot_postcode_raw_code1_insert(xeon_phi_boot_postcode_raw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((xeon_phi_boot_postcode_raw_t )(_fieldval)) << 8)));
}

static inline int xeon_phi_boot_postcode_raw_prtval(char *_s, size_t _size, xeon_phi_boot_postcode_raw_t _regval) __attribute__ ((always_inline));
static inline int xeon_phi_boot_postcode_raw_prtval(char *_s, size_t _size, xeon_phi_boot_postcode_raw_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " code0 =\t%" PRIx8 "\t(code0)\n", xeon_phi_boot_postcode_raw_code0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " code1 =\t%" PRIx8 "\t(code1)\n", xeon_phi_boot_postcode_raw_code1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t sbox_base;
    mackerel_addr_t dbox_base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum xeon_phi_boot_initials {
    xeon_phi_boot_flash_ctrl_initial = 0x0,
    xeon_phi_boot_download_initial = 0x0,
    xeon_phi_boot_res_size_initial = 0x0,
    xeon_phi_boot_os_size_initial = 0x0,
    xeon_phi_boot_meminfo_initial = 0x0,
    xeon_phi_boot_reset_initial = 0x0,
    xeon_phi_boot_postcode_initial = 0x0,
    xeon_phi_boot_postcode_raw_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void xeon_phi_boot_initialize(__DN(t) *_dev, mackerel_addr_t sbox_base, mackerel_addr_t dbox_base) __attribute__ ((always_inline));
static inline void xeon_phi_boot_initialize(__DN(t) *_dev, mackerel_addr_t sbox_base, mackerel_addr_t dbox_base)
{
    _dev->sbox_base = sbox_base;
    _dev->dbox_base = dbox_base;
}

/*
 * Register flash_ctrl: flash_ctrl
 * Type: xeon_phi_boot.flash_ctrl (Implicit type of flash_ctrl register)
 *   percent	(size 7, offset 0, init 0):	RW	Percentage progress
 *   status	(size 4, offset 7, init 0):	RW	Status code
 *   command	(size 4, offset 11, init 0):	RW	flash command
 *   smc_status	(size 4, offset 15, init 0):	RW	SMC Status
 *   _anon19	(size 5, offset 19, init 0):	RSVD	_
 *   cmd_data	(size 7, offset 24, init 0):	RW	Command Data
 *   mm_debug	(size 1, offset 31, init 0):	RW	Memory debug
 */
static inline xeon_phi_boot_flash_ctrl_t xeon_phi_boot_flash_ctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_flash_ctrl_t xeon_phi_boot_flash_ctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->sbox_base, 0xab24));
}

static inline xeon_phi_boot_flash_ctrl_t xeon_phi_boot_flash_ctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_flash_ctrl_t xeon_phi_boot_flash_ctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->sbox_base, 0xab24));
}

static inline void xeon_phi_boot_flash_ctrl_rawwr(__DN(t) *_dev, xeon_phi_boot_flash_ctrl_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_flash_ctrl_rawwr(__DN(t) *_dev, xeon_phi_boot_flash_ctrl_t _regval)
{
    mackerel_write_addr_32(_dev->sbox_base, 0xab24, _regval);
}

static inline void xeon_phi_boot_flash_ctrl_wr(__DN(t) *_dev, xeon_phi_boot_flash_ctrl_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_flash_ctrl_wr(__DN(t) *_dev, xeon_phi_boot_flash_ctrl_t _regval)
{
    _regval = (_regval & 0xff07ffff);
    // No MB1 fields present
    _regval = (_regval | (0xf80000 & mackerel_read_addr_32(_dev->sbox_base, 0xab24)));
    mackerel_write_addr_32(_dev->sbox_base, 0xab24, _regval);
}

static inline int xeon_phi_boot_flash_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_boot_flash_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_boot_flash_ctrl_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab24);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register flash_ctrl (flash_ctrl): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " percent =\t%" PRIx8 "\t(Percentage progress)\n", xeon_phi_boot_flash_ctrl_percent_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t%" PRIx8 "\t(Status code)\n", xeon_phi_boot_flash_ctrl_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " command =\t%" PRIx8 "\t(flash command)\n", xeon_phi_boot_flash_ctrl_command_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smc_status =\t%" PRIx8 "\t(SMC Status)\n", xeon_phi_boot_flash_ctrl_smc_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmd_data =\t%" PRIx8 "\t(Command Data)\n", xeon_phi_boot_flash_ctrl_cmd_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mm_debug =\t%" PRIx8 "\t(Memory debug)\n", xeon_phi_boot_flash_ctrl_mm_debug_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t xeon_phi_boot_flash_ctrl_percent_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_flash_ctrl_percent_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_flash_ctrl_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab24);
    return(xeon_phi_boot_flash_ctrl_percent_extract(_regval));
}

static inline uint8_t xeon_phi_boot_flash_ctrl_status_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_flash_ctrl_status_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_flash_ctrl_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab24);
    return(xeon_phi_boot_flash_ctrl_status_extract(_regval));
}

static inline uint8_t xeon_phi_boot_flash_ctrl_command_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_flash_ctrl_command_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_flash_ctrl_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab24);
    return(xeon_phi_boot_flash_ctrl_command_extract(_regval));
}

static inline uint8_t xeon_phi_boot_flash_ctrl_smc_status_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_flash_ctrl_smc_status_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_flash_ctrl_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab24);
    return(xeon_phi_boot_flash_ctrl_smc_status_extract(_regval));
}

static inline uint8_t xeon_phi_boot_flash_ctrl_cmd_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_flash_ctrl_cmd_data_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_flash_ctrl_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab24);
    return(xeon_phi_boot_flash_ctrl_cmd_data_extract(_regval));
}

static inline uint8_t xeon_phi_boot_flash_ctrl_mm_debug_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_flash_ctrl_mm_debug_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_flash_ctrl_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab24);
    return(xeon_phi_boot_flash_ctrl_mm_debug_extract(_regval));
}

static inline void xeon_phi_boot_flash_ctrl_percent_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_flash_ctrl_percent_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_boot_flash_ctrl_t _regval = 0x7f & (((xeon_phi_boot_flash_ctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff80 & mackerel_read_addr_32(_dev->sbox_base, 0xab24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->sbox_base, 0xab24, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_boot_flash_ctrl_status_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_flash_ctrl_status_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_boot_flash_ctrl_t _regval = 0x780 & (((xeon_phi_boot_flash_ctrl_t )(_fieldval)) << 7);
    _regval = (_regval | (0xfffff87f & mackerel_read_addr_32(_dev->sbox_base, 0xab24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->sbox_base, 0xab24, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_boot_flash_ctrl_command_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_flash_ctrl_command_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_boot_flash_ctrl_t _regval = 0x7800 & (((xeon_phi_boot_flash_ctrl_t )(_fieldval)) << 11);
    _regval = (_regval | (0xffff87ff & mackerel_read_addr_32(_dev->sbox_base, 0xab24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->sbox_base, 0xab24, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_boot_flash_ctrl_smc_status_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_flash_ctrl_smc_status_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_boot_flash_ctrl_t _regval = 0x78000 & (((xeon_phi_boot_flash_ctrl_t )(_fieldval)) << 15);
    _regval = (_regval | (0xfff87fff & mackerel_read_addr_32(_dev->sbox_base, 0xab24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->sbox_base, 0xab24, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_boot_flash_ctrl_cmd_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_flash_ctrl_cmd_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_boot_flash_ctrl_t _regval = 0x7f000000 & (((xeon_phi_boot_flash_ctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0x80ffffff & mackerel_read_addr_32(_dev->sbox_base, 0xab24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->sbox_base, 0xab24, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_boot_flash_ctrl_mm_debug_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_flash_ctrl_mm_debug_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_boot_flash_ctrl_t _regval = 0x80000000 & (((xeon_phi_boot_flash_ctrl_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->sbox_base, 0xab24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->sbox_base, 0xab24, _regval);
    // No shadow register to write to
}

/*
 * Register download: download
 * Type: xeon_phi_boot.download (Implicit type of download register)
 *   status	(size 1, offset 0, init 0):	RW	Download status bit
 *   apicid	(size 9, offset 1, init 0):	RW	APIC ID to send the boot interrupt
 *   _anon10	(size 2, offset 10, init 0):	RSVD	_
 *   offset	(size 20, offset 12, init 0):	RW	Load offset
 */
static inline xeon_phi_boot_download_t xeon_phi_boot_download_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_download_t xeon_phi_boot_download_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->sbox_base, 0xab28));
}

static inline xeon_phi_boot_download_t xeon_phi_boot_download_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_download_t xeon_phi_boot_download_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->sbox_base, 0xab28));
}

static inline void xeon_phi_boot_download_rawwr(__DN(t) *_dev, xeon_phi_boot_download_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_download_rawwr(__DN(t) *_dev, xeon_phi_boot_download_t _regval)
{
    mackerel_write_addr_32(_dev->sbox_base, 0xab28, _regval);
}

static inline void xeon_phi_boot_download_wr(__DN(t) *_dev, xeon_phi_boot_download_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_download_wr(__DN(t) *_dev, xeon_phi_boot_download_t _regval)
{
    _regval = (_regval & 0xfffff3ff);
    // No MB1 fields present
    _regval = (_regval | (0xc00 & mackerel_read_addr_32(_dev->sbox_base, 0xab28)));
    mackerel_write_addr_32(_dev->sbox_base, 0xab28, _regval);
}

static inline int xeon_phi_boot_download_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_boot_download_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_boot_download_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register download (download): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t%" PRIx8 "\t(Download status bit)\n", xeon_phi_boot_download_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apicid =\t%" PRIx16 "\t(APIC ID to send the boot interrupt)\n", xeon_phi_boot_download_apicid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " offset =\t%" PRIx32 "\t(Load offset)\n", xeon_phi_boot_download_offset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t xeon_phi_boot_download_status_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_download_status_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_download_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab28);
    return(xeon_phi_boot_download_status_extract(_regval));
}

static inline uint16_t xeon_phi_boot_download_apicid_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t xeon_phi_boot_download_apicid_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_download_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab28);
    return(xeon_phi_boot_download_apicid_extract(_regval));
}

static inline uint32_t xeon_phi_boot_download_offset_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_boot_download_offset_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_download_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab28);
    return(xeon_phi_boot_download_offset_extract(_regval));
}

static inline void xeon_phi_boot_download_status_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_download_status_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_boot_download_t _regval = 0x1 & (((xeon_phi_boot_download_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->sbox_base, 0xab28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->sbox_base, 0xab28, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_boot_download_apicid_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_download_apicid_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    xeon_phi_boot_download_t _regval = 0x3fe & (((xeon_phi_boot_download_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffc01 & mackerel_read_addr_32(_dev->sbox_base, 0xab28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->sbox_base, 0xab28, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_boot_download_offset_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_download_offset_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_boot_download_t _regval = 0xfffff000 & (((xeon_phi_boot_download_t )(_fieldval)) << 12);
    _regval = (_regval | (0xfff & mackerel_read_addr_32(_dev->sbox_base, 0xab28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->sbox_base, 0xab28, _regval);
    // No shadow register to write to
}

/*
 * Register res_size: res_size
 * Type: xeon_phi_boot.res_size (Implicit type of res_size register)
 *   os	(size 32, offset 0, init 0):	RW	Reserved size
 */
static inline xeon_phi_boot_res_size_t xeon_phi_boot_res_size_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_res_size_t xeon_phi_boot_res_size_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->sbox_base, 0xab2c));
}

static inline xeon_phi_boot_res_size_t xeon_phi_boot_res_size_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_res_size_t xeon_phi_boot_res_size_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->sbox_base, 0xab2c));
}

static inline void xeon_phi_boot_res_size_rawwr(__DN(t) *_dev, xeon_phi_boot_res_size_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_res_size_rawwr(__DN(t) *_dev, xeon_phi_boot_res_size_t _regval)
{
    mackerel_write_addr_32(_dev->sbox_base, 0xab2c, _regval);
}

static inline void xeon_phi_boot_res_size_wr(__DN(t) *_dev, xeon_phi_boot_res_size_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_res_size_wr(__DN(t) *_dev, xeon_phi_boot_res_size_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->sbox_base, 0xab2c, _regval);
}

static inline int xeon_phi_boot_res_size_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_boot_res_size_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_boot_res_size_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab2c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register res_size (res_size): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " os =\t%" PRIx32 "\t(Reserved size)\n", xeon_phi_boot_res_size_os_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_boot_res_size_os_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_boot_res_size_os_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_res_size_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab2c);
    return(xeon_phi_boot_res_size_os_extract(_regval));
}

static inline void xeon_phi_boot_res_size_os_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_res_size_os_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_boot_res_size_t _regval = 0xffffffff & (((xeon_phi_boot_res_size_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->sbox_base, 0xab2c, _regval);
    // No shadow register to write to
}

/*
 * Register os_size: os_size
 * Type: xeon_phi_boot.os_size (Implicit type of os_size register)
 *   size	(size 32, offset 0, init 0):	RW	Size of the loaded image
 */
static inline xeon_phi_boot_os_size_t xeon_phi_boot_os_size_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_os_size_t xeon_phi_boot_os_size_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->sbox_base, 0xab34));
}

static inline xeon_phi_boot_os_size_t xeon_phi_boot_os_size_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_os_size_t xeon_phi_boot_os_size_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->sbox_base, 0xab34));
}

static inline void xeon_phi_boot_os_size_rawwr(__DN(t) *_dev, xeon_phi_boot_os_size_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_os_size_rawwr(__DN(t) *_dev, xeon_phi_boot_os_size_t _regval)
{
    mackerel_write_addr_32(_dev->sbox_base, 0xab34, _regval);
}

static inline void xeon_phi_boot_os_size_wr(__DN(t) *_dev, xeon_phi_boot_os_size_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_os_size_wr(__DN(t) *_dev, xeon_phi_boot_os_size_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->sbox_base, 0xab34, _regval);
}

static inline int xeon_phi_boot_os_size_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_boot_os_size_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_boot_os_size_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab34);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register os_size (os_size): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx32 "\t(Size of the loaded image)\n", xeon_phi_boot_os_size_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t xeon_phi_boot_os_size_size_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_boot_os_size_size_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_os_size_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab34);
    return(xeon_phi_boot_os_size_size_extract(_regval));
}

static inline void xeon_phi_boot_os_size_size_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_os_size_size_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_boot_os_size_t _regval = 0xffffffff & (((xeon_phi_boot_os_size_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->sbox_base, 0xab34, _regval);
    // No shadow register to write to
}

/*
 * Register meminfo: meminfo
 * Type: xeon_phi_boot.meminfo (Implicit type of meminfo register)
 *   test_disable	(size 1, offset 0, init 0):	RW	Memtest disable
 *   usage	(size 2, offset 1, init 0):	RW	Memory usage
 *   size_kb	(size 29, offset 3, init 0):	RW	Memory size in KB
 */
static inline xeon_phi_boot_meminfo_t xeon_phi_boot_meminfo_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_meminfo_t xeon_phi_boot_meminfo_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->sbox_base, 0xab20));
}

static inline xeon_phi_boot_meminfo_t xeon_phi_boot_meminfo_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_meminfo_t xeon_phi_boot_meminfo_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->sbox_base, 0xab20));
}

static inline void xeon_phi_boot_meminfo_rawwr(__DN(t) *_dev, xeon_phi_boot_meminfo_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_meminfo_rawwr(__DN(t) *_dev, xeon_phi_boot_meminfo_t _regval)
{
    mackerel_write_addr_32(_dev->sbox_base, 0xab20, _regval);
}

static inline void xeon_phi_boot_meminfo_wr(__DN(t) *_dev, xeon_phi_boot_meminfo_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_meminfo_wr(__DN(t) *_dev, xeon_phi_boot_meminfo_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->sbox_base, 0xab20, _regval);
}

static inline int xeon_phi_boot_meminfo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_boot_meminfo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_boot_meminfo_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register meminfo (meminfo): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " test_disable =\t%" PRIx8 "\t(Memtest disable)\n", xeon_phi_boot_meminfo_test_disable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usage =\t%" PRIx8 "\t(Memory usage)\n", xeon_phi_boot_meminfo_usage_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size_kb =\t%" PRIx32 "\t(Memory size in KB)\n", xeon_phi_boot_meminfo_size_kb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t xeon_phi_boot_meminfo_test_disable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_meminfo_test_disable_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_meminfo_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab20);
    return(xeon_phi_boot_meminfo_test_disable_extract(_regval));
}

static inline uint8_t xeon_phi_boot_meminfo_usage_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_meminfo_usage_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_meminfo_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab20);
    return(xeon_phi_boot_meminfo_usage_extract(_regval));
}

static inline uint32_t xeon_phi_boot_meminfo_size_kb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xeon_phi_boot_meminfo_size_kb_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_meminfo_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0xab20);
    return(xeon_phi_boot_meminfo_size_kb_extract(_regval));
}

static inline void xeon_phi_boot_meminfo_test_disable_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_meminfo_test_disable_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_boot_meminfo_t _regval = 0x1 & (((xeon_phi_boot_meminfo_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->sbox_base, 0xab20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->sbox_base, 0xab20, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_boot_meminfo_usage_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_meminfo_usage_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_boot_meminfo_t _regval = 0x6 & (((xeon_phi_boot_meminfo_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffff9 & mackerel_read_addr_32(_dev->sbox_base, 0xab20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->sbox_base, 0xab20, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_boot_meminfo_size_kb_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_meminfo_size_kb_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    xeon_phi_boot_meminfo_t _regval = 0xfffffff8 & (((xeon_phi_boot_meminfo_t )(_fieldval)) << 3);
    _regval = (_regval | (0x7 & mackerel_read_addr_32(_dev->sbox_base, 0xab20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->sbox_base, 0xab20, _regval);
    // No shadow register to write to
}

/*
 * Register reset: reset
 * Type: xeon_phi_boot.reset (Implicit type of reset register)
 *   reset	(size 1, offset 0, init 0):	RW	Perform device rest
 *   _anon1	(size 31, offset 1, init 0):	RSVD	_
 */
static inline xeon_phi_boot_reset_t xeon_phi_boot_reset_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_reset_t xeon_phi_boot_reset_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->sbox_base, 0x4010));
}

static inline xeon_phi_boot_reset_t xeon_phi_boot_reset_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_reset_t xeon_phi_boot_reset_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->sbox_base, 0x4010));
}

static inline void xeon_phi_boot_reset_rawwr(__DN(t) *_dev, xeon_phi_boot_reset_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_reset_rawwr(__DN(t) *_dev, xeon_phi_boot_reset_t _regval)
{
    mackerel_write_addr_32(_dev->sbox_base, 0x4010, _regval);
}

static inline void xeon_phi_boot_reset_wr(__DN(t) *_dev, xeon_phi_boot_reset_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_reset_wr(__DN(t) *_dev, xeon_phi_boot_reset_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->sbox_base, 0x4010)));
    mackerel_write_addr_32(_dev->sbox_base, 0x4010, _regval);
}

static inline int xeon_phi_boot_reset_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_boot_reset_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_boot_reset_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0x4010);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register reset (reset): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reset =\t%" PRIx8 "\t(Perform device rest)\n", xeon_phi_boot_reset_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline uint8_t xeon_phi_boot_reset_reset_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_reset_reset_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_reset_t _regval = mackerel_read_addr_32(_dev->sbox_base, 0x4010);
    return(xeon_phi_boot_reset_reset_extract(_regval));
}

static inline void xeon_phi_boot_reset_reset_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_reset_reset_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_boot_reset_t _regval = 0x1 & (((xeon_phi_boot_reset_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->sbox_base, 0x4010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->sbox_base, 0x4010, _regval);
    // No shadow register to write to
}

/*
 * Register postcode: postcode
 * Type: xeon_phi_boot.postcode (Implicit type of postcode register)
 *   code	(size 16, offset 0, init 0):	RW	code
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline xeon_phi_boot_postcode_t xeon_phi_boot_postcode_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_postcode_t xeon_phi_boot_postcode_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dbox_base, 0x242c));
}

static inline xeon_phi_boot_postcode_t xeon_phi_boot_postcode_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_postcode_t xeon_phi_boot_postcode_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dbox_base, 0x242c));
}

static inline void xeon_phi_boot_postcode_rawwr(__DN(t) *_dev, xeon_phi_boot_postcode_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_postcode_rawwr(__DN(t) *_dev, xeon_phi_boot_postcode_t _regval)
{
    mackerel_write_addr_32(_dev->dbox_base, 0x242c, _regval);
}

static inline void xeon_phi_boot_postcode_wr(__DN(t) *_dev, xeon_phi_boot_postcode_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_postcode_wr(__DN(t) *_dev, xeon_phi_boot_postcode_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->dbox_base, 0x242c)));
    mackerel_write_addr_32(_dev->dbox_base, 0x242c, _regval);
}

static inline int xeon_phi_boot_postcode_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_boot_postcode_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_boot_postcode_t _regval = mackerel_read_addr_32(_dev->dbox_base, 0x242c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register postcode (postcode): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " code =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_boot_postcodes_prtval(_s + _r, _avail, xeon_phi_boot_postcode_code_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(code)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline xeon_phi_boot_postcodes_t xeon_phi_boot_postcode_code_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_postcodes_t xeon_phi_boot_postcode_code_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_postcode_t _regval = mackerel_read_addr_32(_dev->dbox_base, 0x242c);
    return(xeon_phi_boot_postcode_code_extract(_regval));
}

static inline void xeon_phi_boot_postcode_code_wrf(__DN(t) *_dev, xeon_phi_boot_postcodes_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_postcode_code_wrf(__DN(t) *_dev, xeon_phi_boot_postcodes_t _fieldval)
{
    xeon_phi_boot_postcode_t _regval = 0xffff & (((xeon_phi_boot_postcode_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->dbox_base, 0x242c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dbox_base, 0x242c, _regval);
    // No shadow register to write to
}

/*
 * Register postcode_raw: postcode_raw
 * Type: xeon_phi_boot.postcode_raw (Implicit type of postcode_raw register)
 *   code0	(size 8, offset 0, init 0):	RW	code0
 *   code1	(size 8, offset 8, init 0):	RW	code1
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline xeon_phi_boot_postcode_raw_t xeon_phi_boot_postcode_raw_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_postcode_raw_t xeon_phi_boot_postcode_raw_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dbox_base, 0x242c));
}

static inline xeon_phi_boot_postcode_raw_t xeon_phi_boot_postcode_raw_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xeon_phi_boot_postcode_raw_t xeon_phi_boot_postcode_raw_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->dbox_base, 0x242c));
}

static inline void xeon_phi_boot_postcode_raw_rawwr(__DN(t) *_dev, xeon_phi_boot_postcode_raw_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_postcode_raw_rawwr(__DN(t) *_dev, xeon_phi_boot_postcode_raw_t _regval)
{
    mackerel_write_addr_32(_dev->dbox_base, 0x242c, _regval);
}

static inline void xeon_phi_boot_postcode_raw_wr(__DN(t) *_dev, xeon_phi_boot_postcode_raw_t _regval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_postcode_raw_wr(__DN(t) *_dev, xeon_phi_boot_postcode_raw_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->dbox_base, 0x242c)));
    mackerel_write_addr_32(_dev->dbox_base, 0x242c, _regval);
}

static inline int xeon_phi_boot_postcode_raw_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_boot_postcode_raw_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xeon_phi_boot_postcode_raw_t _regval = mackerel_read_addr_32(_dev->dbox_base, 0x242c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register postcode_raw (postcode_raw): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " code0 =\t%" PRIx8 "\t(code0)\n", xeon_phi_boot_postcode_raw_code0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " code1 =\t%" PRIx8 "\t(code1)\n", xeon_phi_boot_postcode_raw_code1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t xeon_phi_boot_postcode_raw_code0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_postcode_raw_code0_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_postcode_raw_t _regval = mackerel_read_addr_32(_dev->dbox_base, 0x242c);
    return(xeon_phi_boot_postcode_raw_code0_extract(_regval));
}

static inline uint8_t xeon_phi_boot_postcode_raw_code1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xeon_phi_boot_postcode_raw_code1_rdf(__DN(t) *_dev)
{
    xeon_phi_boot_postcode_raw_t _regval = mackerel_read_addr_32(_dev->dbox_base, 0x242c);
    return(xeon_phi_boot_postcode_raw_code1_extract(_regval));
}

static inline void xeon_phi_boot_postcode_raw_code0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_postcode_raw_code0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_boot_postcode_raw_t _regval = 0xff & (((xeon_phi_boot_postcode_raw_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->dbox_base, 0x242c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dbox_base, 0x242c, _regval);
    // No shadow register to write to
}

static inline void xeon_phi_boot_postcode_raw_code1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xeon_phi_boot_postcode_raw_code1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xeon_phi_boot_postcode_raw_t _regval = 0xff00 & (((xeon_phi_boot_postcode_raw_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->dbox_base, 0x242c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->dbox_base, 0x242c, _regval);
    // No shadow register to write to
}

static inline int xeon_phi_boot_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xeon_phi_boot_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device xeon_phi_boot (Intel Xeon Phi Boot Registers):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_boot_flash_ctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_boot_download_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_boot_res_size_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_boot_os_size_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_boot_meminfo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_boot_reset_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_boot_postcode_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xeon_phi_boot_postcode_raw_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device xeon_phi_boot\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __xeon_phi_boot_DEV_H
