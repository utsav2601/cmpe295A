#ifndef __tulip_DEV_H
#define __tulip_DEV_H 1
/*
 * DEVICE DEFINITION: Tulip Ethernet Controller
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) tulip ## _ ## x
/*
 * Constants defn: tulip.FBEBITS (Fatal bus error bits)
 *  - no width specified
 */
typedef uint8_t tulip_FBEBITS_t;
#define tulip_parity ((tulip_FBEBITS_t)0x0)
#define tulip_mabrt ((tulip_FBEBITS_t)0x1)
#define tulip_tabrt ((tulip_FBEBITS_t)0x2)

static inline char *tulip_FBEBITS_describe(tulip_FBEBITS_t _e) __attribute__ ((always_inline));
static inline char *tulip_FBEBITS_describe(tulip_FBEBITS_t _e)
{
    switch (_e) {
    case tulip_parity:
        return("parity: Parity error");
    case tulip_mabrt:
        return("mabrt: Master abort");
    case tulip_tabrt:
        return("tabrt: Target abort");
    default:
        return(NULL);
    }
}

static inline int tulip_FBEBITS_prtval(char *_s, size_t _size, tulip_FBEBITS_t _e) __attribute__ ((always_inline));
static inline int tulip_FBEBITS_prtval(char *_s, size_t _size, tulip_FBEBITS_t _e)
{
    char *d = tulip_FBEBITS_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "tulip_FBEBITS_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: tulip.TPROCSTATE (Transmit process state)
 *  - no width specified
 */
typedef uint8_t tulip_TPROCSTATE_t;
#define tulip_tpstop ((tulip_TPROCSTATE_t)0x0)
#define tulip_tprftd ((tulip_TPROCSTATE_t)0x1)
#define tulip_tprwet ((tulip_TPROCSTATE_t)0x2)
#define tulip_tprrbm ((tulip_TPROCSTATE_t)0x3)
#define tulip_tprset ((tulip_TPROCSTATE_t)0x5)
#define tulip_tpsusp ((tulip_TPROCSTATE_t)0x6)
#define tulip_tprclo ((tulip_TPROCSTATE_t)0x7)

static inline char *tulip_TPROCSTATE_describe(tulip_TPROCSTATE_t _e) __attribute__ ((always_inline));
static inline char *tulip_TPROCSTATE_describe(tulip_TPROCSTATE_t _e)
{
    switch (_e) {
    case tulip_tpstop:
        return("tpstop: Stopped: reset cmd or tx jabber expired");
    case tulip_tprftd:
        return("tprftd: Running - fetching tx desc.");
    case tulip_tprwet:
        return("tprwet: Running - waiting for end of tx");
    case tulip_tprrbm:
        return("tprrbm: Running - reading buf from mem & queuing tx fifo");
    case tulip_tprset:
        return("tprset: Running - setup packet");
    case tulip_tpsusp:
        return("tpsusp: Suspended - tx fifo underflow, or unavail tx desc");
    case tulip_tprclo:
        return("tprclo: Running - closing tx desc");
    default:
        return(NULL);
    }
}

static inline int tulip_TPROCSTATE_prtval(char *_s, size_t _size, tulip_TPROCSTATE_t _e) __attribute__ ((always_inline));
static inline int tulip_TPROCSTATE_prtval(char *_s, size_t _size, tulip_TPROCSTATE_t _e)
{
    char *d = tulip_TPROCSTATE_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "tulip_TPROCSTATE_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: tulip.RPROCSTATE (Receive process state)
 *  - no width specified
 */
typedef uint8_t tulip_RPROCSTATE_t;
#define tulip_rpstop ((tulip_RPROCSTATE_t)0x0)
#define tulip_rprfrd ((tulip_RPROCSTATE_t)0x1)
#define tulip_rprcep ((tulip_RPROCSTATE_t)0x2)
#define tulip_rprwrp ((tulip_RPROCSTATE_t)0x3)
#define tulip_rpsusp ((tulip_RPROCSTATE_t)0x4)
#define tulip_rprclo ((tulip_RPROCSTATE_t)0x5)
#define tulip_rprflu ((tulip_RPROCSTATE_t)0x6)
#define tulip_rprqrf ((tulip_RPROCSTATE_t)0x7)

static inline char *tulip_RPROCSTATE_describe(tulip_RPROCSTATE_t _e) __attribute__ ((always_inline));
static inline char *tulip_RPROCSTATE_describe(tulip_RPROCSTATE_t _e)
{
    switch (_e) {
    case tulip_rpstop:
        return("rpstop: Stopped: reset or stop rx command");
    case tulip_rprfrd:
        return("rprfrd: Running - fetching rx desc.");
    case tulip_rprcep:
        return("rprcep: Running - checking for end of rx pkt");
    case tulip_rprwrp:
        return("rprwrp: Running - waiting for rx packet");
    case tulip_rpsusp:
        return("rpsusp: Suspected - unavailable rx buf");
    case tulip_rprclo:
        return("rprclo: Running - closing rx desc");
    case tulip_rprflu:
        return("rprflu: Running - flushing current frame (no rx buf)");
    case tulip_rprqrf:
        return("rprqrf: Running - queueing rx frame to buf");
    default:
        return(NULL);
    }
}

static inline int tulip_RPROCSTATE_prtval(char *_s, size_t _size, tulip_RPROCSTATE_t _e) __attribute__ ((always_inline));
static inline int tulip_RPROCSTATE_prtval(char *_s, size_t _size, tulip_RPROCSTATE_t _e)
{
    char *d = tulip_RPROCSTATE_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "tulip_RPROCSTATE_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: tulip.FRAMEDTYPE (Frame data type)
 *  - width 2 bits
 */
typedef uint8_t tulip_FRAMEDTYPE_t;
#define tulip_sr ((tulip_FRAMEDTYPE_t)0x0)
#define tulip_il ((tulip_FRAMEDTYPE_t)0x1)
#define tulip_el ((tulip_FRAMEDTYPE_t)0x2)

static inline char *tulip_FRAMEDTYPE_describe(tulip_FRAMEDTYPE_t _e) __attribute__ ((always_inline));
static inline char *tulip_FRAMEDTYPE_describe(tulip_FRAMEDTYPE_t _e)
{
    switch (_e) {
    case tulip_sr:
        return("sr: Serial received frame");
    case tulip_il:
        return("il: Internal loopback frame");
    case tulip_el:
        return("el: External loopback or serial received frame");
    default:
        return(NULL);
    }
}

static inline int tulip_FRAMEDTYPE_prtval(char *_s, size_t _size, tulip_FRAMEDTYPE_t _e) __attribute__ ((always_inline));
static inline int tulip_FRAMEDTYPE_prtval(char *_s, size_t _size, tulip_FRAMEDTYPE_t _e)
{
    char *d = tulip_FRAMEDTYPE_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "tulip_FRAMEDTYPE_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: tulip.FILTERTYPE (Filtering type)
 *  - width 2 bits
 */
typedef uint8_t tulip_FILTERTYPE_t;
#define tulip_PF ((tulip_FILTERTYPE_t)0x0)
#define tulip_HF ((tulip_FILTERTYPE_t)0x1)
#define tulip_IF ((tulip_FILTERTYPE_t)0x2)
#define tulip_HOF ((tulip_FILTERTYPE_t)0x3)

static inline char *tulip_FILTERTYPE_describe(tulip_FILTERTYPE_t _e) __attribute__ ((always_inline));
static inline char *tulip_FILTERTYPE_describe(tulip_FILTERTYPE_t _e)
{
    switch (_e) {
    case tulip_PF:
        return("PF: Perfect filtering");
    case tulip_HF:
        return("HF: Hash-based filtering");
    case tulip_IF:
        return("IF: Inverse filtering");
    case tulip_HOF:
        return("HOF: Hash-only filtering");
    default:
        return(NULL);
    }
}

static inline int tulip_FILTERTYPE_prtval(char *_s, size_t _size, tulip_FILTERTYPE_t _e) __attribute__ ((always_inline));
static inline int tulip_FILTERTYPE_prtval(char *_s, size_t _size, tulip_FILTERTYPE_t _e)
{
    char *d = tulip_FILTERTYPE_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "tulip_FILTERTYPE_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: tulip_CSR0_t
 * Description: Implicit type of Bus mode register
 * Fields:
 *   SWR	(size 1, offset 0, init 0):	RW	Software reset
 *   BAR	(size 1, offset 1, init 0):	RW	Bus arbitration
 *   DSL	(size 5, offset 2, init 0):	RW	Descriptor Skip Length
 *   BLE	(size 1, offset 7, init 0):	RW	Big/little endian
 *   PBL	(size 6, offset 8, init 0):	RW	Programmable burst length
 *   CAL	(size 2, offset 14, init 0):	RW	Cache alignment
 *   _anon16	(size 1, offset 16, init 0):	MBZ	_
 *   TAP	(size 3, offset 17, init 0):	RW	Transmit auto polling
 *   DBO	(size 1, offset 20, init 0):	RW	Descriptor byte ordering mode
 *   RME	(size 1, offset 21, init 0):	RW	Read multiple enable
 *   _anon22	(size 1, offset 22, init 0):	MBZ	_
 *   RLE	(size 1, offset 23, init 0):	RW	Read line enable
 *   WIE	(size 1, offset 24, init 0):	RW	Write and invalidation enable
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
typedef uint32_t tulip_CSR0_t;
#define tulip_CSR0_default 0x0
static inline uint8_t tulip_CSR0_SWR_extract(tulip_CSR0_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_SWR_extract(tulip_CSR0_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline tulip_CSR0_t tulip_CSR0_SWR_insert(tulip_CSR0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR0_t tulip_CSR0_SWR_insert(tulip_CSR0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((tulip_CSR0_t )(_fieldval)) << 0)));
}

static inline uint8_t tulip_CSR0_BAR_extract(tulip_CSR0_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_BAR_extract(tulip_CSR0_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline tulip_CSR0_t tulip_CSR0_BAR_insert(tulip_CSR0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR0_t tulip_CSR0_BAR_insert(tulip_CSR0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((tulip_CSR0_t )(_fieldval)) << 1)));
}

static inline uint8_t tulip_CSR0_DSL_extract(tulip_CSR0_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_DSL_extract(tulip_CSR0_t _regval)
{
    return((uint8_t )((_regval & 0x7c) >> 2));
}

static inline tulip_CSR0_t tulip_CSR0_DSL_insert(tulip_CSR0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR0_t tulip_CSR0_DSL_insert(tulip_CSR0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff83) | (0x7c & (((tulip_CSR0_t )(_fieldval)) << 2)));
}

static inline uint8_t tulip_CSR0_BLE_extract(tulip_CSR0_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_BLE_extract(tulip_CSR0_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline tulip_CSR0_t tulip_CSR0_BLE_insert(tulip_CSR0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR0_t tulip_CSR0_BLE_insert(tulip_CSR0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((tulip_CSR0_t )(_fieldval)) << 7)));
}

static inline uint8_t tulip_CSR0_PBL_extract(tulip_CSR0_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_PBL_extract(tulip_CSR0_t _regval)
{
    return((uint8_t )((_regval & 0x3f00) >> 8));
}

static inline tulip_CSR0_t tulip_CSR0_PBL_insert(tulip_CSR0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR0_t tulip_CSR0_PBL_insert(tulip_CSR0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffc0ff) | (0x3f00 & (((tulip_CSR0_t )(_fieldval)) << 8)));
}

static inline uint8_t tulip_CSR0_CAL_extract(tulip_CSR0_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_CAL_extract(tulip_CSR0_t _regval)
{
    return((uint8_t )((_regval & 0xc000) >> 14));
}

static inline tulip_CSR0_t tulip_CSR0_CAL_insert(tulip_CSR0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR0_t tulip_CSR0_CAL_insert(tulip_CSR0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff3fff) | (0xc000 & (((tulip_CSR0_t )(_fieldval)) << 14)));
}

static inline uint8_t tulip_CSR0_TAP_extract(tulip_CSR0_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_TAP_extract(tulip_CSR0_t _regval)
{
    return((uint8_t )((_regval & 0xe0000) >> 17));
}

static inline tulip_CSR0_t tulip_CSR0_TAP_insert(tulip_CSR0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR0_t tulip_CSR0_TAP_insert(tulip_CSR0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff1ffff) | (0xe0000 & (((tulip_CSR0_t )(_fieldval)) << 17)));
}

static inline uint8_t tulip_CSR0_DBO_extract(tulip_CSR0_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_DBO_extract(tulip_CSR0_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline tulip_CSR0_t tulip_CSR0_DBO_insert(tulip_CSR0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR0_t tulip_CSR0_DBO_insert(tulip_CSR0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((tulip_CSR0_t )(_fieldval)) << 20)));
}

static inline uint8_t tulip_CSR0_RME_extract(tulip_CSR0_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_RME_extract(tulip_CSR0_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline tulip_CSR0_t tulip_CSR0_RME_insert(tulip_CSR0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR0_t tulip_CSR0_RME_insert(tulip_CSR0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((tulip_CSR0_t )(_fieldval)) << 21)));
}

static inline uint8_t tulip_CSR0_RLE_extract(tulip_CSR0_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_RLE_extract(tulip_CSR0_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline tulip_CSR0_t tulip_CSR0_RLE_insert(tulip_CSR0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR0_t tulip_CSR0_RLE_insert(tulip_CSR0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((tulip_CSR0_t )(_fieldval)) << 23)));
}

static inline uint8_t tulip_CSR0_WIE_extract(tulip_CSR0_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_WIE_extract(tulip_CSR0_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline tulip_CSR0_t tulip_CSR0_WIE_insert(tulip_CSR0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR0_t tulip_CSR0_WIE_insert(tulip_CSR0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((tulip_CSR0_t )(_fieldval)) << 24)));
}

static inline int tulip_CSR0_prtval(char *_s, size_t _size, tulip_CSR0_t _regval) __attribute__ ((always_inline));
static inline int tulip_CSR0_prtval(char *_s, size_t _size, tulip_CSR0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SWR =\t%" PRIx8 "\t(Software reset)\n", tulip_CSR0_SWR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " BAR =\t%" PRIx8 "\t(Bus arbitration)\n", tulip_CSR0_BAR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " DSL =\t%" PRIx8 "\t(Descriptor Skip Length)\n", tulip_CSR0_DSL_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " BLE =\t%" PRIx8 "\t(Big/little endian)\n", tulip_CSR0_BLE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " PBL =\t%" PRIx8 "\t(Programmable burst length)\n", tulip_CSR0_PBL_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " CAL =\t%" PRIx8 "\t(Cache alignment)\n", tulip_CSR0_CAL_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TAP =\t%" PRIx8 "\t(Transmit auto polling)\n", tulip_CSR0_TAP_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " DBO =\t%" PRIx8 "\t(Descriptor byte ordering mode)\n", tulip_CSR0_DBO_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RME =\t%" PRIx8 "\t(Read multiple enable)\n", tulip_CSR0_RME_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RLE =\t%" PRIx8 "\t(Read line enable)\n", tulip_CSR0_RLE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " WIE =\t%" PRIx8 "\t(Write and invalidation enable)\n", tulip_CSR0_WIE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: tulip_CSR5_t
 * Description: Implicit type of Status register
 * Fields:
 *   TI	(size 1, offset 0, init 0):	RWC	Transmit interrupt
 *   TPS	(size 1, offset 1, init 0):	RWC	Transmit process stopped
 *   TU	(size 1, offset 2, init 0):	RWC	Transmit buffer unavailable
 *   TJT	(size 1, offset 3, init 0):	RWC	Transmit jabber timeout
 *   _anon4	(size 1, offset 4, init 0):	MBZ	_
 *   UNF	(size 1, offset 5, init 0):	RWC	Transmit underflow
 *   RI	(size 1, offset 6, init 0):	RWC	Receive interrupt
 *   RU	(size 1, offset 7, init 0):	RWC	Receive buffer unavailable
 *   RPS	(size 1, offset 8, init 0):	RWC	Receive process stopped
 *   RWT	(size 1, offset 9, init 0):	RWC	Receive watchdog timeout
 *   ETI	(size 1, offset 10, init 0):	RWC	Early termination timeout
 *   GTE	(size 1, offset 11, init 0):	RWC	General-purpose timer expired
 *   _anon12	(size 1, offset 12, init 0):	MBZ	_
 *   FBE	(size 1, offset 13, init 0):	RWC	Fatal bus error
 *   ERI	(size 1, offset 14, init 0):	RWC	Early receive interrupt
 *   AIS	(size 1, offset 15, init 0):	RWC	Abnormal interrupt summary
 *   NIS	(size 1, offset 16, init 0):	RWC	Normal interrupt summary
 *   RS	(size 3, offset 17, init 0):	RO	Receive process state
 *   TS	(size 3, offset 20, init 0):	RO	Transmission process state
 *   EB	(size 3, offset 23, init 0):	RO	Error bits
 *   _anon26	(size 6, offset 26, init 0):	MBZ	_
 */
typedef uint32_t tulip_CSR5_t;
#define tulip_CSR5_default 0x0
static inline uint8_t tulip_CSR5_TI_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_TI_extract(tulip_CSR5_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline tulip_CSR5_t tulip_CSR5_TI_insert(tulip_CSR5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_TI_insert(tulip_CSR5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((tulip_CSR5_t )(_fieldval)) << 0)));
}

static inline uint8_t tulip_CSR5_TPS_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_TPS_extract(tulip_CSR5_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline tulip_CSR5_t tulip_CSR5_TPS_insert(tulip_CSR5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_TPS_insert(tulip_CSR5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((tulip_CSR5_t )(_fieldval)) << 1)));
}

static inline uint8_t tulip_CSR5_TU_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_TU_extract(tulip_CSR5_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline tulip_CSR5_t tulip_CSR5_TU_insert(tulip_CSR5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_TU_insert(tulip_CSR5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((tulip_CSR5_t )(_fieldval)) << 2)));
}

static inline uint8_t tulip_CSR5_TJT_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_TJT_extract(tulip_CSR5_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline tulip_CSR5_t tulip_CSR5_TJT_insert(tulip_CSR5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_TJT_insert(tulip_CSR5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((tulip_CSR5_t )(_fieldval)) << 3)));
}

static inline uint8_t tulip_CSR5_UNF_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_UNF_extract(tulip_CSR5_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline tulip_CSR5_t tulip_CSR5_UNF_insert(tulip_CSR5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_UNF_insert(tulip_CSR5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((tulip_CSR5_t )(_fieldval)) << 5)));
}

static inline uint8_t tulip_CSR5_RI_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_RI_extract(tulip_CSR5_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline tulip_CSR5_t tulip_CSR5_RI_insert(tulip_CSR5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_RI_insert(tulip_CSR5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((tulip_CSR5_t )(_fieldval)) << 6)));
}

static inline uint8_t tulip_CSR5_RU_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_RU_extract(tulip_CSR5_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline tulip_CSR5_t tulip_CSR5_RU_insert(tulip_CSR5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_RU_insert(tulip_CSR5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((tulip_CSR5_t )(_fieldval)) << 7)));
}

static inline uint8_t tulip_CSR5_RPS_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_RPS_extract(tulip_CSR5_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline tulip_CSR5_t tulip_CSR5_RPS_insert(tulip_CSR5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_RPS_insert(tulip_CSR5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((tulip_CSR5_t )(_fieldval)) << 8)));
}

static inline uint8_t tulip_CSR5_RWT_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_RWT_extract(tulip_CSR5_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline tulip_CSR5_t tulip_CSR5_RWT_insert(tulip_CSR5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_RWT_insert(tulip_CSR5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((tulip_CSR5_t )(_fieldval)) << 9)));
}

static inline uint8_t tulip_CSR5_ETI_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_ETI_extract(tulip_CSR5_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline tulip_CSR5_t tulip_CSR5_ETI_insert(tulip_CSR5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_ETI_insert(tulip_CSR5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((tulip_CSR5_t )(_fieldval)) << 10)));
}

static inline uint8_t tulip_CSR5_GTE_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_GTE_extract(tulip_CSR5_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline tulip_CSR5_t tulip_CSR5_GTE_insert(tulip_CSR5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_GTE_insert(tulip_CSR5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((tulip_CSR5_t )(_fieldval)) << 11)));
}

static inline uint8_t tulip_CSR5_FBE_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_FBE_extract(tulip_CSR5_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline tulip_CSR5_t tulip_CSR5_FBE_insert(tulip_CSR5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_FBE_insert(tulip_CSR5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((tulip_CSR5_t )(_fieldval)) << 13)));
}

static inline uint8_t tulip_CSR5_ERI_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_ERI_extract(tulip_CSR5_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline tulip_CSR5_t tulip_CSR5_ERI_insert(tulip_CSR5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_ERI_insert(tulip_CSR5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((tulip_CSR5_t )(_fieldval)) << 14)));
}

static inline uint8_t tulip_CSR5_AIS_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_AIS_extract(tulip_CSR5_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline tulip_CSR5_t tulip_CSR5_AIS_insert(tulip_CSR5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_AIS_insert(tulip_CSR5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((tulip_CSR5_t )(_fieldval)) << 15)));
}

static inline uint8_t tulip_CSR5_NIS_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_NIS_extract(tulip_CSR5_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline tulip_CSR5_t tulip_CSR5_NIS_insert(tulip_CSR5_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_NIS_insert(tulip_CSR5_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((tulip_CSR5_t )(_fieldval)) << 16)));
}

static inline tulip_RPROCSTATE_t tulip_CSR5_RS_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline tulip_RPROCSTATE_t tulip_CSR5_RS_extract(tulip_CSR5_t _regval)
{
    return((tulip_RPROCSTATE_t )((_regval & 0xe0000) >> 17));
}

static inline tulip_CSR5_t tulip_CSR5_RS_insert(tulip_CSR5_t _regval, tulip_RPROCSTATE_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_RS_insert(tulip_CSR5_t _regval, tulip_RPROCSTATE_t _fieldval)
{
    return((_regval & 0xfff1ffff) | (0xe0000 & (((tulip_CSR5_t )(_fieldval)) << 17)));
}

static inline tulip_TPROCSTATE_t tulip_CSR5_TS_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline tulip_TPROCSTATE_t tulip_CSR5_TS_extract(tulip_CSR5_t _regval)
{
    return((tulip_TPROCSTATE_t )((_regval & 0x700000) >> 20));
}

static inline tulip_CSR5_t tulip_CSR5_TS_insert(tulip_CSR5_t _regval, tulip_TPROCSTATE_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_TS_insert(tulip_CSR5_t _regval, tulip_TPROCSTATE_t _fieldval)
{
    return((_regval & 0xff8fffff) | (0x700000 & (((tulip_CSR5_t )(_fieldval)) << 20)));
}

static inline tulip_FBEBITS_t tulip_CSR5_EB_extract(tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline tulip_FBEBITS_t tulip_CSR5_EB_extract(tulip_CSR5_t _regval)
{
    return((tulip_FBEBITS_t )((_regval & 0x3800000) >> 23));
}

static inline tulip_CSR5_t tulip_CSR5_EB_insert(tulip_CSR5_t _regval, tulip_FBEBITS_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_EB_insert(tulip_CSR5_t _regval, tulip_FBEBITS_t _fieldval)
{
    return((_regval & 0xfc7fffff) | (0x3800000 & (((tulip_CSR5_t )(_fieldval)) << 23)));
}

static inline int tulip_CSR5_prtval(char *_s, size_t _size, tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline int tulip_CSR5_prtval(char *_s, size_t _size, tulip_CSR5_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TI =\t%" PRIx8 "\t(Transmit interrupt)\n", tulip_CSR5_TI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TPS =\t%" PRIx8 "\t(Transmit process stopped)\n", tulip_CSR5_TPS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TU =\t%" PRIx8 "\t(Transmit buffer unavailable)\n", tulip_CSR5_TU_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TJT =\t%" PRIx8 "\t(Transmit jabber timeout)\n", tulip_CSR5_TJT_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " UNF =\t%" PRIx8 "\t(Transmit underflow)\n", tulip_CSR5_UNF_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RI =\t%" PRIx8 "\t(Receive interrupt)\n", tulip_CSR5_RI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RU =\t%" PRIx8 "\t(Receive buffer unavailable)\n", tulip_CSR5_RU_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RPS =\t%" PRIx8 "\t(Receive process stopped)\n", tulip_CSR5_RPS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RWT =\t%" PRIx8 "\t(Receive watchdog timeout)\n", tulip_CSR5_RWT_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ETI =\t%" PRIx8 "\t(Early termination timeout)\n", tulip_CSR5_ETI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " GTE =\t%" PRIx8 "\t(General-purpose timer expired)\n", tulip_CSR5_GTE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FBE =\t%" PRIx8 "\t(Fatal bus error)\n", tulip_CSR5_FBE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ERI =\t%" PRIx8 "\t(Early receive interrupt)\n", tulip_CSR5_ERI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " AIS =\t%" PRIx8 "\t(Abnormal interrupt summary)\n", tulip_CSR5_AIS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " NIS =\t%" PRIx8 "\t(Normal interrupt summary)\n", tulip_CSR5_NIS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RS =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_RPROCSTATE_prtval(_s + _r, _avail, tulip_CSR5_RS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Receive process state)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TS =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_TPROCSTATE_prtval(_s + _r, _avail, tulip_CSR5_TS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Transmission process state)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " EB =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_FBEBITS_prtval(_s + _r, _avail, tulip_CSR5_EB_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Error bits)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: tulip_CSR6_t
 * Description: Implicit type of Operating mode register
 * Fields:
 *   HP	(size 1, offset 0, init 0):	RW	Hash/perfect recieve filtering mode
 *   SR	(size 1, offset 1, init 0):	RW	Start/stop receive
 *   HO	(size 1, offset 2, init 0):	RW	Hash-only filtering mode
 *   PB	(size 1, offset 3, init 0):	RW	Pass bad frames
 *   IF	(size 1, offset 4, init 0):	RW	Inverse filtering
 *   SB	(size 1, offset 5, init 0):	RW	Start/stop backoff counter
 *   PR	(size 1, offset 6, init 0):	RW	Promiscuous mode
 *   PM	(size 1, offset 7, init 0):	RW	Pass all multicast
 *   _anon8	(size 1, offset 8, init 0):	MBZ	_
 *   FD	(size 1, offset 9, init 0):	RW	Full-duplex mode
 *   OM	(size 2, offset 10, init 0):	RW	Operating mode
 *   FC	(size 1, offset 12, init 0):	RW	Force collision mode
 *   ST	(size 1, offset 13, init 0):	RW	Start/stop transmission command
 *   TR	(size 2, offset 14, init 0):	RW	Threshold control bits
 *   _anon16	(size 1, offset 16, init 0):	MBZ	_
 *   CA	(size 1, offset 17, init 0):	RW	Capture effect enable
 *   PS	(size 1, offset 18, init 0):	RW	Port select
 *   HBD	(size 1, offset 19, init 0):	RW	Heartbeat disable
 *   _anon20	(size 1, offset 20, init 0):	MBZ	_
 *   SF	(size 1, offset 21, init 0):	RW	Store and forward
 *   TTM	(size 1, offset 22, init 0):	RW	Transmit threshold mode
 *   PCS	(size 1, offset 23, init 0):	RW	PCS function
 *   SCR	(size 1, offset 24, init 0):	RW	Scrambler mode
 *   _anon25	(size 1, offset 25, init 1):	MB1	_
 *   _anon26	(size 4, offset 26, init 0):	MBZ	_
 *   RA	(size 1, offset 30, init 0):	RW	Receive all
 *   SC	(size 1, offset 31, init 0):	RW	Special capture effect enable
 */
typedef uint32_t tulip_CSR6_t;
#define tulip_CSR6_default 0x2000000
static inline uint8_t tulip_CSR6_HP_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_HP_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline tulip_CSR6_t tulip_CSR6_HP_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_HP_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((tulip_CSR6_t )(_fieldval)) << 0)));
}

static inline uint8_t tulip_CSR6_SR_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_SR_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline tulip_CSR6_t tulip_CSR6_SR_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_SR_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((tulip_CSR6_t )(_fieldval)) << 1)));
}

static inline uint8_t tulip_CSR6_HO_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_HO_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline tulip_CSR6_t tulip_CSR6_HO_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_HO_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((tulip_CSR6_t )(_fieldval)) << 2)));
}

static inline uint8_t tulip_CSR6_PB_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_PB_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline tulip_CSR6_t tulip_CSR6_PB_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_PB_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((tulip_CSR6_t )(_fieldval)) << 3)));
}

static inline uint8_t tulip_CSR6_IF_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_IF_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline tulip_CSR6_t tulip_CSR6_IF_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_IF_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((tulip_CSR6_t )(_fieldval)) << 4)));
}

static inline uint8_t tulip_CSR6_SB_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_SB_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline tulip_CSR6_t tulip_CSR6_SB_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_SB_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((tulip_CSR6_t )(_fieldval)) << 5)));
}

static inline uint8_t tulip_CSR6_PR_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_PR_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline tulip_CSR6_t tulip_CSR6_PR_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_PR_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((tulip_CSR6_t )(_fieldval)) << 6)));
}

static inline uint8_t tulip_CSR6_PM_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_PM_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline tulip_CSR6_t tulip_CSR6_PM_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_PM_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((tulip_CSR6_t )(_fieldval)) << 7)));
}

static inline uint8_t tulip_CSR6_FD_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_FD_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline tulip_CSR6_t tulip_CSR6_FD_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_FD_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((tulip_CSR6_t )(_fieldval)) << 9)));
}

static inline uint8_t tulip_CSR6_OM_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_OM_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0xc00) >> 10));
}

static inline tulip_CSR6_t tulip_CSR6_OM_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_OM_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff3ff) | (0xc00 & (((tulip_CSR6_t )(_fieldval)) << 10)));
}

static inline uint8_t tulip_CSR6_FC_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_FC_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline tulip_CSR6_t tulip_CSR6_FC_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_FC_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((tulip_CSR6_t )(_fieldval)) << 12)));
}

static inline uint8_t tulip_CSR6_ST_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_ST_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline tulip_CSR6_t tulip_CSR6_ST_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_ST_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((tulip_CSR6_t )(_fieldval)) << 13)));
}

static inline uint8_t tulip_CSR6_TR_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_TR_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0xc000) >> 14));
}

static inline tulip_CSR6_t tulip_CSR6_TR_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_TR_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff3fff) | (0xc000 & (((tulip_CSR6_t )(_fieldval)) << 14)));
}

static inline uint8_t tulip_CSR6_CA_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_CA_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline tulip_CSR6_t tulip_CSR6_CA_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_CA_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((tulip_CSR6_t )(_fieldval)) << 17)));
}

static inline uint8_t tulip_CSR6_PS_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_PS_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline tulip_CSR6_t tulip_CSR6_PS_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_PS_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((tulip_CSR6_t )(_fieldval)) << 18)));
}

static inline uint8_t tulip_CSR6_HBD_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_HBD_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline tulip_CSR6_t tulip_CSR6_HBD_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_HBD_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((tulip_CSR6_t )(_fieldval)) << 19)));
}

static inline uint8_t tulip_CSR6_SF_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_SF_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline tulip_CSR6_t tulip_CSR6_SF_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_SF_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((tulip_CSR6_t )(_fieldval)) << 21)));
}

static inline uint8_t tulip_CSR6_TTM_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_TTM_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline tulip_CSR6_t tulip_CSR6_TTM_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_TTM_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((tulip_CSR6_t )(_fieldval)) << 22)));
}

static inline uint8_t tulip_CSR6_PCS_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_PCS_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline tulip_CSR6_t tulip_CSR6_PCS_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_PCS_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((tulip_CSR6_t )(_fieldval)) << 23)));
}

static inline uint8_t tulip_CSR6_SCR_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_SCR_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline tulip_CSR6_t tulip_CSR6_SCR_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_SCR_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((tulip_CSR6_t )(_fieldval)) << 24)));
}

static inline uint8_t tulip_CSR6_RA_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_RA_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline tulip_CSR6_t tulip_CSR6_RA_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_RA_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((tulip_CSR6_t )(_fieldval)) << 30)));
}

static inline uint8_t tulip_CSR6_SC_extract(tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_SC_extract(tulip_CSR6_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline tulip_CSR6_t tulip_CSR6_SC_insert(tulip_CSR6_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_SC_insert(tulip_CSR6_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((tulip_CSR6_t )(_fieldval)) << 31)));
}

static inline int tulip_CSR6_prtval(char *_s, size_t _size, tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline int tulip_CSR6_prtval(char *_s, size_t _size, tulip_CSR6_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " HP =\t%" PRIx8 "\t(Hash/perfect recieve filtering mode)\n", tulip_CSR6_HP_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SR =\t%" PRIx8 "\t(Start/stop receive)\n", tulip_CSR6_SR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " HO =\t%" PRIx8 "\t(Hash-only filtering mode)\n", tulip_CSR6_HO_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " PB =\t%" PRIx8 "\t(Pass bad frames)\n", tulip_CSR6_PB_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " IF =\t%" PRIx8 "\t(Inverse filtering)\n", tulip_CSR6_IF_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SB =\t%" PRIx8 "\t(Start/stop backoff counter)\n", tulip_CSR6_SB_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " PR =\t%" PRIx8 "\t(Promiscuous mode)\n", tulip_CSR6_PR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " PM =\t%" PRIx8 "\t(Pass all multicast)\n", tulip_CSR6_PM_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FD =\t%" PRIx8 "\t(Full-duplex mode)\n", tulip_CSR6_FD_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " OM =\t%" PRIx8 "\t(Operating mode)\n", tulip_CSR6_OM_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FC =\t%" PRIx8 "\t(Force collision mode)\n", tulip_CSR6_FC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ST =\t%" PRIx8 "\t(Start/stop transmission command)\n", tulip_CSR6_ST_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TR =\t%" PRIx8 "\t(Threshold control bits)\n", tulip_CSR6_TR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " CA =\t%" PRIx8 "\t(Capture effect enable)\n", tulip_CSR6_CA_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " PS =\t%" PRIx8 "\t(Port select)\n", tulip_CSR6_PS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " HBD =\t%" PRIx8 "\t(Heartbeat disable)\n", tulip_CSR6_HBD_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SF =\t%" PRIx8 "\t(Store and forward)\n", tulip_CSR6_SF_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TTM =\t%" PRIx8 "\t(Transmit threshold mode)\n", tulip_CSR6_TTM_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " PCS =\t%" PRIx8 "\t(PCS function)\n", tulip_CSR6_PCS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SCR =\t%" PRIx8 "\t(Scrambler mode)\n", tulip_CSR6_SCR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RA =\t%" PRIx8 "\t(Receive all)\n", tulip_CSR6_RA_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SC =\t%" PRIx8 "\t(Special capture effect enable)\n", tulip_CSR6_SC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: tulip_CSR7_t
 * Description: Implicit type of Interrupt enable register
 * Fields:
 *   TI	(size 1, offset 0, init 0):	RW	Transmit interrupt enable
 *   TS	(size 1, offset 1, init 0):	RW	Transmit stopped enable
 *   TU	(size 1, offset 2, init 0):	RW	Transmit buffer unavailable enable
 *   TJ	(size 1, offset 3, init 0):	RW	Transmit jabber timeout enable
 *   _anon4	(size 1, offset 4, init 0):	MBZ	_
 *   UN	(size 1, offset 5, init 0):	RW	Underflow interrupt enable
 *   RI	(size 1, offset 6, init 0):	RW	Recieve interrupt enable
 *   RU	(size 1, offset 7, init 0):	RW	Recieve buffer unavailable enable
 *   RS	(size 1, offset 8, init 0):	RW	Recieve stopped enable
 *   RW	(size 1, offset 9, init 0):	RW	Recieve watchdog timeout enable
 *   ETE	(size 1, offset 10, init 0):	RW	Early transmit interrupt enable
 *   GPT	(size 1, offset 11, init 0):	RW	General-purpose timer enable
 *   _anon12	(size 1, offset 12, init 0):	MBZ	_
 *   FBE	(size 1, offset 13, init 0):	RW	Fatal bus error enable
 *   ERE	(size 1, offset 14, init 0):	RW	Early receive enable
 *   AI	(size 1, offset 15, init 0):	RW	Abnormal interrupt summary enable
 *   NI	(size 1, offset 16, init 0):	RW	Normal interrupt summary enable
 *   _anon17	(size 15, offset 17, init 0):	MBZ	_
 */
typedef uint32_t tulip_CSR7_t;
#define tulip_CSR7_default 0x0
static inline uint8_t tulip_CSR7_TI_extract(tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_TI_extract(tulip_CSR7_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline tulip_CSR7_t tulip_CSR7_TI_insert(tulip_CSR7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_TI_insert(tulip_CSR7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((tulip_CSR7_t )(_fieldval)) << 0)));
}

static inline uint8_t tulip_CSR7_TS_extract(tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_TS_extract(tulip_CSR7_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline tulip_CSR7_t tulip_CSR7_TS_insert(tulip_CSR7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_TS_insert(tulip_CSR7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((tulip_CSR7_t )(_fieldval)) << 1)));
}

static inline uint8_t tulip_CSR7_TU_extract(tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_TU_extract(tulip_CSR7_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline tulip_CSR7_t tulip_CSR7_TU_insert(tulip_CSR7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_TU_insert(tulip_CSR7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((tulip_CSR7_t )(_fieldval)) << 2)));
}

static inline uint8_t tulip_CSR7_TJ_extract(tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_TJ_extract(tulip_CSR7_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline tulip_CSR7_t tulip_CSR7_TJ_insert(tulip_CSR7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_TJ_insert(tulip_CSR7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((tulip_CSR7_t )(_fieldval)) << 3)));
}

static inline uint8_t tulip_CSR7_UN_extract(tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_UN_extract(tulip_CSR7_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline tulip_CSR7_t tulip_CSR7_UN_insert(tulip_CSR7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_UN_insert(tulip_CSR7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((tulip_CSR7_t )(_fieldval)) << 5)));
}

static inline uint8_t tulip_CSR7_RI_extract(tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_RI_extract(tulip_CSR7_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline tulip_CSR7_t tulip_CSR7_RI_insert(tulip_CSR7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_RI_insert(tulip_CSR7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((tulip_CSR7_t )(_fieldval)) << 6)));
}

static inline uint8_t tulip_CSR7_RU_extract(tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_RU_extract(tulip_CSR7_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline tulip_CSR7_t tulip_CSR7_RU_insert(tulip_CSR7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_RU_insert(tulip_CSR7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((tulip_CSR7_t )(_fieldval)) << 7)));
}

static inline uint8_t tulip_CSR7_RS_extract(tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_RS_extract(tulip_CSR7_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline tulip_CSR7_t tulip_CSR7_RS_insert(tulip_CSR7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_RS_insert(tulip_CSR7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((tulip_CSR7_t )(_fieldval)) << 8)));
}

static inline uint8_t tulip_CSR7_RW_extract(tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_RW_extract(tulip_CSR7_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline tulip_CSR7_t tulip_CSR7_RW_insert(tulip_CSR7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_RW_insert(tulip_CSR7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((tulip_CSR7_t )(_fieldval)) << 9)));
}

static inline uint8_t tulip_CSR7_ETE_extract(tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_ETE_extract(tulip_CSR7_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline tulip_CSR7_t tulip_CSR7_ETE_insert(tulip_CSR7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_ETE_insert(tulip_CSR7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((tulip_CSR7_t )(_fieldval)) << 10)));
}

static inline uint8_t tulip_CSR7_GPT_extract(tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_GPT_extract(tulip_CSR7_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline tulip_CSR7_t tulip_CSR7_GPT_insert(tulip_CSR7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_GPT_insert(tulip_CSR7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((tulip_CSR7_t )(_fieldval)) << 11)));
}

static inline uint8_t tulip_CSR7_FBE_extract(tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_FBE_extract(tulip_CSR7_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline tulip_CSR7_t tulip_CSR7_FBE_insert(tulip_CSR7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_FBE_insert(tulip_CSR7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((tulip_CSR7_t )(_fieldval)) << 13)));
}

static inline uint8_t tulip_CSR7_ERE_extract(tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_ERE_extract(tulip_CSR7_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline tulip_CSR7_t tulip_CSR7_ERE_insert(tulip_CSR7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_ERE_insert(tulip_CSR7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((tulip_CSR7_t )(_fieldval)) << 14)));
}

static inline uint8_t tulip_CSR7_AI_extract(tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_AI_extract(tulip_CSR7_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline tulip_CSR7_t tulip_CSR7_AI_insert(tulip_CSR7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_AI_insert(tulip_CSR7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((tulip_CSR7_t )(_fieldval)) << 15)));
}

static inline uint8_t tulip_CSR7_NI_extract(tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_NI_extract(tulip_CSR7_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline tulip_CSR7_t tulip_CSR7_NI_insert(tulip_CSR7_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_NI_insert(tulip_CSR7_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((tulip_CSR7_t )(_fieldval)) << 16)));
}

static inline int tulip_CSR7_prtval(char *_s, size_t _size, tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline int tulip_CSR7_prtval(char *_s, size_t _size, tulip_CSR7_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TI =\t%" PRIx8 "\t(Transmit interrupt enable)\n", tulip_CSR7_TI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TS =\t%" PRIx8 "\t(Transmit stopped enable)\n", tulip_CSR7_TS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TU =\t%" PRIx8 "\t(Transmit buffer unavailable enable)\n", tulip_CSR7_TU_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TJ =\t%" PRIx8 "\t(Transmit jabber timeout enable)\n", tulip_CSR7_TJ_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " UN =\t%" PRIx8 "\t(Underflow interrupt enable)\n", tulip_CSR7_UN_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RI =\t%" PRIx8 "\t(Recieve interrupt enable)\n", tulip_CSR7_RI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RU =\t%" PRIx8 "\t(Recieve buffer unavailable enable)\n", tulip_CSR7_RU_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RS =\t%" PRIx8 "\t(Recieve stopped enable)\n", tulip_CSR7_RS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RW =\t%" PRIx8 "\t(Recieve watchdog timeout enable)\n", tulip_CSR7_RW_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ETE =\t%" PRIx8 "\t(Early transmit interrupt enable)\n", tulip_CSR7_ETE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " GPT =\t%" PRIx8 "\t(General-purpose timer enable)\n", tulip_CSR7_GPT_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FBE =\t%" PRIx8 "\t(Fatal bus error enable)\n", tulip_CSR7_FBE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ERE =\t%" PRIx8 "\t(Early receive enable)\n", tulip_CSR7_ERE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " AI =\t%" PRIx8 "\t(Abnormal interrupt summary enable)\n", tulip_CSR7_AI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " NI =\t%" PRIx8 "\t(Normal interrupt summary enable)\n", tulip_CSR7_NI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: tulip_CSR8_t
 * Description: Implicit type of Missed frames and overflow counter register
 * Fields:
 *   MFC	(size 16, offset 0, init 0):	RO	Missed frame counter
 *   MFO	(size 1, offset 16, init 0):	RO	Missed frame overflow
 *   FOC	(size 11, offset 17, init 0):	RO	FIFO overflow counter
 *   OCO	(size 1, offset 28, init 0):	RO	Overflow counter overflow
 *   _anon29	(size 3, offset 29, init 0):	MBZ	_
 */
typedef uint32_t tulip_CSR8_t;
#define tulip_CSR8_default 0x0
static inline uint16_t tulip_CSR8_MFC_extract(tulip_CSR8_t _regval) __attribute__ ((always_inline));
static inline uint16_t tulip_CSR8_MFC_extract(tulip_CSR8_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline tulip_CSR8_t tulip_CSR8_MFC_insert(tulip_CSR8_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR8_t tulip_CSR8_MFC_insert(tulip_CSR8_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((tulip_CSR8_t )(_fieldval)) << 0)));
}

static inline uint8_t tulip_CSR8_MFO_extract(tulip_CSR8_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR8_MFO_extract(tulip_CSR8_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline tulip_CSR8_t tulip_CSR8_MFO_insert(tulip_CSR8_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR8_t tulip_CSR8_MFO_insert(tulip_CSR8_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((tulip_CSR8_t )(_fieldval)) << 16)));
}

static inline uint16_t tulip_CSR8_FOC_extract(tulip_CSR8_t _regval) __attribute__ ((always_inline));
static inline uint16_t tulip_CSR8_FOC_extract(tulip_CSR8_t _regval)
{
    return((uint16_t )((_regval & 0xffe0000) >> 17));
}

static inline tulip_CSR8_t tulip_CSR8_FOC_insert(tulip_CSR8_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR8_t tulip_CSR8_FOC_insert(tulip_CSR8_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xf001ffff) | (0xffe0000 & (((tulip_CSR8_t )(_fieldval)) << 17)));
}

static inline uint8_t tulip_CSR8_OCO_extract(tulip_CSR8_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR8_OCO_extract(tulip_CSR8_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline tulip_CSR8_t tulip_CSR8_OCO_insert(tulip_CSR8_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR8_t tulip_CSR8_OCO_insert(tulip_CSR8_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((tulip_CSR8_t )(_fieldval)) << 28)));
}

static inline int tulip_CSR8_prtval(char *_s, size_t _size, tulip_CSR8_t _regval) __attribute__ ((always_inline));
static inline int tulip_CSR8_prtval(char *_s, size_t _size, tulip_CSR8_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " MFC =\t%" PRIx16 "\t(Missed frame counter)\n", tulip_CSR8_MFC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " MFO =\t%" PRIx8 "\t(Missed frame overflow)\n", tulip_CSR8_MFO_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FOC =\t%" PRIx16 "\t(FIFO overflow counter)\n", tulip_CSR8_FOC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " OCO =\t%" PRIx8 "\t(Overflow counter overflow)\n", tulip_CSR8_OCO_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: tulip_CSR9_t
 * Description: Implicit type of Boot ROM Management register
 * Fields:
 *   DATA	(size 8, offset 0, init 0):	RW	Boot ROM data or serial ROM control
 *   _anon8	(size 2, offset 8, init 0):	MBZ	_
 *   REG	(size 1, offset 10, init 0):	RW	External register select
 *   SR	(size 1, offset 11, init 0):	RW	Serial ROM select
 *   BR	(size 1, offset 12, init 0):	RW	Boot ROM select
 *   WR	(size 1, offset 13, init 0):	RW	ROM write operation
 *   RD	(size 1, offset 14, init 0):	RW	ROM read operation
 *   _anon15	(size 1, offset 15, init 0):	MBZ	_
 *   MDC	(size 1, offset 16, init 0):	RW	MII management clock
 *   MDO	(size 1, offset 17, init 0):	RW	MII management write data
 *   MII	(size 1, offset 18, init 0):	RW	MII management operation mode
 *   MDI	(size 1, offset 19, init 0):	RW	MII management data_in
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t tulip_CSR9_t;
#define tulip_CSR9_default 0x0
static inline uint8_t tulip_CSR9_DATA_extract(tulip_CSR9_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_DATA_extract(tulip_CSR9_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline tulip_CSR9_t tulip_CSR9_DATA_insert(tulip_CSR9_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR9_t tulip_CSR9_DATA_insert(tulip_CSR9_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((tulip_CSR9_t )(_fieldval)) << 0)));
}

static inline uint8_t tulip_CSR9_REG_extract(tulip_CSR9_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_REG_extract(tulip_CSR9_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline tulip_CSR9_t tulip_CSR9_REG_insert(tulip_CSR9_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR9_t tulip_CSR9_REG_insert(tulip_CSR9_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((tulip_CSR9_t )(_fieldval)) << 10)));
}

static inline uint8_t tulip_CSR9_SR_extract(tulip_CSR9_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_SR_extract(tulip_CSR9_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline tulip_CSR9_t tulip_CSR9_SR_insert(tulip_CSR9_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR9_t tulip_CSR9_SR_insert(tulip_CSR9_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((tulip_CSR9_t )(_fieldval)) << 11)));
}

static inline uint8_t tulip_CSR9_BR_extract(tulip_CSR9_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_BR_extract(tulip_CSR9_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline tulip_CSR9_t tulip_CSR9_BR_insert(tulip_CSR9_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR9_t tulip_CSR9_BR_insert(tulip_CSR9_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((tulip_CSR9_t )(_fieldval)) << 12)));
}

static inline uint8_t tulip_CSR9_WR_extract(tulip_CSR9_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_WR_extract(tulip_CSR9_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline tulip_CSR9_t tulip_CSR9_WR_insert(tulip_CSR9_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR9_t tulip_CSR9_WR_insert(tulip_CSR9_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((tulip_CSR9_t )(_fieldval)) << 13)));
}

static inline uint8_t tulip_CSR9_RD_extract(tulip_CSR9_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_RD_extract(tulip_CSR9_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline tulip_CSR9_t tulip_CSR9_RD_insert(tulip_CSR9_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR9_t tulip_CSR9_RD_insert(tulip_CSR9_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((tulip_CSR9_t )(_fieldval)) << 14)));
}

static inline uint8_t tulip_CSR9_MDC_extract(tulip_CSR9_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_MDC_extract(tulip_CSR9_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline tulip_CSR9_t tulip_CSR9_MDC_insert(tulip_CSR9_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR9_t tulip_CSR9_MDC_insert(tulip_CSR9_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((tulip_CSR9_t )(_fieldval)) << 16)));
}

static inline uint8_t tulip_CSR9_MDO_extract(tulip_CSR9_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_MDO_extract(tulip_CSR9_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline tulip_CSR9_t tulip_CSR9_MDO_insert(tulip_CSR9_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR9_t tulip_CSR9_MDO_insert(tulip_CSR9_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((tulip_CSR9_t )(_fieldval)) << 17)));
}

static inline uint8_t tulip_CSR9_MII_extract(tulip_CSR9_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_MII_extract(tulip_CSR9_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline tulip_CSR9_t tulip_CSR9_MII_insert(tulip_CSR9_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR9_t tulip_CSR9_MII_insert(tulip_CSR9_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((tulip_CSR9_t )(_fieldval)) << 18)));
}

static inline uint8_t tulip_CSR9_MDI_extract(tulip_CSR9_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_MDI_extract(tulip_CSR9_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline tulip_CSR9_t tulip_CSR9_MDI_insert(tulip_CSR9_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR9_t tulip_CSR9_MDI_insert(tulip_CSR9_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((tulip_CSR9_t )(_fieldval)) << 19)));
}

static inline int tulip_CSR9_prtval(char *_s, size_t _size, tulip_CSR9_t _regval) __attribute__ ((always_inline));
static inline int tulip_CSR9_prtval(char *_s, size_t _size, tulip_CSR9_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " DATA =\t%" PRIx8 "\t(Boot ROM data or serial ROM control)\n", tulip_CSR9_DATA_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " REG =\t%" PRIx8 "\t(External register select)\n", tulip_CSR9_REG_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SR =\t%" PRIx8 "\t(Serial ROM select)\n", tulip_CSR9_SR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " BR =\t%" PRIx8 "\t(Boot ROM select)\n", tulip_CSR9_BR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " WR =\t%" PRIx8 "\t(ROM write operation)\n", tulip_CSR9_WR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RD =\t%" PRIx8 "\t(ROM read operation)\n", tulip_CSR9_RD_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " MDC =\t%" PRIx8 "\t(MII management clock)\n", tulip_CSR9_MDC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " MDO =\t%" PRIx8 "\t(MII management write data)\n", tulip_CSR9_MDO_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " MII =\t%" PRIx8 "\t(MII management operation mode)\n", tulip_CSR9_MII_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " MDI =\t%" PRIx8 "\t(MII management data_in)\n", tulip_CSR9_MDI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: tulip_CSR10_t
 * Description: Implicit type of Boot ROM programming address register
 * Fields:
 *   VAL	(size 18, offset 0, init 0):	RW	Boot ROM address
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t tulip_CSR10_t;
#define tulip_CSR10_default 0x0
static inline uint32_t tulip_CSR10_VAL_extract(tulip_CSR10_t _regval) __attribute__ ((always_inline));
static inline uint32_t tulip_CSR10_VAL_extract(tulip_CSR10_t _regval)
{
    return((uint32_t )((_regval & 0x3ffff) >> 0));
}

static inline tulip_CSR10_t tulip_CSR10_VAL_insert(tulip_CSR10_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR10_t tulip_CSR10_VAL_insert(tulip_CSR10_t _regval, uint32_t _fieldval)
{
    return((_regval & 0xfffc0000) | (0x3ffff & (((tulip_CSR10_t )(_fieldval)) << 0)));
}

static inline int tulip_CSR10_prtval(char *_s, size_t _size, tulip_CSR10_t _regval) __attribute__ ((always_inline));
static inline int tulip_CSR10_prtval(char *_s, size_t _size, tulip_CSR10_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " VAL =\t%" PRIx32 "\t(Boot ROM address)\n", tulip_CSR10_VAL_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: tulip_CSR11_t
 * Description: Implicit type of General-purpose timer register
 * Fields:
 *   VAL	(size 16, offset 0, init 0):	RW	Timer value
 *   CON	(size 1, offset 16, init 0):	RW	Continuous mode
 *   _anon17	(size 15, offset 17, init 0):	MBZ	_
 */
typedef uint32_t tulip_CSR11_t;
#define tulip_CSR11_default 0x0
static inline uint16_t tulip_CSR11_VAL_extract(tulip_CSR11_t _regval) __attribute__ ((always_inline));
static inline uint16_t tulip_CSR11_VAL_extract(tulip_CSR11_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline tulip_CSR11_t tulip_CSR11_VAL_insert(tulip_CSR11_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR11_t tulip_CSR11_VAL_insert(tulip_CSR11_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((tulip_CSR11_t )(_fieldval)) << 0)));
}

static inline uint8_t tulip_CSR11_CON_extract(tulip_CSR11_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR11_CON_extract(tulip_CSR11_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline tulip_CSR11_t tulip_CSR11_CON_insert(tulip_CSR11_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR11_t tulip_CSR11_CON_insert(tulip_CSR11_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((tulip_CSR11_t )(_fieldval)) << 16)));
}

static inline int tulip_CSR11_prtval(char *_s, size_t _size, tulip_CSR11_t _regval) __attribute__ ((always_inline));
static inline int tulip_CSR11_prtval(char *_s, size_t _size, tulip_CSR11_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " VAL =\t%" PRIx16 "\t(Timer value)\n", tulip_CSR11_VAL_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " CON =\t%" PRIx8 "\t(Continuous mode)\n", tulip_CSR11_CON_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: tulip_CSR12_t
 * Description: Implicit type of General purpose port register
 * Fields:
 *   MD	(size 8, offset 0, init 0):	RW	General-purpose mode and data
 *   GPC	(size 1, offset 8, init 0):	RW	General-purpose control
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
typedef uint32_t tulip_CSR12_t;
#define tulip_CSR12_default 0x0
static inline uint8_t tulip_CSR12_MD_extract(tulip_CSR12_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR12_MD_extract(tulip_CSR12_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline tulip_CSR12_t tulip_CSR12_MD_insert(tulip_CSR12_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR12_t tulip_CSR12_MD_insert(tulip_CSR12_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((tulip_CSR12_t )(_fieldval)) << 0)));
}

static inline uint8_t tulip_CSR12_GPC_extract(tulip_CSR12_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR12_GPC_extract(tulip_CSR12_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline tulip_CSR12_t tulip_CSR12_GPC_insert(tulip_CSR12_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR12_t tulip_CSR12_GPC_insert(tulip_CSR12_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((tulip_CSR12_t )(_fieldval)) << 8)));
}

static inline int tulip_CSR12_prtval(char *_s, size_t _size, tulip_CSR12_t _regval) __attribute__ ((always_inline));
static inline int tulip_CSR12_prtval(char *_s, size_t _size, tulip_CSR12_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " MD =\t%" PRIx8 "\t(General-purpose mode and data)\n", tulip_CSR12_MD_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " GPC =\t%" PRIx8 "\t(General-purpose control)\n", tulip_CSR12_GPC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: tulip_CSR15_t
 * Description: Implicit type of Watchdog timer register
 * Fields:
 *   JBD	(size 1, offset 0, init 0):	RW	Jabber disable
 *   HUJ	(size 1, offset 1, init 0):	RW	Host unjab
 *   JCK	(size 1, offset 2, init 0):	RW	Jabber clock
 *   _anon3	(size 1, offset 3, init 0):	MBZ	_
 *   RWD	(size 1, offset 4, init 0):	RW	Receive watchdog disable
 *   RWR	(size 1, offset 5, init 0):	RW	Receive watchdog release
 *   _anon6	(size 26, offset 6, init 0):	RSVD	_
 */
typedef uint32_t tulip_CSR15_t;
#define tulip_CSR15_default 0x0
static inline uint8_t tulip_CSR15_JBD_extract(tulip_CSR15_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR15_JBD_extract(tulip_CSR15_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline tulip_CSR15_t tulip_CSR15_JBD_insert(tulip_CSR15_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR15_t tulip_CSR15_JBD_insert(tulip_CSR15_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((tulip_CSR15_t )(_fieldval)) << 0)));
}

static inline uint8_t tulip_CSR15_HUJ_extract(tulip_CSR15_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR15_HUJ_extract(tulip_CSR15_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline tulip_CSR15_t tulip_CSR15_HUJ_insert(tulip_CSR15_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR15_t tulip_CSR15_HUJ_insert(tulip_CSR15_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((tulip_CSR15_t )(_fieldval)) << 1)));
}

static inline uint8_t tulip_CSR15_JCK_extract(tulip_CSR15_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR15_JCK_extract(tulip_CSR15_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline tulip_CSR15_t tulip_CSR15_JCK_insert(tulip_CSR15_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR15_t tulip_CSR15_JCK_insert(tulip_CSR15_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((tulip_CSR15_t )(_fieldval)) << 2)));
}

static inline uint8_t tulip_CSR15_RWD_extract(tulip_CSR15_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR15_RWD_extract(tulip_CSR15_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline tulip_CSR15_t tulip_CSR15_RWD_insert(tulip_CSR15_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR15_t tulip_CSR15_RWD_insert(tulip_CSR15_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((tulip_CSR15_t )(_fieldval)) << 4)));
}

static inline uint8_t tulip_CSR15_RWR_extract(tulip_CSR15_t _regval) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR15_RWR_extract(tulip_CSR15_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline tulip_CSR15_t tulip_CSR15_RWR_insert(tulip_CSR15_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline tulip_CSR15_t tulip_CSR15_RWR_insert(tulip_CSR15_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((tulip_CSR15_t )(_fieldval)) << 5)));
}

static inline int tulip_CSR15_prtval(char *_s, size_t _size, tulip_CSR15_t _regval) __attribute__ ((always_inline));
static inline int tulip_CSR15_prtval(char *_s, size_t _size, tulip_CSR15_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " JBD =\t%" PRIx8 "\t(Jabber disable)\n", tulip_CSR15_JBD_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " HUJ =\t%" PRIx8 "\t(Host unjab)\n", tulip_CSR15_HUJ_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " JCK =\t%" PRIx8 "\t(Jabber clock)\n", tulip_CSR15_JCK_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RWD =\t%" PRIx8 "\t(Receive watchdog disable)\n", tulip_CSR15_RWD_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RWR =\t%" PRIx8 "\t(Receive watchdog release)\n", tulip_CSR15_RWR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: tulip_RDES_t
 * Description: Receive descriptor
 * Fields:
 *   ZERO	(size 1, offset 0, init 0):	RW	Zero
 *   CE	(size 1, offset 1, init 0):	RW	CRC error
 *   DB	(size 1, offset 2, init 0):	RW	Dribbling bit
 *   RE	(size 1, offset 3, init 0):	RW	Report on MII error
 *   RW	(size 1, offset 4, init 0):	RW	Receive watchdog
 *   FT	(size 1, offset 5, init 0):	RW	Frame type
 *   CS	(size 1, offset 6, init 0):	RW	Collision seen
 *   TL	(size 1, offset 7, init 0):	RW	Frame too long
 *   LS	(size 1, offset 8, init 0):	RW	Last descriptor
 *   FS	(size 1, offset 9, init 0):	RW	First descriptor
 *   MF	(size 1, offset 10, init 0):	RW	Muticast frame
 *   RF	(size 1, offset 11, init 0):	RW	Runt Frame
 *   DT	(size 2, offset 12, init 0):	RW	Data type
 *   DE	(size 1, offset 14, init 0):	RW	Descriptor error
 *   ES	(size 1, offset 15, init 0):	RW	Error summary
 *   FL	(size 14, offset 16, init 0):	RW	Frame length
 *   FF	(size 1, offset 30, init 0):	RW	Filtering fail
 *   OWN	(size 1, offset 31, init 0):	RW	Own bit
 *   RBS1	(size 11, offset 32, init 0):	RW	Buffer 1 size
 *   RBS2	(size 11, offset 43, init 0):	RW	Buffer 2 size
 *   _anon54	(size 2, offset 54, init 0):	RSVD	_
 *   RCH	(size 1, offset 56, init 0):	RW	Second address chained
 *   RER	(size 1, offset 57, init 0):	RW	Receive end of ring
 *   _anon58	(size 6, offset 58, init 0):	RSVD	_
 *   RBA1	(size 32, offset 64, init 0):	RW	Buffer address 1
 *   RBA2	(size 32, offset 96, init 0):	RW	Buffer address 2
 */
typedef uint8_t *tulip_RDES_t;
typedef uint8_t tulip_RDES_array_t[16];
static const size_t tulip_RDES_size = sizeof(tulip_RDES_array_t );
static inline uint8_t tulip_RDES_ZERO_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_ZERO_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x1) >> 0);
}

static inline void tulip_RDES_ZERO_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_ZERO_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t tulip_RDES_CE_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_CE_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x2) >> 1);
}

static inline void tulip_RDES_CE_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_CE_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t tulip_RDES_DB_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_DB_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x4) >> 2);
}

static inline void tulip_RDES_DB_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_DB_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t tulip_RDES_RE_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_RE_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x8) >> 3);
}

static inline void tulip_RDES_RE_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_RE_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xf7) | (0x8 & (_fieldval << 3)));
}

static inline uint8_t tulip_RDES_RW_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_RW_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x10) >> 4);
}

static inline void tulip_RDES_RW_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_RW_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xef) | (0x10 & (_fieldval << 4)));
}

static inline uint8_t tulip_RDES_FT_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_FT_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x20) >> 5);
}

static inline void tulip_RDES_FT_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_FT_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xdf) | (0x20 & (_fieldval << 5)));
}

static inline uint8_t tulip_RDES_CS_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_CS_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x40) >> 6);
}

static inline void tulip_RDES_CS_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_CS_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t tulip_RDES_TL_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_TL_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x80) >> 7);
}

static inline void tulip_RDES_TL_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_TL_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint8_t tulip_RDES_LS_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_LS_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x1) >> 0);
}

static inline void tulip_RDES_LS_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_LS_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t tulip_RDES_FS_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_FS_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x2) >> 1);
}

static inline void tulip_RDES_FS_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_FS_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t tulip_RDES_MF_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_MF_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x4) >> 2);
}

static inline void tulip_RDES_MF_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_MF_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t tulip_RDES_RF_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_RF_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x8) >> 3);
}

static inline void tulip_RDES_RF_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_RF_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xf7) | (0x8 & (_fieldval << 3)));
}

static inline tulip_FRAMEDTYPE_t tulip_RDES_DT_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline tulip_FRAMEDTYPE_t tulip_RDES_DT_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x30) >> 4);
}

static inline void tulip_RDES_DT_insert(tulip_RDES_t _dtptr, tulip_FRAMEDTYPE_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_DT_insert(tulip_RDES_t _dtptr, tulip_FRAMEDTYPE_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xcf) | (0x30 & (_fieldval << 4)));
}

static inline uint8_t tulip_RDES_DE_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_DE_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x40) >> 6);
}

static inline void tulip_RDES_DE_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_DE_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t tulip_RDES_ES_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_ES_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x80) >> 7);
}

static inline void tulip_RDES_ES_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_ES_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint16_t tulip_RDES_FL_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t tulip_RDES_FL_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint16_t *)(2 + _dtptr))) & 0x3fff) >> 0);
}

static inline void tulip_RDES_FL_insert(tulip_RDES_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_FL_insert(tulip_RDES_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(2 + _dtptr)) = (((*((uint16_t *)(2 + _dtptr))) & 0xc000) | (0x3fff & (_fieldval << 0)));
}

static inline uint8_t tulip_RDES_FF_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_FF_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x40) >> 6);
}

static inline void tulip_RDES_FF_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_FF_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t tulip_RDES_OWN_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_OWN_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x80) >> 7);
}

static inline void tulip_RDES_OWN_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_OWN_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint16_t tulip_RDES_RBS1_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t tulip_RDES_RBS1_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint16_t *)(4 + _dtptr))) & 0x7ff) >> 0);
}

static inline void tulip_RDES_RBS1_insert(tulip_RDES_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_RBS1_insert(tulip_RDES_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(4 + _dtptr)) = (((*((uint16_t *)(4 + _dtptr))) & 0xf800) | (0x7ff & (_fieldval << 0)));
}

static inline uint16_t tulip_RDES_RBS2_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t tulip_RDES_RBS2_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint32_t *)(4 + _dtptr))) & 0x3ff800) >> 11);
}

static inline void tulip_RDES_RBS2_insert(tulip_RDES_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_RBS2_insert(tulip_RDES_t _dtptr, uint16_t _fieldval)
{
    *((uint32_t *)(4 + _dtptr)) = (((*((uint32_t *)(4 + _dtptr))) & 0xffc007ff) | (0x3ff800 & (_fieldval << 11)));
}

static inline uint8_t tulip_RDES_RCH_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_RCH_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(7 + _dtptr))) & 0x1) >> 0);
}

static inline void tulip_RDES_RCH_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_RCH_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(7 + _dtptr)) = (((*((uint8_t *)(7 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t tulip_RDES_RER_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_RDES_RER_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint8_t *)(7 + _dtptr))) & 0x2) >> 1);
}

static inline void tulip_RDES_RER_insert(tulip_RDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_RER_insert(tulip_RDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(7 + _dtptr)) = (((*((uint8_t *)(7 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint32_t tulip_RDES_RBA1_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t tulip_RDES_RBA1_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint32_t *)(8 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void tulip_RDES_RBA1_insert(tulip_RDES_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_RBA1_insert(tulip_RDES_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(8 + _dtptr)) = (((*((uint32_t *)(8 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline uint32_t tulip_RDES_RBA2_extract(tulip_RDES_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t tulip_RDES_RBA2_extract(tulip_RDES_t _dtptr)
{
    return(((*((uint32_t *)(12 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void tulip_RDES_RBA2_insert(tulip_RDES_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_RDES_RBA2_insert(tulip_RDES_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(12 + _dtptr)) = (((*((uint32_t *)(12 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline int tulip_RDES_prtval(char *_s, size_t _size, tulip_RDES_t _regval) __attribute__ ((always_inline));
static inline int tulip_RDES_prtval(char *_s, size_t _size, tulip_RDES_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ZERO =\t%" PRIx8 "\t(Zero)\n", tulip_RDES_ZERO_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " CE =\t%" PRIx8 "\t(CRC error)\n", tulip_RDES_CE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " DB =\t%" PRIx8 "\t(Dribbling bit)\n", tulip_RDES_DB_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RE =\t%" PRIx8 "\t(Report on MII error)\n", tulip_RDES_RE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RW =\t%" PRIx8 "\t(Receive watchdog)\n", tulip_RDES_RW_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FT =\t%" PRIx8 "\t(Frame type)\n", tulip_RDES_FT_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " CS =\t%" PRIx8 "\t(Collision seen)\n", tulip_RDES_CS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TL =\t%" PRIx8 "\t(Frame too long)\n", tulip_RDES_TL_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " LS =\t%" PRIx8 "\t(Last descriptor)\n", tulip_RDES_LS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FS =\t%" PRIx8 "\t(First descriptor)\n", tulip_RDES_FS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " MF =\t%" PRIx8 "\t(Muticast frame)\n", tulip_RDES_MF_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RF =\t%" PRIx8 "\t(Runt Frame)\n", tulip_RDES_RF_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " DT =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_FRAMEDTYPE_prtval(_s + _r, _avail, tulip_RDES_DT_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Data type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " DE =\t%" PRIx8 "\t(Descriptor error)\n", tulip_RDES_DE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ES =\t%" PRIx8 "\t(Error summary)\n", tulip_RDES_ES_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FL =\t%" PRIx16 "\t(Frame length)\n", tulip_RDES_FL_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FF =\t%" PRIx8 "\t(Filtering fail)\n", tulip_RDES_FF_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " OWN =\t%" PRIx8 "\t(Own bit)\n", tulip_RDES_OWN_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RBS1 =\t%" PRIx16 "\t(Buffer 1 size)\n", tulip_RDES_RBS1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RBS2 =\t%" PRIx16 "\t(Buffer 2 size)\n", tulip_RDES_RBS2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RCH =\t%" PRIx8 "\t(Second address chained)\n", tulip_RDES_RCH_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RER =\t%" PRIx8 "\t(Receive end of ring)\n", tulip_RDES_RER_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RBA1 =\t%" PRIx32 "\t(Buffer address 1)\n", tulip_RDES_RBA1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RBA2 =\t%" PRIx32 "\t(Buffer address 2)\n", tulip_RDES_RBA2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: tulip_TDES_t
 * Description: Transmit descriptor
 * Fields:
 *   DE	(size 1, offset 0, init 0):	RW	Deferred
 *   UF	(size 1, offset 1, init 0):	RW	Underflow Error
 *   LF	(size 1, offset 2, init 0):	RW	Link Fail Report
 *   CC	(size 4, offset 3, init 0):	RW	Collision Count
 *   HF	(size 1, offset 7, init 0):	RW	Heartbeat Fail
 *   EC	(size 1, offset 8, init 0):	RW	Excessive Collisions
 *   LC	(size 1, offset 9, init 0):	RW	Late Collision
 *   NC	(size 1, offset 10, init 0):	RW	No Carrier
 *   LO	(size 1, offset 11, init 0):	RW	Loss of Carrier
 *   _anon12	(size 2, offset 12, init 0):	RSVD	_
 *   TO	(size 1, offset 14, init 0):	RW	Transmit jabber timeout
 *   ES	(size 1, offset 15, init 0):	RW	Error summary
 *   _anon16	(size 15, offset 16, init 0):	RSVD	_
 *   OWN	(size 1, offset 31, init 0):	RW	Own bit
 *   TBS1	(size 11, offset 32, init 0):	RW	Buffer 1 Size
 *   TBS2	(size 11, offset 43, init 0):	RW	Buffer 2 Size
 *   FT0	(size 1, offset 54, init 0):	RW	Filtering Type
 *   DPD	(size 1, offset 55, init 0):	RW	Disabled Padding
 *   TCH	(size 1, offset 56, init 0):	RW	Second Address Chained
 *   TER	(size 1, offset 57, init 0):	RW	Transmit End of Ring
 *   AC	(size 1, offset 58, init 0):	RW	Add CRC Disable
 *   SET	(size 1, offset 59, init 0):	RW	Setup Packet
 *   FT1	(size 1, offset 60, init 0):	RW	Filtering Type
 *   FS	(size 1, offset 61, init 0):	RW	First Segment
 *   LS	(size 1, offset 62, init 0):	RW	Last Segment
 *   IC	(size 1, offset 63, init 0):	RW	Interrupt on Completion
 *   TBA1	(size 32, offset 64, init 0):	RW	Buffer address 1
 *   TBA2	(size 32, offset 96, init 0):	RW	Buffer address 2
 */
typedef uint8_t *tulip_TDES_t;
typedef uint8_t tulip_TDES_array_t[16];
static const size_t tulip_TDES_size = sizeof(tulip_TDES_array_t );
static inline uint8_t tulip_TDES_DE_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_DE_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x1) >> 0);
}

static inline void tulip_TDES_DE_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_DE_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t tulip_TDES_UF_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_UF_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x2) >> 1);
}

static inline void tulip_TDES_UF_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_UF_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t tulip_TDES_LF_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_LF_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x4) >> 2);
}

static inline void tulip_TDES_LF_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_LF_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t tulip_TDES_CC_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_CC_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x78) >> 3);
}

static inline void tulip_TDES_CC_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_CC_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0x87) | (0x78 & (_fieldval << 3)));
}

static inline uint8_t tulip_TDES_HF_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_HF_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x80) >> 7);
}

static inline void tulip_TDES_HF_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_HF_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint8_t tulip_TDES_EC_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_EC_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x1) >> 0);
}

static inline void tulip_TDES_EC_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_EC_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t tulip_TDES_LC_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_LC_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x2) >> 1);
}

static inline void tulip_TDES_LC_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_LC_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t tulip_TDES_NC_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_NC_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x4) >> 2);
}

static inline void tulip_TDES_NC_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_NC_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t tulip_TDES_LO_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_LO_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x8) >> 3);
}

static inline void tulip_TDES_LO_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_LO_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xf7) | (0x8 & (_fieldval << 3)));
}

static inline uint8_t tulip_TDES_TO_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_TO_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x40) >> 6);
}

static inline void tulip_TDES_TO_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_TO_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t tulip_TDES_ES_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_ES_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x80) >> 7);
}

static inline void tulip_TDES_ES_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_ES_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint8_t tulip_TDES_OWN_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_OWN_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x80) >> 7);
}

static inline void tulip_TDES_OWN_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_OWN_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint16_t tulip_TDES_TBS1_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t tulip_TDES_TBS1_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint16_t *)(4 + _dtptr))) & 0x7ff) >> 0);
}

static inline void tulip_TDES_TBS1_insert(tulip_TDES_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_TBS1_insert(tulip_TDES_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(4 + _dtptr)) = (((*((uint16_t *)(4 + _dtptr))) & 0xf800) | (0x7ff & (_fieldval << 0)));
}

static inline uint16_t tulip_TDES_TBS2_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t tulip_TDES_TBS2_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint32_t *)(4 + _dtptr))) & 0x3ff800) >> 11);
}

static inline void tulip_TDES_TBS2_insert(tulip_TDES_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_TBS2_insert(tulip_TDES_t _dtptr, uint16_t _fieldval)
{
    *((uint32_t *)(4 + _dtptr)) = (((*((uint32_t *)(4 + _dtptr))) & 0xffc007ff) | (0x3ff800 & (_fieldval << 11)));
}

static inline uint8_t tulip_TDES_FT0_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_FT0_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(6 + _dtptr))) & 0x40) >> 6);
}

static inline void tulip_TDES_FT0_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_FT0_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(6 + _dtptr)) = (((*((uint8_t *)(6 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t tulip_TDES_DPD_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_DPD_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(6 + _dtptr))) & 0x80) >> 7);
}

static inline void tulip_TDES_DPD_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_DPD_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(6 + _dtptr)) = (((*((uint8_t *)(6 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint8_t tulip_TDES_TCH_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_TCH_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(7 + _dtptr))) & 0x1) >> 0);
}

static inline void tulip_TDES_TCH_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_TCH_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(7 + _dtptr)) = (((*((uint8_t *)(7 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t tulip_TDES_TER_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_TER_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(7 + _dtptr))) & 0x2) >> 1);
}

static inline void tulip_TDES_TER_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_TER_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(7 + _dtptr)) = (((*((uint8_t *)(7 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t tulip_TDES_AC_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_AC_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(7 + _dtptr))) & 0x4) >> 2);
}

static inline void tulip_TDES_AC_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_AC_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(7 + _dtptr)) = (((*((uint8_t *)(7 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t tulip_TDES_SET_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_SET_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(7 + _dtptr))) & 0x8) >> 3);
}

static inline void tulip_TDES_SET_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_SET_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(7 + _dtptr)) = (((*((uint8_t *)(7 + _dtptr))) & 0xf7) | (0x8 & (_fieldval << 3)));
}

static inline uint8_t tulip_TDES_FT1_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_FT1_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(7 + _dtptr))) & 0x10) >> 4);
}

static inline void tulip_TDES_FT1_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_FT1_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(7 + _dtptr)) = (((*((uint8_t *)(7 + _dtptr))) & 0xef) | (0x10 & (_fieldval << 4)));
}

static inline uint8_t tulip_TDES_FS_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_FS_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(7 + _dtptr))) & 0x20) >> 5);
}

static inline void tulip_TDES_FS_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_FS_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(7 + _dtptr)) = (((*((uint8_t *)(7 + _dtptr))) & 0xdf) | (0x20 & (_fieldval << 5)));
}

static inline uint8_t tulip_TDES_LS_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_LS_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(7 + _dtptr))) & 0x40) >> 6);
}

static inline void tulip_TDES_LS_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_LS_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(7 + _dtptr)) = (((*((uint8_t *)(7 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t tulip_TDES_IC_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t tulip_TDES_IC_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint8_t *)(7 + _dtptr))) & 0x80) >> 7);
}

static inline void tulip_TDES_IC_insert(tulip_TDES_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_IC_insert(tulip_TDES_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(7 + _dtptr)) = (((*((uint8_t *)(7 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint32_t tulip_TDES_TBA1_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t tulip_TDES_TBA1_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint32_t *)(8 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void tulip_TDES_TBA1_insert(tulip_TDES_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_TBA1_insert(tulip_TDES_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(8 + _dtptr)) = (((*((uint32_t *)(8 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline uint32_t tulip_TDES_TBA2_extract(tulip_TDES_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t tulip_TDES_TBA2_extract(tulip_TDES_t _dtptr)
{
    return(((*((uint32_t *)(12 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void tulip_TDES_TBA2_insert(tulip_TDES_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_TDES_TBA2_insert(tulip_TDES_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(12 + _dtptr)) = (((*((uint32_t *)(12 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline int tulip_TDES_prtval(char *_s, size_t _size, tulip_TDES_t _regval) __attribute__ ((always_inline));
static inline int tulip_TDES_prtval(char *_s, size_t _size, tulip_TDES_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " DE =\t%" PRIx8 "\t(Deferred)\n", tulip_TDES_DE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " UF =\t%" PRIx8 "\t(Underflow Error)\n", tulip_TDES_UF_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " LF =\t%" PRIx8 "\t(Link Fail Report)\n", tulip_TDES_LF_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " CC =\t%" PRIx8 "\t(Collision Count)\n", tulip_TDES_CC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " HF =\t%" PRIx8 "\t(Heartbeat Fail)\n", tulip_TDES_HF_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " EC =\t%" PRIx8 "\t(Excessive Collisions)\n", tulip_TDES_EC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " LC =\t%" PRIx8 "\t(Late Collision)\n", tulip_TDES_LC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " NC =\t%" PRIx8 "\t(No Carrier)\n", tulip_TDES_NC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " LO =\t%" PRIx8 "\t(Loss of Carrier)\n", tulip_TDES_LO_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TO =\t%" PRIx8 "\t(Transmit jabber timeout)\n", tulip_TDES_TO_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ES =\t%" PRIx8 "\t(Error summary)\n", tulip_TDES_ES_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " OWN =\t%" PRIx8 "\t(Own bit)\n", tulip_TDES_OWN_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TBS1 =\t%" PRIx16 "\t(Buffer 1 Size)\n", tulip_TDES_TBS1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TBS2 =\t%" PRIx16 "\t(Buffer 2 Size)\n", tulip_TDES_TBS2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FT0 =\t%" PRIx8 "\t(Filtering Type)\n", tulip_TDES_FT0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " DPD =\t%" PRIx8 "\t(Disabled Padding)\n", tulip_TDES_DPD_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TCH =\t%" PRIx8 "\t(Second Address Chained)\n", tulip_TDES_TCH_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TER =\t%" PRIx8 "\t(Transmit End of Ring)\n", tulip_TDES_TER_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " AC =\t%" PRIx8 "\t(Add CRC Disable)\n", tulip_TDES_AC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SET =\t%" PRIx8 "\t(Setup Packet)\n", tulip_TDES_SET_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FT1 =\t%" PRIx8 "\t(Filtering Type)\n", tulip_TDES_FT1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FS =\t%" PRIx8 "\t(First Segment)\n", tulip_TDES_FS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " LS =\t%" PRIx8 "\t(Last Segment)\n", tulip_TDES_LS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " IC =\t%" PRIx8 "\t(Interrupt on Completion)\n", tulip_TDES_IC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TBA1 =\t%" PRIx32 "\t(Buffer address 1)\n", tulip_TDES_TBA1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TBA2 =\t%" PRIx32 "\t(Buffer address 2)\n", tulip_TDES_TBA2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_io_t base;
    uint32_t CSR1_shadow;
    uint32_t CSR2_shadow;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum tulip_initials {
    tulip_CSR0_initial = 0x0,
    tulip_CSR1_initial = 0x0,
    tulip_CSR2_initial = 0x0,
    tulip_CSR3_initial = 0x0,
    tulip_CSR4_initial = 0x0,
    tulip_CSR5_initial = 0x0,
    tulip_CSR6_initial = 0x0,
    tulip_CSR7_initial = 0x0,
    tulip_CSR8_initial = 0x0,
    tulip_CSR9_initial = 0x0,
    tulip_CSR10_initial = 0x0,
    tulip_CSR11_initial = 0x0,
    tulip_CSR12_initial = 0x0,
    tulip_CSR15_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void tulip_initialize(__DN(t) *_dev, mackerel_io_t base) __attribute__ ((always_inline));
static inline void tulip_initialize(__DN(t) *_dev, mackerel_io_t base)
{
    _dev->base = base;
}

/*
 * Register CSR0: Bus mode
 * Type: tulip.CSR0 (Implicit type of Bus mode register)
 *   SWR	(size 1, offset 0, init 0):	RW	Software reset
 *   BAR	(size 1, offset 1, init 0):	RW	Bus arbitration
 *   DSL	(size 5, offset 2, init 0):	RW	Descriptor Skip Length
 *   BLE	(size 1, offset 7, init 0):	RW	Big/little endian
 *   PBL	(size 6, offset 8, init 0):	RW	Programmable burst length
 *   CAL	(size 2, offset 14, init 0):	RW	Cache alignment
 *   _anon16	(size 1, offset 16, init 0):	MBZ	_
 *   TAP	(size 3, offset 17, init 0):	RW	Transmit auto polling
 *   DBO	(size 1, offset 20, init 0):	RW	Descriptor byte ordering mode
 *   RME	(size 1, offset 21, init 0):	RW	Read multiple enable
 *   _anon22	(size 1, offset 22, init 0):	MBZ	_
 *   RLE	(size 1, offset 23, init 0):	RW	Read line enable
 *   WIE	(size 1, offset 24, init 0):	RW	Write and invalidation enable
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
static inline tulip_CSR0_t tulip_CSR0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR0_t tulip_CSR0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x0));
}

static inline tulip_CSR0_t tulip_CSR0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR0_t tulip_CSR0_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x0));
}

static inline void tulip_CSR0_rawwr(__DN(t) *_dev, tulip_CSR0_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR0_rawwr(__DN(t) *_dev, tulip_CSR0_t _regval)
{
    mackerel_write_io_32(_dev->base, 0x0, _regval);
}

static inline void tulip_CSR0_wr(__DN(t) *_dev, tulip_CSR0_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR0_wr(__DN(t) *_dev, tulip_CSR0_t _regval)
{
    _regval = (_regval & 0x1beffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_32(_dev->base, 0x0, _regval);
}

static inline int tulip_CSR0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int tulip_CSR0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    tulip_CSR0_t _regval = mackerel_read_io_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register CSR0 (Bus mode): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SWR =\t%" PRIx8 "\t(Software reset)\n", tulip_CSR0_SWR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " BAR =\t%" PRIx8 "\t(Bus arbitration)\n", tulip_CSR0_BAR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " DSL =\t%" PRIx8 "\t(Descriptor Skip Length)\n", tulip_CSR0_DSL_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " BLE =\t%" PRIx8 "\t(Big/little endian)\n", tulip_CSR0_BLE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " PBL =\t%" PRIx8 "\t(Programmable burst length)\n", tulip_CSR0_PBL_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " CAL =\t%" PRIx8 "\t(Cache alignment)\n", tulip_CSR0_CAL_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TAP =\t%" PRIx8 "\t(Transmit auto polling)\n", tulip_CSR0_TAP_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " DBO =\t%" PRIx8 "\t(Descriptor byte ordering mode)\n", tulip_CSR0_DBO_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RME =\t%" PRIx8 "\t(Read multiple enable)\n", tulip_CSR0_RME_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RLE =\t%" PRIx8 "\t(Read line enable)\n", tulip_CSR0_RLE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " WIE =\t%" PRIx8 "\t(Write and invalidation enable)\n", tulip_CSR0_WIE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    return(_r);
}

static inline uint8_t tulip_CSR0_SWR_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_SWR_rdf(__DN(t) *_dev)
{
    tulip_CSR0_t _regval = mackerel_read_io_32(_dev->base, 0x0);
    return(tulip_CSR0_SWR_extract(_regval));
}

static inline uint8_t tulip_CSR0_BAR_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_BAR_rdf(__DN(t) *_dev)
{
    tulip_CSR0_t _regval = mackerel_read_io_32(_dev->base, 0x0);
    return(tulip_CSR0_BAR_extract(_regval));
}

static inline uint8_t tulip_CSR0_DSL_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_DSL_rdf(__DN(t) *_dev)
{
    tulip_CSR0_t _regval = mackerel_read_io_32(_dev->base, 0x0);
    return(tulip_CSR0_DSL_extract(_regval));
}

static inline uint8_t tulip_CSR0_BLE_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_BLE_rdf(__DN(t) *_dev)
{
    tulip_CSR0_t _regval = mackerel_read_io_32(_dev->base, 0x0);
    return(tulip_CSR0_BLE_extract(_regval));
}

static inline uint8_t tulip_CSR0_PBL_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_PBL_rdf(__DN(t) *_dev)
{
    tulip_CSR0_t _regval = mackerel_read_io_32(_dev->base, 0x0);
    return(tulip_CSR0_PBL_extract(_regval));
}

static inline uint8_t tulip_CSR0_CAL_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_CAL_rdf(__DN(t) *_dev)
{
    tulip_CSR0_t _regval = mackerel_read_io_32(_dev->base, 0x0);
    return(tulip_CSR0_CAL_extract(_regval));
}

static inline uint8_t tulip_CSR0_TAP_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_TAP_rdf(__DN(t) *_dev)
{
    tulip_CSR0_t _regval = mackerel_read_io_32(_dev->base, 0x0);
    return(tulip_CSR0_TAP_extract(_regval));
}

static inline uint8_t tulip_CSR0_DBO_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_DBO_rdf(__DN(t) *_dev)
{
    tulip_CSR0_t _regval = mackerel_read_io_32(_dev->base, 0x0);
    return(tulip_CSR0_DBO_extract(_regval));
}

static inline uint8_t tulip_CSR0_RME_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_RME_rdf(__DN(t) *_dev)
{
    tulip_CSR0_t _regval = mackerel_read_io_32(_dev->base, 0x0);
    return(tulip_CSR0_RME_extract(_regval));
}

static inline uint8_t tulip_CSR0_RLE_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_RLE_rdf(__DN(t) *_dev)
{
    tulip_CSR0_t _regval = mackerel_read_io_32(_dev->base, 0x0);
    return(tulip_CSR0_RLE_extract(_regval));
}

static inline uint8_t tulip_CSR0_WIE_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR0_WIE_rdf(__DN(t) *_dev)
{
    tulip_CSR0_t _regval = mackerel_read_io_32(_dev->base, 0x0);
    return(tulip_CSR0_WIE_extract(_regval));
}

static inline void tulip_CSR0_SWR_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR0_SWR_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR0_t _regval = 0x1 & (((tulip_CSR0_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1befffe & mackerel_read_io_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0x1beffff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR0_BAR_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR0_BAR_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR0_t _regval = 0x2 & (((tulip_CSR0_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1befffd & mackerel_read_io_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0x1beffff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR0_DSL_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR0_DSL_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR0_t _regval = 0x7c & (((tulip_CSR0_t )(_fieldval)) << 2);
    _regval = (_regval | (0x1beff83 & mackerel_read_io_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0x1beffff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR0_BLE_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR0_BLE_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR0_t _regval = 0x80 & (((tulip_CSR0_t )(_fieldval)) << 7);
    _regval = (_regval | (0x1beff7f & mackerel_read_io_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0x1beffff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR0_PBL_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR0_PBL_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR0_t _regval = 0x3f00 & (((tulip_CSR0_t )(_fieldval)) << 8);
    _regval = (_regval | (0x1bec0ff & mackerel_read_io_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0x1beffff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR0_CAL_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR0_CAL_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR0_t _regval = 0xc000 & (((tulip_CSR0_t )(_fieldval)) << 14);
    _regval = (_regval | (0x1be3fff & mackerel_read_io_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0x1beffff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR0_TAP_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR0_TAP_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR0_t _regval = 0xe0000 & (((tulip_CSR0_t )(_fieldval)) << 17);
    _regval = (_regval | (0x1b0ffff & mackerel_read_io_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0x1beffff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR0_DBO_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR0_DBO_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR0_t _regval = 0x100000 & (((tulip_CSR0_t )(_fieldval)) << 20);
    _regval = (_regval | (0x1aeffff & mackerel_read_io_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0x1beffff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR0_RME_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR0_RME_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR0_t _regval = 0x200000 & (((tulip_CSR0_t )(_fieldval)) << 21);
    _regval = (_regval | (0x19effff & mackerel_read_io_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0x1beffff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR0_RLE_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR0_RLE_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR0_t _regval = 0x800000 & (((tulip_CSR0_t )(_fieldval)) << 23);
    _regval = (_regval | (0x13effff & mackerel_read_io_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0x1beffff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR0_WIE_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR0_WIE_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR0_t _regval = 0x1000000 & (((tulip_CSR0_t )(_fieldval)) << 24);
    _regval = (_regval | (0xbeffff & mackerel_read_io_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0x1beffff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register CSR1: Transmit poll demand
 * Type: tulip.uint32 (primitive type)
 */
static inline uint32_t tulip_CSR1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t tulip_CSR1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x8));
}

static inline uint32_t tulip_CSR1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t tulip_CSR1_rd(__DN(t) *_dev)
{
    return(_dev->CSR1_shadow);
}

static inline void tulip_CSR1_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR1_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_io_32(_dev->base, 0x8, _regval);
}

static inline void tulip_CSR1_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR1_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_32(_dev->base, 0x8, _regval);
}

static inline int tulip_CSR1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int tulip_CSR1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = _dev->CSR1_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register CSR1 (Transmit poll demand): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 " (SHADOW copy)\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register CSR2: Receive poll demand
 * Type: tulip.uint32 (primitive type)
 */
static inline uint32_t tulip_CSR2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t tulip_CSR2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x10));
}

static inline uint32_t tulip_CSR2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t tulip_CSR2_rd(__DN(t) *_dev)
{
    return(_dev->CSR2_shadow);
}

static inline void tulip_CSR2_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR2_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_io_32(_dev->base, 0x10, _regval);
}

static inline void tulip_CSR2_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR2_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_32(_dev->base, 0x10, _regval);
}

static inline int tulip_CSR2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int tulip_CSR2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = _dev->CSR2_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register CSR2 (Receive poll demand): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 " (SHADOW copy)\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register CSR3: Receive list base address
 * Type: tulip.uint32 (primitive type)
 */
static inline uint32_t tulip_CSR3_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t tulip_CSR3_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x18));
}

static inline uint32_t tulip_CSR3_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t tulip_CSR3_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x18));
}

static inline void tulip_CSR3_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR3_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_io_32(_dev->base, 0x18, _regval);
}

static inline void tulip_CSR3_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR3_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_32(_dev->base, 0x18, _regval);
}

static inline int tulip_CSR3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int tulip_CSR3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_io_32(_dev->base, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register CSR3 (Receive list base address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register CSR4: Transmit list base address
 * Type: tulip.uint32 (primitive type)
 */
static inline uint32_t tulip_CSR4_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t tulip_CSR4_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x20));
}

static inline uint32_t tulip_CSR4_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t tulip_CSR4_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x20));
}

static inline void tulip_CSR4_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR4_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_io_32(_dev->base, 0x20, _regval);
}

static inline void tulip_CSR4_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR4_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_32(_dev->base, 0x20, _regval);
}

static inline int tulip_CSR4_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int tulip_CSR4_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_io_32(_dev->base, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register CSR4 (Transmit list base address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register CSR5: Status
 * Type: tulip.CSR5 (Implicit type of Status register)
 *   TI	(size 1, offset 0, init 0):	RWC	Transmit interrupt
 *   TPS	(size 1, offset 1, init 0):	RWC	Transmit process stopped
 *   TU	(size 1, offset 2, init 0):	RWC	Transmit buffer unavailable
 *   TJT	(size 1, offset 3, init 0):	RWC	Transmit jabber timeout
 *   _anon4	(size 1, offset 4, init 0):	MBZ	_
 *   UNF	(size 1, offset 5, init 0):	RWC	Transmit underflow
 *   RI	(size 1, offset 6, init 0):	RWC	Receive interrupt
 *   RU	(size 1, offset 7, init 0):	RWC	Receive buffer unavailable
 *   RPS	(size 1, offset 8, init 0):	RWC	Receive process stopped
 *   RWT	(size 1, offset 9, init 0):	RWC	Receive watchdog timeout
 *   ETI	(size 1, offset 10, init 0):	RWC	Early termination timeout
 *   GTE	(size 1, offset 11, init 0):	RWC	General-purpose timer expired
 *   _anon12	(size 1, offset 12, init 0):	MBZ	_
 *   FBE	(size 1, offset 13, init 0):	RWC	Fatal bus error
 *   ERI	(size 1, offset 14, init 0):	RWC	Early receive interrupt
 *   AIS	(size 1, offset 15, init 0):	RWC	Abnormal interrupt summary
 *   NIS	(size 1, offset 16, init 0):	RWC	Normal interrupt summary
 *   RS	(size 3, offset 17, init 0):	RO	Receive process state
 *   TS	(size 3, offset 20, init 0):	RO	Transmission process state
 *   EB	(size 3, offset 23, init 0):	RO	Error bits
 *   _anon26	(size 6, offset 26, init 0):	MBZ	_
 */
static inline tulip_CSR5_t tulip_CSR5_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x28));
}

static inline tulip_CSR5_t tulip_CSR5_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR5_t tulip_CSR5_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x28));
}

static inline void tulip_CSR5_rawwr(__DN(t) *_dev, tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR5_rawwr(__DN(t) *_dev, tulip_CSR5_t _regval)
{
    mackerel_write_io_32(_dev->base, 0x28, _regval);
}

static inline void tulip_CSR5_wr(__DN(t) *_dev, tulip_CSR5_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR5_wr(__DN(t) *_dev, tulip_CSR5_t _regval)
{
    _regval = (_regval & 0x3ffefef);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_32(_dev->base, 0x28, _regval);
}

static inline int tulip_CSR5_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int tulip_CSR5_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register CSR5 (Status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TI =\t%" PRIx8 "\t(Transmit interrupt)\n", tulip_CSR5_TI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TPS =\t%" PRIx8 "\t(Transmit process stopped)\n", tulip_CSR5_TPS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TU =\t%" PRIx8 "\t(Transmit buffer unavailable)\n", tulip_CSR5_TU_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TJT =\t%" PRIx8 "\t(Transmit jabber timeout)\n", tulip_CSR5_TJT_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " UNF =\t%" PRIx8 "\t(Transmit underflow)\n", tulip_CSR5_UNF_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RI =\t%" PRIx8 "\t(Receive interrupt)\n", tulip_CSR5_RI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RU =\t%" PRIx8 "\t(Receive buffer unavailable)\n", tulip_CSR5_RU_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RPS =\t%" PRIx8 "\t(Receive process stopped)\n", tulip_CSR5_RPS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RWT =\t%" PRIx8 "\t(Receive watchdog timeout)\n", tulip_CSR5_RWT_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ETI =\t%" PRIx8 "\t(Early termination timeout)\n", tulip_CSR5_ETI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " GTE =\t%" PRIx8 "\t(General-purpose timer expired)\n", tulip_CSR5_GTE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FBE =\t%" PRIx8 "\t(Fatal bus error)\n", tulip_CSR5_FBE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ERI =\t%" PRIx8 "\t(Early receive interrupt)\n", tulip_CSR5_ERI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " AIS =\t%" PRIx8 "\t(Abnormal interrupt summary)\n", tulip_CSR5_AIS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " NIS =\t%" PRIx8 "\t(Normal interrupt summary)\n", tulip_CSR5_NIS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RS =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_RPROCSTATE_prtval(_s + _r, _avail, tulip_CSR5_RS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Receive process state)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TS =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_TPROCSTATE_prtval(_s + _r, _avail, tulip_CSR5_TS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Transmission process state)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " EB =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_FBEBITS_prtval(_s + _r, _avail, tulip_CSR5_EB_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Error bits)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    return(_r);
}

static inline uint8_t tulip_CSR5_TI_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_TI_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_TI_extract(_regval));
}

static inline uint8_t tulip_CSR5_TPS_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_TPS_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_TPS_extract(_regval));
}

static inline uint8_t tulip_CSR5_TU_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_TU_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_TU_extract(_regval));
}

static inline uint8_t tulip_CSR5_TJT_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_TJT_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_TJT_extract(_regval));
}

static inline uint8_t tulip_CSR5_UNF_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_UNF_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_UNF_extract(_regval));
}

static inline uint8_t tulip_CSR5_RI_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_RI_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_RI_extract(_regval));
}

static inline uint8_t tulip_CSR5_RU_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_RU_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_RU_extract(_regval));
}

static inline uint8_t tulip_CSR5_RPS_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_RPS_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_RPS_extract(_regval));
}

static inline uint8_t tulip_CSR5_RWT_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_RWT_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_RWT_extract(_regval));
}

static inline uint8_t tulip_CSR5_ETI_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_ETI_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_ETI_extract(_regval));
}

static inline uint8_t tulip_CSR5_GTE_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_GTE_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_GTE_extract(_regval));
}

static inline uint8_t tulip_CSR5_FBE_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_FBE_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_FBE_extract(_regval));
}

static inline uint8_t tulip_CSR5_ERI_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_ERI_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_ERI_extract(_regval));
}

static inline uint8_t tulip_CSR5_AIS_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_AIS_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_AIS_extract(_regval));
}

static inline uint8_t tulip_CSR5_NIS_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR5_NIS_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_NIS_extract(_regval));
}

static inline tulip_RPROCSTATE_t tulip_CSR5_RS_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_RPROCSTATE_t tulip_CSR5_RS_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_RS_extract(_regval));
}

static inline tulip_TPROCSTATE_t tulip_CSR5_TS_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_TPROCSTATE_t tulip_CSR5_TS_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_TS_extract(_regval));
}

static inline tulip_FBEBITS_t tulip_CSR5_EB_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_FBEBITS_t tulip_CSR5_EB_rdf(__DN(t) *_dev)
{
    tulip_CSR5_t _regval = mackerel_read_io_32(_dev->base, 0x28);
    return(tulip_CSR5_EB_extract(_regval));
}

static inline void tulip_CSR5_TI_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR5_TI_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR5_t _regval = 0x1 & (((tulip_CSR5_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ffefef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR5_TPS_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR5_TPS_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR5_t _regval = 0x2 & (((tulip_CSR5_t )(_fieldval)) << 1);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ffefef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR5_TU_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR5_TU_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR5_t _regval = 0x4 & (((tulip_CSR5_t )(_fieldval)) << 2);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ffefef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR5_TJT_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR5_TJT_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR5_t _regval = 0x8 & (((tulip_CSR5_t )(_fieldval)) << 3);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ffefef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR5_UNF_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR5_UNF_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR5_t _regval = 0x20 & (((tulip_CSR5_t )(_fieldval)) << 5);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ffefef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR5_RI_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR5_RI_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR5_t _regval = 0x40 & (((tulip_CSR5_t )(_fieldval)) << 6);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ffefef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR5_RU_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR5_RU_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR5_t _regval = 0x80 & (((tulip_CSR5_t )(_fieldval)) << 7);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ffefef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR5_RPS_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR5_RPS_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR5_t _regval = 0x100 & (((tulip_CSR5_t )(_fieldval)) << 8);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ffefef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR5_RWT_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR5_RWT_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR5_t _regval = 0x200 & (((tulip_CSR5_t )(_fieldval)) << 9);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ffefef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR5_ETI_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR5_ETI_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR5_t _regval = 0x400 & (((tulip_CSR5_t )(_fieldval)) << 10);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ffefef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR5_GTE_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR5_GTE_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR5_t _regval = 0x800 & (((tulip_CSR5_t )(_fieldval)) << 11);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ffefef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR5_FBE_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR5_FBE_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR5_t _regval = 0x2000 & (((tulip_CSR5_t )(_fieldval)) << 13);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ffefef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR5_ERI_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR5_ERI_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR5_t _regval = 0x4000 & (((tulip_CSR5_t )(_fieldval)) << 14);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ffefef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR5_AIS_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR5_AIS_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR5_t _regval = 0x8000 & (((tulip_CSR5_t )(_fieldval)) << 15);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ffefef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR5_NIS_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR5_NIS_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR5_t _regval = 0x10000 & (((tulip_CSR5_t )(_fieldval)) << 16);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ffefef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

/*
 * Register CSR6: Operating mode
 * Type: tulip.CSR6 (Implicit type of Operating mode register)
 *   HP	(size 1, offset 0, init 0):	RW	Hash/perfect recieve filtering mode
 *   SR	(size 1, offset 1, init 0):	RW	Start/stop receive
 *   HO	(size 1, offset 2, init 0):	RW	Hash-only filtering mode
 *   PB	(size 1, offset 3, init 0):	RW	Pass bad frames
 *   IF	(size 1, offset 4, init 0):	RW	Inverse filtering
 *   SB	(size 1, offset 5, init 0):	RW	Start/stop backoff counter
 *   PR	(size 1, offset 6, init 0):	RW	Promiscuous mode
 *   PM	(size 1, offset 7, init 0):	RW	Pass all multicast
 *   _anon8	(size 1, offset 8, init 0):	MBZ	_
 *   FD	(size 1, offset 9, init 0):	RW	Full-duplex mode
 *   OM	(size 2, offset 10, init 0):	RW	Operating mode
 *   FC	(size 1, offset 12, init 0):	RW	Force collision mode
 *   ST	(size 1, offset 13, init 0):	RW	Start/stop transmission command
 *   TR	(size 2, offset 14, init 0):	RW	Threshold control bits
 *   _anon16	(size 1, offset 16, init 0):	MBZ	_
 *   CA	(size 1, offset 17, init 0):	RW	Capture effect enable
 *   PS	(size 1, offset 18, init 0):	RW	Port select
 *   HBD	(size 1, offset 19, init 0):	RW	Heartbeat disable
 *   _anon20	(size 1, offset 20, init 0):	MBZ	_
 *   SF	(size 1, offset 21, init 0):	RW	Store and forward
 *   TTM	(size 1, offset 22, init 0):	RW	Transmit threshold mode
 *   PCS	(size 1, offset 23, init 0):	RW	PCS function
 *   SCR	(size 1, offset 24, init 0):	RW	Scrambler mode
 *   _anon25	(size 1, offset 25, init 1):	MB1	_
 *   _anon26	(size 4, offset 26, init 0):	MBZ	_
 *   RA	(size 1, offset 30, init 0):	RW	Receive all
 *   SC	(size 1, offset 31, init 0):	RW	Special capture effect enable
 */
static inline tulip_CSR6_t tulip_CSR6_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x30));
}

static inline tulip_CSR6_t tulip_CSR6_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR6_t tulip_CSR6_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x30));
}

static inline void tulip_CSR6_rawwr(__DN(t) *_dev, tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR6_rawwr(__DN(t) *_dev, tulip_CSR6_t _regval)
{
    mackerel_write_io_32(_dev->base, 0x30, _regval);
}

static inline void tulip_CSR6_wr(__DN(t) *_dev, tulip_CSR6_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR6_wr(__DN(t) *_dev, tulip_CSR6_t _regval)
{
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    // No pre-read of register required
    mackerel_write_io_32(_dev->base, 0x30, _regval);
}

static inline int tulip_CSR6_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int tulip_CSR6_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register CSR6 (Operating mode): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " HP =\t%" PRIx8 "\t(Hash/perfect recieve filtering mode)\n", tulip_CSR6_HP_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SR =\t%" PRIx8 "\t(Start/stop receive)\n", tulip_CSR6_SR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " HO =\t%" PRIx8 "\t(Hash-only filtering mode)\n", tulip_CSR6_HO_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " PB =\t%" PRIx8 "\t(Pass bad frames)\n", tulip_CSR6_PB_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " IF =\t%" PRIx8 "\t(Inverse filtering)\n", tulip_CSR6_IF_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SB =\t%" PRIx8 "\t(Start/stop backoff counter)\n", tulip_CSR6_SB_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " PR =\t%" PRIx8 "\t(Promiscuous mode)\n", tulip_CSR6_PR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " PM =\t%" PRIx8 "\t(Pass all multicast)\n", tulip_CSR6_PM_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FD =\t%" PRIx8 "\t(Full-duplex mode)\n", tulip_CSR6_FD_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " OM =\t%" PRIx8 "\t(Operating mode)\n", tulip_CSR6_OM_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FC =\t%" PRIx8 "\t(Force collision mode)\n", tulip_CSR6_FC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ST =\t%" PRIx8 "\t(Start/stop transmission command)\n", tulip_CSR6_ST_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TR =\t%" PRIx8 "\t(Threshold control bits)\n", tulip_CSR6_TR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " CA =\t%" PRIx8 "\t(Capture effect enable)\n", tulip_CSR6_CA_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " PS =\t%" PRIx8 "\t(Port select)\n", tulip_CSR6_PS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " HBD =\t%" PRIx8 "\t(Heartbeat disable)\n", tulip_CSR6_HBD_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SF =\t%" PRIx8 "\t(Store and forward)\n", tulip_CSR6_SF_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TTM =\t%" PRIx8 "\t(Transmit threshold mode)\n", tulip_CSR6_TTM_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " PCS =\t%" PRIx8 "\t(PCS function)\n", tulip_CSR6_PCS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SCR =\t%" PRIx8 "\t(Scrambler mode)\n", tulip_CSR6_SCR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    // _anon26 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RA =\t%" PRIx8 "\t(Receive all)\n", tulip_CSR6_RA_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SC =\t%" PRIx8 "\t(Special capture effect enable)\n", tulip_CSR6_SC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t tulip_CSR6_HP_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_HP_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_HP_extract(_regval));
}

static inline uint8_t tulip_CSR6_SR_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_SR_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_SR_extract(_regval));
}

static inline uint8_t tulip_CSR6_HO_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_HO_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_HO_extract(_regval));
}

static inline uint8_t tulip_CSR6_PB_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_PB_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_PB_extract(_regval));
}

static inline uint8_t tulip_CSR6_IF_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_IF_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_IF_extract(_regval));
}

static inline uint8_t tulip_CSR6_SB_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_SB_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_SB_extract(_regval));
}

static inline uint8_t tulip_CSR6_PR_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_PR_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_PR_extract(_regval));
}

static inline uint8_t tulip_CSR6_PM_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_PM_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_PM_extract(_regval));
}

static inline uint8_t tulip_CSR6_FD_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_FD_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_FD_extract(_regval));
}

static inline uint8_t tulip_CSR6_OM_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_OM_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_OM_extract(_regval));
}

static inline uint8_t tulip_CSR6_FC_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_FC_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_FC_extract(_regval));
}

static inline uint8_t tulip_CSR6_ST_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_ST_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_ST_extract(_regval));
}

static inline uint8_t tulip_CSR6_TR_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_TR_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_TR_extract(_regval));
}

static inline uint8_t tulip_CSR6_CA_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_CA_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_CA_extract(_regval));
}

static inline uint8_t tulip_CSR6_PS_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_PS_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_PS_extract(_regval));
}

static inline uint8_t tulip_CSR6_HBD_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_HBD_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_HBD_extract(_regval));
}

static inline uint8_t tulip_CSR6_SF_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_SF_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_SF_extract(_regval));
}

static inline uint8_t tulip_CSR6_TTM_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_TTM_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_TTM_extract(_regval));
}

static inline uint8_t tulip_CSR6_PCS_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_PCS_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_PCS_extract(_regval));
}

static inline uint8_t tulip_CSR6_SCR_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_SCR_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_SCR_extract(_regval));
}

static inline uint8_t tulip_CSR6_RA_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_RA_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_RA_extract(_regval));
}

static inline uint8_t tulip_CSR6_SC_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR6_SC_rdf(__DN(t) *_dev)
{
    tulip_CSR6_t _regval = mackerel_read_io_32(_dev->base, 0x30);
    return(tulip_CSR6_SC_extract(_regval));
}

static inline void tulip_CSR6_HP_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_HP_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x1 & (((tulip_CSR6_t )(_fieldval)) << 0);
    _regval = (_regval | (0xc1eefefe & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_SR_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_SR_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x2 & (((tulip_CSR6_t )(_fieldval)) << 1);
    _regval = (_regval | (0xc1eefefd & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_HO_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_HO_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x4 & (((tulip_CSR6_t )(_fieldval)) << 2);
    _regval = (_regval | (0xc1eefefb & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_PB_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_PB_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x8 & (((tulip_CSR6_t )(_fieldval)) << 3);
    _regval = (_regval | (0xc1eefef7 & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_IF_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_IF_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x10 & (((tulip_CSR6_t )(_fieldval)) << 4);
    _regval = (_regval | (0xc1eefeef & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_SB_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_SB_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x20 & (((tulip_CSR6_t )(_fieldval)) << 5);
    _regval = (_regval | (0xc1eefedf & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_PR_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_PR_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x40 & (((tulip_CSR6_t )(_fieldval)) << 6);
    _regval = (_regval | (0xc1eefebf & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_PM_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_PM_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x80 & (((tulip_CSR6_t )(_fieldval)) << 7);
    _regval = (_regval | (0xc1eefe7f & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_FD_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_FD_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x200 & (((tulip_CSR6_t )(_fieldval)) << 9);
    _regval = (_regval | (0xc1eefcff & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_OM_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_OM_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0xc00 & (((tulip_CSR6_t )(_fieldval)) << 10);
    _regval = (_regval | (0xc1eef2ff & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_FC_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_FC_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x1000 & (((tulip_CSR6_t )(_fieldval)) << 12);
    _regval = (_regval | (0xc1eeeeff & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_ST_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_ST_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x2000 & (((tulip_CSR6_t )(_fieldval)) << 13);
    _regval = (_regval | (0xc1eedeff & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_TR_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_TR_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0xc000 & (((tulip_CSR6_t )(_fieldval)) << 14);
    _regval = (_regval | (0xc1ee3eff & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_CA_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_CA_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x20000 & (((tulip_CSR6_t )(_fieldval)) << 17);
    _regval = (_regval | (0xc1ecfeff & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_PS_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_PS_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x40000 & (((tulip_CSR6_t )(_fieldval)) << 18);
    _regval = (_regval | (0xc1eafeff & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_HBD_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_HBD_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x80000 & (((tulip_CSR6_t )(_fieldval)) << 19);
    _regval = (_regval | (0xc1e6feff & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_SF_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_SF_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x200000 & (((tulip_CSR6_t )(_fieldval)) << 21);
    _regval = (_regval | (0xc1cefeff & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_TTM_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_TTM_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x400000 & (((tulip_CSR6_t )(_fieldval)) << 22);
    _regval = (_regval | (0xc1aefeff & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_PCS_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_PCS_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x800000 & (((tulip_CSR6_t )(_fieldval)) << 23);
    _regval = (_regval | (0xc16efeff & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_SCR_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_SCR_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x1000000 & (((tulip_CSR6_t )(_fieldval)) << 24);
    _regval = (_regval | (0xc0eefeff & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_RA_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_RA_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x40000000 & (((tulip_CSR6_t )(_fieldval)) << 30);
    _regval = (_regval | (0x81eefeff & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR6_SC_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR6_SC_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR6_t _regval = 0x80000000 & (((tulip_CSR6_t )(_fieldval)) << 31);
    _regval = (_regval | (0x41eefeff & mackerel_read_io_32(_dev->base, 0x30)));
    // No read of register shadow required
    _regval = (_regval & 0xc3eefeff);
    _regval = (_regval | 0x2000000);
    mackerel_write_io_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

/*
 * Register CSR7: Interrupt enable
 * Type: tulip.CSR7 (Implicit type of Interrupt enable register)
 *   TI	(size 1, offset 0, init 0):	RW	Transmit interrupt enable
 *   TS	(size 1, offset 1, init 0):	RW	Transmit stopped enable
 *   TU	(size 1, offset 2, init 0):	RW	Transmit buffer unavailable enable
 *   TJ	(size 1, offset 3, init 0):	RW	Transmit jabber timeout enable
 *   _anon4	(size 1, offset 4, init 0):	MBZ	_
 *   UN	(size 1, offset 5, init 0):	RW	Underflow interrupt enable
 *   RI	(size 1, offset 6, init 0):	RW	Recieve interrupt enable
 *   RU	(size 1, offset 7, init 0):	RW	Recieve buffer unavailable enable
 *   RS	(size 1, offset 8, init 0):	RW	Recieve stopped enable
 *   RW	(size 1, offset 9, init 0):	RW	Recieve watchdog timeout enable
 *   ETE	(size 1, offset 10, init 0):	RW	Early transmit interrupt enable
 *   GPT	(size 1, offset 11, init 0):	RW	General-purpose timer enable
 *   _anon12	(size 1, offset 12, init 0):	MBZ	_
 *   FBE	(size 1, offset 13, init 0):	RW	Fatal bus error enable
 *   ERE	(size 1, offset 14, init 0):	RW	Early receive enable
 *   AI	(size 1, offset 15, init 0):	RW	Abnormal interrupt summary enable
 *   NI	(size 1, offset 16, init 0):	RW	Normal interrupt summary enable
 *   _anon17	(size 15, offset 17, init 0):	MBZ	_
 */
static inline tulip_CSR7_t tulip_CSR7_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x38));
}

static inline tulip_CSR7_t tulip_CSR7_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR7_t tulip_CSR7_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x38));
}

static inline void tulip_CSR7_rawwr(__DN(t) *_dev, tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR7_rawwr(__DN(t) *_dev, tulip_CSR7_t _regval)
{
    mackerel_write_io_32(_dev->base, 0x38, _regval);
}

static inline void tulip_CSR7_wr(__DN(t) *_dev, tulip_CSR7_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR7_wr(__DN(t) *_dev, tulip_CSR7_t _regval)
{
    _regval = (_regval & 0x1efef);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_32(_dev->base, 0x38, _regval);
}

static inline int tulip_CSR7_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int tulip_CSR7_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    tulip_CSR7_t _regval = mackerel_read_io_32(_dev->base, 0x38);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register CSR7 (Interrupt enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TI =\t%" PRIx8 "\t(Transmit interrupt enable)\n", tulip_CSR7_TI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TS =\t%" PRIx8 "\t(Transmit stopped enable)\n", tulip_CSR7_TS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TU =\t%" PRIx8 "\t(Transmit buffer unavailable enable)\n", tulip_CSR7_TU_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " TJ =\t%" PRIx8 "\t(Transmit jabber timeout enable)\n", tulip_CSR7_TJ_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " UN =\t%" PRIx8 "\t(Underflow interrupt enable)\n", tulip_CSR7_UN_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RI =\t%" PRIx8 "\t(Recieve interrupt enable)\n", tulip_CSR7_RI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RU =\t%" PRIx8 "\t(Recieve buffer unavailable enable)\n", tulip_CSR7_RU_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RS =\t%" PRIx8 "\t(Recieve stopped enable)\n", tulip_CSR7_RS_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RW =\t%" PRIx8 "\t(Recieve watchdog timeout enable)\n", tulip_CSR7_RW_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ETE =\t%" PRIx8 "\t(Early transmit interrupt enable)\n", tulip_CSR7_ETE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " GPT =\t%" PRIx8 "\t(General-purpose timer enable)\n", tulip_CSR7_GPT_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FBE =\t%" PRIx8 "\t(Fatal bus error enable)\n", tulip_CSR7_FBE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ERE =\t%" PRIx8 "\t(Early receive enable)\n", tulip_CSR7_ERE_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " AI =\t%" PRIx8 "\t(Abnormal interrupt summary enable)\n", tulip_CSR7_AI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " NI =\t%" PRIx8 "\t(Normal interrupt summary enable)\n", tulip_CSR7_NI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon17 is anonymous
    return(_r);
}

static inline uint8_t tulip_CSR7_TI_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_TI_rdf(__DN(t) *_dev)
{
    tulip_CSR7_t _regval = mackerel_read_io_32(_dev->base, 0x38);
    return(tulip_CSR7_TI_extract(_regval));
}

static inline uint8_t tulip_CSR7_TS_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_TS_rdf(__DN(t) *_dev)
{
    tulip_CSR7_t _regval = mackerel_read_io_32(_dev->base, 0x38);
    return(tulip_CSR7_TS_extract(_regval));
}

static inline uint8_t tulip_CSR7_TU_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_TU_rdf(__DN(t) *_dev)
{
    tulip_CSR7_t _regval = mackerel_read_io_32(_dev->base, 0x38);
    return(tulip_CSR7_TU_extract(_regval));
}

static inline uint8_t tulip_CSR7_TJ_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_TJ_rdf(__DN(t) *_dev)
{
    tulip_CSR7_t _regval = mackerel_read_io_32(_dev->base, 0x38);
    return(tulip_CSR7_TJ_extract(_regval));
}

static inline uint8_t tulip_CSR7_UN_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_UN_rdf(__DN(t) *_dev)
{
    tulip_CSR7_t _regval = mackerel_read_io_32(_dev->base, 0x38);
    return(tulip_CSR7_UN_extract(_regval));
}

static inline uint8_t tulip_CSR7_RI_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_RI_rdf(__DN(t) *_dev)
{
    tulip_CSR7_t _regval = mackerel_read_io_32(_dev->base, 0x38);
    return(tulip_CSR7_RI_extract(_regval));
}

static inline uint8_t tulip_CSR7_RU_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_RU_rdf(__DN(t) *_dev)
{
    tulip_CSR7_t _regval = mackerel_read_io_32(_dev->base, 0x38);
    return(tulip_CSR7_RU_extract(_regval));
}

static inline uint8_t tulip_CSR7_RS_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_RS_rdf(__DN(t) *_dev)
{
    tulip_CSR7_t _regval = mackerel_read_io_32(_dev->base, 0x38);
    return(tulip_CSR7_RS_extract(_regval));
}

static inline uint8_t tulip_CSR7_RW_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_RW_rdf(__DN(t) *_dev)
{
    tulip_CSR7_t _regval = mackerel_read_io_32(_dev->base, 0x38);
    return(tulip_CSR7_RW_extract(_regval));
}

static inline uint8_t tulip_CSR7_ETE_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_ETE_rdf(__DN(t) *_dev)
{
    tulip_CSR7_t _regval = mackerel_read_io_32(_dev->base, 0x38);
    return(tulip_CSR7_ETE_extract(_regval));
}

static inline uint8_t tulip_CSR7_GPT_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_GPT_rdf(__DN(t) *_dev)
{
    tulip_CSR7_t _regval = mackerel_read_io_32(_dev->base, 0x38);
    return(tulip_CSR7_GPT_extract(_regval));
}

static inline uint8_t tulip_CSR7_FBE_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_FBE_rdf(__DN(t) *_dev)
{
    tulip_CSR7_t _regval = mackerel_read_io_32(_dev->base, 0x38);
    return(tulip_CSR7_FBE_extract(_regval));
}

static inline uint8_t tulip_CSR7_ERE_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_ERE_rdf(__DN(t) *_dev)
{
    tulip_CSR7_t _regval = mackerel_read_io_32(_dev->base, 0x38);
    return(tulip_CSR7_ERE_extract(_regval));
}

static inline uint8_t tulip_CSR7_AI_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_AI_rdf(__DN(t) *_dev)
{
    tulip_CSR7_t _regval = mackerel_read_io_32(_dev->base, 0x38);
    return(tulip_CSR7_AI_extract(_regval));
}

static inline uint8_t tulip_CSR7_NI_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR7_NI_rdf(__DN(t) *_dev)
{
    tulip_CSR7_t _regval = mackerel_read_io_32(_dev->base, 0x38);
    return(tulip_CSR7_NI_extract(_regval));
}

static inline void tulip_CSR7_TI_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR7_TI_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR7_t _regval = 0x1 & (((tulip_CSR7_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1efee & mackerel_read_io_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1efef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR7_TS_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR7_TS_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR7_t _regval = 0x2 & (((tulip_CSR7_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1efed & mackerel_read_io_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1efef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR7_TU_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR7_TU_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR7_t _regval = 0x4 & (((tulip_CSR7_t )(_fieldval)) << 2);
    _regval = (_regval | (0x1efeb & mackerel_read_io_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1efef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR7_TJ_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR7_TJ_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR7_t _regval = 0x8 & (((tulip_CSR7_t )(_fieldval)) << 3);
    _regval = (_regval | (0x1efe7 & mackerel_read_io_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1efef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR7_UN_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR7_UN_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR7_t _regval = 0x20 & (((tulip_CSR7_t )(_fieldval)) << 5);
    _regval = (_regval | (0x1efcf & mackerel_read_io_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1efef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR7_RI_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR7_RI_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR7_t _regval = 0x40 & (((tulip_CSR7_t )(_fieldval)) << 6);
    _regval = (_regval | (0x1efaf & mackerel_read_io_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1efef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR7_RU_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR7_RU_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR7_t _regval = 0x80 & (((tulip_CSR7_t )(_fieldval)) << 7);
    _regval = (_regval | (0x1ef6f & mackerel_read_io_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1efef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR7_RS_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR7_RS_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR7_t _regval = 0x100 & (((tulip_CSR7_t )(_fieldval)) << 8);
    _regval = (_regval | (0x1eeef & mackerel_read_io_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1efef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR7_RW_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR7_RW_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR7_t _regval = 0x200 & (((tulip_CSR7_t )(_fieldval)) << 9);
    _regval = (_regval | (0x1edef & mackerel_read_io_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1efef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR7_ETE_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR7_ETE_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR7_t _regval = 0x400 & (((tulip_CSR7_t )(_fieldval)) << 10);
    _regval = (_regval | (0x1ebef & mackerel_read_io_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1efef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR7_GPT_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR7_GPT_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR7_t _regval = 0x800 & (((tulip_CSR7_t )(_fieldval)) << 11);
    _regval = (_regval | (0x1e7ef & mackerel_read_io_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1efef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR7_FBE_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR7_FBE_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR7_t _regval = 0x2000 & (((tulip_CSR7_t )(_fieldval)) << 13);
    _regval = (_regval | (0x1cfef & mackerel_read_io_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1efef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR7_ERE_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR7_ERE_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR7_t _regval = 0x4000 & (((tulip_CSR7_t )(_fieldval)) << 14);
    _regval = (_regval | (0x1afef & mackerel_read_io_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1efef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR7_AI_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR7_AI_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR7_t _regval = 0x8000 & (((tulip_CSR7_t )(_fieldval)) << 15);
    _regval = (_regval | (0x16fef & mackerel_read_io_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1efef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR7_NI_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR7_NI_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR7_t _regval = 0x10000 & (((tulip_CSR7_t )(_fieldval)) << 16);
    _regval = (_regval | (0xefef & mackerel_read_io_32(_dev->base, 0x38)));
    // No read of register shadow required
    _regval = (_regval & 0x1efef);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

/*
 * Register CSR8: Missed frames and overflow counter
 * Type: tulip.CSR8 (Implicit type of Missed frames and overflow counter register)
 *   MFC	(size 16, offset 0, init 0):	RO	Missed frame counter
 *   MFO	(size 1, offset 16, init 0):	RO	Missed frame overflow
 *   FOC	(size 11, offset 17, init 0):	RO	FIFO overflow counter
 *   OCO	(size 1, offset 28, init 0):	RO	Overflow counter overflow
 *   _anon29	(size 3, offset 29, init 0):	MBZ	_
 */
static inline tulip_CSR8_t tulip_CSR8_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR8_t tulip_CSR8_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x40));
}

static inline tulip_CSR8_t tulip_CSR8_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR8_t tulip_CSR8_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x40));
}

static inline void tulip_CSR8_rawwr(__DN(t) *_dev, tulip_CSR8_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR8_rawwr(__DN(t) *_dev, tulip_CSR8_t _regval)
{
    mackerel_write_io_32(_dev->base, 0x40, _regval);
}

// Register CSR8 is not writeable
static inline int tulip_CSR8_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int tulip_CSR8_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    tulip_CSR8_t _regval = mackerel_read_io_32(_dev->base, 0x40);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register CSR8 (Missed frames and overflow counter): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " MFC =\t%" PRIx16 "\t(Missed frame counter)\n", tulip_CSR8_MFC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " MFO =\t%" PRIx8 "\t(Missed frame overflow)\n", tulip_CSR8_MFO_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " FOC =\t%" PRIx16 "\t(FIFO overflow counter)\n", tulip_CSR8_FOC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " OCO =\t%" PRIx8 "\t(Overflow counter overflow)\n", tulip_CSR8_OCO_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon29 is anonymous
    return(_r);
}

static inline uint16_t tulip_CSR8_MFC_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t tulip_CSR8_MFC_rdf(__DN(t) *_dev)
{
    tulip_CSR8_t _regval = mackerel_read_io_32(_dev->base, 0x40);
    return(tulip_CSR8_MFC_extract(_regval));
}

static inline uint8_t tulip_CSR8_MFO_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR8_MFO_rdf(__DN(t) *_dev)
{
    tulip_CSR8_t _regval = mackerel_read_io_32(_dev->base, 0x40);
    return(tulip_CSR8_MFO_extract(_regval));
}

static inline uint16_t tulip_CSR8_FOC_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t tulip_CSR8_FOC_rdf(__DN(t) *_dev)
{
    tulip_CSR8_t _regval = mackerel_read_io_32(_dev->base, 0x40);
    return(tulip_CSR8_FOC_extract(_regval));
}

static inline uint8_t tulip_CSR8_OCO_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR8_OCO_rdf(__DN(t) *_dev)
{
    tulip_CSR8_t _regval = mackerel_read_io_32(_dev->base, 0x40);
    return(tulip_CSR8_OCO_extract(_regval));
}

/*
 * Register CSR9: Boot ROM Management
 * Type: tulip.CSR9 (Implicit type of Boot ROM Management register)
 *   DATA	(size 8, offset 0, init 0):	RW	Boot ROM data or serial ROM control
 *   _anon8	(size 2, offset 8, init 0):	MBZ	_
 *   REG	(size 1, offset 10, init 0):	RW	External register select
 *   SR	(size 1, offset 11, init 0):	RW	Serial ROM select
 *   BR	(size 1, offset 12, init 0):	RW	Boot ROM select
 *   WR	(size 1, offset 13, init 0):	RW	ROM write operation
 *   RD	(size 1, offset 14, init 0):	RW	ROM read operation
 *   _anon15	(size 1, offset 15, init 0):	MBZ	_
 *   MDC	(size 1, offset 16, init 0):	RW	MII management clock
 *   MDO	(size 1, offset 17, init 0):	RW	MII management write data
 *   MII	(size 1, offset 18, init 0):	RW	MII management operation mode
 *   MDI	(size 1, offset 19, init 0):	RW	MII management data_in
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline tulip_CSR9_t tulip_CSR9_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR9_t tulip_CSR9_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x48));
}

static inline tulip_CSR9_t tulip_CSR9_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR9_t tulip_CSR9_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x48));
}

static inline void tulip_CSR9_rawwr(__DN(t) *_dev, tulip_CSR9_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR9_rawwr(__DN(t) *_dev, tulip_CSR9_t _regval)
{
    mackerel_write_io_32(_dev->base, 0x48, _regval);
}

static inline void tulip_CSR9_wr(__DN(t) *_dev, tulip_CSR9_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR9_wr(__DN(t) *_dev, tulip_CSR9_t _regval)
{
    _regval = (_regval & 0xf7cff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_32(_dev->base, 0x48, _regval);
}

static inline int tulip_CSR9_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int tulip_CSR9_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    tulip_CSR9_t _regval = mackerel_read_io_32(_dev->base, 0x48);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register CSR9 (Boot ROM Management): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " DATA =\t%" PRIx8 "\t(Boot ROM data or serial ROM control)\n", tulip_CSR9_DATA_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " REG =\t%" PRIx8 "\t(External register select)\n", tulip_CSR9_REG_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " SR =\t%" PRIx8 "\t(Serial ROM select)\n", tulip_CSR9_SR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " BR =\t%" PRIx8 "\t(Boot ROM select)\n", tulip_CSR9_BR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " WR =\t%" PRIx8 "\t(ROM write operation)\n", tulip_CSR9_WR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RD =\t%" PRIx8 "\t(ROM read operation)\n", tulip_CSR9_RD_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " MDC =\t%" PRIx8 "\t(MII management clock)\n", tulip_CSR9_MDC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " MDO =\t%" PRIx8 "\t(MII management write data)\n", tulip_CSR9_MDO_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " MII =\t%" PRIx8 "\t(MII management operation mode)\n", tulip_CSR9_MII_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " MDI =\t%" PRIx8 "\t(MII management data_in)\n", tulip_CSR9_MDI_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline uint8_t tulip_CSR9_DATA_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_DATA_rdf(__DN(t) *_dev)
{
    tulip_CSR9_t _regval = mackerel_read_io_32(_dev->base, 0x48);
    return(tulip_CSR9_DATA_extract(_regval));
}

static inline uint8_t tulip_CSR9_REG_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_REG_rdf(__DN(t) *_dev)
{
    tulip_CSR9_t _regval = mackerel_read_io_32(_dev->base, 0x48);
    return(tulip_CSR9_REG_extract(_regval));
}

static inline uint8_t tulip_CSR9_SR_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_SR_rdf(__DN(t) *_dev)
{
    tulip_CSR9_t _regval = mackerel_read_io_32(_dev->base, 0x48);
    return(tulip_CSR9_SR_extract(_regval));
}

static inline uint8_t tulip_CSR9_BR_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_BR_rdf(__DN(t) *_dev)
{
    tulip_CSR9_t _regval = mackerel_read_io_32(_dev->base, 0x48);
    return(tulip_CSR9_BR_extract(_regval));
}

static inline uint8_t tulip_CSR9_WR_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_WR_rdf(__DN(t) *_dev)
{
    tulip_CSR9_t _regval = mackerel_read_io_32(_dev->base, 0x48);
    return(tulip_CSR9_WR_extract(_regval));
}

static inline uint8_t tulip_CSR9_RD_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_RD_rdf(__DN(t) *_dev)
{
    tulip_CSR9_t _regval = mackerel_read_io_32(_dev->base, 0x48);
    return(tulip_CSR9_RD_extract(_regval));
}

static inline uint8_t tulip_CSR9_MDC_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_MDC_rdf(__DN(t) *_dev)
{
    tulip_CSR9_t _regval = mackerel_read_io_32(_dev->base, 0x48);
    return(tulip_CSR9_MDC_extract(_regval));
}

static inline uint8_t tulip_CSR9_MDO_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_MDO_rdf(__DN(t) *_dev)
{
    tulip_CSR9_t _regval = mackerel_read_io_32(_dev->base, 0x48);
    return(tulip_CSR9_MDO_extract(_regval));
}

static inline uint8_t tulip_CSR9_MII_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_MII_rdf(__DN(t) *_dev)
{
    tulip_CSR9_t _regval = mackerel_read_io_32(_dev->base, 0x48);
    return(tulip_CSR9_MII_extract(_regval));
}

static inline uint8_t tulip_CSR9_MDI_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR9_MDI_rdf(__DN(t) *_dev)
{
    tulip_CSR9_t _regval = mackerel_read_io_32(_dev->base, 0x48);
    return(tulip_CSR9_MDI_extract(_regval));
}

static inline void tulip_CSR9_DATA_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR9_DATA_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR9_t _regval = 0xff & (((tulip_CSR9_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf7c00 & mackerel_read_io_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xf7cff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR9_REG_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR9_REG_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR9_t _regval = 0x400 & (((tulip_CSR9_t )(_fieldval)) << 10);
    _regval = (_regval | (0xf78ff & mackerel_read_io_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xf7cff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR9_SR_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR9_SR_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR9_t _regval = 0x800 & (((tulip_CSR9_t )(_fieldval)) << 11);
    _regval = (_regval | (0xf74ff & mackerel_read_io_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xf7cff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR9_BR_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR9_BR_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR9_t _regval = 0x1000 & (((tulip_CSR9_t )(_fieldval)) << 12);
    _regval = (_regval | (0xf6cff & mackerel_read_io_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xf7cff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR9_WR_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR9_WR_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR9_t _regval = 0x2000 & (((tulip_CSR9_t )(_fieldval)) << 13);
    _regval = (_regval | (0xf5cff & mackerel_read_io_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xf7cff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR9_RD_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR9_RD_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR9_t _regval = 0x4000 & (((tulip_CSR9_t )(_fieldval)) << 14);
    _regval = (_regval | (0xf3cff & mackerel_read_io_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xf7cff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR9_MDC_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR9_MDC_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR9_t _regval = 0x10000 & (((tulip_CSR9_t )(_fieldval)) << 16);
    _regval = (_regval | (0xe7cff & mackerel_read_io_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xf7cff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR9_MDO_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR9_MDO_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR9_t _regval = 0x20000 & (((tulip_CSR9_t )(_fieldval)) << 17);
    _regval = (_regval | (0xd7cff & mackerel_read_io_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xf7cff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR9_MII_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR9_MII_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR9_t _regval = 0x40000 & (((tulip_CSR9_t )(_fieldval)) << 18);
    _regval = (_regval | (0xb7cff & mackerel_read_io_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xf7cff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR9_MDI_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR9_MDI_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR9_t _regval = 0x80000 & (((tulip_CSR9_t )(_fieldval)) << 19);
    _regval = (_regval | (0x77cff & mackerel_read_io_32(_dev->base, 0x48)));
    // No read of register shadow required
    _regval = (_regval & 0xf7cff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

/*
 * Register CSR10: Boot ROM programming address
 * Type: tulip.CSR10 (Implicit type of Boot ROM programming address register)
 *   VAL	(size 18, offset 0, init 0):	RW	Boot ROM address
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline tulip_CSR10_t tulip_CSR10_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR10_t tulip_CSR10_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x50));
}

static inline tulip_CSR10_t tulip_CSR10_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR10_t tulip_CSR10_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x50));
}

static inline void tulip_CSR10_rawwr(__DN(t) *_dev, tulip_CSR10_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR10_rawwr(__DN(t) *_dev, tulip_CSR10_t _regval)
{
    mackerel_write_io_32(_dev->base, 0x50, _regval);
}

static inline void tulip_CSR10_wr(__DN(t) *_dev, tulip_CSR10_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR10_wr(__DN(t) *_dev, tulip_CSR10_t _regval)
{
    _regval = (_regval & 0x3ffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_32(_dev->base, 0x50, _regval);
}

static inline int tulip_CSR10_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int tulip_CSR10_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    tulip_CSR10_t _regval = mackerel_read_io_32(_dev->base, 0x50);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register CSR10 (Boot ROM programming address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " VAL =\t%" PRIx32 "\t(Boot ROM address)\n", tulip_CSR10_VAL_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline uint32_t tulip_CSR10_VAL_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t tulip_CSR10_VAL_rdf(__DN(t) *_dev)
{
    tulip_CSR10_t _regval = mackerel_read_io_32(_dev->base, 0x50);
    return(tulip_CSR10_VAL_extract(_regval));
}

static inline void tulip_CSR10_VAL_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR10_VAL_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    tulip_CSR10_t _regval = 0x3ffff & (((tulip_CSR10_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3ffff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x50, _regval);
    // No shadow register to write to
}

/*
 * Register CSR11: General-purpose timer
 * Type: tulip.CSR11 (Implicit type of General-purpose timer register)
 *   VAL	(size 16, offset 0, init 0):	RW	Timer value
 *   CON	(size 1, offset 16, init 0):	RW	Continuous mode
 *   _anon17	(size 15, offset 17, init 0):	MBZ	_
 */
static inline tulip_CSR11_t tulip_CSR11_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR11_t tulip_CSR11_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x58));
}

static inline tulip_CSR11_t tulip_CSR11_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR11_t tulip_CSR11_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x58));
}

static inline void tulip_CSR11_rawwr(__DN(t) *_dev, tulip_CSR11_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR11_rawwr(__DN(t) *_dev, tulip_CSR11_t _regval)
{
    mackerel_write_io_32(_dev->base, 0x58, _regval);
}

static inline void tulip_CSR11_wr(__DN(t) *_dev, tulip_CSR11_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR11_wr(__DN(t) *_dev, tulip_CSR11_t _regval)
{
    _regval = (_regval & 0x1ffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_32(_dev->base, 0x58, _regval);
}

static inline int tulip_CSR11_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int tulip_CSR11_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    tulip_CSR11_t _regval = mackerel_read_io_32(_dev->base, 0x58);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register CSR11 (General-purpose timer): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " VAL =\t%" PRIx16 "\t(Timer value)\n", tulip_CSR11_VAL_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " CON =\t%" PRIx8 "\t(Continuous mode)\n", tulip_CSR11_CON_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon17 is anonymous
    return(_r);
}

static inline uint16_t tulip_CSR11_VAL_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t tulip_CSR11_VAL_rdf(__DN(t) *_dev)
{
    tulip_CSR11_t _regval = mackerel_read_io_32(_dev->base, 0x58);
    return(tulip_CSR11_VAL_extract(_regval));
}

static inline uint8_t tulip_CSR11_CON_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR11_CON_rdf(__DN(t) *_dev)
{
    tulip_CSR11_t _regval = mackerel_read_io_32(_dev->base, 0x58);
    return(tulip_CSR11_CON_extract(_regval));
}

static inline void tulip_CSR11_VAL_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR11_VAL_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    tulip_CSR11_t _regval = 0xffff & (((tulip_CSR11_t )(_fieldval)) << 0);
    _regval = (_regval | (0x10000 & mackerel_read_io_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR11_CON_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR11_CON_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR11_t _regval = 0x10000 & (((tulip_CSR11_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_io_32(_dev->base, 0x58)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x58, _regval);
    // No shadow register to write to
}

/*
 * Register CSR12: General purpose port
 * Type: tulip.CSR12 (Implicit type of General purpose port register)
 *   MD	(size 8, offset 0, init 0):	RW	General-purpose mode and data
 *   GPC	(size 1, offset 8, init 0):	RW	General-purpose control
 *   _anon9	(size 23, offset 9, init 0):	MBZ	_
 */
static inline tulip_CSR12_t tulip_CSR12_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR12_t tulip_CSR12_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x60));
}

static inline tulip_CSR12_t tulip_CSR12_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR12_t tulip_CSR12_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x60));
}

static inline void tulip_CSR12_rawwr(__DN(t) *_dev, tulip_CSR12_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR12_rawwr(__DN(t) *_dev, tulip_CSR12_t _regval)
{
    mackerel_write_io_32(_dev->base, 0x60, _regval);
}

static inline void tulip_CSR12_wr(__DN(t) *_dev, tulip_CSR12_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR12_wr(__DN(t) *_dev, tulip_CSR12_t _regval)
{
    _regval = (_regval & 0x1ff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_32(_dev->base, 0x60, _regval);
}

static inline int tulip_CSR12_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int tulip_CSR12_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    tulip_CSR12_t _regval = mackerel_read_io_32(_dev->base, 0x60);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register CSR12 (General purpose port): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " MD =\t%" PRIx8 "\t(General-purpose mode and data)\n", tulip_CSR12_MD_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " GPC =\t%" PRIx8 "\t(General-purpose control)\n", tulip_CSR12_GPC_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    return(_r);
}

static inline uint8_t tulip_CSR12_MD_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR12_MD_rdf(__DN(t) *_dev)
{
    tulip_CSR12_t _regval = mackerel_read_io_32(_dev->base, 0x60);
    return(tulip_CSR12_MD_extract(_regval));
}

static inline uint8_t tulip_CSR12_GPC_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR12_GPC_rdf(__DN(t) *_dev)
{
    tulip_CSR12_t _regval = mackerel_read_io_32(_dev->base, 0x60);
    return(tulip_CSR12_GPC_extract(_regval));
}

static inline void tulip_CSR12_MD_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR12_MD_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR12_t _regval = 0xff & (((tulip_CSR12_t )(_fieldval)) << 0);
    _regval = (_regval | (0x100 & mackerel_read_io_32(_dev->base, 0x60)));
    // No read of register shadow required
    _regval = (_regval & 0x1ff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x60, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR12_GPC_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR12_GPC_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR12_t _regval = 0x100 & (((tulip_CSR12_t )(_fieldval)) << 8);
    _regval = (_regval | (0xff & mackerel_read_io_32(_dev->base, 0x60)));
    // No read of register shadow required
    _regval = (_regval & 0x1ff);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x60, _regval);
    // No shadow register to write to
}

/*
 * Register CSR15: Watchdog timer
 * Type: tulip.CSR15 (Implicit type of Watchdog timer register)
 *   JBD	(size 1, offset 0, init 0):	RW	Jabber disable
 *   HUJ	(size 1, offset 1, init 0):	RW	Host unjab
 *   JCK	(size 1, offset 2, init 0):	RW	Jabber clock
 *   _anon3	(size 1, offset 3, init 0):	MBZ	_
 *   RWD	(size 1, offset 4, init 0):	RW	Receive watchdog disable
 *   RWR	(size 1, offset 5, init 0):	RW	Receive watchdog release
 *   _anon6	(size 26, offset 6, init 0):	RSVD	_
 */
static inline tulip_CSR15_t tulip_CSR15_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR15_t tulip_CSR15_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x78));
}

static inline tulip_CSR15_t tulip_CSR15_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline tulip_CSR15_t tulip_CSR15_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x78));
}

static inline void tulip_CSR15_rawwr(__DN(t) *_dev, tulip_CSR15_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR15_rawwr(__DN(t) *_dev, tulip_CSR15_t _regval)
{
    mackerel_write_io_32(_dev->base, 0x78, _regval);
}

static inline void tulip_CSR15_wr(__DN(t) *_dev, tulip_CSR15_t _regval) __attribute__ ((always_inline));
static inline void tulip_CSR15_wr(__DN(t) *_dev, tulip_CSR15_t _regval)
{
    _regval = (_regval & 0x37);
    // No MB1 fields present
    _regval = (_regval | (0xffffffc0 & mackerel_read_io_32(_dev->base, 0x78)));
    mackerel_write_io_32(_dev->base, 0x78, _regval);
}

static inline int tulip_CSR15_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int tulip_CSR15_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    tulip_CSR15_t _regval = mackerel_read_io_32(_dev->base, 0x78);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register CSR15 (Watchdog timer): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " JBD =\t%" PRIx8 "\t(Jabber disable)\n", tulip_CSR15_JBD_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " HUJ =\t%" PRIx8 "\t(Host unjab)\n", tulip_CSR15_HUJ_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " JCK =\t%" PRIx8 "\t(Jabber clock)\n", tulip_CSR15_JCK_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RWD =\t%" PRIx8 "\t(Receive watchdog disable)\n", tulip_CSR15_RWD_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " RWR =\t%" PRIx8 "\t(Receive watchdog release)\n", tulip_CSR15_RWR_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    return(_r);
}

static inline uint8_t tulip_CSR15_JBD_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR15_JBD_rdf(__DN(t) *_dev)
{
    tulip_CSR15_t _regval = mackerel_read_io_32(_dev->base, 0x78);
    return(tulip_CSR15_JBD_extract(_regval));
}

static inline uint8_t tulip_CSR15_HUJ_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR15_HUJ_rdf(__DN(t) *_dev)
{
    tulip_CSR15_t _regval = mackerel_read_io_32(_dev->base, 0x78);
    return(tulip_CSR15_HUJ_extract(_regval));
}

static inline uint8_t tulip_CSR15_JCK_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR15_JCK_rdf(__DN(t) *_dev)
{
    tulip_CSR15_t _regval = mackerel_read_io_32(_dev->base, 0x78);
    return(tulip_CSR15_JCK_extract(_regval));
}

static inline uint8_t tulip_CSR15_RWD_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR15_RWD_rdf(__DN(t) *_dev)
{
    tulip_CSR15_t _regval = mackerel_read_io_32(_dev->base, 0x78);
    return(tulip_CSR15_RWD_extract(_regval));
}

static inline uint8_t tulip_CSR15_RWR_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t tulip_CSR15_RWR_rdf(__DN(t) *_dev)
{
    tulip_CSR15_t _regval = mackerel_read_io_32(_dev->base, 0x78);
    return(tulip_CSR15_RWR_extract(_regval));
}

static inline void tulip_CSR15_JBD_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR15_JBD_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR15_t _regval = 0x1 & (((tulip_CSR15_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff6 & mackerel_read_io_32(_dev->base, 0x78)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffff7);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x78, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR15_HUJ_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR15_HUJ_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR15_t _regval = 0x2 & (((tulip_CSR15_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffff5 & mackerel_read_io_32(_dev->base, 0x78)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffff7);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x78, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR15_JCK_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR15_JCK_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR15_t _regval = 0x4 & (((tulip_CSR15_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffff3 & mackerel_read_io_32(_dev->base, 0x78)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffff7);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x78, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR15_RWD_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR15_RWD_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR15_t _regval = 0x10 & (((tulip_CSR15_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffe7 & mackerel_read_io_32(_dev->base, 0x78)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffff7);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x78, _regval);
    // No shadow register to write to
}

static inline void tulip_CSR15_RWR_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void tulip_CSR15_RWR_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    tulip_CSR15_t _regval = 0x20 & (((tulip_CSR15_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffd7 & mackerel_read_io_32(_dev->base, 0x78)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffff7);
    // No MB1 fields present
    mackerel_write_io_32(_dev->base, 0x78, _regval);
    // No shadow register to write to
}

static inline int tulip_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int tulip_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device tulip (Tulip Ethernet Controller):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_CSR0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_CSR1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_CSR2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_CSR3_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_CSR4_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_CSR5_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_CSR6_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_CSR7_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_CSR8_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_CSR9_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_CSR10_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_CSR11_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_CSR12_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = tulip_CSR15_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device tulip\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __tulip_DEV_H
