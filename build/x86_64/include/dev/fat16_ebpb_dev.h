#ifndef __fat16_ebpb_DEV_H
#define __fat16_ebpb_DEV_H 1
/*
 * DEVICE DEFINITION: FAT16 Extended BIOS Parameter Block (EBPB)
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) fat16_ebpb ## _ ## x
/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t b;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum fat16_ebpb_initials {
    fat16_ebpb_drv_initial = 0x0,
    fat16_ebpb_rsv_initial = 0x0,
    fat16_ebpb_ebs_initial = 0x0,
    fat16_ebpb_vsn_initial = 0x0,
    fat16_ebpb_vlb_initial = 0x0,
    fat16_ebpb_fst_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void fat16_ebpb_initialize(__DN(t) *_dev, mackerel_addr_t b) __attribute__ ((always_inline));
static inline void fat16_ebpb_initialize(__DN(t) *_dev, mackerel_addr_t b)
{
    _dev->b = b;
}

/*
 * Register drv: Drive number
 * Type: fat16_ebpb.uint8 (primitive type)
 */
static inline uint8_t fat16_ebpb_drv_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat16_ebpb_drv_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0x24));
}

static inline uint8_t fat16_ebpb_drv_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat16_ebpb_drv_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0x24));
}

static inline void fat16_ebpb_drv_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat16_ebpb_drv_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->b, 0x24, _regval);
}

static inline void fat16_ebpb_drv_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat16_ebpb_drv_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->b, 0x24, _regval);
}

static inline int fat16_ebpb_drv_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat16_ebpb_drv_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->b, 0x24);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register drv (Drive number): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rsv: Reserved
 * Type: fat16_ebpb.uint8 (primitive type)
 */
static inline uint8_t fat16_ebpb_rsv_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat16_ebpb_rsv_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0x25));
}

static inline uint8_t fat16_ebpb_rsv_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat16_ebpb_rsv_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0x25));
}

static inline void fat16_ebpb_rsv_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat16_ebpb_rsv_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->b, 0x25, _regval);
}

static inline void fat16_ebpb_rsv_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat16_ebpb_rsv_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->b, 0x25, _regval);
}

static inline int fat16_ebpb_rsv_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat16_ebpb_rsv_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->b, 0x25);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rsv (Reserved): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ebs: Extended boot signature
 * Type: fat16_ebpb.uint8 (primitive type)
 */
static inline uint8_t fat16_ebpb_ebs_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat16_ebpb_ebs_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0x26));
}

static inline uint8_t fat16_ebpb_ebs_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat16_ebpb_ebs_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0x26));
}

static inline void fat16_ebpb_ebs_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat16_ebpb_ebs_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->b, 0x26, _regval);
}

static inline void fat16_ebpb_ebs_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat16_ebpb_ebs_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->b, 0x26, _regval);
}

static inline int fat16_ebpb_ebs_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat16_ebpb_ebs_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->b, 0x26);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ebs (Extended boot signature): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register vsn: Volume serial number
 * Type: fat16_ebpb.uint32 (primitive type)
 */
static inline uint32_t fat16_ebpb_vsn_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t fat16_ebpb_vsn_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x27));
}

static inline uint32_t fat16_ebpb_vsn_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t fat16_ebpb_vsn_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x27));
}

static inline void fat16_ebpb_vsn_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void fat16_ebpb_vsn_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x27, _regval);
}

static inline void fat16_ebpb_vsn_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void fat16_ebpb_vsn_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->b, 0x27, _regval);
}

static inline int fat16_ebpb_vsn_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat16_ebpb_vsn_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->b, 0x27);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vsn (Volume serial number): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register array vlb: Volume label
 * Type: fat16_ebpb.uint8 (primitive type)
 */
static const size_t fat16_ebpb_vlb_length = 11;
static inline uint8_t fat16_ebpb_vlb_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t fat16_ebpb_vlb_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->b, 0x2b + (_i * (8 / 8))));
}

static inline uint8_t fat16_ebpb_vlb_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t fat16_ebpb_vlb_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->b, 0x2b + (_i * (8 / 8))));
}

static inline void fat16_ebpb_vlb_rawwr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat16_ebpb_vlb_rawwr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->b, 0x2b + (_i * (8 / 8)), _regval);
}

static inline void fat16_ebpb_vlb_wr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat16_ebpb_vlb_wr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->b, 0x2b + (_i * (8 / 8)), _regval);
}

static inline int fat16_ebpb_vlb_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int fat16_ebpb_vlb_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->b, 0x2b + (_i * (8 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vlb", _i, "Volume label");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int fat16_ebpb_vlb_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat16_ebpb_vlb_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 11; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = fat16_ebpb_vlb_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array fst: File system type, informative
 * Type: fat16_ebpb.uint8 (primitive type)
 */
static const size_t fat16_ebpb_fst_length = 8;
static inline uint8_t fat16_ebpb_fst_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t fat16_ebpb_fst_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->b, 0x36 + (_i * (8 / 8))));
}

static inline uint8_t fat16_ebpb_fst_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t fat16_ebpb_fst_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->b, 0x36 + (_i * (8 / 8))));
}

static inline void fat16_ebpb_fst_rawwr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat16_ebpb_fst_rawwr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->b, 0x36 + (_i * (8 / 8)), _regval);
}

static inline void fat16_ebpb_fst_wr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat16_ebpb_fst_wr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->b, 0x36 + (_i * (8 / 8)), _regval);
}

static inline int fat16_ebpb_fst_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int fat16_ebpb_fst_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->b, 0x36 + (_i * (8 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "fst", _i, "File system type, informative");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int fat16_ebpb_fst_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat16_ebpb_fst_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = fat16_ebpb_fst_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline int fat16_ebpb_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat16_ebpb_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device fat16_ebpb (FAT16 Extended BIOS Parameter Block (EBPB)):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat16_ebpb_drv_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat16_ebpb_rsv_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat16_ebpb_ebs_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat16_ebpb_vsn_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat16_ebpb_vlb_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat16_ebpb_fst_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device fat16_ebpb\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __fat16_ebpb_DEV_H
