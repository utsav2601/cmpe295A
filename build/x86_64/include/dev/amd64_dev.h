#ifndef __amd64_DEV_H
#define __amd64_DEV_H 1
/*
 * DEVICE DEFINITION: Intel64 and AMD 64-bit architecture definitions
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) amd64 ## _ ## x
/*
 * Register type: amd64_cr0_t
 * Description: Implicit type of Control register 0 register
 * Fields:
 *   pe	(size 1, offset 0, init 0):	RW	Protection enable
 *   mp	(size 1, offset 1, init 0):	RW	Monitor coprocessor
 *   em	(size 1, offset 2, init 0):	RW	Emulation
 *   ts	(size 1, offset 3, init 0):	RW	Task switched
 *   et	(size 1, offset 4, init 0):	RW	Extension type
 *   ne	(size 1, offset 5, init 0):	RW	Numeric error
 *   _anon6	(size 10, offset 6, init 0):	RSVD	_
 *   wp	(size 1, offset 16, init 0):	RW	Write protect
 *   _anon17	(size 1, offset 17, init 0):	RSVD	_
 *   am	(size 1, offset 18, init 0):	RW	Alignment mask
 *   _anon19	(size 10, offset 19, init 0):	RSVD	_
 *   nw	(size 1, offset 29, init 0):	RW	Not write-through
 *   cd	(size 1, offset 30, init 0):	RW	Cache disable
 *   pg	(size 1, offset 31, init 0):	RW	Paging
 */
typedef uint32_t amd64_cr0_t;
#define amd64_cr0_default 0x0
static inline uint8_t amd64_cr0_pe_extract(amd64_cr0_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_pe_extract(amd64_cr0_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline amd64_cr0_t amd64_cr0_pe_insert(amd64_cr0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr0_t amd64_cr0_pe_insert(amd64_cr0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((amd64_cr0_t )(_fieldval)) << 0)));
}

static inline uint8_t amd64_cr0_mp_extract(amd64_cr0_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_mp_extract(amd64_cr0_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline amd64_cr0_t amd64_cr0_mp_insert(amd64_cr0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr0_t amd64_cr0_mp_insert(amd64_cr0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((amd64_cr0_t )(_fieldval)) << 1)));
}

static inline uint8_t amd64_cr0_em_extract(amd64_cr0_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_em_extract(amd64_cr0_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline amd64_cr0_t amd64_cr0_em_insert(amd64_cr0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr0_t amd64_cr0_em_insert(amd64_cr0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((amd64_cr0_t )(_fieldval)) << 2)));
}

static inline uint8_t amd64_cr0_ts_extract(amd64_cr0_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_ts_extract(amd64_cr0_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline amd64_cr0_t amd64_cr0_ts_insert(amd64_cr0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr0_t amd64_cr0_ts_insert(amd64_cr0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((amd64_cr0_t )(_fieldval)) << 3)));
}

static inline uint8_t amd64_cr0_et_extract(amd64_cr0_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_et_extract(amd64_cr0_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline amd64_cr0_t amd64_cr0_et_insert(amd64_cr0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr0_t amd64_cr0_et_insert(amd64_cr0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((amd64_cr0_t )(_fieldval)) << 4)));
}

static inline uint8_t amd64_cr0_ne_extract(amd64_cr0_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_ne_extract(amd64_cr0_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline amd64_cr0_t amd64_cr0_ne_insert(amd64_cr0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr0_t amd64_cr0_ne_insert(amd64_cr0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((amd64_cr0_t )(_fieldval)) << 5)));
}

static inline uint8_t amd64_cr0_wp_extract(amd64_cr0_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_wp_extract(amd64_cr0_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline amd64_cr0_t amd64_cr0_wp_insert(amd64_cr0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr0_t amd64_cr0_wp_insert(amd64_cr0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((amd64_cr0_t )(_fieldval)) << 16)));
}

static inline uint8_t amd64_cr0_am_extract(amd64_cr0_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_am_extract(amd64_cr0_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline amd64_cr0_t amd64_cr0_am_insert(amd64_cr0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr0_t amd64_cr0_am_insert(amd64_cr0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((amd64_cr0_t )(_fieldval)) << 18)));
}

static inline uint8_t amd64_cr0_nw_extract(amd64_cr0_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_nw_extract(amd64_cr0_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline amd64_cr0_t amd64_cr0_nw_insert(amd64_cr0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr0_t amd64_cr0_nw_insert(amd64_cr0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((amd64_cr0_t )(_fieldval)) << 29)));
}

static inline uint8_t amd64_cr0_cd_extract(amd64_cr0_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_cd_extract(amd64_cr0_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline amd64_cr0_t amd64_cr0_cd_insert(amd64_cr0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr0_t amd64_cr0_cd_insert(amd64_cr0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((amd64_cr0_t )(_fieldval)) << 30)));
}

static inline uint8_t amd64_cr0_pg_extract(amd64_cr0_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_pg_extract(amd64_cr0_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline amd64_cr0_t amd64_cr0_pg_insert(amd64_cr0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr0_t amd64_cr0_pg_insert(amd64_cr0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((amd64_cr0_t )(_fieldval)) << 31)));
}

static inline int amd64_cr0_prtval(char *_s, size_t _size, amd64_cr0_t _regval) __attribute__ ((always_inline));
static inline int amd64_cr0_prtval(char *_s, size_t _size, amd64_cr0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pe =\t%" PRIx8 "\t(Protection enable)\n", amd64_cr0_pe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mp =\t%" PRIx8 "\t(Monitor coprocessor)\n", amd64_cr0_mp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " em =\t%" PRIx8 "\t(Emulation)\n", amd64_cr0_em_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ts =\t%" PRIx8 "\t(Task switched)\n", amd64_cr0_ts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " et =\t%" PRIx8 "\t(Extension type)\n", amd64_cr0_et_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ne =\t%" PRIx8 "\t(Numeric error)\n", amd64_cr0_ne_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wp =\t%" PRIx8 "\t(Write protect)\n", amd64_cr0_wp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " am =\t%" PRIx8 "\t(Alignment mask)\n", amd64_cr0_am_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nw =\t%" PRIx8 "\t(Not write-through)\n", amd64_cr0_nw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cd =\t%" PRIx8 "\t(Cache disable)\n", amd64_cr0_cd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pg =\t%" PRIx8 "\t(Paging)\n", amd64_cr0_pg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: amd64_cr3_t
 * Description: Implicit type of Control register 3 (PDBR) register
 * Fields:
 *   _anon0	(size 3, offset 0, init 0):	RSVD	_
 *   pwt	(size 1, offset 3, init 0):	RW	Page-level writes transparent
 *   pcd	(size 1, offset 4, init 0):	RW	Page-level cache disable
 *   _anon5	(size 7, offset 5, init 0):	RSVD	_
 *   pdb	(size 52, offset 12, init 0):	RW	Page-directory base
 */
typedef uint64_t amd64_cr3_t;
#define amd64_cr3_default 0x0
static inline uint8_t amd64_cr3_pwt_extract(amd64_cr3_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr3_pwt_extract(amd64_cr3_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline amd64_cr3_t amd64_cr3_pwt_insert(amd64_cr3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr3_t amd64_cr3_pwt_insert(amd64_cr3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffff7) | (0x8 & (((amd64_cr3_t )(_fieldval)) << 3)));
}

static inline uint8_t amd64_cr3_pcd_extract(amd64_cr3_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr3_pcd_extract(amd64_cr3_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline amd64_cr3_t amd64_cr3_pcd_insert(amd64_cr3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr3_t amd64_cr3_pcd_insert(amd64_cr3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffffffffffef) | (0x10 & (((amd64_cr3_t )(_fieldval)) << 4)));
}

static inline uint64_t amd64_cr3_pdb_extract(amd64_cr3_t _regval) __attribute__ ((always_inline));
static inline uint64_t amd64_cr3_pdb_extract(amd64_cr3_t _regval)
{
    return((uint64_t )((_regval & 0xfffffffffffff000) >> 12));
}

static inline amd64_cr3_t amd64_cr3_pdb_insert(amd64_cr3_t _regval, uint64_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr3_t amd64_cr3_pdb_insert(amd64_cr3_t _regval, uint64_t _fieldval)
{
    return((_regval & 0xfff) | (0xfffffffffffff000 & (((amd64_cr3_t )(_fieldval)) << 12)));
}

static inline int amd64_cr3_prtval(char *_s, size_t _size, amd64_cr3_t _regval) __attribute__ ((always_inline));
static inline int amd64_cr3_prtval(char *_s, size_t _size, amd64_cr3_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pwt =\t%" PRIx8 "\t(Page-level writes transparent)\n", amd64_cr3_pwt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcd =\t%" PRIx8 "\t(Page-level cache disable)\n", amd64_cr3_pcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pdb =\t%" PRIx64 "\t(Page-directory base)\n", amd64_cr3_pdb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: amd64_cr4_t
 * Description: Implicit type of Control register 4 register
 * Fields:
 *   vme	(size 1, offset 0, init 0):	RW	Virtual 8086 mode extensions
 *   pvi	(size 1, offset 1, init 0):	RW	Protected-mode virtual interrupts
 *   tsd	(size 1, offset 2, init 0):	RW	Time stamp disable
 *   de	(size 1, offset 3, init 0):	RW	Debugging extensions
 *   pse	(size 1, offset 4, init 0):	RW	Page size extensions
 *   pae	(size 1, offset 5, init 0):	RW	Physical address extensions
 *   mce	(size 1, offset 6, init 0):	RW	Machine-check enable
 *   pge	(size 1, offset 7, init 0):	RW	Page global enable
 *   pce	(size 1, offset 8, init 0):	RW	Performance-monitoring counter enable
 *   osfxsr	(size 1, offset 9, init 0):	RW	OS support for FXSAVE and FXRSTOR instructions
 *   osxmmexcpt	(size 1, offset 10, init 0):	RW	OS support for unmasked SIMD FP exceptions
 *   _anon11	(size 2, offset 11, init 0):	MBZ	_
 *   vmxe	(size 1, offset 13, init 0):	RW	VMX enable
 *   smxe	(size 1, offset 14, init 0):	RW	SMX enable
 *   _anon15	(size 49, offset 15, init 0):	MBZ	_
 */
typedef uint64_t amd64_cr4_t;
#define amd64_cr4_default 0x0
static inline uint8_t amd64_cr4_vme_extract(amd64_cr4_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_vme_extract(amd64_cr4_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline amd64_cr4_t amd64_cr4_vme_insert(amd64_cr4_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr4_t amd64_cr4_vme_insert(amd64_cr4_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffffe) | (0x1 & (((amd64_cr4_t )(_fieldval)) << 0)));
}

static inline uint8_t amd64_cr4_pvi_extract(amd64_cr4_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_pvi_extract(amd64_cr4_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline amd64_cr4_t amd64_cr4_pvi_insert(amd64_cr4_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr4_t amd64_cr4_pvi_insert(amd64_cr4_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffffd) | (0x2 & (((amd64_cr4_t )(_fieldval)) << 1)));
}

static inline uint8_t amd64_cr4_tsd_extract(amd64_cr4_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_tsd_extract(amd64_cr4_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline amd64_cr4_t amd64_cr4_tsd_insert(amd64_cr4_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr4_t amd64_cr4_tsd_insert(amd64_cr4_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffffb) | (0x4 & (((amd64_cr4_t )(_fieldval)) << 2)));
}

static inline uint8_t amd64_cr4_de_extract(amd64_cr4_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_de_extract(amd64_cr4_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline amd64_cr4_t amd64_cr4_de_insert(amd64_cr4_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr4_t amd64_cr4_de_insert(amd64_cr4_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffff7) | (0x8 & (((amd64_cr4_t )(_fieldval)) << 3)));
}

static inline uint8_t amd64_cr4_pse_extract(amd64_cr4_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_pse_extract(amd64_cr4_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline amd64_cr4_t amd64_cr4_pse_insert(amd64_cr4_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr4_t amd64_cr4_pse_insert(amd64_cr4_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffffffffffef) | (0x10 & (((amd64_cr4_t )(_fieldval)) << 4)));
}

static inline uint8_t amd64_cr4_pae_extract(amd64_cr4_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_pae_extract(amd64_cr4_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline amd64_cr4_t amd64_cr4_pae_insert(amd64_cr4_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr4_t amd64_cr4_pae_insert(amd64_cr4_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffffffffffdf) | (0x20 & (((amd64_cr4_t )(_fieldval)) << 5)));
}

static inline uint8_t amd64_cr4_mce_extract(amd64_cr4_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_mce_extract(amd64_cr4_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline amd64_cr4_t amd64_cr4_mce_insert(amd64_cr4_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr4_t amd64_cr4_mce_insert(amd64_cr4_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffffffffffbf) | (0x40 & (((amd64_cr4_t )(_fieldval)) << 6)));
}

static inline uint8_t amd64_cr4_pge_extract(amd64_cr4_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_pge_extract(amd64_cr4_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline amd64_cr4_t amd64_cr4_pge_insert(amd64_cr4_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr4_t amd64_cr4_pge_insert(amd64_cr4_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffffffffff7f) | (0x80 & (((amd64_cr4_t )(_fieldval)) << 7)));
}

static inline uint8_t amd64_cr4_pce_extract(amd64_cr4_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_pce_extract(amd64_cr4_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline amd64_cr4_t amd64_cr4_pce_insert(amd64_cr4_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr4_t amd64_cr4_pce_insert(amd64_cr4_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffeff) | (0x100 & (((amd64_cr4_t )(_fieldval)) << 8)));
}

static inline uint8_t amd64_cr4_osfxsr_extract(amd64_cr4_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_osfxsr_extract(amd64_cr4_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline amd64_cr4_t amd64_cr4_osfxsr_insert(amd64_cr4_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr4_t amd64_cr4_osfxsr_insert(amd64_cr4_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffdff) | (0x200 & (((amd64_cr4_t )(_fieldval)) << 9)));
}

static inline uint8_t amd64_cr4_osxmmexcpt_extract(amd64_cr4_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_osxmmexcpt_extract(amd64_cr4_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline amd64_cr4_t amd64_cr4_osxmmexcpt_insert(amd64_cr4_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr4_t amd64_cr4_osxmmexcpt_insert(amd64_cr4_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffbff) | (0x400 & (((amd64_cr4_t )(_fieldval)) << 10)));
}

static inline uint8_t amd64_cr4_vmxe_extract(amd64_cr4_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_vmxe_extract(amd64_cr4_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline amd64_cr4_t amd64_cr4_vmxe_insert(amd64_cr4_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr4_t amd64_cr4_vmxe_insert(amd64_cr4_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffffffffdfff) | (0x2000 & (((amd64_cr4_t )(_fieldval)) << 13)));
}

static inline uint8_t amd64_cr4_smxe_extract(amd64_cr4_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_smxe_extract(amd64_cr4_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline amd64_cr4_t amd64_cr4_smxe_insert(amd64_cr4_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr4_t amd64_cr4_smxe_insert(amd64_cr4_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffffffffbfff) | (0x4000 & (((amd64_cr4_t )(_fieldval)) << 14)));
}

static inline int amd64_cr4_prtval(char *_s, size_t _size, amd64_cr4_t _regval) __attribute__ ((always_inline));
static inline int amd64_cr4_prtval(char *_s, size_t _size, amd64_cr4_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vme =\t%" PRIx8 "\t(Virtual 8086 mode extensions)\n", amd64_cr4_vme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pvi =\t%" PRIx8 "\t(Protected-mode virtual interrupts)\n", amd64_cr4_pvi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tsd =\t%" PRIx8 "\t(Time stamp disable)\n", amd64_cr4_tsd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " de =\t%" PRIx8 "\t(Debugging extensions)\n", amd64_cr4_de_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pse =\t%" PRIx8 "\t(Page size extensions)\n", amd64_cr4_pse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pae =\t%" PRIx8 "\t(Physical address extensions)\n", amd64_cr4_pae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mce =\t%" PRIx8 "\t(Machine-check enable)\n", amd64_cr4_mce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pge =\t%" PRIx8 "\t(Page global enable)\n", amd64_cr4_pge_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pce =\t%" PRIx8 "\t(Performance-monitoring counter enable)\n", amd64_cr4_pce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " osfxsr =\t%" PRIx8 "\t(OS support for FXSAVE and FXRSTOR instructions)\n", amd64_cr4_osfxsr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " osxmmexcpt =\t%" PRIx8 "\t(OS support for unmasked SIMD FP exceptions)\n", amd64_cr4_osxmmexcpt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vmxe =\t%" PRIx8 "\t(VMX enable)\n", amd64_cr4_vmxe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smxe =\t%" PRIx8 "\t(SMX enable)\n", amd64_cr4_smxe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: amd64_cr8_t
 * Description: Control register 8
 * Fields:
 *   tpl	(size 4, offset 0, init 0):	NOATTR	Task priority level
 *   _anon4	(size 60, offset 4, init 0):	RSVD	_
 */
typedef uint64_t amd64_cr8_t;
#define amd64_cr8_default 0x0
static inline uint8_t amd64_cr8_tpl_extract(amd64_cr8_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_cr8_tpl_extract(amd64_cr8_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline amd64_cr8_t amd64_cr8_tpl_insert(amd64_cr8_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_cr8_t amd64_cr8_tpl_insert(amd64_cr8_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffff0) | (0xf & (((amd64_cr8_t )(_fieldval)) << 0)));
}

static inline int amd64_cr8_prtval(char *_s, size_t _size, amd64_cr8_t _regval) __attribute__ ((always_inline));
static inline int amd64_cr8_prtval(char *_s, size_t _size, amd64_cr8_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tpl =\t%" PRIx8 "\t(Task priority level)\n", amd64_cr8_tpl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: amd64_pdir_entry_t
 * Description: Page-Directory Entry
 * Fields:
 *   present	(size 1, offset 0, init 0):	NOATTR	Present
 *   rw	(size 1, offset 1, init 0):	NOATTR	Read/Write
 *   us	(size 1, offset 2, init 0):	NOATTR	User/Supervisor
 *   pwt	(size 1, offset 3, init 0):	NOATTR	Write-through
 *   pcd	(size 1, offset 4, init 0):	NOATTR	Cache disabled
 *   accessed	(size 1, offset 5, init 0):	NOATTR	Accessed
 *   avail3	(size 1, offset 6, init 0):	NOATTR	Available
 *   _anon7	(size 2, offset 7, init 0):	MBZ	_
 *   avail2	(size 3, offset 9, init 0):	NOATTR	Available
 *   base	(size 28, offset 12, init 0):	NOATTR	Base address
 *   _anon40	(size 12, offset 40, init 0):	MBZ	_
 *   avail	(size 11, offset 52, init 0):	NOATTR	Available
 *   exb	(size 1, offset 63, init 0):	NOATTR	Execute-Disable
 */
typedef uint64_t amd64_pdir_entry_t;
#define amd64_pdir_entry_default 0x0
static inline uint8_t amd64_pdir_entry_present_extract(amd64_pdir_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_pdir_entry_present_extract(amd64_pdir_entry_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline amd64_pdir_entry_t amd64_pdir_entry_present_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_pdir_entry_t amd64_pdir_entry_present_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffffe) | (0x1 & (((amd64_pdir_entry_t )(_fieldval)) << 0)));
}

static inline uint8_t amd64_pdir_entry_rw_extract(amd64_pdir_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_pdir_entry_rw_extract(amd64_pdir_entry_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline amd64_pdir_entry_t amd64_pdir_entry_rw_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_pdir_entry_t amd64_pdir_entry_rw_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffffd) | (0x2 & (((amd64_pdir_entry_t )(_fieldval)) << 1)));
}

static inline uint8_t amd64_pdir_entry_us_extract(amd64_pdir_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_pdir_entry_us_extract(amd64_pdir_entry_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline amd64_pdir_entry_t amd64_pdir_entry_us_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_pdir_entry_t amd64_pdir_entry_us_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffffb) | (0x4 & (((amd64_pdir_entry_t )(_fieldval)) << 2)));
}

static inline uint8_t amd64_pdir_entry_pwt_extract(amd64_pdir_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_pdir_entry_pwt_extract(amd64_pdir_entry_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline amd64_pdir_entry_t amd64_pdir_entry_pwt_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_pdir_entry_t amd64_pdir_entry_pwt_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffff7) | (0x8 & (((amd64_pdir_entry_t )(_fieldval)) << 3)));
}

static inline uint8_t amd64_pdir_entry_pcd_extract(amd64_pdir_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_pdir_entry_pcd_extract(amd64_pdir_entry_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline amd64_pdir_entry_t amd64_pdir_entry_pcd_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_pdir_entry_t amd64_pdir_entry_pcd_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffffffffffef) | (0x10 & (((amd64_pdir_entry_t )(_fieldval)) << 4)));
}

static inline uint8_t amd64_pdir_entry_accessed_extract(amd64_pdir_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_pdir_entry_accessed_extract(amd64_pdir_entry_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline amd64_pdir_entry_t amd64_pdir_entry_accessed_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_pdir_entry_t amd64_pdir_entry_accessed_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffffffffffdf) | (0x20 & (((amd64_pdir_entry_t )(_fieldval)) << 5)));
}

static inline uint8_t amd64_pdir_entry_avail3_extract(amd64_pdir_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_pdir_entry_avail3_extract(amd64_pdir_entry_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline amd64_pdir_entry_t amd64_pdir_entry_avail3_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_pdir_entry_t amd64_pdir_entry_avail3_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffffffffffbf) | (0x40 & (((amd64_pdir_entry_t )(_fieldval)) << 6)));
}

static inline uint8_t amd64_pdir_entry_avail2_extract(amd64_pdir_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_pdir_entry_avail2_extract(amd64_pdir_entry_t _regval)
{
    return((uint8_t )((_regval & 0xe00) >> 9));
}

static inline amd64_pdir_entry_t amd64_pdir_entry_avail2_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_pdir_entry_t amd64_pdir_entry_avail2_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffff1ff) | (0xe00 & (((amd64_pdir_entry_t )(_fieldval)) << 9)));
}

static inline uint32_t amd64_pdir_entry_base_extract(amd64_pdir_entry_t _regval) __attribute__ ((always_inline));
static inline uint32_t amd64_pdir_entry_base_extract(amd64_pdir_entry_t _regval)
{
    return((uint32_t )((_regval & 0xfffffff000) >> 12));
}

static inline amd64_pdir_entry_t amd64_pdir_entry_base_insert(amd64_pdir_entry_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline amd64_pdir_entry_t amd64_pdir_entry_base_insert(amd64_pdir_entry_t _regval, uint32_t _fieldval)
{
    return((_regval & 0xffffff0000000fff) | (0xfffffff000 & (((amd64_pdir_entry_t )(_fieldval)) << 12)));
}

static inline uint16_t amd64_pdir_entry_avail_extract(amd64_pdir_entry_t _regval) __attribute__ ((always_inline));
static inline uint16_t amd64_pdir_entry_avail_extract(amd64_pdir_entry_t _regval)
{
    return((uint16_t )((_regval & 0x7ff0000000000000) >> 52));
}

static inline amd64_pdir_entry_t amd64_pdir_entry_avail_insert(amd64_pdir_entry_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline amd64_pdir_entry_t amd64_pdir_entry_avail_insert(amd64_pdir_entry_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x800fffffffffffff) | (0x7ff0000000000000 & (((amd64_pdir_entry_t )(_fieldval)) << 52)));
}

static inline uint8_t amd64_pdir_entry_exb_extract(amd64_pdir_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_pdir_entry_exb_extract(amd64_pdir_entry_t _regval)
{
    return((uint8_t )((_regval & 0x8000000000000000) >> 63));
}

static inline amd64_pdir_entry_t amd64_pdir_entry_exb_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_pdir_entry_t amd64_pdir_entry_exb_insert(amd64_pdir_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffffffffffff) | (0x8000000000000000 & (((amd64_pdir_entry_t )(_fieldval)) << 63)));
}

static inline int amd64_pdir_entry_prtval(char *_s, size_t _size, amd64_pdir_entry_t _regval) __attribute__ ((always_inline));
static inline int amd64_pdir_entry_prtval(char *_s, size_t _size, amd64_pdir_entry_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " present =\t%" PRIx8 "\t(Present)\n", amd64_pdir_entry_present_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rw =\t%" PRIx8 "\t(Read/Write)\n", amd64_pdir_entry_rw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " us =\t%" PRIx8 "\t(User/Supervisor)\n", amd64_pdir_entry_us_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pwt =\t%" PRIx8 "\t(Write-through)\n", amd64_pdir_entry_pwt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcd =\t%" PRIx8 "\t(Cache disabled)\n", amd64_pdir_entry_pcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " accessed =\t%" PRIx8 "\t(Accessed)\n", amd64_pdir_entry_accessed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " avail3 =\t%" PRIx8 "\t(Available)\n", amd64_pdir_entry_avail3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " avail2 =\t%" PRIx8 "\t(Available)\n", amd64_pdir_entry_avail2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " base =\t%" PRIx32 "\t(Base address)\n", amd64_pdir_entry_base_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " avail =\t%" PRIx16 "\t(Available)\n", amd64_pdir_entry_avail_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " exb =\t%" PRIx8 "\t(Execute-Disable)\n", amd64_pdir_entry_exb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: amd64_ptable_entry_t
 * Description: Page-Table Entry
 * Fields:
 *   present	(size 1, offset 0, init 0):	NOATTR	Present
 *   rw	(size 1, offset 1, init 0):	NOATTR	Read/Write
 *   us	(size 1, offset 2, init 0):	NOATTR	User/Supervisor
 *   pwt	(size 1, offset 3, init 0):	NOATTR	Write-through
 *   pcd	(size 1, offset 4, init 0):	NOATTR	Cache disabled
 *   accessed	(size 1, offset 5, init 0):	NOATTR	Accessed
 *   dirty	(size 1, offset 6, init 0):	NOATTR	Dirty
 *   pat	(size 1, offset 7, init 0):	NOATTR	Page-Attribute index
 *   global	(size 1, offset 8, init 0):	NOATTR	Global
 *   avail2	(size 3, offset 9, init 0):	NOATTR	Available
 *   base	(size 28, offset 12, init 0):	NOATTR	Base address
 *   _anon40	(size 12, offset 40, init 0):	MBZ	_
 *   avail	(size 11, offset 52, init 0):	NOATTR	Available
 *   exb	(size 1, offset 63, init 0):	NOATTR	Execute-Disable
 */
typedef uint64_t amd64_ptable_entry_t;
#define amd64_ptable_entry_default 0x0
static inline uint8_t amd64_ptable_entry_present_extract(amd64_ptable_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_ptable_entry_present_extract(amd64_ptable_entry_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline amd64_ptable_entry_t amd64_ptable_entry_present_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_ptable_entry_t amd64_ptable_entry_present_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffffe) | (0x1 & (((amd64_ptable_entry_t )(_fieldval)) << 0)));
}

static inline uint8_t amd64_ptable_entry_rw_extract(amd64_ptable_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_ptable_entry_rw_extract(amd64_ptable_entry_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline amd64_ptable_entry_t amd64_ptable_entry_rw_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_ptable_entry_t amd64_ptable_entry_rw_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffffd) | (0x2 & (((amd64_ptable_entry_t )(_fieldval)) << 1)));
}

static inline uint8_t amd64_ptable_entry_us_extract(amd64_ptable_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_ptable_entry_us_extract(amd64_ptable_entry_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline amd64_ptable_entry_t amd64_ptable_entry_us_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_ptable_entry_t amd64_ptable_entry_us_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffffb) | (0x4 & (((amd64_ptable_entry_t )(_fieldval)) << 2)));
}

static inline uint8_t amd64_ptable_entry_pwt_extract(amd64_ptable_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_ptable_entry_pwt_extract(amd64_ptable_entry_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline amd64_ptable_entry_t amd64_ptable_entry_pwt_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_ptable_entry_t amd64_ptable_entry_pwt_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffff7) | (0x8 & (((amd64_ptable_entry_t )(_fieldval)) << 3)));
}

static inline uint8_t amd64_ptable_entry_pcd_extract(amd64_ptable_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_ptable_entry_pcd_extract(amd64_ptable_entry_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline amd64_ptable_entry_t amd64_ptable_entry_pcd_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_ptable_entry_t amd64_ptable_entry_pcd_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffffffffffef) | (0x10 & (((amd64_ptable_entry_t )(_fieldval)) << 4)));
}

static inline uint8_t amd64_ptable_entry_accessed_extract(amd64_ptable_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_ptable_entry_accessed_extract(amd64_ptable_entry_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline amd64_ptable_entry_t amd64_ptable_entry_accessed_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_ptable_entry_t amd64_ptable_entry_accessed_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffffffffffdf) | (0x20 & (((amd64_ptable_entry_t )(_fieldval)) << 5)));
}

static inline uint8_t amd64_ptable_entry_dirty_extract(amd64_ptable_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_ptable_entry_dirty_extract(amd64_ptable_entry_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline amd64_ptable_entry_t amd64_ptable_entry_dirty_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_ptable_entry_t amd64_ptable_entry_dirty_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffffffffffbf) | (0x40 & (((amd64_ptable_entry_t )(_fieldval)) << 6)));
}

static inline uint8_t amd64_ptable_entry_pat_extract(amd64_ptable_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_ptable_entry_pat_extract(amd64_ptable_entry_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline amd64_ptable_entry_t amd64_ptable_entry_pat_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_ptable_entry_t amd64_ptable_entry_pat_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffffffffff7f) | (0x80 & (((amd64_ptable_entry_t )(_fieldval)) << 7)));
}

static inline uint8_t amd64_ptable_entry_global_extract(amd64_ptable_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_ptable_entry_global_extract(amd64_ptable_entry_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline amd64_ptable_entry_t amd64_ptable_entry_global_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_ptable_entry_t amd64_ptable_entry_global_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffffeff) | (0x100 & (((amd64_ptable_entry_t )(_fieldval)) << 8)));
}

static inline uint8_t amd64_ptable_entry_avail2_extract(amd64_ptable_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_ptable_entry_avail2_extract(amd64_ptable_entry_t _regval)
{
    return((uint8_t )((_regval & 0xe00) >> 9));
}

static inline amd64_ptable_entry_t amd64_ptable_entry_avail2_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_ptable_entry_t amd64_ptable_entry_avail2_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffffffff1ff) | (0xe00 & (((amd64_ptable_entry_t )(_fieldval)) << 9)));
}

static inline uint32_t amd64_ptable_entry_base_extract(amd64_ptable_entry_t _regval) __attribute__ ((always_inline));
static inline uint32_t amd64_ptable_entry_base_extract(amd64_ptable_entry_t _regval)
{
    return((uint32_t )((_regval & 0xfffffff000) >> 12));
}

static inline amd64_ptable_entry_t amd64_ptable_entry_base_insert(amd64_ptable_entry_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline amd64_ptable_entry_t amd64_ptable_entry_base_insert(amd64_ptable_entry_t _regval, uint32_t _fieldval)
{
    return((_regval & 0xffffff0000000fff) | (0xfffffff000 & (((amd64_ptable_entry_t )(_fieldval)) << 12)));
}

static inline uint16_t amd64_ptable_entry_avail_extract(amd64_ptable_entry_t _regval) __attribute__ ((always_inline));
static inline uint16_t amd64_ptable_entry_avail_extract(amd64_ptable_entry_t _regval)
{
    return((uint16_t )((_regval & 0x7ff0000000000000) >> 52));
}

static inline amd64_ptable_entry_t amd64_ptable_entry_avail_insert(amd64_ptable_entry_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline amd64_ptable_entry_t amd64_ptable_entry_avail_insert(amd64_ptable_entry_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x800fffffffffffff) | (0x7ff0000000000000 & (((amd64_ptable_entry_t )(_fieldval)) << 52)));
}

static inline uint8_t amd64_ptable_entry_exb_extract(amd64_ptable_entry_t _regval) __attribute__ ((always_inline));
static inline uint8_t amd64_ptable_entry_exb_extract(amd64_ptable_entry_t _regval)
{
    return((uint8_t )((_regval & 0x8000000000000000) >> 63));
}

static inline amd64_ptable_entry_t amd64_ptable_entry_exb_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline amd64_ptable_entry_t amd64_ptable_entry_exb_insert(amd64_ptable_entry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffffffffffff) | (0x8000000000000000 & (((amd64_ptable_entry_t )(_fieldval)) << 63)));
}

static inline int amd64_ptable_entry_prtval(char *_s, size_t _size, amd64_ptable_entry_t _regval) __attribute__ ((always_inline));
static inline int amd64_ptable_entry_prtval(char *_s, size_t _size, amd64_ptable_entry_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " present =\t%" PRIx8 "\t(Present)\n", amd64_ptable_entry_present_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rw =\t%" PRIx8 "\t(Read/Write)\n", amd64_ptable_entry_rw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " us =\t%" PRIx8 "\t(User/Supervisor)\n", amd64_ptable_entry_us_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pwt =\t%" PRIx8 "\t(Write-through)\n", amd64_ptable_entry_pwt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcd =\t%" PRIx8 "\t(Cache disabled)\n", amd64_ptable_entry_pcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " accessed =\t%" PRIx8 "\t(Accessed)\n", amd64_ptable_entry_accessed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dirty =\t%" PRIx8 "\t(Dirty)\n", amd64_ptable_entry_dirty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pat =\t%" PRIx8 "\t(Page-Attribute index)\n", amd64_ptable_entry_pat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " global =\t%" PRIx8 "\t(Global)\n", amd64_ptable_entry_global_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " avail2 =\t%" PRIx8 "\t(Available)\n", amd64_ptable_entry_avail2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " base =\t%" PRIx32 "\t(Base address)\n", amd64_ptable_entry_base_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " avail =\t%" PRIx16 "\t(Available)\n", amd64_ptable_entry_avail_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " exb =\t%" PRIx8 "\t(Execute-Disable)\n", amd64_ptable_entry_exb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum amd64_initials {
    amd64_cr0_initial = 0x0,
    amd64_cr2_initial = 0x0,
    amd64_cr3_initial = 0x0,
    amd64_cr4_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void amd64_initialize(__DN(t) *_dev) __attribute__ ((always_inline));
static inline void amd64_initialize(__DN(t) *_dev)
{
}

/*
 * Register cr0: Control register 0
 * Type: amd64.cr0 (Implicit type of Control register 0 register)
 *   pe	(size 1, offset 0, init 0):	RW	Protection enable
 *   mp	(size 1, offset 1, init 0):	RW	Monitor coprocessor
 *   em	(size 1, offset 2, init 0):	RW	Emulation
 *   ts	(size 1, offset 3, init 0):	RW	Task switched
 *   et	(size 1, offset 4, init 0):	RW	Extension type
 *   ne	(size 1, offset 5, init 0):	RW	Numeric error
 *   _anon6	(size 10, offset 6, init 0):	RSVD	_
 *   wp	(size 1, offset 16, init 0):	RW	Write protect
 *   _anon17	(size 1, offset 17, init 0):	RSVD	_
 *   am	(size 1, offset 18, init 0):	RW	Alignment mask
 *   _anon19	(size 10, offset 19, init 0):	RSVD	_
 *   nw	(size 1, offset 29, init 0):	RW	Not write-through
 *   cd	(size 1, offset 30, init 0):	RW	Cache disable
 *   pg	(size 1, offset 31, init 0):	RW	Paging
 */
// cr0 has no address, user must supply amd64_cr0_rawrd
static inline amd64_cr0_t amd64_cr0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline amd64_cr0_t amd64_cr0_rd(__DN(t) *_dev)
{
    return(amd64_cr0_rawrd(_dev));
}

// cr0 has no address, user must supply amd64_cr0_rawwr
static inline void amd64_cr0_wr(__DN(t) *_dev, amd64_cr0_t _regval) __attribute__ ((always_inline));
static inline void amd64_cr0_wr(__DN(t) *_dev, amd64_cr0_t _regval)
{
    _regval = (_regval & 0xe005003f);
    // No MB1 fields present
    _regval = (_regval | (0x1ffaffc0 & amd64_cr0_rawrd(_dev)));
    amd64_cr0_rawwr(_dev, _regval);
}

static inline int amd64_cr0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int amd64_cr0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    amd64_cr0_t _regval = amd64_cr0_rawrd(_dev);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cr0 (Control register 0): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pe =\t%" PRIx8 "\t(Protection enable)\n", amd64_cr0_pe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mp =\t%" PRIx8 "\t(Monitor coprocessor)\n", amd64_cr0_mp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " em =\t%" PRIx8 "\t(Emulation)\n", amd64_cr0_em_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ts =\t%" PRIx8 "\t(Task switched)\n", amd64_cr0_ts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " et =\t%" PRIx8 "\t(Extension type)\n", amd64_cr0_et_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ne =\t%" PRIx8 "\t(Numeric error)\n", amd64_cr0_ne_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wp =\t%" PRIx8 "\t(Write protect)\n", amd64_cr0_wp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon17 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " am =\t%" PRIx8 "\t(Alignment mask)\n", amd64_cr0_am_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nw =\t%" PRIx8 "\t(Not write-through)\n", amd64_cr0_nw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cd =\t%" PRIx8 "\t(Cache disable)\n", amd64_cr0_cd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pg =\t%" PRIx8 "\t(Paging)\n", amd64_cr0_pg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t amd64_cr0_pe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_pe_rdf(__DN(t) *_dev)
{
    amd64_cr0_t _regval = amd64_cr0_rawrd(_dev);
    return(amd64_cr0_pe_extract(_regval));
}

static inline uint8_t amd64_cr0_mp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_mp_rdf(__DN(t) *_dev)
{
    amd64_cr0_t _regval = amd64_cr0_rawrd(_dev);
    return(amd64_cr0_mp_extract(_regval));
}

static inline uint8_t amd64_cr0_em_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_em_rdf(__DN(t) *_dev)
{
    amd64_cr0_t _regval = amd64_cr0_rawrd(_dev);
    return(amd64_cr0_em_extract(_regval));
}

static inline uint8_t amd64_cr0_ts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_ts_rdf(__DN(t) *_dev)
{
    amd64_cr0_t _regval = amd64_cr0_rawrd(_dev);
    return(amd64_cr0_ts_extract(_regval));
}

static inline uint8_t amd64_cr0_et_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_et_rdf(__DN(t) *_dev)
{
    amd64_cr0_t _regval = amd64_cr0_rawrd(_dev);
    return(amd64_cr0_et_extract(_regval));
}

static inline uint8_t amd64_cr0_ne_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_ne_rdf(__DN(t) *_dev)
{
    amd64_cr0_t _regval = amd64_cr0_rawrd(_dev);
    return(amd64_cr0_ne_extract(_regval));
}

static inline uint8_t amd64_cr0_wp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_wp_rdf(__DN(t) *_dev)
{
    amd64_cr0_t _regval = amd64_cr0_rawrd(_dev);
    return(amd64_cr0_wp_extract(_regval));
}

static inline uint8_t amd64_cr0_am_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_am_rdf(__DN(t) *_dev)
{
    amd64_cr0_t _regval = amd64_cr0_rawrd(_dev);
    return(amd64_cr0_am_extract(_regval));
}

static inline uint8_t amd64_cr0_nw_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_nw_rdf(__DN(t) *_dev)
{
    amd64_cr0_t _regval = amd64_cr0_rawrd(_dev);
    return(amd64_cr0_nw_extract(_regval));
}

static inline uint8_t amd64_cr0_cd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_cd_rdf(__DN(t) *_dev)
{
    amd64_cr0_t _regval = amd64_cr0_rawrd(_dev);
    return(amd64_cr0_cd_extract(_regval));
}

static inline uint8_t amd64_cr0_pg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr0_pg_rdf(__DN(t) *_dev)
{
    amd64_cr0_t _regval = amd64_cr0_rawrd(_dev);
    return(amd64_cr0_pg_extract(_regval));
}

static inline void amd64_cr0_pe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr0_pe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr0_t _regval = 0x1 & (((amd64_cr0_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & amd64_cr0_rawrd(_dev)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    amd64_cr0_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr0_mp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr0_mp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr0_t _regval = 0x2 & (((amd64_cr0_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & amd64_cr0_rawrd(_dev)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    amd64_cr0_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr0_em_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr0_em_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr0_t _regval = 0x4 & (((amd64_cr0_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & amd64_cr0_rawrd(_dev)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    amd64_cr0_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr0_ts_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr0_ts_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr0_t _regval = 0x8 & (((amd64_cr0_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & amd64_cr0_rawrd(_dev)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    amd64_cr0_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr0_et_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr0_et_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr0_t _regval = 0x10 & (((amd64_cr0_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & amd64_cr0_rawrd(_dev)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    amd64_cr0_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr0_ne_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr0_ne_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr0_t _regval = 0x20 & (((amd64_cr0_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & amd64_cr0_rawrd(_dev)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    amd64_cr0_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr0_wp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr0_wp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr0_t _regval = 0x10000 & (((amd64_cr0_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & amd64_cr0_rawrd(_dev)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    amd64_cr0_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr0_am_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr0_am_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr0_t _regval = 0x40000 & (((amd64_cr0_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfffbffff & amd64_cr0_rawrd(_dev)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    amd64_cr0_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr0_nw_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr0_nw_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr0_t _regval = 0x20000000 & (((amd64_cr0_t )(_fieldval)) << 29);
    _regval = (_regval | (0xdfffffff & amd64_cr0_rawrd(_dev)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    amd64_cr0_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr0_cd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr0_cd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr0_t _regval = 0x40000000 & (((amd64_cr0_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & amd64_cr0_rawrd(_dev)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    amd64_cr0_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr0_pg_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr0_pg_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr0_t _regval = 0x80000000 & (((amd64_cr0_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & amd64_cr0_rawrd(_dev)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    amd64_cr0_rawwr(_dev, _regval);
    // No shadow register to write to
}

/*
 * Register cr2: Page-fault linear address
 * Type: amd64.uint64 (primitive type)
 */
// cr2 has no address, user must supply amd64_cr2_rawrd
static inline uint64_t amd64_cr2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint64_t amd64_cr2_rd(__DN(t) *_dev)
{
    return(amd64_cr2_rawrd(_dev));
}

// cr2 has no address, user must supply amd64_cr2_rawwr
static inline void amd64_cr2_wr(__DN(t) *_dev, uint64_t _regval) __attribute__ ((always_inline));
static inline void amd64_cr2_wr(__DN(t) *_dev, uint64_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    amd64_cr2_rawwr(_dev, _regval);
}

static inline int amd64_cr2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int amd64_cr2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint64_t _regval = amd64_cr2_rawrd(_dev);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cr2 (Page-fault linear address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx64 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register cr3: Control register 3 (PDBR)
 * Type: amd64.cr3 (Implicit type of Control register 3 (PDBR) register)
 *   _anon0	(size 3, offset 0, init 0):	RSVD	_
 *   pwt	(size 1, offset 3, init 0):	RW	Page-level writes transparent
 *   pcd	(size 1, offset 4, init 0):	RW	Page-level cache disable
 *   _anon5	(size 7, offset 5, init 0):	RSVD	_
 *   pdb	(size 52, offset 12, init 0):	RW	Page-directory base
 */
// cr3 has no address, user must supply amd64_cr3_rawrd
static inline amd64_cr3_t amd64_cr3_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline amd64_cr3_t amd64_cr3_rd(__DN(t) *_dev)
{
    return(amd64_cr3_rawrd(_dev));
}

// cr3 has no address, user must supply amd64_cr3_rawwr
static inline void amd64_cr3_wr(__DN(t) *_dev, amd64_cr3_t _regval) __attribute__ ((always_inline));
static inline void amd64_cr3_wr(__DN(t) *_dev, amd64_cr3_t _regval)
{
    _regval = (_regval & 0xfffffffffffff018);
    // No MB1 fields present
    _regval = (_regval | (0xfe7 & amd64_cr3_rawrd(_dev)));
    amd64_cr3_rawwr(_dev, _regval);
}

static inline int amd64_cr3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int amd64_cr3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    amd64_cr3_t _regval = amd64_cr3_rawrd(_dev);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cr3 (Control register 3 (PDBR)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pwt =\t%" PRIx8 "\t(Page-level writes transparent)\n", amd64_cr3_pwt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcd =\t%" PRIx8 "\t(Page-level cache disable)\n", amd64_cr3_pcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pdb =\t%" PRIx64 "\t(Page-directory base)\n", amd64_cr3_pdb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t amd64_cr3_pwt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr3_pwt_rdf(__DN(t) *_dev)
{
    amd64_cr3_t _regval = amd64_cr3_rawrd(_dev);
    return(amd64_cr3_pwt_extract(_regval));
}

static inline uint8_t amd64_cr3_pcd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr3_pcd_rdf(__DN(t) *_dev)
{
    amd64_cr3_t _regval = amd64_cr3_rawrd(_dev);
    return(amd64_cr3_pcd_extract(_regval));
}

static inline uint64_t amd64_cr3_pdb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint64_t amd64_cr3_pdb_rdf(__DN(t) *_dev)
{
    amd64_cr3_t _regval = amd64_cr3_rawrd(_dev);
    return(amd64_cr3_pdb_extract(_regval));
}

static inline void amd64_cr3_pwt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr3_pwt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr3_t _regval = 0x8 & (((amd64_cr3_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffffffffffff7 & amd64_cr3_rawrd(_dev)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    amd64_cr3_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr3_pcd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr3_pcd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr3_t _regval = 0x10 & (((amd64_cr3_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffffffffffef & amd64_cr3_rawrd(_dev)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    amd64_cr3_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr3_pdb_wrf(__DN(t) *_dev, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr3_pdb_wrf(__DN(t) *_dev, uint64_t _fieldval)
{
    amd64_cr3_t _regval = 0xfffffffffffff000 & (((amd64_cr3_t )(_fieldval)) << 12);
    _regval = (_regval | (0xfff & amd64_cr3_rawrd(_dev)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    amd64_cr3_rawwr(_dev, _regval);
    // No shadow register to write to
}

/*
 * Register cr4: Control register 4
 * Type: amd64.cr4 (Implicit type of Control register 4 register)
 *   vme	(size 1, offset 0, init 0):	RW	Virtual 8086 mode extensions
 *   pvi	(size 1, offset 1, init 0):	RW	Protected-mode virtual interrupts
 *   tsd	(size 1, offset 2, init 0):	RW	Time stamp disable
 *   de	(size 1, offset 3, init 0):	RW	Debugging extensions
 *   pse	(size 1, offset 4, init 0):	RW	Page size extensions
 *   pae	(size 1, offset 5, init 0):	RW	Physical address extensions
 *   mce	(size 1, offset 6, init 0):	RW	Machine-check enable
 *   pge	(size 1, offset 7, init 0):	RW	Page global enable
 *   pce	(size 1, offset 8, init 0):	RW	Performance-monitoring counter enable
 *   osfxsr	(size 1, offset 9, init 0):	RW	OS support for FXSAVE and FXRSTOR instructions
 *   osxmmexcpt	(size 1, offset 10, init 0):	RW	OS support for unmasked SIMD FP exceptions
 *   _anon11	(size 2, offset 11, init 0):	MBZ	_
 *   vmxe	(size 1, offset 13, init 0):	RW	VMX enable
 *   smxe	(size 1, offset 14, init 0):	RW	SMX enable
 *   _anon15	(size 49, offset 15, init 0):	MBZ	_
 */
// cr4 has no address, user must supply amd64_cr4_rawrd
static inline amd64_cr4_t amd64_cr4_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline amd64_cr4_t amd64_cr4_rd(__DN(t) *_dev)
{
    return(amd64_cr4_rawrd(_dev));
}

// cr4 has no address, user must supply amd64_cr4_rawwr
static inline void amd64_cr4_wr(__DN(t) *_dev, amd64_cr4_t _regval) __attribute__ ((always_inline));
static inline void amd64_cr4_wr(__DN(t) *_dev, amd64_cr4_t _regval)
{
    _regval = (_regval & 0x67ff);
    // No MB1 fields present
    // No pre-read of register required
    amd64_cr4_rawwr(_dev, _regval);
}

static inline int amd64_cr4_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int amd64_cr4_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    amd64_cr4_t _regval = amd64_cr4_rawrd(_dev);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cr4 (Control register 4): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vme =\t%" PRIx8 "\t(Virtual 8086 mode extensions)\n", amd64_cr4_vme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pvi =\t%" PRIx8 "\t(Protected-mode virtual interrupts)\n", amd64_cr4_pvi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tsd =\t%" PRIx8 "\t(Time stamp disable)\n", amd64_cr4_tsd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " de =\t%" PRIx8 "\t(Debugging extensions)\n", amd64_cr4_de_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pse =\t%" PRIx8 "\t(Page size extensions)\n", amd64_cr4_pse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pae =\t%" PRIx8 "\t(Physical address extensions)\n", amd64_cr4_pae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mce =\t%" PRIx8 "\t(Machine-check enable)\n", amd64_cr4_mce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pge =\t%" PRIx8 "\t(Page global enable)\n", amd64_cr4_pge_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pce =\t%" PRIx8 "\t(Performance-monitoring counter enable)\n", amd64_cr4_pce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " osfxsr =\t%" PRIx8 "\t(OS support for FXSAVE and FXRSTOR instructions)\n", amd64_cr4_osfxsr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " osxmmexcpt =\t%" PRIx8 "\t(OS support for unmasked SIMD FP exceptions)\n", amd64_cr4_osxmmexcpt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vmxe =\t%" PRIx8 "\t(VMX enable)\n", amd64_cr4_vmxe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smxe =\t%" PRIx8 "\t(SMX enable)\n", amd64_cr4_smxe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    return(_r);
}

static inline uint8_t amd64_cr4_vme_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_vme_rdf(__DN(t) *_dev)
{
    amd64_cr4_t _regval = amd64_cr4_rawrd(_dev);
    return(amd64_cr4_vme_extract(_regval));
}

static inline uint8_t amd64_cr4_pvi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_pvi_rdf(__DN(t) *_dev)
{
    amd64_cr4_t _regval = amd64_cr4_rawrd(_dev);
    return(amd64_cr4_pvi_extract(_regval));
}

static inline uint8_t amd64_cr4_tsd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_tsd_rdf(__DN(t) *_dev)
{
    amd64_cr4_t _regval = amd64_cr4_rawrd(_dev);
    return(amd64_cr4_tsd_extract(_regval));
}

static inline uint8_t amd64_cr4_de_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_de_rdf(__DN(t) *_dev)
{
    amd64_cr4_t _regval = amd64_cr4_rawrd(_dev);
    return(amd64_cr4_de_extract(_regval));
}

static inline uint8_t amd64_cr4_pse_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_pse_rdf(__DN(t) *_dev)
{
    amd64_cr4_t _regval = amd64_cr4_rawrd(_dev);
    return(amd64_cr4_pse_extract(_regval));
}

static inline uint8_t amd64_cr4_pae_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_pae_rdf(__DN(t) *_dev)
{
    amd64_cr4_t _regval = amd64_cr4_rawrd(_dev);
    return(amd64_cr4_pae_extract(_regval));
}

static inline uint8_t amd64_cr4_mce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_mce_rdf(__DN(t) *_dev)
{
    amd64_cr4_t _regval = amd64_cr4_rawrd(_dev);
    return(amd64_cr4_mce_extract(_regval));
}

static inline uint8_t amd64_cr4_pge_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_pge_rdf(__DN(t) *_dev)
{
    amd64_cr4_t _regval = amd64_cr4_rawrd(_dev);
    return(amd64_cr4_pge_extract(_regval));
}

static inline uint8_t amd64_cr4_pce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_pce_rdf(__DN(t) *_dev)
{
    amd64_cr4_t _regval = amd64_cr4_rawrd(_dev);
    return(amd64_cr4_pce_extract(_regval));
}

static inline uint8_t amd64_cr4_osfxsr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_osfxsr_rdf(__DN(t) *_dev)
{
    amd64_cr4_t _regval = amd64_cr4_rawrd(_dev);
    return(amd64_cr4_osfxsr_extract(_regval));
}

static inline uint8_t amd64_cr4_osxmmexcpt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_osxmmexcpt_rdf(__DN(t) *_dev)
{
    amd64_cr4_t _regval = amd64_cr4_rawrd(_dev);
    return(amd64_cr4_osxmmexcpt_extract(_regval));
}

static inline uint8_t amd64_cr4_vmxe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_vmxe_rdf(__DN(t) *_dev)
{
    amd64_cr4_t _regval = amd64_cr4_rawrd(_dev);
    return(amd64_cr4_vmxe_extract(_regval));
}

static inline uint8_t amd64_cr4_smxe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t amd64_cr4_smxe_rdf(__DN(t) *_dev)
{
    amd64_cr4_t _regval = amd64_cr4_rawrd(_dev);
    return(amd64_cr4_smxe_extract(_regval));
}

static inline void amd64_cr4_vme_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr4_vme_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr4_t _regval = 0x1 & (((amd64_cr4_t )(_fieldval)) << 0);
    _regval = (_regval | (0x67fe & amd64_cr4_rawrd(_dev)));
    // No read of register shadow required
    _regval = (_regval & 0x67ff);
    // No MB1 fields present
    amd64_cr4_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr4_pvi_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr4_pvi_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr4_t _regval = 0x2 & (((amd64_cr4_t )(_fieldval)) << 1);
    _regval = (_regval | (0x67fd & amd64_cr4_rawrd(_dev)));
    // No read of register shadow required
    _regval = (_regval & 0x67ff);
    // No MB1 fields present
    amd64_cr4_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr4_tsd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr4_tsd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr4_t _regval = 0x4 & (((amd64_cr4_t )(_fieldval)) << 2);
    _regval = (_regval | (0x67fb & amd64_cr4_rawrd(_dev)));
    // No read of register shadow required
    _regval = (_regval & 0x67ff);
    // No MB1 fields present
    amd64_cr4_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr4_de_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr4_de_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr4_t _regval = 0x8 & (((amd64_cr4_t )(_fieldval)) << 3);
    _regval = (_regval | (0x67f7 & amd64_cr4_rawrd(_dev)));
    // No read of register shadow required
    _regval = (_regval & 0x67ff);
    // No MB1 fields present
    amd64_cr4_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr4_pse_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr4_pse_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr4_t _regval = 0x10 & (((amd64_cr4_t )(_fieldval)) << 4);
    _regval = (_regval | (0x67ef & amd64_cr4_rawrd(_dev)));
    // No read of register shadow required
    _regval = (_regval & 0x67ff);
    // No MB1 fields present
    amd64_cr4_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr4_pae_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr4_pae_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr4_t _regval = 0x20 & (((amd64_cr4_t )(_fieldval)) << 5);
    _regval = (_regval | (0x67df & amd64_cr4_rawrd(_dev)));
    // No read of register shadow required
    _regval = (_regval & 0x67ff);
    // No MB1 fields present
    amd64_cr4_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr4_mce_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr4_mce_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr4_t _regval = 0x40 & (((amd64_cr4_t )(_fieldval)) << 6);
    _regval = (_regval | (0x67bf & amd64_cr4_rawrd(_dev)));
    // No read of register shadow required
    _regval = (_regval & 0x67ff);
    // No MB1 fields present
    amd64_cr4_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr4_pge_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr4_pge_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr4_t _regval = 0x80 & (((amd64_cr4_t )(_fieldval)) << 7);
    _regval = (_regval | (0x677f & amd64_cr4_rawrd(_dev)));
    // No read of register shadow required
    _regval = (_regval & 0x67ff);
    // No MB1 fields present
    amd64_cr4_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr4_pce_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr4_pce_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr4_t _regval = 0x100 & (((amd64_cr4_t )(_fieldval)) << 8);
    _regval = (_regval | (0x66ff & amd64_cr4_rawrd(_dev)));
    // No read of register shadow required
    _regval = (_regval & 0x67ff);
    // No MB1 fields present
    amd64_cr4_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr4_osfxsr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr4_osfxsr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr4_t _regval = 0x200 & (((amd64_cr4_t )(_fieldval)) << 9);
    _regval = (_regval | (0x65ff & amd64_cr4_rawrd(_dev)));
    // No read of register shadow required
    _regval = (_regval & 0x67ff);
    // No MB1 fields present
    amd64_cr4_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr4_osxmmexcpt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr4_osxmmexcpt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr4_t _regval = 0x400 & (((amd64_cr4_t )(_fieldval)) << 10);
    _regval = (_regval | (0x63ff & amd64_cr4_rawrd(_dev)));
    // No read of register shadow required
    _regval = (_regval & 0x67ff);
    // No MB1 fields present
    amd64_cr4_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr4_vmxe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr4_vmxe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr4_t _regval = 0x2000 & (((amd64_cr4_t )(_fieldval)) << 13);
    _regval = (_regval | (0x47ff & amd64_cr4_rawrd(_dev)));
    // No read of register shadow required
    _regval = (_regval & 0x67ff);
    // No MB1 fields present
    amd64_cr4_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline void amd64_cr4_smxe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void amd64_cr4_smxe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    amd64_cr4_t _regval = 0x4000 & (((amd64_cr4_t )(_fieldval)) << 14);
    _regval = (_regval | (0x27ff & amd64_cr4_rawrd(_dev)));
    // No read of register shadow required
    _regval = (_regval & 0x67ff);
    // No MB1 fields present
    amd64_cr4_rawwr(_dev, _regval);
    // No shadow register to write to
}

static inline int amd64_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int amd64_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device amd64 (Intel64 and AMD 64-bit architecture definitions):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = amd64_cr0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = amd64_cr2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = amd64_cr3_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = amd64_cr4_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device amd64\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __amd64_DEV_H
