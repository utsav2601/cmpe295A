/*
 * DEVICE DEFINITION: HyperTransport Configuration
 * 
 * Copyright (c) 2007, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich.
 *  Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED: DO NOT EDIT!
 */

#ifndef __ht_config_H
#define __ht_config_H

#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR
#define __DN(x) ht_config ## _ ## x
#ifdef ht_config_PREFIX
#define __DP(x) __DP1(x,ht_config_PREFIX)
#define __DP1(x1,x2) __DP2(x1,x2)
#define __DP2(x1,x2) x2 ## x1
#else
#define __DP(x) ht_config##_ ##x
#endif
#define __STR(x) #x
#define __XTR(x) __STR(x)

/*
 * Constant definition: ht_config.rtdest (Routing Destination)
 */
typedef enum ht_config_rtdest_t {
    __DP(self) = (0x1),
    __DP(link0_0) = (0x2),
    __DP(link1_0) = (0x4),
    __DP(link2_0) = (0x8),
    __DP(link3_0) = (0x10),
    __DP(link0_1) = (0x20),
    __DP(link1_1) = (0x40),
    __DP(link2_1) = (0x80),
    __DP(link3_1) = (0x100),
} ht_config_rtdest_t;

static inline int ht_config_rtdest_prt( char * s, size_t sz, ht_config_rtdest_t e ) __attribute__ ((always_inline));
static inline int ht_config_rtdest_prt( char * s, size_t sz, ht_config_rtdest_t e )
{
    switch (e) {
        case __DP(self):
        return snprintf(s, sz, "%s", "Route to this node");
        case __DP(link0_0):
        return snprintf(s, sz, "%s", "Route to link 0, sublink 0");
        case __DP(link1_0):
        return snprintf(s, sz, "%s", "Route to link 1, sublink 0");
        case __DP(link2_0):
        return snprintf(s, sz, "%s", "Route to link 2, sublink 0");
        case __DP(link3_0):
        return snprintf(s, sz, "%s", "Route to link 3, sublink 0");
        case __DP(link0_1):
        return snprintf(s, sz, "%s", "Route to link 0, sublink 1");
        case __DP(link1_1):
        return snprintf(s, sz, "%s", "Route to link 1, sublink 1");
        case __DP(link2_1):
        return snprintf(s, sz, "%s", "Route to link 2, sublink 1");
        case __DP(link3_1):
        return snprintf(s, sz, "%s", "Route to link 3, sublink 1");
        default:
        return snprintf(s, sz, "Unknown " __XTR(ht_config_rtdest_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int ht_config_rtdest_chk( ht_config_rtdest_t e ) __attribute__ ((always_inline));
static inline int ht_config_rtdest_chk( ht_config_rtdest_t e )
{
    switch (e) {
        case __DP(self):
        return 1;
        case __DP(link0_0):
        return 1;
        case __DP(link1_0):
        return 1;
        case __DP(link2_0):
        return 1;
        case __DP(link3_0):
        return 1;
        case __DP(link0_1):
        return 1;
        case __DP(link1_1):
        return 1;
        case __DP(link2_1):
        return 1;
        case __DP(link3_1):
        return 1;
        default:
        return 0;
    }
}


/*
 * Register type: Routing Table
 */

/*
 * Dump of fields for register type: ht_config_rtnode_t
 *   rqrte (size 9, offset 0):	 NOATTR	  Request Route
 *   rprte (size 9, offset 9):	 NOATTR	  Response Route
 *   bcrte (size 9, offset 18):	 NOATTR	  Broadcast Route
 *   _anon27 (size 5, offset 27):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct ht_config_rtnode_t {
    ht_config_rtdest_t	rqrte	:9;
    ht_config_rtdest_t	rprte	:9;
    ht_config_rtdest_t	bcrte	:9;
    uint8_t	_anon27	:5;
} __attribute__ ((packed))
 ht_config_rtnode_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(ht_config_rtnode_t, sizeof(uint32_t));

typedef union ht_config_rtnode_un {
    ht_config_rtnode_t	val;
    uint32_t	raw;
}
 ht_config_rtnode_un;
static inline int ht_config_rtnode_prtval( char * s, size_t sz, ht_config_rtnode_t v ) __attribute__ ((always_inline));
static inline int ht_config_rtnode_prtval( char * s, size_t sz, ht_config_rtnode_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " rqrte=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = ht_config_rtdest_prt(s+r, _avail, v.rqrte);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Request Route)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " rprte=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = ht_config_rtdest_prt(s+r, _avail, v.rprte);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Response Route)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " bcrte=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = ht_config_rtdest_prt(s+r, _avail, v.bcrte);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Broadcast Route)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Node ID register
 */

/*
 * Dump of fields for register type: ht_config_nodeid_t
 *   nodeid (size 3, offset 0):	 RW	  This Node ID
 *   _anon3 (size 1, offset 3):	 RSVD	  _
 *   nodecnt (size 3, offset 4):	 RW	  Node Count
 *   _anon7 (size 1, offset 7):	 RSVD	  _
 *   sbnode (size 3, offset 8):	 RW	  HyperTransport I/O Hub Node ID
 *   _anon11 (size 1, offset 11):	 RSVD	  _
 *   lknode (size 3, offset 12):	 RW	  Lock Controller Node ID
 *   _anon15 (size 1, offset 15):	 RSVD	  _
 *   cpucnt (size 5, offset 16):	 RW	  CPU Count
 *   _anon21 (size 3, offset 21):	 MBZ	  _
 *   _anon24 (size 8, offset 24):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct ht_config_nodeid_t {
    uint8_t	nodeid	:3;
    uint8_t	_anon3	:1;
    uint8_t	nodecnt	:3;
    uint8_t	_anon7	:1;
    uint8_t	sbnode	:3;
    uint8_t	_anon11	:1;
    uint8_t	lknode	:3;
    uint8_t	_anon15	:1;
    uint8_t	cpucnt	:5;
    uint8_t	_anon21	:3;
    uint8_t	_anon24	:8;
} __attribute__ ((packed))
 ht_config_nodeid_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(ht_config_nodeid_t, sizeof(uint32_t));

typedef union ht_config_nodeid_un {
    ht_config_nodeid_t	val;
    uint32_t	raw;
}
 ht_config_nodeid_un;
static inline int ht_config_nodeid_prtval( char * s, size_t sz, ht_config_nodeid_t v ) __attribute__ ((always_inline));
static inline int ht_config_nodeid_prtval( char * s, size_t sz, ht_config_nodeid_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " nodeid=0x%"PRIx8" (This Node ID)\n", (uint8_t)(v.nodeid));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " nodecnt=0x%"PRIx8" (Node Count)\n", (uint8_t)(v.nodecnt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sbnode=0x%"PRIx8" (HyperTransport I/O Hub Node ID)\n", (uint8_t)(v.sbnode));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lknode=0x%"PRIx8" (Lock Controller Node ID)\n", (uint8_t)(v.lknode));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cpucnt=0x%"PRIx8" (CPU Count)\n", (uint8_t)(v.cpucnt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Unit ID register
 */

/*
 * Dump of fields for register type: ht_config_unitid_t
 *   cpuunit (size 2, offset 0):	 RW	  CPU Unit ID
 *   _anon2 (size 2, offset 2):	 RSVD	  _
 *   mctunit (size 2, offset 4):	 RW	  Memory Controller Unit ID
 *   hbunit (size 2, offset 6):	 RW	  Host Bridge Unit ID
 *   sblink (size 3, offset 8):	 RW	  Southbridge I/O Hub Link ID
 *   _anon11 (size 21, offset 11):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct ht_config_unitid_t {
    uint8_t	cpuunit	:2;
    uint8_t	_anon2	:2;
    uint8_t	mctunit	:2;
    uint8_t	hbunit	:2;
    uint8_t	sblink	:3;
    uint32_t	_anon11	:21;
} __attribute__ ((packed))
 ht_config_unitid_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(ht_config_unitid_t, sizeof(uint32_t));

typedef union ht_config_unitid_un {
    ht_config_unitid_t	val;
    uint32_t	raw;
}
 ht_config_unitid_un;
static inline int ht_config_unitid_prtval( char * s, size_t sz, ht_config_unitid_t v ) __attribute__ ((always_inline));
static inline int ht_config_unitid_prtval( char * s, size_t sz, ht_config_unitid_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cpuunit=0x%"PRIx8" (CPU Unit ID)\n", (uint8_t)(v.cpuunit));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mctunit=0x%"PRIx8" (Memory Controller Unit ID)\n", (uint8_t)(v.mctunit));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " hbunit=0x%"PRIx8" (Host Bridge Unit ID)\n", (uint8_t)(v.hbunit));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sblink=0x%"PRIx8" (Southbridge I/O Hub Link ID)\n", (uint8_t)(v.sblink));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Device representation structure
 */
typedef struct __DN(t) {
    // Device arguments
    mackerel_pci_t	base;
    // Shadow registers
}
 __DN(t);

/*
 * Device Initialization function
 */
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_pci_t base ) __attribute__ ((always_inline));
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_pci_t base )
{
    /* Setting up device arguments*/
    _dev->base = base;
    /* Setting up shadow registers*/
}

// No user-defined spaces

/*
 * Register rtnodes (Routing Table Nodes); type ht_config.rtnode (Routing Table)
 */

/*
 * Dump of fields for register: rtnodes
 *   rqrte (size 9, offset 0):	 RW	  Request Route
 *   rprte (size 9, offset 9):	 RW	  Response Route
 *   bcrte (size 9, offset 18):	 RW	  Broadcast Route
 *   _anon27 (size 5, offset 27):	 RSVD	  _
 */
static const int __DP(rtnodes_length) = 0x8;
static inline uint32_t __DP(rtnodes_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(rtnodes_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_pci_32(_dev->base,(0x40) + (_i *(32/8)));
}

static inline ht_config_rtnode_t __DP(rtnodes_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline ht_config_rtnode_t __DP(rtnodes_rd)( __DN(t) * _dev, int _i )
{
    ht_config_rtnode_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x40) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(rtnodes_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rtnodes_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x40) + (_i *(32/8)),val);
}

static inline void __DP(rtnodes_wr)( __DN(t) * _dev, int _i, ht_config_rtnode_t val ) __attribute__ ((always_inline));
static inline void __DP(rtnodes_wr)( __DN(t) * _dev, int _i, ht_config_rtnode_t val )
{
    ht_config_rtnode_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x40) + (_i *(32/8)));
    u.val.rqrte 	= val.rqrte;
    u.val.rprte 	= val.rprte;
    u.val.bcrte 	= val.bcrte;
    mackerel_write_pci_32(_dev->base,(0x40) + (_i *(32/8)),u.raw);
}

static inline void __DP(rtnodes_rqrte_wrf)( __DN(t) * _dev, int _i, ht_config_rtdest_t val ) __attribute__ ((always_inline));
static inline void __DP(rtnodes_rqrte_wrf)( __DN(t) * _dev, int _i, ht_config_rtdest_t val )
{
    ht_config_rtnode_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x40) + (_i *(32/8)));
    u.val.rqrte = val;
    mackerel_write_pci_32(_dev->base,(0x40) + (_i *(32/8)),u.raw);
}

static inline void __DP(rtnodes_rprte_wrf)( __DN(t) * _dev, int _i, ht_config_rtdest_t val ) __attribute__ ((always_inline));
static inline void __DP(rtnodes_rprte_wrf)( __DN(t) * _dev, int _i, ht_config_rtdest_t val )
{
    ht_config_rtnode_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x40) + (_i *(32/8)));
    u.val.rprte = val;
    mackerel_write_pci_32(_dev->base,(0x40) + (_i *(32/8)),u.raw);
}

static inline void __DP(rtnodes_bcrte_wrf)( __DN(t) * _dev, int _i, ht_config_rtdest_t val ) __attribute__ ((always_inline));
static inline void __DP(rtnodes_bcrte_wrf)( __DN(t) * _dev, int _i, ht_config_rtdest_t val )
{
    ht_config_rtnode_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x40) + (_i *(32/8)));
    u.val.bcrte = val;
    mackerel_write_pci_32(_dev->base,(0x40) + (_i *(32/8)),u.raw);
}


static inline int __DP(rtnodes_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(rtnodes_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    ht_config_rtnode_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x40) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register rtnodes[%d] (Routing Table Nodes):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.rqrte;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rqrte =\t0x%0"PRIx16" (Request Route", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = ht_config_rtdest_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.rprte;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rprte =\t0x%0"PRIx16" (Response Route", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = ht_config_rtdest_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.bcrte;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bcrte =\t0x%0"PRIx16" (Broadcast Route", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = ht_config_rtdest_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(rtnodes_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rtnodes_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x8; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(rtnodes_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register nodeid (Node ID); type ht_config.nodeid (Implicit type of Node ID register)
 */

/*
 * Dump of fields for register: nodeid
 *   nodeid (size 3, offset 0):	 RW	  This Node ID
 *   _anon3 (size 1, offset 3):	 RSVD	  _
 *   nodecnt (size 3, offset 4):	 RW	  Node Count
 *   _anon7 (size 1, offset 7):	 RSVD	  _
 *   sbnode (size 3, offset 8):	 RW	  HyperTransport I/O Hub Node ID
 *   _anon11 (size 1, offset 11):	 RSVD	  _
 *   lknode (size 3, offset 12):	 RW	  Lock Controller Node ID
 *   _anon15 (size 1, offset 15):	 RSVD	  _
 *   cpucnt (size 5, offset 16):	 RW	  CPU Count
 *   _anon21 (size 3, offset 21):	 MBZ	  _
 *   _anon24 (size 8, offset 24):	 RSVD	  _
 */

static inline uint32_t __DP(nodeid_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(nodeid_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x60));
}

static inline ht_config_nodeid_t __DP(nodeid_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline ht_config_nodeid_t __DP(nodeid_rd)( __DN(t) * _dev )
{
    ht_config_nodeid_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x60));
    return u.val;
}

static inline void __DP(nodeid_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(nodeid_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x60),val);
}

static inline void __DP(nodeid_wr)( __DN(t) * _dev, ht_config_nodeid_t val ) __attribute__ ((always_inline));
static inline void __DP(nodeid_wr)( __DN(t) * _dev, ht_config_nodeid_t val )
{
    ht_config_nodeid_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x60));
    u.val.nodeid 	= val.nodeid;
    u.val.nodecnt 	= val.nodecnt;
    u.val.sbnode 	= val.sbnode;
    u.val.lknode 	= val.lknode;
    u.val.cpucnt 	= val.cpucnt;
    u.val._anon21 	= val._anon21;
    u.val._anon21 	= 0;
    mackerel_write_pci_32(_dev->base,(0x60),u.raw);
}

static inline void __DP(nodeid_nodeid_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(nodeid_nodeid_wrf)( __DN(t) * _dev, uint8_t val )
{
    ht_config_nodeid_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x60));
    u.val._anon21 	= 0;
    u.val.nodeid = val;
    mackerel_write_pci_32(_dev->base,(0x60),u.raw);
}

static inline void __DP(nodeid_nodecnt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(nodeid_nodecnt_wrf)( __DN(t) * _dev, uint8_t val )
{
    ht_config_nodeid_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x60));
    u.val._anon21 	= 0;
    u.val.nodecnt = val;
    mackerel_write_pci_32(_dev->base,(0x60),u.raw);
}

static inline void __DP(nodeid_sbnode_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(nodeid_sbnode_wrf)( __DN(t) * _dev, uint8_t val )
{
    ht_config_nodeid_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x60));
    u.val._anon21 	= 0;
    u.val.sbnode = val;
    mackerel_write_pci_32(_dev->base,(0x60),u.raw);
}

static inline void __DP(nodeid_lknode_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(nodeid_lknode_wrf)( __DN(t) * _dev, uint8_t val )
{
    ht_config_nodeid_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x60));
    u.val._anon21 	= 0;
    u.val.lknode = val;
    mackerel_write_pci_32(_dev->base,(0x60),u.raw);
}

static inline void __DP(nodeid_cpucnt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(nodeid_cpucnt_wrf)( __DN(t) * _dev, uint8_t val )
{
    ht_config_nodeid_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x60));
    u.val._anon21 	= 0;
    u.val.cpucnt = val;
    mackerel_write_pci_32(_dev->base,(0x60),u.raw);
}


static inline int __DP(nodeid_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(nodeid_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    ht_config_nodeid_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x60));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register nodeid (Node ID):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.nodeid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " nodeid =\t0x%"PRIx8" (This Node ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.nodecnt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " nodecnt =\t0x%"PRIx8" (Node Count", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.sbnode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sbnode =\t0x%"PRIx8" (HyperTransport I/O Hub Node ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.lknode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lknode =\t0x%"PRIx8" (Lock Controller Node ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.cpucnt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cpucnt =\t0x%"PRIx8" (CPU Count", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    // skipping anonymous field
    return r;
}


/*
 * Register unitid (Unit ID); type ht_config.unitid (Implicit type of Unit ID register)
 */

/*
 * Dump of fields for register: unitid
 *   cpuunit (size 2, offset 0):	 RW	  CPU Unit ID
 *   _anon2 (size 2, offset 2):	 RSVD	  _
 *   mctunit (size 2, offset 4):	 RW	  Memory Controller Unit ID
 *   hbunit (size 2, offset 6):	 RW	  Host Bridge Unit ID
 *   sblink (size 3, offset 8):	 RW	  Southbridge I/O Hub Link ID
 *   _anon11 (size 21, offset 11):	 RSVD	  _
 */

static inline uint32_t __DP(unitid_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(unitid_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x64));
}

static inline ht_config_unitid_t __DP(unitid_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline ht_config_unitid_t __DP(unitid_rd)( __DN(t) * _dev )
{
    ht_config_unitid_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x64));
    return u.val;
}

static inline void __DP(unitid_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(unitid_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x64),val);
}

static inline void __DP(unitid_wr)( __DN(t) * _dev, ht_config_unitid_t val ) __attribute__ ((always_inline));
static inline void __DP(unitid_wr)( __DN(t) * _dev, ht_config_unitid_t val )
{
    ht_config_unitid_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x64));
    u.val.cpuunit 	= val.cpuunit;
    u.val.mctunit 	= val.mctunit;
    u.val.hbunit 	= val.hbunit;
    u.val.sblink 	= val.sblink;
    mackerel_write_pci_32(_dev->base,(0x64),u.raw);
}

static inline void __DP(unitid_cpuunit_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(unitid_cpuunit_wrf)( __DN(t) * _dev, uint8_t val )
{
    ht_config_unitid_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x64));
    u.val.cpuunit = val;
    mackerel_write_pci_32(_dev->base,(0x64),u.raw);
}

static inline void __DP(unitid_mctunit_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(unitid_mctunit_wrf)( __DN(t) * _dev, uint8_t val )
{
    ht_config_unitid_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x64));
    u.val.mctunit = val;
    mackerel_write_pci_32(_dev->base,(0x64),u.raw);
}

static inline void __DP(unitid_hbunit_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(unitid_hbunit_wrf)( __DN(t) * _dev, uint8_t val )
{
    ht_config_unitid_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x64));
    u.val.hbunit = val;
    mackerel_write_pci_32(_dev->base,(0x64),u.raw);
}

static inline void __DP(unitid_sblink_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(unitid_sblink_wrf)( __DN(t) * _dev, uint8_t val )
{
    ht_config_unitid_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x64));
    u.val.sblink = val;
    mackerel_write_pci_32(_dev->base,(0x64),u.raw);
}


static inline int __DP(unitid_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(unitid_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    ht_config_unitid_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x64));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register unitid (Unit ID):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.cpuunit;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cpuunit =\t0x%"PRIx8" (CPU Unit ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.mctunit;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mctunit =\t0x%"PRIx8" (Memory Controller Unit ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.hbunit;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " hbunit =\t0x%"PRIx8" (Host Bridge Unit ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sblink;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sblink =\t0x%"PRIx8" (Southbridge I/O Hub Link ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}

static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Dump of device ht_config (HyperTransport Configuration):\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rtnodes_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(nodeid_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(unitid_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "End of dump of device ht_config\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR


#endif // __ht_config_H
