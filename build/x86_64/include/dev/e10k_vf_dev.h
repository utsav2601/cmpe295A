#ifndef __e10k_vf_DEV_H
#define __e10k_vf_DEV_H 1
/*
 * DEVICE DEFINITION: Intel 82599 10 GbE Controller Virtual Function
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) e10k_vf ## _ ## x
/*
 * Constants defn: e10k_vf.lanid (LAN ID)
 *  - no width specified
 */
typedef uint8_t e10k_vf_lanid_t;
#define e10k_vf_lan_0 ((e10k_vf_lanid_t)0x0)
#define e10k_vf_lan_1 ((e10k_vf_lanid_t)0x1)
#define e10k_vf_lan_not_u1 ((e10k_vf_lanid_t)0x2)
#define e10k_vf_lan_not_u2 ((e10k_vf_lanid_t)0x3)

static inline char *e10k_vf_lanid_describe(e10k_vf_lanid_t _e) __attribute__ ((always_inline));
static inline char *e10k_vf_lanid_describe(e10k_vf_lanid_t _e)
{
    switch (_e) {
    case e10k_vf_lan_0:
        return("lan_0: LAN 0");
    case e10k_vf_lan_1:
        return("lan_1: LAN 1");
    case e10k_vf_lan_not_u1:
        return("lan_not_u1: LAN ID not used");
    case e10k_vf_lan_not_u2:
        return("lan_not_u2: LAN ID not used");
    default:
        return(NULL);
    }
}

static inline int e10k_vf_lanid_prtval(char *_s, size_t _size, e10k_vf_lanid_t _e) __attribute__ ((always_inline));
static inline int e10k_vf_lanid_prtval(char *_s, size_t _size, e10k_vf_lanid_t _e)
{
    char *d = e10k_vf_lanid_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_vf_lanid_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k_vf.mac_lnkmode (MAC link mode status)
 *  - no width specified
 */
typedef uint8_t e10k_vf_mac_lnkmode_t;
#define e10k_vf_lms_1g ((e10k_vf_mac_lnkmode_t)0x0)
#define e10k_vf_lms_10g_par ((e10k_vf_mac_lnkmode_t)0x1)
#define e10k_vf_lms_10g_ser ((e10k_vf_mac_lnkmode_t)0x2)
#define e10k_vf_lms_aneg ((e10k_vf_mac_lnkmode_t)0x3)

static inline char *e10k_vf_mac_lnkmode_describe(e10k_vf_mac_lnkmode_t _e) __attribute__ ((always_inline));
static inline char *e10k_vf_mac_lnkmode_describe(e10k_vf_mac_lnkmode_t _e)
{
    switch (_e) {
    case e10k_vf_lms_1g:
        return("lms_1g: 1 GbE");
    case e10k_vf_lms_10g_par:
        return("lms_10g_par: 10 GbE parallel");
    case e10k_vf_lms_10g_ser:
        return("lms_10g_ser: 10 GbE serial");
    case e10k_vf_lms_aneg:
        return("lms_aneg: auto-negotiation");
    default:
        return(NULL);
    }
}

static inline int e10k_vf_mac_lnkmode_prtval(char *_s, size_t _size, e10k_vf_mac_lnkmode_t _e) __attribute__ ((always_inline));
static inline int e10k_vf_mac_lnkmode_prtval(char *_s, size_t _size, e10k_vf_mac_lnkmode_t _e)
{
    char *d = e10k_vf_mac_lnkmode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_vf_mac_lnkmode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k_vf.link_speed (MAC link speed status)
 *  - no width specified
 */
typedef uint8_t e10k_vf_link_speed_t;
#define e10k_vf_ls_100m ((e10k_vf_link_speed_t)0x1)
#define e10k_vf_ls_1g ((e10k_vf_link_speed_t)0x2)
#define e10k_vf_ls_10g ((e10k_vf_link_speed_t)0x3)

static inline char *e10k_vf_link_speed_describe(e10k_vf_link_speed_t _e) __attribute__ ((always_inline));
static inline char *e10k_vf_link_speed_describe(e10k_vf_link_speed_t _e)
{
    switch (_e) {
    case e10k_vf_ls_100m:
        return("ls_100m: 100 Mb/s");
    case e10k_vf_ls_1g:
        return("ls_1g: 1 GbE");
    case e10k_vf_ls_10g:
        return("ls_10g: 10 GbE");
    default:
        return(NULL);
    }
}

static inline int e10k_vf_link_speed_prtval(char *_s, size_t _size, e10k_vf_link_speed_t _e) __attribute__ ((always_inline));
static inline int e10k_vf_link_speed_prtval(char *_s, size_t _size, e10k_vf_link_speed_t _e)
{
    char *d = e10k_vf_link_speed_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_vf_link_speed_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k_vf.rx_desctype (RX Descriptor Type)
 *  - no width specified
 */
typedef uint8_t e10k_vf_rx_desctype_t;
#define e10k_vf_legacy ((e10k_vf_rx_desctype_t)0x0)
#define e10k_vf_adv_1buf ((e10k_vf_rx_desctype_t)0x1)
#define e10k_vf_adv_hdrsp ((e10k_vf_rx_desctype_t)0x2)
#define e10k_vf_adv_usehb ((e10k_vf_rx_desctype_t)0x5)

static inline char *e10k_vf_rx_desctype_describe(e10k_vf_rx_desctype_t _e) __attribute__ ((always_inline));
static inline char *e10k_vf_rx_desctype_describe(e10k_vf_rx_desctype_t _e)
{
    switch (_e) {
    case e10k_vf_legacy:
        return("legacy: Legacy");
    case e10k_vf_adv_1buf:
        return("adv_1buf: Advanced descriptor one buffer");
    case e10k_vf_adv_hdrsp:
        return("adv_hdrsp: Advanced descriptor header splitting");
    case e10k_vf_adv_usehb:
        return("adv_usehb: Advanced descriptor header splitting always use header buffer");
    default:
        return(NULL);
    }
}

static inline int e10k_vf_rx_desctype_prtval(char *_s, size_t _size, e10k_vf_rx_desctype_t _e) __attribute__ ((always_inline));
static inline int e10k_vf_rx_desctype_prtval(char *_s, size_t _size, e10k_vf_rx_desctype_t _e)
{
    char *d = e10k_vf_rx_desctype_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_vf_rx_desctype_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k_vf.rsc_maxdesc (Maximum descriptors per Large receive)
 *  - no width specified
 */
typedef uint8_t e10k_vf_rsc_maxdesc_t;
#define e10k_vf_max_1desc ((e10k_vf_rsc_maxdesc_t)0x0)
#define e10k_vf_max_4desc ((e10k_vf_rsc_maxdesc_t)0x1)
#define e10k_vf_max_8desc ((e10k_vf_rsc_maxdesc_t)0x2)
#define e10k_vf_max_16desc ((e10k_vf_rsc_maxdesc_t)0x3)

static inline char *e10k_vf_rsc_maxdesc_describe(e10k_vf_rsc_maxdesc_t _e) __attribute__ ((always_inline));
static inline char *e10k_vf_rsc_maxdesc_describe(e10k_vf_rsc_maxdesc_t _e)
{
    switch (_e) {
    case e10k_vf_max_1desc:
        return("max_1desc: Maximum of 1 descriptor per large receive");
    case e10k_vf_max_4desc:
        return("max_4desc: Maximum of 4 descriptors per large receive");
    case e10k_vf_max_8desc:
        return("max_8desc: Maximum of 8 descriptors per large receive");
    case e10k_vf_max_16desc:
        return("max_16desc: Maximum of 16 descriptors per large receive");
    default:
        return(NULL);
    }
}

static inline int e10k_vf_rsc_maxdesc_prtval(char *_s, size_t _size, e10k_vf_rsc_maxdesc_t _e) __attribute__ ((always_inline));
static inline int e10k_vf_rsc_maxdesc_prtval(char *_s, size_t _size, e10k_vf_rsc_maxdesc_t _e)
{
    char *d = e10k_vf_rsc_maxdesc_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_vf_rsc_maxdesc_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: e10k_vf_vfctrl_t
 * Description: Implicit type of VF control register
 * Fields:
 *   _anon0	(size 26, offset 0, init 0):	RSVD	_
 *   rst	(size 1, offset 26, init 0):	WO	Device reset
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
typedef uint32_t e10k_vf_vfctrl_t;
#define e10k_vf_vfctrl_default 0x0
static inline uint8_t e10k_vf_vfctrl_rst_extract(e10k_vf_vfctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfctrl_rst_extract(e10k_vf_vfctrl_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e10k_vf_vfctrl_t e10k_vf_vfctrl_rst_insert(e10k_vf_vfctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfctrl_t e10k_vf_vfctrl_rst_insert(e10k_vf_vfctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e10k_vf_vfctrl_t )(_fieldval)) << 26)));
}

static inline int e10k_vf_vfctrl_prtval(char *_s, size_t _size, e10k_vf_vfctrl_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vfctrl_prtval(char *_s, size_t _size, e10k_vf_vfctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rst =\t%" PRIx8 "\t(Device reset)\n", e10k_vf_vfctrl_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_vfstatus_t
 * Description: Implicit type of VF status register
 * Fields:
 *   _anon0	(size 2, offset 0, init 0):	RSVD	_
 *   lan_id	(size 2, offset 2, init 0):	RO	LAN ID
 *   _anon4	(size 3, offset 4, init 0):	RSVD	_
 *   link_up	(size 1, offset 7, init 0):	RO	Linkup Status Indication
 *   _anon8	(size 2, offset 8, init 0):	RSVD	_
 *   num_vfs	(size 8, offset 10, init 0):	RO	Num VFs
 *   iov_active	(size 1, offset 18, init 0):	RO	IOV Active
 *   pcie_mes	(size 1, offset 19, init 0):	RO	PCIe Master Enable Status
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
typedef uint32_t e10k_vf_vfstatus_t;
#define e10k_vf_vfstatus_default 0x0
static inline e10k_vf_lanid_t e10k_vf_vfstatus_lan_id_extract(e10k_vf_vfstatus_t _regval) __attribute__ ((always_inline));
static inline e10k_vf_lanid_t e10k_vf_vfstatus_lan_id_extract(e10k_vf_vfstatus_t _regval)
{
    return((e10k_vf_lanid_t )((_regval & 0xc) >> 2));
}

static inline e10k_vf_vfstatus_t e10k_vf_vfstatus_lan_id_insert(e10k_vf_vfstatus_t _regval, e10k_vf_lanid_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfstatus_t e10k_vf_vfstatus_lan_id_insert(e10k_vf_vfstatus_t _regval, e10k_vf_lanid_t _fieldval)
{
    return((_regval & 0xfffffff3) | (0xc & (((e10k_vf_vfstatus_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_vf_vfstatus_link_up_extract(e10k_vf_vfstatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfstatus_link_up_extract(e10k_vf_vfstatus_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_vf_vfstatus_t e10k_vf_vfstatus_link_up_insert(e10k_vf_vfstatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfstatus_t e10k_vf_vfstatus_link_up_insert(e10k_vf_vfstatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_vf_vfstatus_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_vf_vfstatus_num_vfs_extract(e10k_vf_vfstatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfstatus_num_vfs_extract(e10k_vf_vfstatus_t _regval)
{
    return((uint8_t )((_regval & 0x3fc00) >> 10));
}

static inline e10k_vf_vfstatus_t e10k_vf_vfstatus_num_vfs_insert(e10k_vf_vfstatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfstatus_t e10k_vf_vfstatus_num_vfs_insert(e10k_vf_vfstatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffc03ff) | (0x3fc00 & (((e10k_vf_vfstatus_t )(_fieldval)) << 10)));
}

static inline uint8_t e10k_vf_vfstatus_iov_active_extract(e10k_vf_vfstatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfstatus_iov_active_extract(e10k_vf_vfstatus_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e10k_vf_vfstatus_t e10k_vf_vfstatus_iov_active_insert(e10k_vf_vfstatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfstatus_t e10k_vf_vfstatus_iov_active_insert(e10k_vf_vfstatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e10k_vf_vfstatus_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_vf_vfstatus_pcie_mes_extract(e10k_vf_vfstatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfstatus_pcie_mes_extract(e10k_vf_vfstatus_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e10k_vf_vfstatus_t e10k_vf_vfstatus_pcie_mes_insert(e10k_vf_vfstatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfstatus_t e10k_vf_vfstatus_pcie_mes_insert(e10k_vf_vfstatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e10k_vf_vfstatus_t )(_fieldval)) << 19)));
}

static inline int e10k_vf_vfstatus_prtval(char *_s, size_t _size, e10k_vf_vfstatus_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vfstatus_prtval(char *_s, size_t _size, e10k_vf_vfstatus_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan_id =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_lanid_prtval(_s + _r, _avail, e10k_vf_vfstatus_lan_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LAN ID)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " link_up =\t%" PRIx8 "\t(Linkup Status Indication)\n", e10k_vf_vfstatus_link_up_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " num_vfs =\t%" PRIx8 "\t(Num VFs)\n", e10k_vf_vfstatus_num_vfs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iov_active =\t%" PRIx8 "\t(IOV Active)\n", e10k_vf_vfstatus_iov_active_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie_mes =\t%" PRIx8 "\t(PCIe Master Enable Status)\n", e10k_vf_vfstatus_pcie_mes_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_vflinks_t
 * Description: Implicit type of VF Link Status Register register
 * Fields:
 *   kxsig_det	(size 1, offset 0, init 0):	RO	A signal is present
 *   fecsig_det	(size 1, offset 1, init 0):	RO	FEC reports signal detected
 *   fecblk_lck	(size 1, offset 2, init 0):	RO	FEC reached block lock
 *   krhberr	(size 1, offset 3, init 0):	RO	10GbE serial KR_PCS high error rate
 *   krpcsbl	(size 1, offset 4, init 0):	RO	10 GbE serial PCS block lock
 *   kxr_annprcv	(size 1, offset 5, init 0):	RO	KX/KX4/KR AN Next Page Received
 *   kxr_anprcv	(size 1, offset 6, init 0):	RO	KX/KX4/KR Backplane Auto Negotiation Page Received
 *   lnk_stat	(size 1, offset 7, init 0):	RO	Link Up and there was no link down from last time read
 *   kx4sig_det	(size 4, offset 8, init 0):	RO	Signal Detect of 10 GbE Parallel (KX4, CX4 or XAUI) (1bit per lane)
 *   krsig_det	(size 1, offset 12, init 0):	RO	Signal Detect of 10 GbE serial (KR or SFI)
 *   l10g_syncst	(size 4, offset 13, init 0):	RO	10G Parallel lane sync status (1bit per lane)
 *   l10g_algst	(size 1, offset 17, init 0):	RO	10 GbE align_status
 *   l1g_syncst	(size 1, offset 18, init 0):	RO	1G sync_status
 *   kxr_anrxid	(size 1, offset 19, init 0):	RO	KX/KX4/KR Backplane Auto Negotiation Rx Idle
 *   l1g_anen	(size 1, offset 20, init 0):	RO	PCS_1 GbE auto-negotiation is enabled
 *   l1g_lnken	(size 1, offset 21, init 0):	RO	1 GbE PCS enabled for 1 GbE and SGMII operation
 *   l10g_lnken	(size 1, offset 22, init 0):	RO	XGXS Enabled for 10 GbE operation
 *   fec_en	(size 1, offset 23, init 0):	RO	Status of forwarderrorcorrection in 10 GbE serial link
 *   l10g_seren	(size 1, offset 24, init 0):	RO	Status of 10 GbE serial PCS (KR PCS) for KR or SFI operation
 *   sgmii_en	(size 1, offset 25, init 0):	RO	Status of SGMII operation
 *   mlink_mode	(size 2, offset 26, init 0):	RO	MAC link mode status
 *   lnk_speed	(size 2, offset 28, init 0):	RO	MAC link speed status
 *   lnk_up	(size 1, offset 30, init 0):	RO	Link is up
 *   kxr_ancomp	(size 1, offset 31, init 0):	RO	KX/KX4/KR backplane auto-negotiation has completed successfully
 */
typedef uint32_t e10k_vf_vflinks_t;
#define e10k_vf_vflinks_default 0x0
static inline uint8_t e10k_vf_vflinks_kxsig_det_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_kxsig_det_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_kxsig_det_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_kxsig_det_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_vf_vflinks_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_vf_vflinks_fecsig_det_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_fecsig_det_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_fecsig_det_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_fecsig_det_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_vf_vflinks_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_vf_vflinks_fecblk_lck_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_fecblk_lck_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_fecblk_lck_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_fecblk_lck_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_vf_vflinks_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_vf_vflinks_krhberr_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_krhberr_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_krhberr_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_krhberr_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_vf_vflinks_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_vf_vflinks_krpcsbl_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_krpcsbl_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_krpcsbl_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_krpcsbl_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_vf_vflinks_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_vf_vflinks_kxr_annprcv_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_kxr_annprcv_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_kxr_annprcv_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_kxr_annprcv_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_vf_vflinks_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_vf_vflinks_kxr_anprcv_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_kxr_anprcv_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_kxr_anprcv_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_kxr_anprcv_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_vf_vflinks_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_vf_vflinks_lnk_stat_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_lnk_stat_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_lnk_stat_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_lnk_stat_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_vf_vflinks_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_vf_vflinks_kx4sig_det_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_kx4sig_det_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0xf00) >> 8));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_kx4sig_det_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_kx4sig_det_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff0ff) | (0xf00 & (((e10k_vf_vflinks_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_vf_vflinks_krsig_det_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_krsig_det_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_krsig_det_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_krsig_det_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e10k_vf_vflinks_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_vf_vflinks_l10g_syncst_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_l10g_syncst_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x1e000) >> 13));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_l10g_syncst_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_l10g_syncst_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe1fff) | (0x1e000 & (((e10k_vf_vflinks_t )(_fieldval)) << 13)));
}

static inline uint8_t e10k_vf_vflinks_l10g_algst_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_l10g_algst_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_l10g_algst_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_l10g_algst_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e10k_vf_vflinks_t )(_fieldval)) << 17)));
}

static inline uint8_t e10k_vf_vflinks_l1g_syncst_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_l1g_syncst_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_l1g_syncst_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_l1g_syncst_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e10k_vf_vflinks_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_vf_vflinks_kxr_anrxid_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_kxr_anrxid_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_kxr_anrxid_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_kxr_anrxid_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e10k_vf_vflinks_t )(_fieldval)) << 19)));
}

static inline uint8_t e10k_vf_vflinks_l1g_anen_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_l1g_anen_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_l1g_anen_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_l1g_anen_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e10k_vf_vflinks_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_vf_vflinks_l1g_lnken_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_l1g_lnken_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_l1g_lnken_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_l1g_lnken_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e10k_vf_vflinks_t )(_fieldval)) << 21)));
}

static inline uint8_t e10k_vf_vflinks_l10g_lnken_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_l10g_lnken_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_l10g_lnken_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_l10g_lnken_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e10k_vf_vflinks_t )(_fieldval)) << 22)));
}

static inline uint8_t e10k_vf_vflinks_fec_en_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_fec_en_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_fec_en_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_fec_en_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e10k_vf_vflinks_t )(_fieldval)) << 23)));
}

static inline uint8_t e10k_vf_vflinks_l10g_seren_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_l10g_seren_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_l10g_seren_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_l10g_seren_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((e10k_vf_vflinks_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_vf_vflinks_sgmii_en_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_sgmii_en_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_sgmii_en_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_sgmii_en_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e10k_vf_vflinks_t )(_fieldval)) << 25)));
}

static inline e10k_vf_mac_lnkmode_t e10k_vf_vflinks_mlink_mode_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline e10k_vf_mac_lnkmode_t e10k_vf_vflinks_mlink_mode_extract(e10k_vf_vflinks_t _regval)
{
    return((e10k_vf_mac_lnkmode_t )((_regval & 0xc000000) >> 26));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_mlink_mode_insert(e10k_vf_vflinks_t _regval, e10k_vf_mac_lnkmode_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_mlink_mode_insert(e10k_vf_vflinks_t _regval, e10k_vf_mac_lnkmode_t _fieldval)
{
    return((_regval & 0xf3ffffff) | (0xc000000 & (((e10k_vf_vflinks_t )(_fieldval)) << 26)));
}

static inline e10k_vf_link_speed_t e10k_vf_vflinks_lnk_speed_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline e10k_vf_link_speed_t e10k_vf_vflinks_lnk_speed_extract(e10k_vf_vflinks_t _regval)
{
    return((e10k_vf_link_speed_t )((_regval & 0x30000000) >> 28));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_lnk_speed_insert(e10k_vf_vflinks_t _regval, e10k_vf_link_speed_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_lnk_speed_insert(e10k_vf_vflinks_t _regval, e10k_vf_link_speed_t _fieldval)
{
    return((_regval & 0xcfffffff) | (0x30000000 & (((e10k_vf_vflinks_t )(_fieldval)) << 28)));
}

static inline uint8_t e10k_vf_vflinks_lnk_up_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_lnk_up_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_lnk_up_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_lnk_up_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_vf_vflinks_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_vf_vflinks_kxr_ancomp_extract(e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_kxr_ancomp_extract(e10k_vf_vflinks_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_kxr_ancomp_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_kxr_ancomp_insert(e10k_vf_vflinks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_vf_vflinks_t )(_fieldval)) << 31)));
}

static inline int e10k_vf_vflinks_prtval(char *_s, size_t _size, e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vflinks_prtval(char *_s, size_t _size, e10k_vf_vflinks_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxsig_det =\t%" PRIx8 "\t(A signal is present)\n", e10k_vf_vflinks_kxsig_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fecsig_det =\t%" PRIx8 "\t(FEC reports signal detected)\n", e10k_vf_vflinks_fecsig_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fecblk_lck =\t%" PRIx8 "\t(FEC reached block lock)\n", e10k_vf_vflinks_fecblk_lck_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " krhberr =\t%" PRIx8 "\t(10GbE serial KR_PCS high error rate)\n", e10k_vf_vflinks_krhberr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " krpcsbl =\t%" PRIx8 "\t(10 GbE serial PCS block lock)\n", e10k_vf_vflinks_krpcsbl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxr_annprcv =\t%" PRIx8 "\t(KX/KX4/KR AN Next Page Received)\n", e10k_vf_vflinks_kxr_annprcv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxr_anprcv =\t%" PRIx8 "\t(KX/KX4/KR Backplane Auto Negotiation Page Received)\n", e10k_vf_vflinks_kxr_anprcv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_stat =\t%" PRIx8 "\t(Link Up and there was no link down from last time read)\n", e10k_vf_vflinks_lnk_stat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kx4sig_det =\t%" PRIx8 "\t(Signal Detect of 10 GbE Parallel (KX4, CX4 or XAUI) (1bit per lane))\n", e10k_vf_vflinks_kx4sig_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " krsig_det =\t%" PRIx8 "\t(Signal Detect of 10 GbE serial (KR or SFI))\n", e10k_vf_vflinks_krsig_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l10g_syncst =\t%" PRIx8 "\t(10G Parallel lane sync status (1bit per lane))\n", e10k_vf_vflinks_l10g_syncst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l10g_algst =\t%" PRIx8 "\t(10 GbE align_status)\n", e10k_vf_vflinks_l10g_algst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1g_syncst =\t%" PRIx8 "\t(1G sync_status)\n", e10k_vf_vflinks_l1g_syncst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxr_anrxid =\t%" PRIx8 "\t(KX/KX4/KR Backplane Auto Negotiation Rx Idle)\n", e10k_vf_vflinks_kxr_anrxid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1g_anen =\t%" PRIx8 "\t(PCS_1 GbE auto-negotiation is enabled)\n", e10k_vf_vflinks_l1g_anen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1g_lnken =\t%" PRIx8 "\t(1 GbE PCS enabled for 1 GbE and SGMII operation)\n", e10k_vf_vflinks_l1g_lnken_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l10g_lnken =\t%" PRIx8 "\t(XGXS Enabled for 10 GbE operation)\n", e10k_vf_vflinks_l10g_lnken_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_en =\t%" PRIx8 "\t(Status of forwarderrorcorrection in 10 GbE serial link)\n", e10k_vf_vflinks_fec_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l10g_seren =\t%" PRIx8 "\t(Status of 10 GbE serial PCS (KR PCS) for KR or SFI operation)\n", e10k_vf_vflinks_l10g_seren_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sgmii_en =\t%" PRIx8 "\t(Status of SGMII operation)\n", e10k_vf_vflinks_sgmii_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mlink_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_mac_lnkmode_prtval(_s + _r, _avail, e10k_vf_vflinks_mlink_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(MAC link mode status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_speed =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_link_speed_prtval(_s + _r, _avail, e10k_vf_vflinks_lnk_speed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(MAC link speed status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_up =\t%" PRIx8 "\t(Link is up)\n", e10k_vf_vflinks_lnk_up_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxr_ancomp =\t%" PRIx8 "\t(KX/KX4/KR backplane auto-negotiation has completed successfully)\n", e10k_vf_vflinks_kxr_ancomp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_vfrxmemwrap_t
 * Description: Implicit type of VF Rx Packet Buffer Flush Detect register
 * Fields:
 *   tc0_wrap	(size 3, offset 0, init 0):	RO	Packet Buffer 0 Wrap Around Counter
 *   tc0_empty	(size 1, offset 3, init 0):	RO	Packet Buffer 0 Empty
 *   tc1_wrap	(size 3, offset 4, init 0):	RO	Packet Buffer 1 Wrap Around Counter
 *   tc1_empty	(size 1, offset 7, init 0):	RO	Packet Buffer 1 Empty
 *   tc2_wrap	(size 3, offset 8, init 0):	RO	Packet Buffer 2 Wrap Around Counter
 *   tc2_empty	(size 1, offset 11, init 0):	RO	Packet Buffer 2 Empty
 *   tc3_wrap	(size 3, offset 12, init 0):	RO	Packet Buffer 3 Wrap Around Counter
 *   tc3_empty	(size 1, offset 15, init 0):	RO	Packet Buffer 3 Empty
 *   tc4_wrap	(size 3, offset 16, init 0):	RO	Packet Buffer 4 Wrap Around Counter
 *   tc4_empty	(size 1, offset 19, init 0):	RO	Packet Buffer 4 Empty
 *   tc5_wrap	(size 3, offset 20, init 0):	RO	Packet Buffer 5 Wrap Around Counter
 *   tc5_empty	(size 1, offset 23, init 0):	RO	Packet Buffer 5 Empty
 *   tc6_wrap	(size 3, offset 24, init 0):	RO	Packet Buffer 6 Wrap Around Counter
 *   tc6_empty	(size 1, offset 27, init 0):	RO	Packet Buffer 6 Empty
 *   tc7_wrap	(size 3, offset 28, init 0):	RO	Packet Buffer 7 Wrap Around Counter
 *   tc7_empty	(size 1, offset 31, init 0):	RO	Packet Buffer 7 Empty
 */
typedef uint32_t e10k_vf_vfrxmemwrap_t;
#define e10k_vf_vfrxmemwrap_default 0x0
static inline uint8_t e10k_vf_vfrxmemwrap_tc0_wrap_extract(e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc0_wrap_extract(e10k_vf_vfrxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc0_wrap_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc0_wrap_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((e10k_vf_vfrxmemwrap_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc0_empty_extract(e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc0_empty_extract(e10k_vf_vfrxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc0_empty_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc0_empty_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_vf_vfrxmemwrap_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc1_wrap_extract(e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc1_wrap_extract(e10k_vf_vfrxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x70) >> 4));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc1_wrap_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc1_wrap_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff8f) | (0x70 & (((e10k_vf_vfrxmemwrap_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc1_empty_extract(e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc1_empty_extract(e10k_vf_vfrxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc1_empty_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc1_empty_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_vf_vfrxmemwrap_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc2_wrap_extract(e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc2_wrap_extract(e10k_vf_vfrxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x700) >> 8));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc2_wrap_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc2_wrap_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff8ff) | (0x700 & (((e10k_vf_vfrxmemwrap_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc2_empty_extract(e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc2_empty_extract(e10k_vf_vfrxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc2_empty_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc2_empty_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e10k_vf_vfrxmemwrap_t )(_fieldval)) << 11)));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc3_wrap_extract(e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc3_wrap_extract(e10k_vf_vfrxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x7000) >> 12));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc3_wrap_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc3_wrap_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff8fff) | (0x7000 & (((e10k_vf_vfrxmemwrap_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc3_empty_extract(e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc3_empty_extract(e10k_vf_vfrxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc3_empty_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc3_empty_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_vf_vfrxmemwrap_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc4_wrap_extract(e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc4_wrap_extract(e10k_vf_vfrxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x70000) >> 16));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc4_wrap_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc4_wrap_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff8ffff) | (0x70000 & (((e10k_vf_vfrxmemwrap_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc4_empty_extract(e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc4_empty_extract(e10k_vf_vfrxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc4_empty_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc4_empty_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e10k_vf_vfrxmemwrap_t )(_fieldval)) << 19)));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc5_wrap_extract(e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc5_wrap_extract(e10k_vf_vfrxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x700000) >> 20));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc5_wrap_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc5_wrap_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff8fffff) | (0x700000 & (((e10k_vf_vfrxmemwrap_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc5_empty_extract(e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc5_empty_extract(e10k_vf_vfrxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc5_empty_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc5_empty_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e10k_vf_vfrxmemwrap_t )(_fieldval)) << 23)));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc6_wrap_extract(e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc6_wrap_extract(e10k_vf_vfrxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x7000000) >> 24));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc6_wrap_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc6_wrap_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf8ffffff) | (0x7000000 & (((e10k_vf_vfrxmemwrap_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc6_empty_extract(e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc6_empty_extract(e10k_vf_vfrxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc6_empty_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc6_empty_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e10k_vf_vfrxmemwrap_t )(_fieldval)) << 27)));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc7_wrap_extract(e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc7_wrap_extract(e10k_vf_vfrxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x70000000) >> 28));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc7_wrap_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc7_wrap_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x8fffffff) | (0x70000000 & (((e10k_vf_vfrxmemwrap_t )(_fieldval)) << 28)));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc7_empty_extract(e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc7_empty_extract(e10k_vf_vfrxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc7_empty_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_tc7_empty_insert(e10k_vf_vfrxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_vf_vfrxmemwrap_t )(_fieldval)) << 31)));
}

static inline int e10k_vf_vfrxmemwrap_prtval(char *_s, size_t _size, e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vfrxmemwrap_prtval(char *_s, size_t _size, e10k_vf_vfrxmemwrap_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc0_wrap =\t%" PRIx8 "\t(Packet Buffer 0 Wrap Around Counter)\n", e10k_vf_vfrxmemwrap_tc0_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc0_empty =\t%" PRIx8 "\t(Packet Buffer 0 Empty)\n", e10k_vf_vfrxmemwrap_tc0_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc1_wrap =\t%" PRIx8 "\t(Packet Buffer 1 Wrap Around Counter)\n", e10k_vf_vfrxmemwrap_tc1_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc1_empty =\t%" PRIx8 "\t(Packet Buffer 1 Empty)\n", e10k_vf_vfrxmemwrap_tc1_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc2_wrap =\t%" PRIx8 "\t(Packet Buffer 2 Wrap Around Counter)\n", e10k_vf_vfrxmemwrap_tc2_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc2_empty =\t%" PRIx8 "\t(Packet Buffer 2 Empty)\n", e10k_vf_vfrxmemwrap_tc2_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc3_wrap =\t%" PRIx8 "\t(Packet Buffer 3 Wrap Around Counter)\n", e10k_vf_vfrxmemwrap_tc3_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc3_empty =\t%" PRIx8 "\t(Packet Buffer 3 Empty)\n", e10k_vf_vfrxmemwrap_tc3_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc4_wrap =\t%" PRIx8 "\t(Packet Buffer 4 Wrap Around Counter)\n", e10k_vf_vfrxmemwrap_tc4_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc4_empty =\t%" PRIx8 "\t(Packet Buffer 4 Empty)\n", e10k_vf_vfrxmemwrap_tc4_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc5_wrap =\t%" PRIx8 "\t(Packet Buffer 5 Wrap Around Counter)\n", e10k_vf_vfrxmemwrap_tc5_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc5_empty =\t%" PRIx8 "\t(Packet Buffer 5 Empty)\n", e10k_vf_vfrxmemwrap_tc5_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc6_wrap =\t%" PRIx8 "\t(Packet Buffer 6 Wrap Around Counter)\n", e10k_vf_vfrxmemwrap_tc6_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc6_empty =\t%" PRIx8 "\t(Packet Buffer 6 Empty)\n", e10k_vf_vfrxmemwrap_tc6_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc7_wrap =\t%" PRIx8 "\t(Packet Buffer 7 Wrap Around Counter)\n", e10k_vf_vfrxmemwrap_tc7_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc7_empty =\t%" PRIx8 "\t(Packet Buffer 7 Empty)\n", e10k_vf_vfrxmemwrap_tc7_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_vfeicr_t
 * Description: Implicit type of VF Extended Interrupt Cause register
 * Fields:
 *   msix	(size 3, offset 0, init 0):	RWC	Indicates an interrupt cause mapped to MSI-X vectors 2:0
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
typedef uint32_t e10k_vf_vfeicr_t;
#define e10k_vf_vfeicr_default 0x0
static inline uint8_t e10k_vf_vfeicr_msix_extract(e10k_vf_vfeicr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfeicr_msix_extract(e10k_vf_vfeicr_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline e10k_vf_vfeicr_t e10k_vf_vfeicr_msix_insert(e10k_vf_vfeicr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfeicr_t e10k_vf_vfeicr_msix_insert(e10k_vf_vfeicr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((e10k_vf_vfeicr_t )(_fieldval)) << 0)));
}

static inline int e10k_vf_vfeicr_prtval(char *_s, size_t _size, e10k_vf_vfeicr_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vfeicr_prtval(char *_s, size_t _size, e10k_vf_vfeicr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msix =\t%" PRIx8 "\t(Indicates an interrupt cause mapped to MSI-X vectors 2:0)\n", e10k_vf_vfeicr_msix_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_vfeics_t
 * Description: Implicit type of VF Extended Interrupt Cause Set register
 * Fields:
 *   msix	(size 3, offset 0, init 0):	WO	Sets to corresponding EICR bit of MSI-X vectors 2:0
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
typedef uint32_t e10k_vf_vfeics_t;
#define e10k_vf_vfeics_default 0x0
static inline uint8_t e10k_vf_vfeics_msix_extract(e10k_vf_vfeics_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfeics_msix_extract(e10k_vf_vfeics_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline e10k_vf_vfeics_t e10k_vf_vfeics_msix_insert(e10k_vf_vfeics_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfeics_t e10k_vf_vfeics_msix_insert(e10k_vf_vfeics_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((e10k_vf_vfeics_t )(_fieldval)) << 0)));
}

static inline int e10k_vf_vfeics_prtval(char *_s, size_t _size, e10k_vf_vfeics_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vfeics_prtval(char *_s, size_t _size, e10k_vf_vfeics_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msix =\t%" PRIx8 "\t(Sets to corresponding EICR bit of MSI-X vectors 2:0)\n", e10k_vf_vfeics_msix_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_vfeims_t
 * Description: Implicit type of VF Extended Interrupt Mask Set/Read register
 * Fields:
 *   msix	(size 3, offset 0, init 0):	RW	Set mask bit for the corresponding EICR bit of MSI-X vectors 2:0
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
typedef uint32_t e10k_vf_vfeims_t;
#define e10k_vf_vfeims_default 0x0
static inline uint8_t e10k_vf_vfeims_msix_extract(e10k_vf_vfeims_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfeims_msix_extract(e10k_vf_vfeims_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline e10k_vf_vfeims_t e10k_vf_vfeims_msix_insert(e10k_vf_vfeims_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfeims_t e10k_vf_vfeims_msix_insert(e10k_vf_vfeims_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((e10k_vf_vfeims_t )(_fieldval)) << 0)));
}

static inline int e10k_vf_vfeims_prtval(char *_s, size_t _size, e10k_vf_vfeims_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vfeims_prtval(char *_s, size_t _size, e10k_vf_vfeims_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msix =\t%" PRIx8 "\t(Set mask bit for the corresponding EICR bit of MSI-X vectors 2:0)\n", e10k_vf_vfeims_msix_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_vfeimc_t
 * Description: Implicit type of VF Extended Interrupt Mask Clear register
 * Fields:
 *   msix	(size 3, offset 0, init 0):	WO	Clear mask bit for the corresponding EICR bit of MSI-X vectors 2:0
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
typedef uint32_t e10k_vf_vfeimc_t;
#define e10k_vf_vfeimc_default 0x0
static inline uint8_t e10k_vf_vfeimc_msix_extract(e10k_vf_vfeimc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfeimc_msix_extract(e10k_vf_vfeimc_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline e10k_vf_vfeimc_t e10k_vf_vfeimc_msix_insert(e10k_vf_vfeimc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfeimc_t e10k_vf_vfeimc_msix_insert(e10k_vf_vfeimc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((e10k_vf_vfeimc_t )(_fieldval)) << 0)));
}

static inline int e10k_vf_vfeimc_prtval(char *_s, size_t _size, e10k_vf_vfeimc_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vfeimc_prtval(char *_s, size_t _size, e10k_vf_vfeimc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msix =\t%" PRIx8 "\t(Clear mask bit for the corresponding EICR bit of MSI-X vectors 2:0)\n", e10k_vf_vfeimc_msix_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_vfeiam_t
 * Description: Implicit type of VF Extended Interrupt Auto Mask Enable register
 * Fields:
 *   msix	(size 3, offset 0, init 0):	RW	Auto mask bit for the corresponding EICR bit of MSI-X vectors 2:0
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
typedef uint32_t e10k_vf_vfeiam_t;
#define e10k_vf_vfeiam_default 0x0
static inline uint8_t e10k_vf_vfeiam_msix_extract(e10k_vf_vfeiam_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfeiam_msix_extract(e10k_vf_vfeiam_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline e10k_vf_vfeiam_t e10k_vf_vfeiam_msix_insert(e10k_vf_vfeiam_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfeiam_t e10k_vf_vfeiam_msix_insert(e10k_vf_vfeiam_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((e10k_vf_vfeiam_t )(_fieldval)) << 0)));
}

static inline int e10k_vf_vfeiam_prtval(char *_s, size_t _size, e10k_vf_vfeiam_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vfeiam_prtval(char *_s, size_t _size, e10k_vf_vfeiam_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msix =\t%" PRIx8 "\t(Auto mask bit for the corresponding EICR bit of MSI-X vectors 2:0)\n", e10k_vf_vfeiam_msix_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_vfivar_t
 * Description: Implicit type of VF Interrupt Vector Allocation Registers register array
 * Fields:
 *   i_alloc0	(size 1, offset 0, init 0):	NOATTR	Defines the MSI-X vector (0 or 1) assigned to Rx queue 2*N for IVAR N register (N = 0..3)
 *   _anon1	(size 6, offset 1, init 0):	RSVD	_
 *   i_allocval0	(size 1, offset 7, init 0):	NOATTR	Interrupt allocation 0 valid
 *   i_alloc1	(size 1, offset 8, init 0):	NOATTR	The interrupt allocation for Tx queue 2n
 *   _anon9	(size 6, offset 9, init 0):	RSVD	_
 *   i_allocval1	(size 1, offset 15, init 0):	NOATTR	Interrupt allocation 1 valid
 *   i_alloc2	(size 1, offset 16, init 0):	NOATTR	The interrupt allocation for Rx queue 2n+1
 *   _anon17	(size 6, offset 17, init 0):	RSVD	_
 *   i_allocval2	(size 1, offset 23, init 0):	NOATTR	Interrupt allocation 2 valid
 *   i_alloc3	(size 1, offset 24, init 0):	NOATTR	The interrupt allocation for Tx queue 2n+1
 *   _anon25	(size 6, offset 25, init 0):	RSVD	_
 *   i_allocval3	(size 1, offset 31, init 0):	NOATTR	Interrupt allocation 3 valid
 */
typedef uint32_t e10k_vf_vfivar_t;
#define e10k_vf_vfivar_default 0x0
static inline uint8_t e10k_vf_vfivar_i_alloc0_extract(e10k_vf_vfivar_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_i_alloc0_extract(e10k_vf_vfivar_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_vf_vfivar_t e10k_vf_vfivar_i_alloc0_insert(e10k_vf_vfivar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfivar_t e10k_vf_vfivar_i_alloc0_insert(e10k_vf_vfivar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_vf_vfivar_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_vf_vfivar_i_allocval0_extract(e10k_vf_vfivar_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_i_allocval0_extract(e10k_vf_vfivar_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_vf_vfivar_t e10k_vf_vfivar_i_allocval0_insert(e10k_vf_vfivar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfivar_t e10k_vf_vfivar_i_allocval0_insert(e10k_vf_vfivar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_vf_vfivar_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_vf_vfivar_i_alloc1_extract(e10k_vf_vfivar_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_i_alloc1_extract(e10k_vf_vfivar_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e10k_vf_vfivar_t e10k_vf_vfivar_i_alloc1_insert(e10k_vf_vfivar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfivar_t e10k_vf_vfivar_i_alloc1_insert(e10k_vf_vfivar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e10k_vf_vfivar_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_vf_vfivar_i_allocval1_extract(e10k_vf_vfivar_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_i_allocval1_extract(e10k_vf_vfivar_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_vf_vfivar_t e10k_vf_vfivar_i_allocval1_insert(e10k_vf_vfivar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfivar_t e10k_vf_vfivar_i_allocval1_insert(e10k_vf_vfivar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_vf_vfivar_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_vf_vfivar_i_alloc2_extract(e10k_vf_vfivar_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_i_alloc2_extract(e10k_vf_vfivar_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e10k_vf_vfivar_t e10k_vf_vfivar_i_alloc2_insert(e10k_vf_vfivar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfivar_t e10k_vf_vfivar_i_alloc2_insert(e10k_vf_vfivar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e10k_vf_vfivar_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_vf_vfivar_i_allocval2_extract(e10k_vf_vfivar_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_i_allocval2_extract(e10k_vf_vfivar_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e10k_vf_vfivar_t e10k_vf_vfivar_i_allocval2_insert(e10k_vf_vfivar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfivar_t e10k_vf_vfivar_i_allocval2_insert(e10k_vf_vfivar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e10k_vf_vfivar_t )(_fieldval)) << 23)));
}

static inline uint8_t e10k_vf_vfivar_i_alloc3_extract(e10k_vf_vfivar_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_i_alloc3_extract(e10k_vf_vfivar_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline e10k_vf_vfivar_t e10k_vf_vfivar_i_alloc3_insert(e10k_vf_vfivar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfivar_t e10k_vf_vfivar_i_alloc3_insert(e10k_vf_vfivar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((e10k_vf_vfivar_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_vf_vfivar_i_allocval3_extract(e10k_vf_vfivar_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_i_allocval3_extract(e10k_vf_vfivar_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_vf_vfivar_t e10k_vf_vfivar_i_allocval3_insert(e10k_vf_vfivar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfivar_t e10k_vf_vfivar_i_allocval3_insert(e10k_vf_vfivar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_vf_vfivar_t )(_fieldval)) << 31)));
}

static inline int e10k_vf_vfivar_prtval(char *_s, size_t _size, e10k_vf_vfivar_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vfivar_prtval(char *_s, size_t _size, e10k_vf_vfivar_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc0 =\t%" PRIx8 "\t(Defines the MSI-X vector (0 or 1) assigned to Rx queue 2*N for IVAR N register (N = 0..3))\n", e10k_vf_vfivar_i_alloc0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval0 =\t%" PRIx8 "\t(Interrupt allocation 0 valid)\n", e10k_vf_vfivar_i_allocval0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc1 =\t%" PRIx8 "\t(The interrupt allocation for Tx queue 2n)\n", e10k_vf_vfivar_i_alloc1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval1 =\t%" PRIx8 "\t(Interrupt allocation 1 valid)\n", e10k_vf_vfivar_i_allocval1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc2 =\t%" PRIx8 "\t(The interrupt allocation for Rx queue 2n+1)\n", e10k_vf_vfivar_i_alloc2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval2 =\t%" PRIx8 "\t(Interrupt allocation 2 valid)\n", e10k_vf_vfivar_i_allocval2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc3 =\t%" PRIx8 "\t(The interrupt allocation for Tx queue 2n+1)\n", e10k_vf_vfivar_i_alloc3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval3 =\t%" PRIx8 "\t(Interrupt allocation 3 valid)\n", e10k_vf_vfivar_i_allocval3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_vfivar_misc_t
 * Description: Implicit type of VF Miscellaneous Interrupt Vector Allocation register
 * Fields:
 *   i_alloc0	(size 2, offset 0, init 0):	RW	MSI-X vector assigned to the mailbox interrupt
 *   _anon2	(size 5, offset 2, init 0):	RSVD	_
 *   i_allocval0	(size 1, offset 7, init 0):	RW	Interrupt allocation 0 valid
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t e10k_vf_vfivar_misc_t;
#define e10k_vf_vfivar_misc_default 0x0
static inline uint8_t e10k_vf_vfivar_misc_i_alloc0_extract(e10k_vf_vfivar_misc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_misc_i_alloc0_extract(e10k_vf_vfivar_misc_t _regval)
{
    return((uint8_t )((_regval & 0x3) >> 0));
}

static inline e10k_vf_vfivar_misc_t e10k_vf_vfivar_misc_i_alloc0_insert(e10k_vf_vfivar_misc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfivar_misc_t e10k_vf_vfivar_misc_i_alloc0_insert(e10k_vf_vfivar_misc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((e10k_vf_vfivar_misc_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_vf_vfivar_misc_i_allocval0_extract(e10k_vf_vfivar_misc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_misc_i_allocval0_extract(e10k_vf_vfivar_misc_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_vf_vfivar_misc_t e10k_vf_vfivar_misc_i_allocval0_insert(e10k_vf_vfivar_misc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfivar_misc_t e10k_vf_vfivar_misc_i_allocval0_insert(e10k_vf_vfivar_misc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_vf_vfivar_misc_t )(_fieldval)) << 7)));
}

static inline int e10k_vf_vfivar_misc_prtval(char *_s, size_t _size, e10k_vf_vfivar_misc_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vfivar_misc_prtval(char *_s, size_t _size, e10k_vf_vfivar_misc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc0 =\t%" PRIx8 "\t(MSI-X vector assigned to the mailbox interrupt)\n", e10k_vf_vfivar_misc_i_alloc0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval0 =\t%" PRIx8 "\t(Interrupt allocation 0 valid)\n", e10k_vf_vfivar_misc_i_allocval0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_vfpbacl_t
 * Description: Implicit type of VF MSI-X PBA Clear register
 * Fields:
 *   penbit	(size 3, offset 0, init 0):	RWC	MSI-X Pending Bits Clear. Reading returns PBA vector.
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
typedef uint32_t e10k_vf_vfpbacl_t;
#define e10k_vf_vfpbacl_default 0x0
static inline uint8_t e10k_vf_vfpbacl_penbit_extract(e10k_vf_vfpbacl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfpbacl_penbit_extract(e10k_vf_vfpbacl_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline e10k_vf_vfpbacl_t e10k_vf_vfpbacl_penbit_insert(e10k_vf_vfpbacl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfpbacl_t e10k_vf_vfpbacl_penbit_insert(e10k_vf_vfpbacl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((e10k_vf_vfpbacl_t )(_fieldval)) << 0)));
}

static inline int e10k_vf_vfpbacl_prtval(char *_s, size_t _size, e10k_vf_vfpbacl_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vfpbacl_prtval(char *_s, size_t _size, e10k_vf_vfpbacl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " penbit =\t%" PRIx8 "\t(MSI-X Pending Bits Clear. Reading returns PBA vector.)\n", e10k_vf_vfpbacl_penbit_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_rxdctl_t
 * Description: Receive Descriptor Control
 * Fields:
 *   _anon0	(size 25, offset 0, init 0):	RSVD	_
 *   enable	(size 1, offset 25, init 0):	NOATTR	Receive Queue Enable
 *   _anon26	(size 4, offset 26, init 0):	RSVD	_
 *   vme	(size 1, offset 30, init 0):	NOATTR	VLAN Mode Enable
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_vf_rxdctl_t;
#define e10k_vf_rxdctl_default 0x0
static inline uint8_t e10k_vf_rxdctl_enable_extract(e10k_vf_rxdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_rxdctl_enable_extract(e10k_vf_rxdctl_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e10k_vf_rxdctl_t e10k_vf_rxdctl_enable_insert(e10k_vf_rxdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_rxdctl_t e10k_vf_rxdctl_enable_insert(e10k_vf_rxdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e10k_vf_rxdctl_t )(_fieldval)) << 25)));
}

static inline uint8_t e10k_vf_rxdctl_vme_extract(e10k_vf_rxdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_rxdctl_vme_extract(e10k_vf_rxdctl_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_vf_rxdctl_t e10k_vf_rxdctl_vme_insert(e10k_vf_rxdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_rxdctl_t e10k_vf_rxdctl_vme_insert(e10k_vf_rxdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_vf_rxdctl_t )(_fieldval)) << 30)));
}

static inline int e10k_vf_rxdctl_prtval(char *_s, size_t _size, e10k_vf_rxdctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_rxdctl_prtval(char *_s, size_t _size, e10k_vf_rxdctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(Receive Queue Enable)\n", e10k_vf_rxdctl_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vme =\t%" PRIx8 "\t(VLAN Mode Enable)\n", e10k_vf_rxdctl_vme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_srrctl_t
 * Description: Split Receive Control Registers
 * Fields:
 *   bsz_pkt	(size 5, offset 0, init 0):	NOATTR	Receive Buffer Size for Packet Buffer
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   bsz_hdr	(size 6, offset 8, init 0):	NOATTR	Receive Buffer Size for Header Buffer
 *   _anon14	(size 8, offset 14, init 0):	RSVD	_
 *   rdmts	(size 3, offset 22, init 0):	NOATTR	Receive Descriptor Minimum Threshold Size
 *   desctype	(size 3, offset 25, init 0):	NOATTR	Define the descriptor type
 *   drop_en	(size 1, offset 28, init 0):	NOATTR	Drop Enabled
 *   _anon29	(size 3, offset 29, init 0):	RSVD	_
 */
typedef uint32_t e10k_vf_srrctl_t;
#define e10k_vf_srrctl_default 0x0
static inline uint8_t e10k_vf_srrctl_bsz_pkt_extract(e10k_vf_srrctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_srrctl_bsz_pkt_extract(e10k_vf_srrctl_t _regval)
{
    return((uint8_t )((_regval & 0x1f) >> 0));
}

static inline e10k_vf_srrctl_t e10k_vf_srrctl_bsz_pkt_insert(e10k_vf_srrctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_srrctl_t e10k_vf_srrctl_bsz_pkt_insert(e10k_vf_srrctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((e10k_vf_srrctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_vf_srrctl_bsz_hdr_extract(e10k_vf_srrctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_srrctl_bsz_hdr_extract(e10k_vf_srrctl_t _regval)
{
    return((uint8_t )((_regval & 0x3f00) >> 8));
}

static inline e10k_vf_srrctl_t e10k_vf_srrctl_bsz_hdr_insert(e10k_vf_srrctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_srrctl_t e10k_vf_srrctl_bsz_hdr_insert(e10k_vf_srrctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffc0ff) | (0x3f00 & (((e10k_vf_srrctl_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_vf_srrctl_rdmts_extract(e10k_vf_srrctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_srrctl_rdmts_extract(e10k_vf_srrctl_t _regval)
{
    return((uint8_t )((_regval & 0x1c00000) >> 22));
}

static inline e10k_vf_srrctl_t e10k_vf_srrctl_rdmts_insert(e10k_vf_srrctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_srrctl_t e10k_vf_srrctl_rdmts_insert(e10k_vf_srrctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe3fffff) | (0x1c00000 & (((e10k_vf_srrctl_t )(_fieldval)) << 22)));
}

static inline e10k_vf_rx_desctype_t e10k_vf_srrctl_desctype_extract(e10k_vf_srrctl_t _regval) __attribute__ ((always_inline));
static inline e10k_vf_rx_desctype_t e10k_vf_srrctl_desctype_extract(e10k_vf_srrctl_t _regval)
{
    return((e10k_vf_rx_desctype_t )((_regval & 0xe000000) >> 25));
}

static inline e10k_vf_srrctl_t e10k_vf_srrctl_desctype_insert(e10k_vf_srrctl_t _regval, e10k_vf_rx_desctype_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_srrctl_t e10k_vf_srrctl_desctype_insert(e10k_vf_srrctl_t _regval, e10k_vf_rx_desctype_t _fieldval)
{
    return((_regval & 0xf1ffffff) | (0xe000000 & (((e10k_vf_srrctl_t )(_fieldval)) << 25)));
}

static inline uint8_t e10k_vf_srrctl_drop_en_extract(e10k_vf_srrctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_srrctl_drop_en_extract(e10k_vf_srrctl_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e10k_vf_srrctl_t e10k_vf_srrctl_drop_en_insert(e10k_vf_srrctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_srrctl_t e10k_vf_srrctl_drop_en_insert(e10k_vf_srrctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e10k_vf_srrctl_t )(_fieldval)) << 28)));
}

static inline int e10k_vf_srrctl_prtval(char *_s, size_t _size, e10k_vf_srrctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_srrctl_prtval(char *_s, size_t _size, e10k_vf_srrctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsz_pkt =\t%" PRIx8 "\t(Receive Buffer Size for Packet Buffer)\n", e10k_vf_srrctl_bsz_pkt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsz_hdr =\t%" PRIx8 "\t(Receive Buffer Size for Header Buffer)\n", e10k_vf_srrctl_bsz_hdr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rdmts =\t%" PRIx8 "\t(Receive Descriptor Minimum Threshold Size)\n", e10k_vf_srrctl_rdmts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " desctype =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_rx_desctype_prtval(_s + _r, _avail, e10k_vf_srrctl_desctype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Define the descriptor type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drop_en =\t%" PRIx8 "\t(Drop Enabled)\n", e10k_vf_srrctl_drop_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_vfpsrtype_t
 * Description: Implicit type of VF Replication Packet Split Receive Type register
 * Fields:
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   split_nfs	(size 1, offset 1, init 0):	RW	Split received NFS packets after NFS header
 *   _anon2	(size 2, offset 2, init 0):	MBZ	_
 *   split_tcp	(size 1, offset 4, init 0):	RW	Split received TCP packets after TCP header
 *   split_udp	(size 1, offset 5, init 0):	RW	Split received UDP packets after UDP header
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   split_ip4	(size 1, offset 8, init 0):	RW	Split received IPv4 packets after IPv4 header
 *   split_ip6	(size 1, offset 9, init 0):	RW	Split received IPv6 packets after IPv6 header
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   split_l2	(size 1, offset 12, init 0):	RW	Split received L2 packets after L2 header
 *   _anon13	(size 16, offset 13, init 0):	MBZ	_
 *   rqpl	(size 3, offset 29, init 0):	RW	Number of bits to use for RSS redirection
 */
typedef uint32_t e10k_vf_vfpsrtype_t;
#define e10k_vf_vfpsrtype_default 0x0
static inline uint8_t e10k_vf_vfpsrtype_split_nfs_extract(e10k_vf_vfpsrtype_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfpsrtype_split_nfs_extract(e10k_vf_vfpsrtype_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_split_nfs_insert(e10k_vf_vfpsrtype_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_split_nfs_insert(e10k_vf_vfpsrtype_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_vf_vfpsrtype_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_vf_vfpsrtype_split_tcp_extract(e10k_vf_vfpsrtype_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfpsrtype_split_tcp_extract(e10k_vf_vfpsrtype_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_split_tcp_insert(e10k_vf_vfpsrtype_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_split_tcp_insert(e10k_vf_vfpsrtype_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_vf_vfpsrtype_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_vf_vfpsrtype_split_udp_extract(e10k_vf_vfpsrtype_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfpsrtype_split_udp_extract(e10k_vf_vfpsrtype_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_split_udp_insert(e10k_vf_vfpsrtype_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_split_udp_insert(e10k_vf_vfpsrtype_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_vf_vfpsrtype_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_vf_vfpsrtype_split_ip4_extract(e10k_vf_vfpsrtype_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfpsrtype_split_ip4_extract(e10k_vf_vfpsrtype_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_split_ip4_insert(e10k_vf_vfpsrtype_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_split_ip4_insert(e10k_vf_vfpsrtype_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e10k_vf_vfpsrtype_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_vf_vfpsrtype_split_ip6_extract(e10k_vf_vfpsrtype_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfpsrtype_split_ip6_extract(e10k_vf_vfpsrtype_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_split_ip6_insert(e10k_vf_vfpsrtype_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_split_ip6_insert(e10k_vf_vfpsrtype_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_vf_vfpsrtype_t )(_fieldval)) << 9)));
}

static inline uint8_t e10k_vf_vfpsrtype_split_l2_extract(e10k_vf_vfpsrtype_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfpsrtype_split_l2_extract(e10k_vf_vfpsrtype_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_split_l2_insert(e10k_vf_vfpsrtype_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_split_l2_insert(e10k_vf_vfpsrtype_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e10k_vf_vfpsrtype_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_vf_vfpsrtype_rqpl_extract(e10k_vf_vfpsrtype_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfpsrtype_rqpl_extract(e10k_vf_vfpsrtype_t _regval)
{
    return((uint8_t )((_regval & 0xe0000000) >> 29));
}

static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_rqpl_insert(e10k_vf_vfpsrtype_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_rqpl_insert(e10k_vf_vfpsrtype_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x1fffffff) | (0xe0000000 & (((e10k_vf_vfpsrtype_t )(_fieldval)) << 29)));
}

static inline int e10k_vf_vfpsrtype_prtval(char *_s, size_t _size, e10k_vf_vfpsrtype_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vfpsrtype_prtval(char *_s, size_t _size, e10k_vf_vfpsrtype_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_nfs =\t%" PRIx8 "\t(Split received NFS packets after NFS header)\n", e10k_vf_vfpsrtype_split_nfs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_tcp =\t%" PRIx8 "\t(Split received TCP packets after TCP header)\n", e10k_vf_vfpsrtype_split_tcp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_udp =\t%" PRIx8 "\t(Split received UDP packets after UDP header)\n", e10k_vf_vfpsrtype_split_udp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_ip4 =\t%" PRIx8 "\t(Split received IPv4 packets after IPv4 header)\n", e10k_vf_vfpsrtype_split_ip4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_ip6 =\t%" PRIx8 "\t(Split received IPv6 packets after IPv6 header)\n", e10k_vf_vfpsrtype_split_ip6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_l2 =\t%" PRIx8 "\t(Split received L2 packets after L2 header)\n", e10k_vf_vfpsrtype_split_l2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqpl =\t%" PRIx8 "\t(Number of bits to use for RSS redirection)\n", e10k_vf_vfpsrtype_rqpl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_rscctl_t
 * Description: RSC Control
 * Fields:
 *   rsc_en	(size 1, offset 0, init 0):	NOATTR	RSC Enable
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   maxdesc	(size 2, offset 2, init 0):	NOATTR	Maximum descriptors per Large receive
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
typedef uint32_t e10k_vf_rscctl_t;
#define e10k_vf_rscctl_default 0x0
static inline uint8_t e10k_vf_rscctl_rsc_en_extract(e10k_vf_rscctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_rscctl_rsc_en_extract(e10k_vf_rscctl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_vf_rscctl_t e10k_vf_rscctl_rsc_en_insert(e10k_vf_rscctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_rscctl_t e10k_vf_rscctl_rsc_en_insert(e10k_vf_rscctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_vf_rscctl_t )(_fieldval)) << 0)));
}

static inline e10k_vf_rsc_maxdesc_t e10k_vf_rscctl_maxdesc_extract(e10k_vf_rscctl_t _regval) __attribute__ ((always_inline));
static inline e10k_vf_rsc_maxdesc_t e10k_vf_rscctl_maxdesc_extract(e10k_vf_rscctl_t _regval)
{
    return((e10k_vf_rsc_maxdesc_t )((_regval & 0xc) >> 2));
}

static inline e10k_vf_rscctl_t e10k_vf_rscctl_maxdesc_insert(e10k_vf_rscctl_t _regval, e10k_vf_rsc_maxdesc_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_rscctl_t e10k_vf_rscctl_maxdesc_insert(e10k_vf_rscctl_t _regval, e10k_vf_rsc_maxdesc_t _fieldval)
{
    return((_regval & 0xfffffff3) | (0xc & (((e10k_vf_rscctl_t )(_fieldval)) << 2)));
}

static inline int e10k_vf_rscctl_prtval(char *_s, size_t _size, e10k_vf_rscctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_rscctl_prtval(char *_s, size_t _size, e10k_vf_rscctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rsc_en =\t%" PRIx8 "\t(RSC Enable)\n", e10k_vf_rscctl_rsc_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " maxdesc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_rsc_maxdesc_prtval(_s + _r, _avail, e10k_vf_rscctl_maxdesc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Maximum descriptors per Large receive)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_vftxdctl_t
 * Description: Implicit type of VF Transmit Descriptor Control register array
 * Fields:
 *   pthresh	(size 7, offset 0, init 0):	NOATTR	Pre-Fetch Threshold
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 *   hthresh	(size 7, offset 8, init 0):	NOATTR	Host Threshold
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 *   wthresh	(size 7, offset 16, init 0):	NOATTR	Write-Back Threshold
 *   _anon23	(size 2, offset 23, init 0):	RSVD	_
 *   enable	(size 1, offset 25, init 0):	NOATTR	Transmit Queue Enable
 *   swflsh	(size 1, offset 26, init 0):	NOATTR	Transmit Software Flush
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
typedef uint32_t e10k_vf_vftxdctl_t;
#define e10k_vf_vftxdctl_default 0x0
static inline uint8_t e10k_vf_vftxdctl_pthresh_extract(e10k_vf_vftxdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vftxdctl_pthresh_extract(e10k_vf_vftxdctl_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline e10k_vf_vftxdctl_t e10k_vf_vftxdctl_pthresh_insert(e10k_vf_vftxdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vftxdctl_t e10k_vf_vftxdctl_pthresh_insert(e10k_vf_vftxdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff80) | (0x7f & (((e10k_vf_vftxdctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_vf_vftxdctl_hthresh_extract(e10k_vf_vftxdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vftxdctl_hthresh_extract(e10k_vf_vftxdctl_t _regval)
{
    return((uint8_t )((_regval & 0x7f00) >> 8));
}

static inline e10k_vf_vftxdctl_t e10k_vf_vftxdctl_hthresh_insert(e10k_vf_vftxdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vftxdctl_t e10k_vf_vftxdctl_hthresh_insert(e10k_vf_vftxdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff80ff) | (0x7f00 & (((e10k_vf_vftxdctl_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_vf_vftxdctl_wthresh_extract(e10k_vf_vftxdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vftxdctl_wthresh_extract(e10k_vf_vftxdctl_t _regval)
{
    return((uint8_t )((_regval & 0x7f0000) >> 16));
}

static inline e10k_vf_vftxdctl_t e10k_vf_vftxdctl_wthresh_insert(e10k_vf_vftxdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vftxdctl_t e10k_vf_vftxdctl_wthresh_insert(e10k_vf_vftxdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff80ffff) | (0x7f0000 & (((e10k_vf_vftxdctl_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_vf_vftxdctl_enable_extract(e10k_vf_vftxdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vftxdctl_enable_extract(e10k_vf_vftxdctl_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e10k_vf_vftxdctl_t e10k_vf_vftxdctl_enable_insert(e10k_vf_vftxdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vftxdctl_t e10k_vf_vftxdctl_enable_insert(e10k_vf_vftxdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e10k_vf_vftxdctl_t )(_fieldval)) << 25)));
}

static inline uint8_t e10k_vf_vftxdctl_swflsh_extract(e10k_vf_vftxdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vftxdctl_swflsh_extract(e10k_vf_vftxdctl_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e10k_vf_vftxdctl_t e10k_vf_vftxdctl_swflsh_insert(e10k_vf_vftxdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vftxdctl_t e10k_vf_vftxdctl_swflsh_insert(e10k_vf_vftxdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e10k_vf_vftxdctl_t )(_fieldval)) << 26)));
}

static inline int e10k_vf_vftxdctl_prtval(char *_s, size_t _size, e10k_vf_vftxdctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vftxdctl_prtval(char *_s, size_t _size, e10k_vf_vftxdctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pthresh =\t%" PRIx8 "\t(Pre-Fetch Threshold)\n", e10k_vf_vftxdctl_pthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hthresh =\t%" PRIx8 "\t(Host Threshold)\n", e10k_vf_vftxdctl_hthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wthresh =\t%" PRIx8 "\t(Write-Back Threshold)\n", e10k_vf_vftxdctl_wthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(Transmit Queue Enable)\n", e10k_vf_vftxdctl_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " swflsh =\t%" PRIx8 "\t(Transmit Software Flush)\n", e10k_vf_vftxdctl_swflsh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_vftdwbal_t
 * Description: Implicit type of VF Tx Descriptor Completion Write Back Address Low register array
 * Fields:
 *   headwb_en	(size 1, offset 0, init 0):	NOATTR	Head Write-Back Enable
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   headwb_low	(size 30, offset 2, init 0):	NOATTR	Lowest 32 bits of the head write-back memory location
 */
typedef uint32_t e10k_vf_vftdwbal_t;
#define e10k_vf_vftdwbal_default 0x0
static inline uint8_t e10k_vf_vftdwbal_headwb_en_extract(e10k_vf_vftdwbal_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vftdwbal_headwb_en_extract(e10k_vf_vftdwbal_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_vf_vftdwbal_t e10k_vf_vftdwbal_headwb_en_insert(e10k_vf_vftdwbal_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vftdwbal_t e10k_vf_vftdwbal_headwb_en_insert(e10k_vf_vftdwbal_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_vf_vftdwbal_t )(_fieldval)) << 0)));
}

static inline uint32_t e10k_vf_vftdwbal_headwb_low_extract(e10k_vf_vftdwbal_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vftdwbal_headwb_low_extract(e10k_vf_vftdwbal_t _regval)
{
    return((uint32_t )((_regval & 0xfffffffc) >> 2));
}

static inline e10k_vf_vftdwbal_t e10k_vf_vftdwbal_headwb_low_insert(e10k_vf_vftdwbal_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vftdwbal_t e10k_vf_vftdwbal_headwb_low_insert(e10k_vf_vftdwbal_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x3) | (0xfffffffc & (((e10k_vf_vftdwbal_t )(_fieldval)) << 2)));
}

static inline int e10k_vf_vftdwbal_prtval(char *_s, size_t _size, e10k_vf_vftdwbal_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vftdwbal_prtval(char *_s, size_t _size, e10k_vf_vftdwbal_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " headwb_en =\t%" PRIx8 "\t(Head Write-Back Enable)\n", e10k_vf_vftdwbal_headwb_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " headwb_low =\t%" PRIx32 "\t(Lowest 32 bits of the head write-back memory location)\n", e10k_vf_vftdwbal_headwb_low_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_vftdwbah_t
 * Description: Implicit type of VF Tx Descriptor Completion Write Back Address High register array
 * Fields:
 *   headwb_high	(size 32, offset 0, init 0):	NOATTR	Highest 32 bits of the head write-back memory location
 */
typedef uint32_t e10k_vf_vftdwbah_t;
#define e10k_vf_vftdwbah_default 0x0
static inline uint32_t e10k_vf_vftdwbah_headwb_high_extract(e10k_vf_vftdwbah_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vftdwbah_headwb_high_extract(e10k_vf_vftdwbah_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_vf_vftdwbah_t e10k_vf_vftdwbah_headwb_high_insert(e10k_vf_vftdwbah_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vftdwbah_t e10k_vf_vftdwbah_headwb_high_insert(e10k_vf_vftdwbah_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_vf_vftdwbah_t )(_fieldval)) << 0)));
}

static inline int e10k_vf_vftdwbah_prtval(char *_s, size_t _size, e10k_vf_vftdwbah_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vftdwbah_prtval(char *_s, size_t _size, e10k_vf_vftdwbah_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " headwb_high =\t%" PRIx32 "\t(Highest 32 bits of the head write-back memory location)\n", e10k_vf_vftdwbah_headwb_high_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_dca_rxctrl_t
 * Description: Rx DCA Control Register
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   rxdca_desc	(size 1, offset 5, init 0):	NOATTR	Descriptor DCA EN
 *   rxdca_hdr	(size 1, offset 6, init 0):	NOATTR	Rx Header DCA EN
 *   rxdca_payl	(size 1, offset 7, init 0):	NOATTR	Payload DCA EN
 *   _anon8	(size 1, offset 8, init 0):	RSVD	_
 *   rxdesc_rdro	(size 1, offset 9, init 0):	NOATTR	Rx Descriptor Read Relax Order Enable
 *   _anon10	(size 1, offset 10, init 0):	RSVD	_
 *   rxdesc_wbro	(size 1, offset 11, init 0):	MBZ	Rx Descriptor Write Back Relax Order Enable
 *   _anon12	(size 1, offset 12, init 0):	RSVD	_
 *   rxdata_wrro	(size 1, offset 13, init 0):	NOATTR	Rx data Write Relax Order Enable
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   rxhdr_ro	(size 1, offset 15, init 0):	NOATTR	Rx Split Header Relax Order Enable
 *   _anon16	(size 8, offset 16, init 0):	RSVD	_
 *   cpuid	(size 8, offset 24, init 0):	NOATTR	Physical ID
 */
typedef uint32_t e10k_vf_dca_rxctrl_t;
#define e10k_vf_dca_rxctrl_default 0x0
static inline uint8_t e10k_vf_dca_rxctrl_rxdca_desc_extract(e10k_vf_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_dca_rxctrl_rxdca_desc_extract(e10k_vf_dca_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_vf_dca_rxctrl_t e10k_vf_dca_rxctrl_rxdca_desc_insert(e10k_vf_dca_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_dca_rxctrl_t e10k_vf_dca_rxctrl_rxdca_desc_insert(e10k_vf_dca_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_vf_dca_rxctrl_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_vf_dca_rxctrl_rxdca_hdr_extract(e10k_vf_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_dca_rxctrl_rxdca_hdr_extract(e10k_vf_dca_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_vf_dca_rxctrl_t e10k_vf_dca_rxctrl_rxdca_hdr_insert(e10k_vf_dca_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_dca_rxctrl_t e10k_vf_dca_rxctrl_rxdca_hdr_insert(e10k_vf_dca_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_vf_dca_rxctrl_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_vf_dca_rxctrl_rxdca_payl_extract(e10k_vf_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_dca_rxctrl_rxdca_payl_extract(e10k_vf_dca_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_vf_dca_rxctrl_t e10k_vf_dca_rxctrl_rxdca_payl_insert(e10k_vf_dca_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_dca_rxctrl_t e10k_vf_dca_rxctrl_rxdca_payl_insert(e10k_vf_dca_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_vf_dca_rxctrl_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_vf_dca_rxctrl_rxdesc_rdro_extract(e10k_vf_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_dca_rxctrl_rxdesc_rdro_extract(e10k_vf_dca_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_vf_dca_rxctrl_t e10k_vf_dca_rxctrl_rxdesc_rdro_insert(e10k_vf_dca_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_dca_rxctrl_t e10k_vf_dca_rxctrl_rxdesc_rdro_insert(e10k_vf_dca_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_vf_dca_rxctrl_t )(_fieldval)) << 9)));
}

static inline uint8_t e10k_vf_dca_rxctrl_rxdesc_wbro_extract(e10k_vf_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_dca_rxctrl_rxdesc_wbro_extract(e10k_vf_dca_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e10k_vf_dca_rxctrl_t e10k_vf_dca_rxctrl_rxdesc_wbro_insert(e10k_vf_dca_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_dca_rxctrl_t e10k_vf_dca_rxctrl_rxdesc_wbro_insert(e10k_vf_dca_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e10k_vf_dca_rxctrl_t )(_fieldval)) << 11)));
}

static inline uint8_t e10k_vf_dca_rxctrl_rxdata_wrro_extract(e10k_vf_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_dca_rxctrl_rxdata_wrro_extract(e10k_vf_dca_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e10k_vf_dca_rxctrl_t e10k_vf_dca_rxctrl_rxdata_wrro_insert(e10k_vf_dca_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_dca_rxctrl_t e10k_vf_dca_rxctrl_rxdata_wrro_insert(e10k_vf_dca_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e10k_vf_dca_rxctrl_t )(_fieldval)) << 13)));
}

static inline uint8_t e10k_vf_dca_rxctrl_rxhdr_ro_extract(e10k_vf_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_dca_rxctrl_rxhdr_ro_extract(e10k_vf_dca_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_vf_dca_rxctrl_t e10k_vf_dca_rxctrl_rxhdr_ro_insert(e10k_vf_dca_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_dca_rxctrl_t e10k_vf_dca_rxctrl_rxhdr_ro_insert(e10k_vf_dca_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_vf_dca_rxctrl_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_vf_dca_rxctrl_cpuid_extract(e10k_vf_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_dca_rxctrl_cpuid_extract(e10k_vf_dca_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline e10k_vf_dca_rxctrl_t e10k_vf_dca_rxctrl_cpuid_insert(e10k_vf_dca_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_dca_rxctrl_t e10k_vf_dca_rxctrl_cpuid_insert(e10k_vf_dca_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((e10k_vf_dca_rxctrl_t )(_fieldval)) << 24)));
}

static inline int e10k_vf_dca_rxctrl_prtval(char *_s, size_t _size, e10k_vf_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_dca_rxctrl_prtval(char *_s, size_t _size, e10k_vf_dca_rxctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdca_desc =\t%" PRIx8 "\t(Descriptor DCA EN)\n", e10k_vf_dca_rxctrl_rxdca_desc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdca_hdr =\t%" PRIx8 "\t(Rx Header DCA EN)\n", e10k_vf_dca_rxctrl_rxdca_hdr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdca_payl =\t%" PRIx8 "\t(Payload DCA EN)\n", e10k_vf_dca_rxctrl_rxdca_payl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdesc_rdro =\t%" PRIx8 "\t(Rx Descriptor Read Relax Order Enable)\n", e10k_vf_dca_rxctrl_rxdesc_rdro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdesc_wbro =\t%" PRIx8 "\t(Rx Descriptor Write Back Relax Order Enable)\n", e10k_vf_dca_rxctrl_rxdesc_wbro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdata_wrro =\t%" PRIx8 "\t(Rx data Write Relax Order Enable)\n", e10k_vf_dca_rxctrl_rxdata_wrro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxhdr_ro =\t%" PRIx8 "\t(Rx Split Header Relax Order Enable)\n", e10k_vf_dca_rxctrl_rxhdr_ro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpuid =\t%" PRIx8 "\t(Physical ID)\n", e10k_vf_dca_rxctrl_cpuid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vf_vfdca_txctrl_t
 * Description: Implicit type of VF Tx DCA Control Registers register array
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   txdesc_dca	(size 1, offset 5, init 0):	NOATTR	Descriptor DCA Enable
 *   _anon6	(size 3, offset 6, init 0):	RSVD	_
 *   txdesc_rdro	(size 1, offset 9, init 0):	NOATTR	Tx Descriptor Read Relax Order Enable
 *   _anon10	(size 1, offset 10, init 0):	RSVD	_
 *   txdesc_wbro	(size 1, offset 11, init 0):	NOATTR	Relax Order Enable of Tx Descriptor well as head pointer write back
 *   _anon12	(size 1, offset 12, init 0):	RSVD	_
 *   txdata_rdro	(size 1, offset 13, init 0):	NOATTR	Tx Data Read Relax Order Enable
 *   _anon14	(size 10, offset 14, init 0):	RSVD	_
 *   cpuid	(size 8, offset 24, init 0):	NOATTR	Physical ID
 */
typedef uint32_t e10k_vf_vfdca_txctrl_t;
#define e10k_vf_vfdca_txctrl_default 0x0
static inline uint8_t e10k_vf_vfdca_txctrl_txdesc_dca_extract(e10k_vf_vfdca_txctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_txctrl_txdesc_dca_extract(e10k_vf_vfdca_txctrl_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_vf_vfdca_txctrl_t e10k_vf_vfdca_txctrl_txdesc_dca_insert(e10k_vf_vfdca_txctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfdca_txctrl_t e10k_vf_vfdca_txctrl_txdesc_dca_insert(e10k_vf_vfdca_txctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_vf_vfdca_txctrl_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_vf_vfdca_txctrl_txdesc_rdro_extract(e10k_vf_vfdca_txctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_txctrl_txdesc_rdro_extract(e10k_vf_vfdca_txctrl_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_vf_vfdca_txctrl_t e10k_vf_vfdca_txctrl_txdesc_rdro_insert(e10k_vf_vfdca_txctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfdca_txctrl_t e10k_vf_vfdca_txctrl_txdesc_rdro_insert(e10k_vf_vfdca_txctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_vf_vfdca_txctrl_t )(_fieldval)) << 9)));
}

static inline uint8_t e10k_vf_vfdca_txctrl_txdesc_wbro_extract(e10k_vf_vfdca_txctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_txctrl_txdesc_wbro_extract(e10k_vf_vfdca_txctrl_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e10k_vf_vfdca_txctrl_t e10k_vf_vfdca_txctrl_txdesc_wbro_insert(e10k_vf_vfdca_txctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfdca_txctrl_t e10k_vf_vfdca_txctrl_txdesc_wbro_insert(e10k_vf_vfdca_txctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e10k_vf_vfdca_txctrl_t )(_fieldval)) << 11)));
}

static inline uint8_t e10k_vf_vfdca_txctrl_txdata_rdro_extract(e10k_vf_vfdca_txctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_txctrl_txdata_rdro_extract(e10k_vf_vfdca_txctrl_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e10k_vf_vfdca_txctrl_t e10k_vf_vfdca_txctrl_txdata_rdro_insert(e10k_vf_vfdca_txctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfdca_txctrl_t e10k_vf_vfdca_txctrl_txdata_rdro_insert(e10k_vf_vfdca_txctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e10k_vf_vfdca_txctrl_t )(_fieldval)) << 13)));
}

static inline uint8_t e10k_vf_vfdca_txctrl_cpuid_extract(e10k_vf_vfdca_txctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_txctrl_cpuid_extract(e10k_vf_vfdca_txctrl_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline e10k_vf_vfdca_txctrl_t e10k_vf_vfdca_txctrl_cpuid_insert(e10k_vf_vfdca_txctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vf_vfdca_txctrl_t e10k_vf_vfdca_txctrl_cpuid_insert(e10k_vf_vfdca_txctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((e10k_vf_vfdca_txctrl_t )(_fieldval)) << 24)));
}

static inline int e10k_vf_vfdca_txctrl_prtval(char *_s, size_t _size, e10k_vf_vfdca_txctrl_t _regval) __attribute__ ((always_inline));
static inline int e10k_vf_vfdca_txctrl_prtval(char *_s, size_t _size, e10k_vf_vfdca_txctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdesc_dca =\t%" PRIx8 "\t(Descriptor DCA Enable)\n", e10k_vf_vfdca_txctrl_txdesc_dca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdesc_rdro =\t%" PRIx8 "\t(Tx Descriptor Read Relax Order Enable)\n", e10k_vf_vfdca_txctrl_txdesc_rdro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdesc_wbro =\t%" PRIx8 "\t(Relax Order Enable of Tx Descriptor well as head pointer write back)\n", e10k_vf_vfdca_txctrl_txdesc_wbro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdata_rdro =\t%" PRIx8 "\t(Tx Data Read Relax Order Enable)\n", e10k_vf_vfdca_txctrl_txdata_rdro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpuid =\t%" PRIx8 "\t(Physical ID)\n", e10k_vf_vfdca_txctrl_cpuid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
    e10k_vf_vfctrl_t vfctrl_shadow;
    e10k_vf_vfeics_t vfeics_shadow;
    e10k_vf_vfeimc_t vfeimc_shadow;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum e10k_vf_initials {
    e10k_vf_vfctrl_initial = 0x0,
    e10k_vf_vfstatus_initial = 0x0,
    e10k_vf_vflinks_initial = 0x0,
    e10k_vf_vfrxmemwrap_initial = 0x0,
    e10k_vf_vfeicr_initial = 0x0,
    e10k_vf_vfeics_initial = 0x0,
    e10k_vf_vfeims_initial = 0x0,
    e10k_vf_vfeimc_initial = 0x0,
    e10k_vf_vfeiam_initial = 0x0,
    e10k_vf_vfeitr_initial = 0x0,
    e10k_vf_vfivar_initial = 0x0,
    e10k_vf_vfivar_misc_initial = 0x0,
    e10k_vf_vfrscint_initial = 0x0,
    e10k_vf_vfpbacl_initial = 0x0,
    e10k_vf_vfrdbal_initial = 0x0,
    e10k_vf_vfrdbah_initial = 0x0,
    e10k_vf_vfrdlen_initial = 0x0,
    e10k_vf_vfrdh_initial = 0x0,
    e10k_vf_vfrdt_initial = 0x0,
    e10k_vf_vfrxdctl_initial = 0x0,
    e10k_vf_vfsrrctl_initial = 0x0,
    e10k_vf_vfpsrtype_initial = 0x0,
    e10k_vf_vfrscctl_initial = 0x0,
    e10k_vf_vftdbal_initial = 0x0,
    e10k_vf_vftdbah_initial = 0x0,
    e10k_vf_vftdlen_initial = 0x0,
    e10k_vf_vftdh_initial = 0x0,
    e10k_vf_vftdt_initial = 0x0,
    e10k_vf_vftxdctl_initial = 0x0,
    e10k_vf_vftdwbal_initial = 0x0,
    e10k_vf_vftdwbah_initial = 0x0,
    e10k_vf_vfdca_rxctrl_initial = 0x0,
    e10k_vf_vfdca_txctrl_initial = 0x0,
    e10k_vf_vfgprc_initial = 0x0,
    e10k_vf_vfgptc_initial = 0x0,
    e10k_vf_vfgorc_lsb_initial = 0x0,
    e10k_vf_vfgorc_msb_initial = 0x0,
    e10k_vf_vfgotc_lsb_initial = 0x0,
    e10k_vf_vfgotc_msb_initial = 0x0,
    e10k_vf_vfmprc_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void e10k_vf_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void e10k_vf_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register vfctrl: VF control
 * Type: e10k_vf.vfctrl (Implicit type of VF control register)
 *   _anon0	(size 26, offset 0, init 0):	RSVD	_
 *   rst	(size 1, offset 26, init 0):	WO	Device reset
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
static inline e10k_vf_vfctrl_t e10k_vf_vfctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfctrl_t e10k_vf_vfctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline e10k_vf_vfctrl_t e10k_vf_vfctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfctrl_t e10k_vf_vfctrl_rd(__DN(t) *_dev)
{
    return(_dev->vfctrl_shadow);
}

static inline void e10k_vf_vfctrl_rawwr(__DN(t) *_dev, e10k_vf_vfctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfctrl_rawwr(__DN(t) *_dev, e10k_vf_vfctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline void e10k_vf_vfctrl_wr(__DN(t) *_dev, e10k_vf_vfctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfctrl_wr(__DN(t) *_dev, e10k_vf_vfctrl_t _regval)
{
    _regval = (_regval & 0x4000000);
    // No MB1 fields present
    _regval = (_regval | (0xfbffffff & mackerel_read_addr_32(_dev->base, 0x0)));
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline int e10k_vf_vfctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vfctrl_t _regval = _dev->vfctrl_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfctrl (VF control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rst =\t%" PRIx8 "\t(Device reset)\n", e10k_vf_vfctrl_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon27 is anonymous
    return(_r);
}

static inline uint8_t e10k_vf_vfctrl_rst_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfctrl_rst_rd_shadow(__DN(t) *_dev)
{
    return(e10k_vf_vfctrl_rst_extract(_dev->vfctrl_shadow));
}

static inline void e10k_vf_vfctrl_rst_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfctrl_rst_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vf_vfctrl_t _regval = 0x4000000 & (((e10k_vf_vfctrl_t )(_fieldval)) << 26);
    _regval = (_regval | (0xfbffffff & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    _dev->vfctrl_shadow = _regval;
}

/*
 * Register vfstatus: VF status
 * Type: e10k_vf.vfstatus (Implicit type of VF status register)
 *   _anon0	(size 2, offset 0, init 0):	RSVD	_
 *   lan_id	(size 2, offset 2, init 0):	RO	LAN ID
 *   _anon4	(size 3, offset 4, init 0):	RSVD	_
 *   link_up	(size 1, offset 7, init 0):	RO	Linkup Status Indication
 *   _anon8	(size 2, offset 8, init 0):	RSVD	_
 *   num_vfs	(size 8, offset 10, init 0):	RO	Num VFs
 *   iov_active	(size 1, offset 18, init 0):	RO	IOV Active
 *   pcie_mes	(size 1, offset 19, init 0):	RO	PCIe Master Enable Status
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
static inline e10k_vf_vfstatus_t e10k_vf_vfstatus_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfstatus_t e10k_vf_vfstatus_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline e10k_vf_vfstatus_t e10k_vf_vfstatus_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfstatus_t e10k_vf_vfstatus_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void e10k_vf_vfstatus_rawwr(__DN(t) *_dev, e10k_vf_vfstatus_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfstatus_rawwr(__DN(t) *_dev, e10k_vf_vfstatus_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

// Register vfstatus is not writeable
static inline int e10k_vf_vfstatus_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfstatus_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vfstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfstatus (VF status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan_id =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_lanid_prtval(_s + _r, _avail, e10k_vf_vfstatus_lan_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LAN ID)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " link_up =\t%" PRIx8 "\t(Linkup Status Indication)\n", e10k_vf_vfstatus_link_up_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " num_vfs =\t%" PRIx8 "\t(Num VFs)\n", e10k_vf_vfstatus_num_vfs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iov_active =\t%" PRIx8 "\t(IOV Active)\n", e10k_vf_vfstatus_iov_active_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie_mes =\t%" PRIx8 "\t(PCIe Master Enable Status)\n", e10k_vf_vfstatus_pcie_mes_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline e10k_vf_lanid_t e10k_vf_vfstatus_lan_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_lanid_t e10k_vf_vfstatus_lan_id_rdf(__DN(t) *_dev)
{
    e10k_vf_vfstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e10k_vf_vfstatus_lan_id_extract(_regval));
}

static inline uint8_t e10k_vf_vfstatus_link_up_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfstatus_link_up_rdf(__DN(t) *_dev)
{
    e10k_vf_vfstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e10k_vf_vfstatus_link_up_extract(_regval));
}

static inline uint8_t e10k_vf_vfstatus_num_vfs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfstatus_num_vfs_rdf(__DN(t) *_dev)
{
    e10k_vf_vfstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e10k_vf_vfstatus_num_vfs_extract(_regval));
}

static inline uint8_t e10k_vf_vfstatus_iov_active_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfstatus_iov_active_rdf(__DN(t) *_dev)
{
    e10k_vf_vfstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e10k_vf_vfstatus_iov_active_extract(_regval));
}

static inline uint8_t e10k_vf_vfstatus_pcie_mes_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfstatus_pcie_mes_rdf(__DN(t) *_dev)
{
    e10k_vf_vfstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e10k_vf_vfstatus_pcie_mes_extract(_regval));
}

/*
 * Register vflinks: VF Link Status Register
 * Type: e10k_vf.vflinks (Implicit type of VF Link Status Register register)
 *   kxsig_det	(size 1, offset 0, init 0):	RO	A signal is present
 *   fecsig_det	(size 1, offset 1, init 0):	RO	FEC reports signal detected
 *   fecblk_lck	(size 1, offset 2, init 0):	RO	FEC reached block lock
 *   krhberr	(size 1, offset 3, init 0):	RO	10GbE serial KR_PCS high error rate
 *   krpcsbl	(size 1, offset 4, init 0):	RO	10 GbE serial PCS block lock
 *   kxr_annprcv	(size 1, offset 5, init 0):	RO	KX/KX4/KR AN Next Page Received
 *   kxr_anprcv	(size 1, offset 6, init 0):	RO	KX/KX4/KR Backplane Auto Negotiation Page Received
 *   lnk_stat	(size 1, offset 7, init 0):	RO	Link Up and there was no link down from last time read
 *   kx4sig_det	(size 4, offset 8, init 0):	RO	Signal Detect of 10 GbE Parallel (KX4, CX4 or XAUI) (1bit per lane)
 *   krsig_det	(size 1, offset 12, init 0):	RO	Signal Detect of 10 GbE serial (KR or SFI)
 *   l10g_syncst	(size 4, offset 13, init 0):	RO	10G Parallel lane sync status (1bit per lane)
 *   l10g_algst	(size 1, offset 17, init 0):	RO	10 GbE align_status
 *   l1g_syncst	(size 1, offset 18, init 0):	RO	1G sync_status
 *   kxr_anrxid	(size 1, offset 19, init 0):	RO	KX/KX4/KR Backplane Auto Negotiation Rx Idle
 *   l1g_anen	(size 1, offset 20, init 0):	RO	PCS_1 GbE auto-negotiation is enabled
 *   l1g_lnken	(size 1, offset 21, init 0):	RO	1 GbE PCS enabled for 1 GbE and SGMII operation
 *   l10g_lnken	(size 1, offset 22, init 0):	RO	XGXS Enabled for 10 GbE operation
 *   fec_en	(size 1, offset 23, init 0):	RO	Status of forwarderrorcorrection in 10 GbE serial link
 *   l10g_seren	(size 1, offset 24, init 0):	RO	Status of 10 GbE serial PCS (KR PCS) for KR or SFI operation
 *   sgmii_en	(size 1, offset 25, init 0):	RO	Status of SGMII operation
 *   mlink_mode	(size 2, offset 26, init 0):	RO	MAC link mode status
 *   lnk_speed	(size 2, offset 28, init 0):	RO	MAC link speed status
 *   lnk_up	(size 1, offset 30, init 0):	RO	Link is up
 *   kxr_ancomp	(size 1, offset 31, init 0):	RO	KX/KX4/KR backplane auto-negotiation has completed successfully
 */
static inline e10k_vf_vflinks_t e10k_vf_vflinks_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline e10k_vf_vflinks_t e10k_vf_vflinks_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vflinks_t e10k_vf_vflinks_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void e10k_vf_vflinks_rawwr(__DN(t) *_dev, e10k_vf_vflinks_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vflinks_rawwr(__DN(t) *_dev, e10k_vf_vflinks_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

// Register vflinks is not writeable
static inline int e10k_vf_vflinks_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vflinks_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vflinks (VF Link Status Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxsig_det =\t%" PRIx8 "\t(A signal is present)\n", e10k_vf_vflinks_kxsig_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fecsig_det =\t%" PRIx8 "\t(FEC reports signal detected)\n", e10k_vf_vflinks_fecsig_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fecblk_lck =\t%" PRIx8 "\t(FEC reached block lock)\n", e10k_vf_vflinks_fecblk_lck_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " krhberr =\t%" PRIx8 "\t(10GbE serial KR_PCS high error rate)\n", e10k_vf_vflinks_krhberr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " krpcsbl =\t%" PRIx8 "\t(10 GbE serial PCS block lock)\n", e10k_vf_vflinks_krpcsbl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxr_annprcv =\t%" PRIx8 "\t(KX/KX4/KR AN Next Page Received)\n", e10k_vf_vflinks_kxr_annprcv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxr_anprcv =\t%" PRIx8 "\t(KX/KX4/KR Backplane Auto Negotiation Page Received)\n", e10k_vf_vflinks_kxr_anprcv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_stat =\t%" PRIx8 "\t(Link Up and there was no link down from last time read)\n", e10k_vf_vflinks_lnk_stat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kx4sig_det =\t%" PRIx8 "\t(Signal Detect of 10 GbE Parallel (KX4, CX4 or XAUI) (1bit per lane))\n", e10k_vf_vflinks_kx4sig_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " krsig_det =\t%" PRIx8 "\t(Signal Detect of 10 GbE serial (KR or SFI))\n", e10k_vf_vflinks_krsig_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l10g_syncst =\t%" PRIx8 "\t(10G Parallel lane sync status (1bit per lane))\n", e10k_vf_vflinks_l10g_syncst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l10g_algst =\t%" PRIx8 "\t(10 GbE align_status)\n", e10k_vf_vflinks_l10g_algst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1g_syncst =\t%" PRIx8 "\t(1G sync_status)\n", e10k_vf_vflinks_l1g_syncst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxr_anrxid =\t%" PRIx8 "\t(KX/KX4/KR Backplane Auto Negotiation Rx Idle)\n", e10k_vf_vflinks_kxr_anrxid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1g_anen =\t%" PRIx8 "\t(PCS_1 GbE auto-negotiation is enabled)\n", e10k_vf_vflinks_l1g_anen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1g_lnken =\t%" PRIx8 "\t(1 GbE PCS enabled for 1 GbE and SGMII operation)\n", e10k_vf_vflinks_l1g_lnken_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l10g_lnken =\t%" PRIx8 "\t(XGXS Enabled for 10 GbE operation)\n", e10k_vf_vflinks_l10g_lnken_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_en =\t%" PRIx8 "\t(Status of forwarderrorcorrection in 10 GbE serial link)\n", e10k_vf_vflinks_fec_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l10g_seren =\t%" PRIx8 "\t(Status of 10 GbE serial PCS (KR PCS) for KR or SFI operation)\n", e10k_vf_vflinks_l10g_seren_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sgmii_en =\t%" PRIx8 "\t(Status of SGMII operation)\n", e10k_vf_vflinks_sgmii_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mlink_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_mac_lnkmode_prtval(_s + _r, _avail, e10k_vf_vflinks_mlink_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(MAC link mode status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_speed =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_link_speed_prtval(_s + _r, _avail, e10k_vf_vflinks_lnk_speed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(MAC link speed status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_up =\t%" PRIx8 "\t(Link is up)\n", e10k_vf_vflinks_lnk_up_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxr_ancomp =\t%" PRIx8 "\t(KX/KX4/KR backplane auto-negotiation has completed successfully)\n", e10k_vf_vflinks_kxr_ancomp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_vf_vflinks_kxsig_det_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_kxsig_det_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_kxsig_det_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_fecsig_det_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_fecsig_det_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_fecsig_det_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_fecblk_lck_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_fecblk_lck_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_fecblk_lck_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_krhberr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_krhberr_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_krhberr_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_krpcsbl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_krpcsbl_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_krpcsbl_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_kxr_annprcv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_kxr_annprcv_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_kxr_annprcv_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_kxr_anprcv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_kxr_anprcv_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_kxr_anprcv_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_lnk_stat_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_lnk_stat_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_lnk_stat_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_kx4sig_det_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_kx4sig_det_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_kx4sig_det_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_krsig_det_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_krsig_det_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_krsig_det_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_l10g_syncst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_l10g_syncst_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_l10g_syncst_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_l10g_algst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_l10g_algst_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_l10g_algst_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_l1g_syncst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_l1g_syncst_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_l1g_syncst_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_kxr_anrxid_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_kxr_anrxid_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_kxr_anrxid_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_l1g_anen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_l1g_anen_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_l1g_anen_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_l1g_lnken_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_l1g_lnken_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_l1g_lnken_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_l10g_lnken_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_l10g_lnken_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_l10g_lnken_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_fec_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_fec_en_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_fec_en_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_l10g_seren_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_l10g_seren_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_l10g_seren_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_sgmii_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_sgmii_en_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_sgmii_en_extract(_regval));
}

static inline e10k_vf_mac_lnkmode_t e10k_vf_vflinks_mlink_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_mac_lnkmode_t e10k_vf_vflinks_mlink_mode_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_mlink_mode_extract(_regval));
}

static inline e10k_vf_link_speed_t e10k_vf_vflinks_lnk_speed_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_link_speed_t e10k_vf_vflinks_lnk_speed_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_lnk_speed_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_lnk_up_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_lnk_up_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_lnk_up_extract(_regval));
}

static inline uint8_t e10k_vf_vflinks_kxr_ancomp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vflinks_kxr_ancomp_rdf(__DN(t) *_dev)
{
    e10k_vf_vflinks_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e10k_vf_vflinks_kxr_ancomp_extract(_regval));
}

/*
 * Register vfrxmemwrap: VF Rx Packet Buffer Flush Detect
 * Type: e10k_vf.vfrxmemwrap (Implicit type of VF Rx Packet Buffer Flush Detect register)
 *   tc0_wrap	(size 3, offset 0, init 0):	RO	Packet Buffer 0 Wrap Around Counter
 *   tc0_empty	(size 1, offset 3, init 0):	RO	Packet Buffer 0 Empty
 *   tc1_wrap	(size 3, offset 4, init 0):	RO	Packet Buffer 1 Wrap Around Counter
 *   tc1_empty	(size 1, offset 7, init 0):	RO	Packet Buffer 1 Empty
 *   tc2_wrap	(size 3, offset 8, init 0):	RO	Packet Buffer 2 Wrap Around Counter
 *   tc2_empty	(size 1, offset 11, init 0):	RO	Packet Buffer 2 Empty
 *   tc3_wrap	(size 3, offset 12, init 0):	RO	Packet Buffer 3 Wrap Around Counter
 *   tc3_empty	(size 1, offset 15, init 0):	RO	Packet Buffer 3 Empty
 *   tc4_wrap	(size 3, offset 16, init 0):	RO	Packet Buffer 4 Wrap Around Counter
 *   tc4_empty	(size 1, offset 19, init 0):	RO	Packet Buffer 4 Empty
 *   tc5_wrap	(size 3, offset 20, init 0):	RO	Packet Buffer 5 Wrap Around Counter
 *   tc5_empty	(size 1, offset 23, init 0):	RO	Packet Buffer 5 Empty
 *   tc6_wrap	(size 3, offset 24, init 0):	RO	Packet Buffer 6 Wrap Around Counter
 *   tc6_empty	(size 1, offset 27, init 0):	RO	Packet Buffer 6 Empty
 *   tc7_wrap	(size 3, offset 28, init 0):	RO	Packet Buffer 7 Wrap Around Counter
 *   tc7_empty	(size 1, offset 31, init 0):	RO	Packet Buffer 7 Empty
 */
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3190));
}

static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfrxmemwrap_t e10k_vf_vfrxmemwrap_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3190));
}

static inline void e10k_vf_vfrxmemwrap_rawwr(__DN(t) *_dev, e10k_vf_vfrxmemwrap_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrxmemwrap_rawwr(__DN(t) *_dev, e10k_vf_vfrxmemwrap_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3190, _regval);
}

// Register vfrxmemwrap is not writeable
static inline int e10k_vf_vfrxmemwrap_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfrxmemwrap_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfrxmemwrap (VF Rx Packet Buffer Flush Detect): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc0_wrap =\t%" PRIx8 "\t(Packet Buffer 0 Wrap Around Counter)\n", e10k_vf_vfrxmemwrap_tc0_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc0_empty =\t%" PRIx8 "\t(Packet Buffer 0 Empty)\n", e10k_vf_vfrxmemwrap_tc0_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc1_wrap =\t%" PRIx8 "\t(Packet Buffer 1 Wrap Around Counter)\n", e10k_vf_vfrxmemwrap_tc1_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc1_empty =\t%" PRIx8 "\t(Packet Buffer 1 Empty)\n", e10k_vf_vfrxmemwrap_tc1_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc2_wrap =\t%" PRIx8 "\t(Packet Buffer 2 Wrap Around Counter)\n", e10k_vf_vfrxmemwrap_tc2_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc2_empty =\t%" PRIx8 "\t(Packet Buffer 2 Empty)\n", e10k_vf_vfrxmemwrap_tc2_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc3_wrap =\t%" PRIx8 "\t(Packet Buffer 3 Wrap Around Counter)\n", e10k_vf_vfrxmemwrap_tc3_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc3_empty =\t%" PRIx8 "\t(Packet Buffer 3 Empty)\n", e10k_vf_vfrxmemwrap_tc3_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc4_wrap =\t%" PRIx8 "\t(Packet Buffer 4 Wrap Around Counter)\n", e10k_vf_vfrxmemwrap_tc4_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc4_empty =\t%" PRIx8 "\t(Packet Buffer 4 Empty)\n", e10k_vf_vfrxmemwrap_tc4_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc5_wrap =\t%" PRIx8 "\t(Packet Buffer 5 Wrap Around Counter)\n", e10k_vf_vfrxmemwrap_tc5_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc5_empty =\t%" PRIx8 "\t(Packet Buffer 5 Empty)\n", e10k_vf_vfrxmemwrap_tc5_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc6_wrap =\t%" PRIx8 "\t(Packet Buffer 6 Wrap Around Counter)\n", e10k_vf_vfrxmemwrap_tc6_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc6_empty =\t%" PRIx8 "\t(Packet Buffer 6 Empty)\n", e10k_vf_vfrxmemwrap_tc6_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc7_wrap =\t%" PRIx8 "\t(Packet Buffer 7 Wrap Around Counter)\n", e10k_vf_vfrxmemwrap_tc7_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc7_empty =\t%" PRIx8 "\t(Packet Buffer 7 Empty)\n", e10k_vf_vfrxmemwrap_tc7_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc0_wrap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc0_wrap_rdf(__DN(t) *_dev)
{
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_vf_vfrxmemwrap_tc0_wrap_extract(_regval));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc0_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc0_empty_rdf(__DN(t) *_dev)
{
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_vf_vfrxmemwrap_tc0_empty_extract(_regval));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc1_wrap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc1_wrap_rdf(__DN(t) *_dev)
{
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_vf_vfrxmemwrap_tc1_wrap_extract(_regval));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc1_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc1_empty_rdf(__DN(t) *_dev)
{
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_vf_vfrxmemwrap_tc1_empty_extract(_regval));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc2_wrap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc2_wrap_rdf(__DN(t) *_dev)
{
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_vf_vfrxmemwrap_tc2_wrap_extract(_regval));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc2_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc2_empty_rdf(__DN(t) *_dev)
{
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_vf_vfrxmemwrap_tc2_empty_extract(_regval));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc3_wrap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc3_wrap_rdf(__DN(t) *_dev)
{
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_vf_vfrxmemwrap_tc3_wrap_extract(_regval));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc3_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc3_empty_rdf(__DN(t) *_dev)
{
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_vf_vfrxmemwrap_tc3_empty_extract(_regval));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc4_wrap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc4_wrap_rdf(__DN(t) *_dev)
{
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_vf_vfrxmemwrap_tc4_wrap_extract(_regval));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc4_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc4_empty_rdf(__DN(t) *_dev)
{
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_vf_vfrxmemwrap_tc4_empty_extract(_regval));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc5_wrap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc5_wrap_rdf(__DN(t) *_dev)
{
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_vf_vfrxmemwrap_tc5_wrap_extract(_regval));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc5_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc5_empty_rdf(__DN(t) *_dev)
{
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_vf_vfrxmemwrap_tc5_empty_extract(_regval));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc6_wrap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc6_wrap_rdf(__DN(t) *_dev)
{
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_vf_vfrxmemwrap_tc6_wrap_extract(_regval));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc6_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc6_empty_rdf(__DN(t) *_dev)
{
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_vf_vfrxmemwrap_tc6_empty_extract(_regval));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc7_wrap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc7_wrap_rdf(__DN(t) *_dev)
{
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_vf_vfrxmemwrap_tc7_wrap_extract(_regval));
}

static inline uint8_t e10k_vf_vfrxmemwrap_tc7_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxmemwrap_tc7_empty_rdf(__DN(t) *_dev)
{
    e10k_vf_vfrxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_vf_vfrxmemwrap_tc7_empty_extract(_regval));
}

/*
 * Register vfeicr: VF Extended Interrupt Cause
 * Type: e10k_vf.vfeicr (Implicit type of VF Extended Interrupt Cause register)
 *   msix	(size 3, offset 0, init 0):	RWC	Indicates an interrupt cause mapped to MSI-X vectors 2:0
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
static inline e10k_vf_vfeicr_t e10k_vf_vfeicr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfeicr_t e10k_vf_vfeicr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x100));
}

static inline e10k_vf_vfeicr_t e10k_vf_vfeicr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfeicr_t e10k_vf_vfeicr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x100));
}

static inline void e10k_vf_vfeicr_rawwr(__DN(t) *_dev, e10k_vf_vfeicr_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeicr_rawwr(__DN(t) *_dev, e10k_vf_vfeicr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
}

static inline void e10k_vf_vfeicr_wr(__DN(t) *_dev, e10k_vf_vfeicr_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeicr_wr(__DN(t) *_dev, e10k_vf_vfeicr_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x100)));
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
}

static inline int e10k_vf_vfeicr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfeicr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vfeicr_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfeicr (VF Extended Interrupt Cause): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msix =\t%" PRIx8 "\t(Indicates an interrupt cause mapped to MSI-X vectors 2:0)\n", e10k_vf_vfeicr_msix_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t e10k_vf_vfeicr_msix_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfeicr_msix_rdf(__DN(t) *_dev)
{
    e10k_vf_vfeicr_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e10k_vf_vfeicr_msix_extract(_regval));
}

static inline void e10k_vf_vfeicr_msix_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeicr_msix_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vf_vfeicr_t _regval = 0x7 & (((e10k_vf_vfeicr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

/*
 * Register vfeics: VF Extended Interrupt Cause Set
 * Type: e10k_vf.vfeics (Implicit type of VF Extended Interrupt Cause Set register)
 *   msix	(size 3, offset 0, init 0):	WO	Sets to corresponding EICR bit of MSI-X vectors 2:0
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
static inline e10k_vf_vfeics_t e10k_vf_vfeics_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfeics_t e10k_vf_vfeics_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x104));
}

static inline e10k_vf_vfeics_t e10k_vf_vfeics_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfeics_t e10k_vf_vfeics_rd(__DN(t) *_dev)
{
    return(_dev->vfeics_shadow);
}

static inline void e10k_vf_vfeics_rawwr(__DN(t) *_dev, e10k_vf_vfeics_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeics_rawwr(__DN(t) *_dev, e10k_vf_vfeics_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x104, _regval);
}

static inline void e10k_vf_vfeics_wr(__DN(t) *_dev, e10k_vf_vfeics_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeics_wr(__DN(t) *_dev, e10k_vf_vfeics_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x104)));
    mackerel_write_addr_32(_dev->base, 0x104, _regval);
}

static inline int e10k_vf_vfeics_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfeics_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vfeics_t _regval = _dev->vfeics_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfeics (VF Extended Interrupt Cause Set): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msix =\t%" PRIx8 "\t(Sets to corresponding EICR bit of MSI-X vectors 2:0)\n", e10k_vf_vfeics_msix_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t e10k_vf_vfeics_msix_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfeics_msix_rd_shadow(__DN(t) *_dev)
{
    return(e10k_vf_vfeics_msix_extract(_dev->vfeics_shadow));
}

static inline void e10k_vf_vfeics_msix_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeics_msix_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vf_vfeics_t _regval = 0x7 & (((e10k_vf_vfeics_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x104)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x104, _regval);
    _dev->vfeics_shadow = _regval;
}

/*
 * Register vfeims: VF Extended Interrupt Mask Set/Read
 * Type: e10k_vf.vfeims (Implicit type of VF Extended Interrupt Mask Set/Read register)
 *   msix	(size 3, offset 0, init 0):	RW	Set mask bit for the corresponding EICR bit of MSI-X vectors 2:0
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
static inline e10k_vf_vfeims_t e10k_vf_vfeims_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfeims_t e10k_vf_vfeims_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x108));
}

static inline e10k_vf_vfeims_t e10k_vf_vfeims_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfeims_t e10k_vf_vfeims_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x108));
}

static inline void e10k_vf_vfeims_rawwr(__DN(t) *_dev, e10k_vf_vfeims_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeims_rawwr(__DN(t) *_dev, e10k_vf_vfeims_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x108, _regval);
}

static inline void e10k_vf_vfeims_wr(__DN(t) *_dev, e10k_vf_vfeims_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeims_wr(__DN(t) *_dev, e10k_vf_vfeims_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x108)));
    mackerel_write_addr_32(_dev->base, 0x108, _regval);
}

static inline int e10k_vf_vfeims_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfeims_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vfeims_t _regval = mackerel_read_addr_32(_dev->base, 0x108);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfeims (VF Extended Interrupt Mask Set/Read): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msix =\t%" PRIx8 "\t(Set mask bit for the corresponding EICR bit of MSI-X vectors 2:0)\n", e10k_vf_vfeims_msix_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t e10k_vf_vfeims_msix_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfeims_msix_rdf(__DN(t) *_dev)
{
    e10k_vf_vfeims_t _regval = mackerel_read_addr_32(_dev->base, 0x108);
    return(e10k_vf_vfeims_msix_extract(_regval));
}

static inline void e10k_vf_vfeims_msix_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeims_msix_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vf_vfeims_t _regval = 0x7 & (((e10k_vf_vfeims_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x108)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x108, _regval);
    // No shadow register to write to
}

/*
 * Register vfeimc: VF Extended Interrupt Mask Clear
 * Type: e10k_vf.vfeimc (Implicit type of VF Extended Interrupt Mask Clear register)
 *   msix	(size 3, offset 0, init 0):	WO	Clear mask bit for the corresponding EICR bit of MSI-X vectors 2:0
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
static inline e10k_vf_vfeimc_t e10k_vf_vfeimc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfeimc_t e10k_vf_vfeimc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10c));
}

static inline e10k_vf_vfeimc_t e10k_vf_vfeimc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfeimc_t e10k_vf_vfeimc_rd(__DN(t) *_dev)
{
    return(_dev->vfeimc_shadow);
}

static inline void e10k_vf_vfeimc_rawwr(__DN(t) *_dev, e10k_vf_vfeimc_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeimc_rawwr(__DN(t) *_dev, e10k_vf_vfeimc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10c, _regval);
}

static inline void e10k_vf_vfeimc_wr(__DN(t) *_dev, e10k_vf_vfeimc_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeimc_wr(__DN(t) *_dev, e10k_vf_vfeimc_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x10c)));
    mackerel_write_addr_32(_dev->base, 0x10c, _regval);
}

static inline int e10k_vf_vfeimc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfeimc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vfeimc_t _regval = _dev->vfeimc_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfeimc (VF Extended Interrupt Mask Clear): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msix =\t%" PRIx8 "\t(Clear mask bit for the corresponding EICR bit of MSI-X vectors 2:0)\n", e10k_vf_vfeimc_msix_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t e10k_vf_vfeimc_msix_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfeimc_msix_rd_shadow(__DN(t) *_dev)
{
    return(e10k_vf_vfeimc_msix_extract(_dev->vfeimc_shadow));
}

static inline void e10k_vf_vfeimc_msix_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeimc_msix_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vf_vfeimc_t _regval = 0x7 & (((e10k_vf_vfeimc_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x10c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10c, _regval);
    _dev->vfeimc_shadow = _regval;
}

/*
 * Register vfeiam: VF Extended Interrupt Auto Mask Enable
 * Type: e10k_vf.vfeiam (Implicit type of VF Extended Interrupt Auto Mask Enable register)
 *   msix	(size 3, offset 0, init 0):	RW	Auto mask bit for the corresponding EICR bit of MSI-X vectors 2:0
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
static inline e10k_vf_vfeiam_t e10k_vf_vfeiam_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfeiam_t e10k_vf_vfeiam_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x114));
}

static inline e10k_vf_vfeiam_t e10k_vf_vfeiam_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfeiam_t e10k_vf_vfeiam_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x114));
}

static inline void e10k_vf_vfeiam_rawwr(__DN(t) *_dev, e10k_vf_vfeiam_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeiam_rawwr(__DN(t) *_dev, e10k_vf_vfeiam_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x114, _regval);
}

static inline void e10k_vf_vfeiam_wr(__DN(t) *_dev, e10k_vf_vfeiam_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeiam_wr(__DN(t) *_dev, e10k_vf_vfeiam_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x114)));
    mackerel_write_addr_32(_dev->base, 0x114, _regval);
}

static inline int e10k_vf_vfeiam_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfeiam_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vfeiam_t _regval = mackerel_read_addr_32(_dev->base, 0x114);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfeiam (VF Extended Interrupt Auto Mask Enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msix =\t%" PRIx8 "\t(Auto mask bit for the corresponding EICR bit of MSI-X vectors 2:0)\n", e10k_vf_vfeiam_msix_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t e10k_vf_vfeiam_msix_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfeiam_msix_rdf(__DN(t) *_dev)
{
    e10k_vf_vfeiam_t _regval = mackerel_read_addr_32(_dev->base, 0x114);
    return(e10k_vf_vfeiam_msix_extract(_regval));
}

static inline void e10k_vf_vfeiam_msix_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeiam_msix_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vf_vfeiam_t _regval = 0x7 & (((e10k_vf_vfeiam_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x114)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x114, _regval);
    // No shadow register to write to
}

/*
 * Register array vfeitr: VF Extended Interrupt Mask Set/Read #0-#1
 * Type: e10k_vf.uint32 (primitive type)
 */
static const size_t e10k_vf_vfeitr_length = 2;
static inline uint32_t e10k_vf_vfeitr_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfeitr_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8))));
}

static inline uint32_t e10k_vf_vfeitr_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfeitr_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8))));
}

static inline void e10k_vf_vfeitr_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeitr_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x820 + (_i * (32 / 8)), _regval);
}

static inline void e10k_vf_vfeitr_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfeitr_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x820 + (_i * (32 / 8)), _regval);
}

static inline int e10k_vf_vfeitr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vfeitr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vfeitr", _i, "VF Extended Interrupt Mask Set/Read #0-#1");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vfeitr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfeitr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vfeitr_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array vfivar: VF Interrupt Vector Allocation Registers
 * Type: e10k_vf.vfivar (Implicit type of VF Interrupt Vector Allocation Registers register array)
 *   i_alloc0	(size 1, offset 0, init 0):	RW	Defines the MSI-X vector (0 or 1) assigned to Rx queue 2*N for IVAR N register (N = 0..3)
 *   _anon1	(size 6, offset 1, init 0):	RSVD	_
 *   i_allocval0	(size 1, offset 7, init 0):	RW	Interrupt allocation 0 valid
 *   i_alloc1	(size 1, offset 8, init 0):	RW	The interrupt allocation for Tx queue 2n
 *   _anon9	(size 6, offset 9, init 0):	RSVD	_
 *   i_allocval1	(size 1, offset 15, init 0):	RW	Interrupt allocation 1 valid
 *   i_alloc2	(size 1, offset 16, init 0):	RW	The interrupt allocation for Rx queue 2n+1
 *   _anon17	(size 6, offset 17, init 0):	RSVD	_
 *   i_allocval2	(size 1, offset 23, init 0):	RW	Interrupt allocation 2 valid
 *   i_alloc3	(size 1, offset 24, init 0):	RW	The interrupt allocation for Tx queue 2n+1
 *   _anon25	(size 6, offset 25, init 0):	RSVD	_
 *   i_allocval3	(size 1, offset 31, init 0):	RW	Interrupt allocation 3 valid
 */
static const size_t e10k_vf_vfivar_length = 4;
static inline e10k_vf_vfivar_t e10k_vf_vfivar_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_vfivar_t e10k_vf_vfivar_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8))));
}

static inline e10k_vf_vfivar_t e10k_vf_vfivar_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_vfivar_t e10k_vf_vfivar_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8))));
}

static inline void e10k_vf_vfivar_rawwr(__DN(t) *_dev, int _i, e10k_vf_vfivar_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfivar_rawwr(__DN(t) *_dev, int _i, e10k_vf_vfivar_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x120 + (_i * (32 / 8)), _regval);
}

static inline void e10k_vf_vfivar_wr(__DN(t) *_dev, int _i, e10k_vf_vfivar_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfivar_wr(__DN(t) *_dev, int _i, e10k_vf_vfivar_t _regval)
{
    _regval = (_regval & 0x81818181);
    // No MB1 fields present
    _regval = (_regval | (0x7e7e7e7e & mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x120 + (_i * (32 / 8)), _regval);
}

static inline int e10k_vf_vfivar_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vfivar_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vfivar_t _regval = mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vfivar", _i, "VF Interrupt Vector Allocation Registers");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc0 =\t%" PRIx8 "\t(Defines the MSI-X vector (0 or 1) assigned to Rx queue 2*N for IVAR N register (N = 0..3))\n", e10k_vf_vfivar_i_alloc0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval0 =\t%" PRIx8 "\t(Interrupt allocation 0 valid)\n", e10k_vf_vfivar_i_allocval0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc1 =\t%" PRIx8 "\t(The interrupt allocation for Tx queue 2n)\n", e10k_vf_vfivar_i_alloc1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval1 =\t%" PRIx8 "\t(Interrupt allocation 1 valid)\n", e10k_vf_vfivar_i_allocval1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc2 =\t%" PRIx8 "\t(The interrupt allocation for Rx queue 2n+1)\n", e10k_vf_vfivar_i_alloc2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon17 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval2 =\t%" PRIx8 "\t(Interrupt allocation 2 valid)\n", e10k_vf_vfivar_i_allocval2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc3 =\t%" PRIx8 "\t(The interrupt allocation for Tx queue 2n+1)\n", e10k_vf_vfivar_i_alloc3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval3 =\t%" PRIx8 "\t(Interrupt allocation 3 valid)\n", e10k_vf_vfivar_i_allocval3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vfivar_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfivar_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vfivar_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_vf_vfivar_i_alloc0_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_i_alloc0_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vfivar_t _regval = mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)));
    return(e10k_vf_vfivar_i_alloc0_extract(_regval));
}

static inline uint8_t e10k_vf_vfivar_i_allocval0_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_i_allocval0_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vfivar_t _regval = mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)));
    return(e10k_vf_vfivar_i_allocval0_extract(_regval));
}

static inline uint8_t e10k_vf_vfivar_i_alloc1_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_i_alloc1_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vfivar_t _regval = mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)));
    return(e10k_vf_vfivar_i_alloc1_extract(_regval));
}

static inline uint8_t e10k_vf_vfivar_i_allocval1_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_i_allocval1_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vfivar_t _regval = mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)));
    return(e10k_vf_vfivar_i_allocval1_extract(_regval));
}

static inline uint8_t e10k_vf_vfivar_i_alloc2_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_i_alloc2_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vfivar_t _regval = mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)));
    return(e10k_vf_vfivar_i_alloc2_extract(_regval));
}

static inline uint8_t e10k_vf_vfivar_i_allocval2_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_i_allocval2_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vfivar_t _regval = mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)));
    return(e10k_vf_vfivar_i_allocval2_extract(_regval));
}

static inline uint8_t e10k_vf_vfivar_i_alloc3_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_i_alloc3_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vfivar_t _regval = mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)));
    return(e10k_vf_vfivar_i_alloc3_extract(_regval));
}

static inline uint8_t e10k_vf_vfivar_i_allocval3_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_i_allocval3_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vfivar_t _regval = mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)));
    return(e10k_vf_vfivar_i_allocval3_extract(_regval));
}

static inline void e10k_vf_vfivar_i_alloc0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfivar_i_alloc0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vfivar_t _regval = 0x1 & (((e10k_vf_vfivar_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x120 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfivar_i_allocval0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfivar_i_allocval0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vfivar_t _regval = 0x80 & (((e10k_vf_vfivar_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x120 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfivar_i_alloc1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfivar_i_alloc1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vfivar_t _regval = 0x100 & (((e10k_vf_vfivar_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffffeff & mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x120 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfivar_i_allocval1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfivar_i_allocval1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vfivar_t _regval = 0x8000 & (((e10k_vf_vfivar_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x120 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfivar_i_alloc2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfivar_i_alloc2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vfivar_t _regval = 0x10000 & (((e10k_vf_vfivar_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x120 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfivar_i_allocval2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfivar_i_allocval2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vfivar_t _regval = 0x800000 & (((e10k_vf_vfivar_t )(_fieldval)) << 23);
    _regval = (_regval | (0xff7fffff & mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x120 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfivar_i_alloc3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfivar_i_alloc3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vfivar_t _regval = 0x1000000 & (((e10k_vf_vfivar_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfeffffff & mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x120 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfivar_i_allocval3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfivar_i_allocval3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vfivar_t _regval = 0x80000000 & (((e10k_vf_vfivar_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x120 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x120 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register vfivar_misc: VF Miscellaneous Interrupt Vector Allocation
 * Type: e10k_vf.vfivar_misc (Implicit type of VF Miscellaneous Interrupt Vector Allocation register)
 *   i_alloc0	(size 2, offset 0, init 0):	RW	MSI-X vector assigned to the mailbox interrupt
 *   _anon2	(size 5, offset 2, init 0):	RSVD	_
 *   i_allocval0	(size 1, offset 7, init 0):	RW	Interrupt allocation 0 valid
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline e10k_vf_vfivar_misc_t e10k_vf_vfivar_misc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfivar_misc_t e10k_vf_vfivar_misc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x140));
}

static inline e10k_vf_vfivar_misc_t e10k_vf_vfivar_misc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfivar_misc_t e10k_vf_vfivar_misc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x140));
}

static inline void e10k_vf_vfivar_misc_rawwr(__DN(t) *_dev, e10k_vf_vfivar_misc_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfivar_misc_rawwr(__DN(t) *_dev, e10k_vf_vfivar_misc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x140, _regval);
}

static inline void e10k_vf_vfivar_misc_wr(__DN(t) *_dev, e10k_vf_vfivar_misc_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfivar_misc_wr(__DN(t) *_dev, e10k_vf_vfivar_misc_t _regval)
{
    _regval = (_regval & 0x83);
    // No MB1 fields present
    _regval = (_regval | (0xffffff7c & mackerel_read_addr_32(_dev->base, 0x140)));
    mackerel_write_addr_32(_dev->base, 0x140, _regval);
}

static inline int e10k_vf_vfivar_misc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfivar_misc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vfivar_misc_t _regval = mackerel_read_addr_32(_dev->base, 0x140);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfivar_misc (VF Miscellaneous Interrupt Vector Allocation): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc0 =\t%" PRIx8 "\t(MSI-X vector assigned to the mailbox interrupt)\n", e10k_vf_vfivar_misc_i_alloc0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval0 =\t%" PRIx8 "\t(Interrupt allocation 0 valid)\n", e10k_vf_vfivar_misc_i_allocval0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t e10k_vf_vfivar_misc_i_alloc0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_misc_i_alloc0_rdf(__DN(t) *_dev)
{
    e10k_vf_vfivar_misc_t _regval = mackerel_read_addr_32(_dev->base, 0x140);
    return(e10k_vf_vfivar_misc_i_alloc0_extract(_regval));
}

static inline uint8_t e10k_vf_vfivar_misc_i_allocval0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfivar_misc_i_allocval0_rdf(__DN(t) *_dev)
{
    e10k_vf_vfivar_misc_t _regval = mackerel_read_addr_32(_dev->base, 0x140);
    return(e10k_vf_vfivar_misc_i_allocval0_extract(_regval));
}

static inline void e10k_vf_vfivar_misc_i_alloc0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfivar_misc_i_alloc0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vf_vfivar_misc_t _regval = 0x3 & (((e10k_vf_vfivar_misc_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0x140)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x140, _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfivar_misc_i_allocval0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfivar_misc_i_allocval0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vf_vfivar_misc_t _regval = 0x80 & (((e10k_vf_vfivar_misc_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0x140)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x140, _regval);
    // No shadow register to write to
}

/*
 * Register array vfrscint: VF RSC Enable Interrupt
 * Type: e10k_vf.uint32 (primitive type)
 */
static const size_t e10k_vf_vfrscint_length = 2;
static inline uint32_t e10k_vf_vfrscint_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfrscint_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x180 + (_i * (32 / 8))));
}

static inline uint32_t e10k_vf_vfrscint_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfrscint_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x180 + (_i * (32 / 8))));
}

static inline void e10k_vf_vfrscint_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrscint_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x180 + (_i * (32 / 8)), _regval);
}

static inline void e10k_vf_vfrscint_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrscint_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x180 + (_i * (32 / 8)), _regval);
}

static inline int e10k_vf_vfrscint_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vfrscint_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x180 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vfrscint", _i, "VF RSC Enable Interrupt");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vfrscint_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfrscint_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vfrscint_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register vfpbacl: VF MSI-X PBA Clear
 * Type: e10k_vf.vfpbacl (Implicit type of VF MSI-X PBA Clear register)
 *   penbit	(size 3, offset 0, init 0):	RWC	MSI-X Pending Bits Clear. Reading returns PBA vector.
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
static inline e10k_vf_vfpbacl_t e10k_vf_vfpbacl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfpbacl_t e10k_vf_vfpbacl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x148));
}

static inline e10k_vf_vfpbacl_t e10k_vf_vfpbacl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfpbacl_t e10k_vf_vfpbacl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x148));
}

static inline void e10k_vf_vfpbacl_rawwr(__DN(t) *_dev, e10k_vf_vfpbacl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfpbacl_rawwr(__DN(t) *_dev, e10k_vf_vfpbacl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x148, _regval);
}

static inline void e10k_vf_vfpbacl_wr(__DN(t) *_dev, e10k_vf_vfpbacl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfpbacl_wr(__DN(t) *_dev, e10k_vf_vfpbacl_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x148)));
    mackerel_write_addr_32(_dev->base, 0x148, _regval);
}

static inline int e10k_vf_vfpbacl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfpbacl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vfpbacl_t _regval = mackerel_read_addr_32(_dev->base, 0x148);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfpbacl (VF MSI-X PBA Clear): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " penbit =\t%" PRIx8 "\t(MSI-X Pending Bits Clear. Reading returns PBA vector.)\n", e10k_vf_vfpbacl_penbit_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t e10k_vf_vfpbacl_penbit_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfpbacl_penbit_rdf(__DN(t) *_dev)
{
    e10k_vf_vfpbacl_t _regval = mackerel_read_addr_32(_dev->base, 0x148);
    return(e10k_vf_vfpbacl_penbit_extract(_regval));
}

static inline void e10k_vf_vfpbacl_penbit_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfpbacl_penbit_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vf_vfpbacl_t _regval = 0x7 & (((e10k_vf_vfpbacl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x148)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x148, _regval);
    // No shadow register to write to
}

/*
 * Register array vfrdbal: VF Receive Descriptor Base Address Low (#0-#7)
 * Type: e10k_vf.uint32 (primitive type)
 */
static const size_t e10k_vf_vfrdbal_length = 8;
static inline uint32_t e10k_vf_vfrdbal_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfrdbal_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1000 + (_i * 64)));
}

static inline uint32_t e10k_vf_vfrdbal_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfrdbal_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1000 + (_i * 64)));
}

static inline void e10k_vf_vfrdbal_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrdbal_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1000 + (_i * 64), _regval);
}

static inline void e10k_vf_vfrdbal_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrdbal_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1000 + (_i * 64), _regval);
}

static inline int e10k_vf_vfrdbal_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vfrdbal_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1000 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vfrdbal", _i, "VF Receive Descriptor Base Address Low (#0-#7)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vfrdbal_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfrdbal_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vfrdbal_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array vfrdbah: VF Receive Descriptor Base Address High (#0-#7)
 * Type: e10k_vf.uint32 (primitive type)
 */
static const size_t e10k_vf_vfrdbah_length = 8;
static inline uint32_t e10k_vf_vfrdbah_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfrdbah_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1004 + (_i * 64)));
}

static inline uint32_t e10k_vf_vfrdbah_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfrdbah_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1004 + (_i * 64)));
}

static inline void e10k_vf_vfrdbah_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrdbah_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1004 + (_i * 64), _regval);
}

static inline void e10k_vf_vfrdbah_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrdbah_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1004 + (_i * 64), _regval);
}

static inline int e10k_vf_vfrdbah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vfrdbah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1004 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vfrdbah", _i, "VF Receive Descriptor Base Address High (#0-#7)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vfrdbah_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfrdbah_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vfrdbah_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array vfrdlen: VF Receive Descriptor Length (#0-#7)
 * Type: e10k_vf.uint32 (primitive type)
 */
static const size_t e10k_vf_vfrdlen_length = 8;
static inline uint32_t e10k_vf_vfrdlen_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfrdlen_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1008 + (_i * 64)));
}

static inline uint32_t e10k_vf_vfrdlen_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfrdlen_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1008 + (_i * 64)));
}

static inline void e10k_vf_vfrdlen_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrdlen_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1008 + (_i * 64), _regval);
}

static inline void e10k_vf_vfrdlen_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrdlen_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1008 + (_i * 64), _regval);
}

static inline int e10k_vf_vfrdlen_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vfrdlen_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1008 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vfrdlen", _i, "VF Receive Descriptor Length (#0-#7)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vfrdlen_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfrdlen_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vfrdlen_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array vfrdh: VF Receive Descriptor Head (#0-#7)
 * Type: e10k_vf.uint32 (primitive type)
 */
static const size_t e10k_vf_vfrdh_length = 8;
static inline uint32_t e10k_vf_vfrdh_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfrdh_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1010 + (_i * 64)));
}

static inline uint32_t e10k_vf_vfrdh_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfrdh_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1010 + (_i * 64)));
}

static inline void e10k_vf_vfrdh_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrdh_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1010 + (_i * 64), _regval);
}

static inline void e10k_vf_vfrdh_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrdh_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1010 + (_i * 64), _regval);
}

static inline int e10k_vf_vfrdh_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vfrdh_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1010 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vfrdh", _i, "VF Receive Descriptor Head (#0-#7)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vfrdh_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfrdh_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vfrdh_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array vfrdt: VF Receive Descriptor Tail (#0-#7)
 * Type: e10k_vf.uint32 (primitive type)
 */
static const size_t e10k_vf_vfrdt_length = 8;
static inline uint32_t e10k_vf_vfrdt_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfrdt_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1018 + (_i * 64)));
}

static inline uint32_t e10k_vf_vfrdt_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfrdt_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1018 + (_i * 64)));
}

static inline void e10k_vf_vfrdt_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrdt_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1018 + (_i * 64), _regval);
}

static inline void e10k_vf_vfrdt_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrdt_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1018 + (_i * 64), _regval);
}

static inline int e10k_vf_vfrdt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vfrdt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1018 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vfrdt", _i, "VF Receive Descriptor Tail (#0-#7)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vfrdt_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfrdt_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vfrdt_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array vfrxdctl: VF Receive Descriptor Control (#0-#7)
 * Type: e10k_vf.rxdctl (Receive Descriptor Control)
 *   _anon0	(size 25, offset 0, init 0):	RSVD	_
 *   enable	(size 1, offset 25, init 0):	RW	Receive Queue Enable
 *   _anon26	(size 4, offset 26, init 0):	RSVD	_
 *   vme	(size 1, offset 30, init 0):	RW	VLAN Mode Enable
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static const size_t e10k_vf_vfrxdctl_length = 8;
static inline e10k_vf_rxdctl_t e10k_vf_vfrxdctl_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_rxdctl_t e10k_vf_vfrxdctl_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1028 + (_i * 64)));
}

static inline e10k_vf_rxdctl_t e10k_vf_vfrxdctl_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_rxdctl_t e10k_vf_vfrxdctl_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1028 + (_i * 64)));
}

static inline void e10k_vf_vfrxdctl_rawwr(__DN(t) *_dev, int _i, e10k_vf_rxdctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrxdctl_rawwr(__DN(t) *_dev, int _i, e10k_vf_rxdctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1028 + (_i * 64), _regval);
}

static inline void e10k_vf_vfrxdctl_wr(__DN(t) *_dev, int _i, e10k_vf_rxdctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrxdctl_wr(__DN(t) *_dev, int _i, e10k_vf_rxdctl_t _regval)
{
    _regval = (_regval & 0x42000000);
    // No MB1 fields present
    _regval = (_regval | (0xbdffffff & mackerel_read_addr_32(_dev->base, 0x1028 + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0x1028 + (_i * 64), _regval);
}

static inline int e10k_vf_vfrxdctl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vfrxdctl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_rxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1028 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vfrxdctl", _i, "VF Receive Descriptor Control (#0-#7)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(Receive Queue Enable)\n", e10k_vf_rxdctl_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vme =\t%" PRIx8 "\t(VLAN Mode Enable)\n", e10k_vf_rxdctl_vme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline int e10k_vf_vfrxdctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfrxdctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vfrxdctl_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_vf_vfrxdctl_enable_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxdctl_enable_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_rxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1028 + (_i * 64));
    return(e10k_vf_rxdctl_enable_extract(_regval));
}

static inline uint8_t e10k_vf_vfrxdctl_vme_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrxdctl_vme_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_rxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1028 + (_i * 64));
    return(e10k_vf_rxdctl_vme_extract(_regval));
}

static inline void e10k_vf_vfrxdctl_enable_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrxdctl_enable_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_rxdctl_t _regval = 0x2000000 & (((e10k_vf_rxdctl_t )(_fieldval)) << 25);
    _regval = (_regval | (0xfdffffff & mackerel_read_addr_32(_dev->base, 0x1028 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1028 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfrxdctl_vme_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrxdctl_vme_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_rxdctl_t _regval = 0x40000000 & (((e10k_vf_rxdctl_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x1028 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1028 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array vfsrrctl: VF Split Receive Control Registers (#0-#7)
 * Type: e10k_vf.srrctl (Split Receive Control Registers)
 *   bsz_pkt	(size 5, offset 0, init 0):	RW	Receive Buffer Size for Packet Buffer
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   bsz_hdr	(size 6, offset 8, init 0):	RW	Receive Buffer Size for Header Buffer
 *   _anon14	(size 8, offset 14, init 0):	RSVD	_
 *   rdmts	(size 3, offset 22, init 0):	RW	Receive Descriptor Minimum Threshold Size
 *   desctype	(size 3, offset 25, init 0):	RW	Define the descriptor type
 *   drop_en	(size 1, offset 28, init 0):	RW	Drop Enabled
 *   _anon29	(size 3, offset 29, init 0):	RSVD	_
 */
static const size_t e10k_vf_vfsrrctl_length = 8;
static inline e10k_vf_srrctl_t e10k_vf_vfsrrctl_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_srrctl_t e10k_vf_vfsrrctl_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64)));
}

static inline e10k_vf_srrctl_t e10k_vf_vfsrrctl_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_srrctl_t e10k_vf_vfsrrctl_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64)));
}

static inline void e10k_vf_vfsrrctl_rawwr(__DN(t) *_dev, int _i, e10k_vf_srrctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfsrrctl_rawwr(__DN(t) *_dev, int _i, e10k_vf_srrctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1014 + (_i * 64), _regval);
}

static inline void e10k_vf_vfsrrctl_wr(__DN(t) *_dev, int _i, e10k_vf_srrctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfsrrctl_wr(__DN(t) *_dev, int _i, e10k_vf_srrctl_t _regval)
{
    _regval = (_regval & 0x1fc03f1f);
    // No MB1 fields present
    _regval = (_regval | (0xe03fc000 & mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0x1014 + (_i * 64), _regval);
}

static inline int e10k_vf_vfsrrctl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vfsrrctl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vfsrrctl", _i, "VF Split Receive Control Registers (#0-#7)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsz_pkt =\t%" PRIx8 "\t(Receive Buffer Size for Packet Buffer)\n", e10k_vf_srrctl_bsz_pkt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsz_hdr =\t%" PRIx8 "\t(Receive Buffer Size for Header Buffer)\n", e10k_vf_srrctl_bsz_hdr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rdmts =\t%" PRIx8 "\t(Receive Descriptor Minimum Threshold Size)\n", e10k_vf_srrctl_rdmts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " desctype =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_rx_desctype_prtval(_s + _r, _avail, e10k_vf_srrctl_desctype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Define the descriptor type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drop_en =\t%" PRIx8 "\t(Drop Enabled)\n", e10k_vf_srrctl_drop_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon29 is anonymous
    return(_r);
}

static inline int e10k_vf_vfsrrctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfsrrctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vfsrrctl_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_vf_vfsrrctl_bsz_pkt_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfsrrctl_bsz_pkt_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64));
    return(e10k_vf_srrctl_bsz_pkt_extract(_regval));
}

static inline uint8_t e10k_vf_vfsrrctl_bsz_hdr_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfsrrctl_bsz_hdr_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64));
    return(e10k_vf_srrctl_bsz_hdr_extract(_regval));
}

static inline uint8_t e10k_vf_vfsrrctl_rdmts_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfsrrctl_rdmts_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64));
    return(e10k_vf_srrctl_rdmts_extract(_regval));
}

static inline e10k_vf_rx_desctype_t e10k_vf_vfsrrctl_desctype_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_rx_desctype_t e10k_vf_vfsrrctl_desctype_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64));
    return(e10k_vf_srrctl_desctype_extract(_regval));
}

static inline uint8_t e10k_vf_vfsrrctl_drop_en_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfsrrctl_drop_en_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64));
    return(e10k_vf_srrctl_drop_en_extract(_regval));
}

static inline void e10k_vf_vfsrrctl_bsz_pkt_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfsrrctl_bsz_pkt_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_srrctl_t _regval = 0x1f & (((e10k_vf_srrctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1014 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfsrrctl_bsz_hdr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfsrrctl_bsz_hdr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_srrctl_t _regval = 0x3f00 & (((e10k_vf_srrctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffffc01f & mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1014 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfsrrctl_rdmts_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfsrrctl_rdmts_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_srrctl_t _regval = 0x1c00000 & (((e10k_vf_srrctl_t )(_fieldval)) << 22);
    _regval = (_regval | (0xfe3fff1f & mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1014 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfsrrctl_desctype_wrf(__DN(t) *_dev, int _i, e10k_vf_rx_desctype_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfsrrctl_desctype_wrf(__DN(t) *_dev, int _i, e10k_vf_rx_desctype_t _fieldval)
{
    e10k_vf_srrctl_t _regval = 0xe000000 & (((e10k_vf_srrctl_t )(_fieldval)) << 25);
    _regval = (_regval | (0xf1ffff1f & mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1014 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfsrrctl_drop_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfsrrctl_drop_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_srrctl_t _regval = 0x10000000 & (((e10k_vf_srrctl_t )(_fieldval)) << 28);
    _regval = (_regval | (0xefffff1f & mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1014 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register vfpsrtype: VF Replication Packet Split Receive Type
 * Type: e10k_vf.vfpsrtype (Implicit type of VF Replication Packet Split Receive Type register)
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   split_nfs	(size 1, offset 1, init 0):	RW	Split received NFS packets after NFS header
 *   _anon2	(size 2, offset 2, init 0):	MBZ	_
 *   split_tcp	(size 1, offset 4, init 0):	RW	Split received TCP packets after TCP header
 *   split_udp	(size 1, offset 5, init 0):	RW	Split received UDP packets after UDP header
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   split_ip4	(size 1, offset 8, init 0):	RW	Split received IPv4 packets after IPv4 header
 *   split_ip6	(size 1, offset 9, init 0):	RW	Split received IPv6 packets after IPv6 header
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   split_l2	(size 1, offset 12, init 0):	RW	Split received L2 packets after L2 header
 *   _anon13	(size 16, offset 13, init 0):	MBZ	_
 *   rqpl	(size 3, offset 29, init 0):	RW	Number of bits to use for RSS redirection
 */
static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x300));
}

static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vf_vfpsrtype_t e10k_vf_vfpsrtype_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x300));
}

static inline void e10k_vf_vfpsrtype_rawwr(__DN(t) *_dev, e10k_vf_vfpsrtype_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfpsrtype_rawwr(__DN(t) *_dev, e10k_vf_vfpsrtype_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
}

static inline void e10k_vf_vfpsrtype_wr(__DN(t) *_dev, e10k_vf_vfpsrtype_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfpsrtype_wr(__DN(t) *_dev, e10k_vf_vfpsrtype_t _regval)
{
    _regval = (_regval & 0xe0001332);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
}

static inline int e10k_vf_vfpsrtype_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfpsrtype_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vfpsrtype_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfpsrtype (VF Replication Packet Split Receive Type): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_nfs =\t%" PRIx8 "\t(Split received NFS packets after NFS header)\n", e10k_vf_vfpsrtype_split_nfs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_tcp =\t%" PRIx8 "\t(Split received TCP packets after TCP header)\n", e10k_vf_vfpsrtype_split_tcp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_udp =\t%" PRIx8 "\t(Split received UDP packets after UDP header)\n", e10k_vf_vfpsrtype_split_udp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_ip4 =\t%" PRIx8 "\t(Split received IPv4 packets after IPv4 header)\n", e10k_vf_vfpsrtype_split_ip4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_ip6 =\t%" PRIx8 "\t(Split received IPv6 packets after IPv6 header)\n", e10k_vf_vfpsrtype_split_ip6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_l2 =\t%" PRIx8 "\t(Split received L2 packets after L2 header)\n", e10k_vf_vfpsrtype_split_l2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqpl =\t%" PRIx8 "\t(Number of bits to use for RSS redirection)\n", e10k_vf_vfpsrtype_rqpl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_vf_vfpsrtype_split_nfs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfpsrtype_split_nfs_rdf(__DN(t) *_dev)
{
    e10k_vf_vfpsrtype_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    return(e10k_vf_vfpsrtype_split_nfs_extract(_regval));
}

static inline uint8_t e10k_vf_vfpsrtype_split_tcp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfpsrtype_split_tcp_rdf(__DN(t) *_dev)
{
    e10k_vf_vfpsrtype_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    return(e10k_vf_vfpsrtype_split_tcp_extract(_regval));
}

static inline uint8_t e10k_vf_vfpsrtype_split_udp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfpsrtype_split_udp_rdf(__DN(t) *_dev)
{
    e10k_vf_vfpsrtype_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    return(e10k_vf_vfpsrtype_split_udp_extract(_regval));
}

static inline uint8_t e10k_vf_vfpsrtype_split_ip4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfpsrtype_split_ip4_rdf(__DN(t) *_dev)
{
    e10k_vf_vfpsrtype_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    return(e10k_vf_vfpsrtype_split_ip4_extract(_regval));
}

static inline uint8_t e10k_vf_vfpsrtype_split_ip6_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfpsrtype_split_ip6_rdf(__DN(t) *_dev)
{
    e10k_vf_vfpsrtype_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    return(e10k_vf_vfpsrtype_split_ip6_extract(_regval));
}

static inline uint8_t e10k_vf_vfpsrtype_split_l2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfpsrtype_split_l2_rdf(__DN(t) *_dev)
{
    e10k_vf_vfpsrtype_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    return(e10k_vf_vfpsrtype_split_l2_extract(_regval));
}

static inline uint8_t e10k_vf_vfpsrtype_rqpl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfpsrtype_rqpl_rdf(__DN(t) *_dev)
{
    e10k_vf_vfpsrtype_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    return(e10k_vf_vfpsrtype_rqpl_extract(_regval));
}

static inline void e10k_vf_vfpsrtype_split_nfs_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfpsrtype_split_nfs_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vf_vfpsrtype_t _regval = 0x2 & (((e10k_vf_vfpsrtype_t )(_fieldval)) << 1);
    _regval = (_regval | (0xe0001330 & mackerel_read_addr_32(_dev->base, 0x300)));
    // No read of register shadow required
    _regval = (_regval & 0xe0001332);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfpsrtype_split_tcp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfpsrtype_split_tcp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vf_vfpsrtype_t _regval = 0x10 & (((e10k_vf_vfpsrtype_t )(_fieldval)) << 4);
    _regval = (_regval | (0xe0001322 & mackerel_read_addr_32(_dev->base, 0x300)));
    // No read of register shadow required
    _regval = (_regval & 0xe0001332);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfpsrtype_split_udp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfpsrtype_split_udp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vf_vfpsrtype_t _regval = 0x20 & (((e10k_vf_vfpsrtype_t )(_fieldval)) << 5);
    _regval = (_regval | (0xe0001312 & mackerel_read_addr_32(_dev->base, 0x300)));
    // No read of register shadow required
    _regval = (_regval & 0xe0001332);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfpsrtype_split_ip4_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfpsrtype_split_ip4_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vf_vfpsrtype_t _regval = 0x100 & (((e10k_vf_vfpsrtype_t )(_fieldval)) << 8);
    _regval = (_regval | (0xe0001232 & mackerel_read_addr_32(_dev->base, 0x300)));
    // No read of register shadow required
    _regval = (_regval & 0xe0001332);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfpsrtype_split_ip6_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfpsrtype_split_ip6_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vf_vfpsrtype_t _regval = 0x200 & (((e10k_vf_vfpsrtype_t )(_fieldval)) << 9);
    _regval = (_regval | (0xe0001132 & mackerel_read_addr_32(_dev->base, 0x300)));
    // No read of register shadow required
    _regval = (_regval & 0xe0001332);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfpsrtype_split_l2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfpsrtype_split_l2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vf_vfpsrtype_t _regval = 0x1000 & (((e10k_vf_vfpsrtype_t )(_fieldval)) << 12);
    _regval = (_regval | (0xe0000332 & mackerel_read_addr_32(_dev->base, 0x300)));
    // No read of register shadow required
    _regval = (_regval & 0xe0001332);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfpsrtype_rqpl_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfpsrtype_rqpl_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vf_vfpsrtype_t _regval = 0xe0000000 & (((e10k_vf_vfpsrtype_t )(_fieldval)) << 29);
    _regval = (_regval | (0x1332 & mackerel_read_addr_32(_dev->base, 0x300)));
    // No read of register shadow required
    _regval = (_regval & 0xe0001332);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
    // No shadow register to write to
}

/*
 * Register array vfrscctl: RSC Control (#0-#7)
 * Type: e10k_vf.rscctl (RSC Control)
 *   rsc_en	(size 1, offset 0, init 0):	RW	RSC Enable
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   maxdesc	(size 2, offset 2, init 0):	RW	Maximum descriptors per Large receive
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
static const size_t e10k_vf_vfrscctl_length = 8;
static inline e10k_vf_rscctl_t e10k_vf_vfrscctl_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_rscctl_t e10k_vf_vfrscctl_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x102c + (_i * 64)));
}

static inline e10k_vf_rscctl_t e10k_vf_vfrscctl_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_rscctl_t e10k_vf_vfrscctl_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x102c + (_i * 64)));
}

static inline void e10k_vf_vfrscctl_rawwr(__DN(t) *_dev, int _i, e10k_vf_rscctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrscctl_rawwr(__DN(t) *_dev, int _i, e10k_vf_rscctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x102c + (_i * 64), _regval);
}

static inline void e10k_vf_vfrscctl_wr(__DN(t) *_dev, int _i, e10k_vf_rscctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrscctl_wr(__DN(t) *_dev, int _i, e10k_vf_rscctl_t _regval)
{
    _regval = (_regval & 0xd);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff2 & mackerel_read_addr_32(_dev->base, 0x102c + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0x102c + (_i * 64), _regval);
}

static inline int e10k_vf_vfrscctl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vfrscctl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_rscctl_t _regval = mackerel_read_addr_32(_dev->base, 0x102c + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vfrscctl", _i, "RSC Control (#0-#7)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rsc_en =\t%" PRIx8 "\t(RSC Enable)\n", e10k_vf_rscctl_rsc_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " maxdesc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_rsc_maxdesc_prtval(_s + _r, _avail, e10k_vf_rscctl_maxdesc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Maximum descriptors per Large receive)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    return(_r);
}

static inline int e10k_vf_vfrscctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfrscctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vfrscctl_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_vf_vfrscctl_rsc_en_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfrscctl_rsc_en_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_rscctl_t _regval = mackerel_read_addr_32(_dev->base, 0x102c + (_i * 64));
    return(e10k_vf_rscctl_rsc_en_extract(_regval));
}

static inline e10k_vf_rsc_maxdesc_t e10k_vf_vfrscctl_maxdesc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_rsc_maxdesc_t e10k_vf_vfrscctl_maxdesc_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_rscctl_t _regval = mackerel_read_addr_32(_dev->base, 0x102c + (_i * 64));
    return(e10k_vf_rscctl_maxdesc_extract(_regval));
}

static inline void e10k_vf_vfrscctl_rsc_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrscctl_rsc_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_rscctl_t _regval = 0x1 & (((e10k_vf_rscctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x102c + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x102c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfrscctl_maxdesc_wrf(__DN(t) *_dev, int _i, e10k_vf_rsc_maxdesc_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfrscctl_maxdesc_wrf(__DN(t) *_dev, int _i, e10k_vf_rsc_maxdesc_t _fieldval)
{
    e10k_vf_rscctl_t _regval = 0xc & (((e10k_vf_rscctl_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffff3 & mackerel_read_addr_32(_dev->base, 0x102c + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x102c + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array vftdbal: VF Transmit Descriptor Base Address Low
 * Type: e10k_vf.uint32 (primitive type)
 */
static const size_t e10k_vf_vftdbal_length = 4;
static inline uint32_t e10k_vf_vftdbal_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vftdbal_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2000 + (_i * 64)));
}

static inline uint32_t e10k_vf_vftdbal_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vftdbal_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2000 + (_i * 64)));
}

static inline void e10k_vf_vftdbal_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdbal_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2000 + (_i * 64), _regval);
}

static inline void e10k_vf_vftdbal_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdbal_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2000 + (_i * 64), _regval);
}

static inline int e10k_vf_vftdbal_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vftdbal_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2000 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vftdbal", _i, "VF Transmit Descriptor Base Address Low");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vftdbal_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vftdbal_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vftdbal_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array vftdbah: VF Transmit Descriptor Base Address High
 * Type: e10k_vf.uint32 (primitive type)
 */
static const size_t e10k_vf_vftdbah_length = 4;
static inline uint32_t e10k_vf_vftdbah_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vftdbah_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2004 + (_i * 64)));
}

static inline uint32_t e10k_vf_vftdbah_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vftdbah_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2004 + (_i * 64)));
}

static inline void e10k_vf_vftdbah_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdbah_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2004 + (_i * 64), _regval);
}

static inline void e10k_vf_vftdbah_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdbah_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2004 + (_i * 64), _regval);
}

static inline int e10k_vf_vftdbah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vftdbah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2004 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vftdbah", _i, "VF Transmit Descriptor Base Address High");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vftdbah_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vftdbah_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vftdbah_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array vftdlen: VF Transmit Descriptor Length
 * Type: e10k_vf.uint32 (primitive type)
 */
static const size_t e10k_vf_vftdlen_length = 4;
static inline uint32_t e10k_vf_vftdlen_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vftdlen_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2008 + (_i * 64)));
}

static inline uint32_t e10k_vf_vftdlen_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vftdlen_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2008 + (_i * 64)));
}

static inline void e10k_vf_vftdlen_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdlen_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2008 + (_i * 64), _regval);
}

static inline void e10k_vf_vftdlen_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdlen_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2008 + (_i * 64), _regval);
}

static inline int e10k_vf_vftdlen_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vftdlen_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2008 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vftdlen", _i, "VF Transmit Descriptor Length");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vftdlen_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vftdlen_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vftdlen_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array vftdh: VF Transmit Descriptor Head
 * Type: e10k_vf.uint32 (primitive type)
 */
static const size_t e10k_vf_vftdh_length = 4;
static inline uint32_t e10k_vf_vftdh_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vftdh_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2010 + (_i * 64)));
}

static inline uint32_t e10k_vf_vftdh_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vftdh_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2010 + (_i * 64)));
}

static inline void e10k_vf_vftdh_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdh_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2010 + (_i * 64), _regval);
}

static inline void e10k_vf_vftdh_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdh_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2010 + (_i * 64), _regval);
}

static inline int e10k_vf_vftdh_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vftdh_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2010 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vftdh", _i, "VF Transmit Descriptor Head");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vftdh_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vftdh_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vftdh_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array vftdt: VF Transmit Descriptor Tail
 * Type: e10k_vf.uint32 (primitive type)
 */
static const size_t e10k_vf_vftdt_length = 4;
static inline uint32_t e10k_vf_vftdt_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vftdt_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2018 + (_i * 64)));
}

static inline uint32_t e10k_vf_vftdt_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vftdt_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2018 + (_i * 64)));
}

static inline void e10k_vf_vftdt_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdt_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2018 + (_i * 64), _regval);
}

static inline void e10k_vf_vftdt_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdt_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2018 + (_i * 64), _regval);
}

static inline int e10k_vf_vftdt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vftdt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2018 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vftdt", _i, "VF Transmit Descriptor Tail");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vftdt_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vftdt_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vftdt_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array vftxdctl: VF Transmit Descriptor Control
 * Type: e10k_vf.vftxdctl (Implicit type of VF Transmit Descriptor Control register array)
 *   pthresh	(size 7, offset 0, init 0):	RW	Pre-Fetch Threshold
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 *   hthresh	(size 7, offset 8, init 0):	RW	Host Threshold
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 *   wthresh	(size 7, offset 16, init 0):	RW	Write-Back Threshold
 *   _anon23	(size 2, offset 23, init 0):	RSVD	_
 *   enable	(size 1, offset 25, init 0):	RW	Transmit Queue Enable
 *   swflsh	(size 1, offset 26, init 0):	RW	Transmit Software Flush
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
static const size_t e10k_vf_vftxdctl_length = 4;
static inline e10k_vf_vftxdctl_t e10k_vf_vftxdctl_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_vftxdctl_t e10k_vf_vftxdctl_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2028 + (_i * 64)));
}

static inline e10k_vf_vftxdctl_t e10k_vf_vftxdctl_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_vftxdctl_t e10k_vf_vftxdctl_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2028 + (_i * 64)));
}

static inline void e10k_vf_vftxdctl_rawwr(__DN(t) *_dev, int _i, e10k_vf_vftxdctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vftxdctl_rawwr(__DN(t) *_dev, int _i, e10k_vf_vftxdctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2028 + (_i * 64), _regval);
}

static inline void e10k_vf_vftxdctl_wr(__DN(t) *_dev, int _i, e10k_vf_vftxdctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vftxdctl_wr(__DN(t) *_dev, int _i, e10k_vf_vftxdctl_t _regval)
{
    _regval = (_regval & 0x67f7f7f);
    // No MB1 fields present
    _regval = (_regval | (0xf9808080 & mackerel_read_addr_32(_dev->base, 0x2028 + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0x2028 + (_i * 64), _regval);
}

static inline int e10k_vf_vftxdctl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vftxdctl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vftxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2028 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vftxdctl", _i, "VF Transmit Descriptor Control");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pthresh =\t%" PRIx8 "\t(Pre-Fetch Threshold)\n", e10k_vf_vftxdctl_pthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hthresh =\t%" PRIx8 "\t(Host Threshold)\n", e10k_vf_vftxdctl_hthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wthresh =\t%" PRIx8 "\t(Write-Back Threshold)\n", e10k_vf_vftxdctl_wthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon23 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(Transmit Queue Enable)\n", e10k_vf_vftxdctl_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " swflsh =\t%" PRIx8 "\t(Transmit Software Flush)\n", e10k_vf_vftxdctl_swflsh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon27 is anonymous
    return(_r);
}

static inline int e10k_vf_vftxdctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vftxdctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vftxdctl_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_vf_vftxdctl_pthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vftxdctl_pthresh_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vftxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2028 + (_i * 64));
    return(e10k_vf_vftxdctl_pthresh_extract(_regval));
}

static inline uint8_t e10k_vf_vftxdctl_hthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vftxdctl_hthresh_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vftxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2028 + (_i * 64));
    return(e10k_vf_vftxdctl_hthresh_extract(_regval));
}

static inline uint8_t e10k_vf_vftxdctl_wthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vftxdctl_wthresh_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vftxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2028 + (_i * 64));
    return(e10k_vf_vftxdctl_wthresh_extract(_regval));
}

static inline uint8_t e10k_vf_vftxdctl_enable_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vftxdctl_enable_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vftxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2028 + (_i * 64));
    return(e10k_vf_vftxdctl_enable_extract(_regval));
}

static inline uint8_t e10k_vf_vftxdctl_swflsh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vftxdctl_swflsh_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vftxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2028 + (_i * 64));
    return(e10k_vf_vftxdctl_swflsh_extract(_regval));
}

static inline void e10k_vf_vftxdctl_pthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vftxdctl_pthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vftxdctl_t _regval = 0x7f & (((e10k_vf_vftxdctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff80 & mackerel_read_addr_32(_dev->base, 0x2028 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2028 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vftxdctl_hthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vftxdctl_hthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vftxdctl_t _regval = 0x7f00 & (((e10k_vf_vftxdctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff80ff & mackerel_read_addr_32(_dev->base, 0x2028 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2028 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vftxdctl_wthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vftxdctl_wthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vftxdctl_t _regval = 0x7f0000 & (((e10k_vf_vftxdctl_t )(_fieldval)) << 16);
    _regval = (_regval | (0xff80ffff & mackerel_read_addr_32(_dev->base, 0x2028 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2028 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vftxdctl_enable_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vftxdctl_enable_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vftxdctl_t _regval = 0x2000000 & (((e10k_vf_vftxdctl_t )(_fieldval)) << 25);
    _regval = (_regval | (0xfdffffff & mackerel_read_addr_32(_dev->base, 0x2028 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2028 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vftxdctl_swflsh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vftxdctl_swflsh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vftxdctl_t _regval = 0x4000000 & (((e10k_vf_vftxdctl_t )(_fieldval)) << 26);
    _regval = (_regval | (0xfbffffff & mackerel_read_addr_32(_dev->base, 0x2028 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2028 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array vftdwbal: VF Tx Descriptor Completion Write Back Address Low
 * Type: e10k_vf.vftdwbal (Implicit type of VF Tx Descriptor Completion Write Back Address Low register array)
 *   headwb_en	(size 1, offset 0, init 0):	RW	Head Write-Back Enable
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   headwb_low	(size 30, offset 2, init 0):	RW	Lowest 32 bits of the head write-back memory location
 */
static const size_t e10k_vf_vftdwbal_length = 4;
static inline e10k_vf_vftdwbal_t e10k_vf_vftdwbal_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_vftdwbal_t e10k_vf_vftdwbal_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2038 + (_i * 64)));
}

static inline e10k_vf_vftdwbal_t e10k_vf_vftdwbal_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_vftdwbal_t e10k_vf_vftdwbal_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2038 + (_i * 64)));
}

static inline void e10k_vf_vftdwbal_rawwr(__DN(t) *_dev, int _i, e10k_vf_vftdwbal_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdwbal_rawwr(__DN(t) *_dev, int _i, e10k_vf_vftdwbal_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2038 + (_i * 64), _regval);
}

static inline void e10k_vf_vftdwbal_wr(__DN(t) *_dev, int _i, e10k_vf_vftdwbal_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdwbal_wr(__DN(t) *_dev, int _i, e10k_vf_vftdwbal_t _regval)
{
    _regval = (_regval & 0xfffffffd);
    // No MB1 fields present
    _regval = (_regval | (0x2 & mackerel_read_addr_32(_dev->base, 0x2038 + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0x2038 + (_i * 64), _regval);
}

static inline int e10k_vf_vftdwbal_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vftdwbal_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vftdwbal_t _regval = mackerel_read_addr_32(_dev->base, 0x2038 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vftdwbal", _i, "VF Tx Descriptor Completion Write Back Address Low");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " headwb_en =\t%" PRIx8 "\t(Head Write-Back Enable)\n", e10k_vf_vftdwbal_headwb_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " headwb_low =\t%" PRIx32 "\t(Lowest 32 bits of the head write-back memory location)\n", e10k_vf_vftdwbal_headwb_low_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vftdwbal_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vftdwbal_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vftdwbal_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_vf_vftdwbal_headwb_en_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vftdwbal_headwb_en_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vftdwbal_t _regval = mackerel_read_addr_32(_dev->base, 0x2038 + (_i * 64));
    return(e10k_vf_vftdwbal_headwb_en_extract(_regval));
}

static inline uint32_t e10k_vf_vftdwbal_headwb_low_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vftdwbal_headwb_low_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vftdwbal_t _regval = mackerel_read_addr_32(_dev->base, 0x2038 + (_i * 64));
    return(e10k_vf_vftdwbal_headwb_low_extract(_regval));
}

static inline void e10k_vf_vftdwbal_headwb_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdwbal_headwb_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vftdwbal_t _regval = 0x1 & (((e10k_vf_vftdwbal_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x2038 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2038 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vftdwbal_headwb_low_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdwbal_headwb_low_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_vf_vftdwbal_t _regval = 0xfffffffc & (((e10k_vf_vftdwbal_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x2038 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2038 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array vftdwbah: VF Tx Descriptor Completion Write Back Address High
 * Type: e10k_vf.vftdwbah (Implicit type of VF Tx Descriptor Completion Write Back Address High register array)
 *   headwb_high	(size 32, offset 0, init 0):	RW	Highest 32 bits of the head write-back memory location
 */
static const size_t e10k_vf_vftdwbah_length = 4;
static inline e10k_vf_vftdwbah_t e10k_vf_vftdwbah_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_vftdwbah_t e10k_vf_vftdwbah_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x203c + (_i * 64)));
}

static inline e10k_vf_vftdwbah_t e10k_vf_vftdwbah_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_vftdwbah_t e10k_vf_vftdwbah_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x203c + (_i * 64)));
}

static inline void e10k_vf_vftdwbah_rawwr(__DN(t) *_dev, int _i, e10k_vf_vftdwbah_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdwbah_rawwr(__DN(t) *_dev, int _i, e10k_vf_vftdwbah_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x203c + (_i * 64), _regval);
}

static inline void e10k_vf_vftdwbah_wr(__DN(t) *_dev, int _i, e10k_vf_vftdwbah_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdwbah_wr(__DN(t) *_dev, int _i, e10k_vf_vftdwbah_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x203c + (_i * 64), _regval);
}

static inline int e10k_vf_vftdwbah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vftdwbah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vftdwbah_t _regval = mackerel_read_addr_32(_dev->base, 0x203c + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vftdwbah", _i, "VF Tx Descriptor Completion Write Back Address High");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " headwb_high =\t%" PRIx32 "\t(Highest 32 bits of the head write-back memory location)\n", e10k_vf_vftdwbah_headwb_high_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vftdwbah_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vftdwbah_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vftdwbah_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_vf_vftdwbah_headwb_high_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vftdwbah_headwb_high_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vftdwbah_t _regval = mackerel_read_addr_32(_dev->base, 0x203c + (_i * 64));
    return(e10k_vf_vftdwbah_headwb_high_extract(_regval));
}

static inline void e10k_vf_vftdwbah_headwb_high_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vftdwbah_headwb_high_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_vf_vftdwbah_t _regval = 0xffffffff & (((e10k_vf_vftdwbah_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x203c + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array vfdca_rxctrl: VF Rx DCA Control Register (#0-#7)
 * Type: e10k_vf.dca_rxctrl (Rx DCA Control Register)
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   rxdca_desc	(size 1, offset 5, init 0):	RW	Descriptor DCA EN
 *   rxdca_hdr	(size 1, offset 6, init 0):	RW	Rx Header DCA EN
 *   rxdca_payl	(size 1, offset 7, init 0):	RW	Payload DCA EN
 *   _anon8	(size 1, offset 8, init 0):	RSVD	_
 *   rxdesc_rdro	(size 1, offset 9, init 0):	RW	Rx Descriptor Read Relax Order Enable
 *   _anon10	(size 1, offset 10, init 0):	RSVD	_
 *   rxdesc_wbro	(size 1, offset 11, init 0):	MBZ	Rx Descriptor Write Back Relax Order Enable
 *   _anon12	(size 1, offset 12, init 0):	RSVD	_
 *   rxdata_wrro	(size 1, offset 13, init 0):	RW	Rx data Write Relax Order Enable
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   rxhdr_ro	(size 1, offset 15, init 0):	RW	Rx Split Header Relax Order Enable
 *   _anon16	(size 8, offset 16, init 0):	RSVD	_
 *   cpuid	(size 8, offset 24, init 0):	RW	Physical ID
 */
static const size_t e10k_vf_vfdca_rxctrl_length = 8;
static inline e10k_vf_dca_rxctrl_t e10k_vf_vfdca_rxctrl_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_dca_rxctrl_t e10k_vf_vfdca_rxctrl_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64)));
}

static inline e10k_vf_dca_rxctrl_t e10k_vf_vfdca_rxctrl_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_dca_rxctrl_t e10k_vf_vfdca_rxctrl_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64)));
}

static inline void e10k_vf_vfdca_rxctrl_rawwr(__DN(t) *_dev, int _i, e10k_vf_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfdca_rxctrl_rawwr(__DN(t) *_dev, int _i, e10k_vf_dca_rxctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
}

static inline void e10k_vf_vfdca_rxctrl_wr(__DN(t) *_dev, int _i, e10k_vf_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfdca_rxctrl_wr(__DN(t) *_dev, int _i, e10k_vf_dca_rxctrl_t _regval)
{
    _regval = (_regval & 0xff00a2e0);
    // No MB1 fields present
    _regval = (_regval | (0xff551f & mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
}

static inline int e10k_vf_vfdca_rxctrl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vfdca_rxctrl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vfdca_rxctrl", _i, "VF Rx DCA Control Register (#0-#7)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdca_desc =\t%" PRIx8 "\t(Descriptor DCA EN)\n", e10k_vf_dca_rxctrl_rxdca_desc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdca_hdr =\t%" PRIx8 "\t(Rx Header DCA EN)\n", e10k_vf_dca_rxctrl_rxdca_hdr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdca_payl =\t%" PRIx8 "\t(Payload DCA EN)\n", e10k_vf_dca_rxctrl_rxdca_payl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdesc_rdro =\t%" PRIx8 "\t(Rx Descriptor Read Relax Order Enable)\n", e10k_vf_dca_rxctrl_rxdesc_rdro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdesc_wbro =\t%" PRIx8 "\t(Rx Descriptor Write Back Relax Order Enable)\n", e10k_vf_dca_rxctrl_rxdesc_wbro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdata_wrro =\t%" PRIx8 "\t(Rx data Write Relax Order Enable)\n", e10k_vf_dca_rxctrl_rxdata_wrro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxhdr_ro =\t%" PRIx8 "\t(Rx Split Header Relax Order Enable)\n", e10k_vf_dca_rxctrl_rxhdr_ro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpuid =\t%" PRIx8 "\t(Physical ID)\n", e10k_vf_dca_rxctrl_cpuid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vfdca_rxctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfdca_rxctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vfdca_rxctrl_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_vf_vfdca_rxctrl_rxdca_desc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_rxctrl_rxdca_desc_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64));
    return(e10k_vf_dca_rxctrl_rxdca_desc_extract(_regval));
}

static inline uint8_t e10k_vf_vfdca_rxctrl_rxdca_hdr_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_rxctrl_rxdca_hdr_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64));
    return(e10k_vf_dca_rxctrl_rxdca_hdr_extract(_regval));
}

static inline uint8_t e10k_vf_vfdca_rxctrl_rxdca_payl_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_rxctrl_rxdca_payl_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64));
    return(e10k_vf_dca_rxctrl_rxdca_payl_extract(_regval));
}

static inline uint8_t e10k_vf_vfdca_rxctrl_rxdesc_rdro_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_rxctrl_rxdesc_rdro_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64));
    return(e10k_vf_dca_rxctrl_rxdesc_rdro_extract(_regval));
}

static inline uint8_t e10k_vf_vfdca_rxctrl_rxdata_wrro_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_rxctrl_rxdata_wrro_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64));
    return(e10k_vf_dca_rxctrl_rxdata_wrro_extract(_regval));
}

static inline uint8_t e10k_vf_vfdca_rxctrl_rxhdr_ro_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_rxctrl_rxhdr_ro_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64));
    return(e10k_vf_dca_rxctrl_rxhdr_ro_extract(_regval));
}

static inline uint8_t e10k_vf_vfdca_rxctrl_cpuid_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_rxctrl_cpuid_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64));
    return(e10k_vf_dca_rxctrl_cpuid_extract(_regval));
}

static inline void e10k_vf_vfdca_rxctrl_rxdca_desc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfdca_rxctrl_rxdca_desc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_dca_rxctrl_t _regval = 0x20 & (((e10k_vf_dca_rxctrl_t )(_fieldval)) << 5);
    _regval = (_regval | (0xfffff7df & mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfdca_rxctrl_rxdca_hdr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfdca_rxctrl_rxdca_hdr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_dca_rxctrl_t _regval = 0x40 & (((e10k_vf_dca_rxctrl_t )(_fieldval)) << 6);
    _regval = (_regval | (0xfffff7bf & mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfdca_rxctrl_rxdca_payl_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfdca_rxctrl_rxdca_payl_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_dca_rxctrl_t _regval = 0x80 & (((e10k_vf_dca_rxctrl_t )(_fieldval)) << 7);
    _regval = (_regval | (0xfffff77f & mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfdca_rxctrl_rxdesc_rdro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfdca_rxctrl_rxdesc_rdro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_dca_rxctrl_t _regval = 0x200 & (((e10k_vf_dca_rxctrl_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffff5ff & mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfdca_rxctrl_rxdata_wrro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfdca_rxctrl_rxdata_wrro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_dca_rxctrl_t _regval = 0x2000 & (((e10k_vf_dca_rxctrl_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffd7ff & mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfdca_rxctrl_rxhdr_ro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfdca_rxctrl_rxhdr_ro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_dca_rxctrl_t _regval = 0x8000 & (((e10k_vf_dca_rxctrl_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff77ff & mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfdca_rxctrl_cpuid_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfdca_rxctrl_cpuid_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_dca_rxctrl_t _regval = 0xff000000 & (((e10k_vf_dca_rxctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfff7ff & mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array vfdca_txctrl: VF Tx DCA Control Registers
 * Type: e10k_vf.vfdca_txctrl (Implicit type of VF Tx DCA Control Registers register array)
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   txdesc_dca	(size 1, offset 5, init 0):	RW	Descriptor DCA Enable
 *   _anon6	(size 3, offset 6, init 0):	RSVD	_
 *   txdesc_rdro	(size 1, offset 9, init 0):	RW	Tx Descriptor Read Relax Order Enable
 *   _anon10	(size 1, offset 10, init 0):	RSVD	_
 *   txdesc_wbro	(size 1, offset 11, init 0):	RW	Relax Order Enable of Tx Descriptor well as head pointer write back
 *   _anon12	(size 1, offset 12, init 0):	RSVD	_
 *   txdata_rdro	(size 1, offset 13, init 0):	RW	Tx Data Read Relax Order Enable
 *   _anon14	(size 10, offset 14, init 0):	RSVD	_
 *   cpuid	(size 8, offset 24, init 0):	RW	Physical ID
 */
static const size_t e10k_vf_vfdca_txctrl_length = 8;
static inline e10k_vf_vfdca_txctrl_t e10k_vf_vfdca_txctrl_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_vfdca_txctrl_t e10k_vf_vfdca_txctrl_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x200c + (_i * 64)));
}

static inline e10k_vf_vfdca_txctrl_t e10k_vf_vfdca_txctrl_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vf_vfdca_txctrl_t e10k_vf_vfdca_txctrl_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x200c + (_i * 64)));
}

static inline void e10k_vf_vfdca_txctrl_rawwr(__DN(t) *_dev, int _i, e10k_vf_vfdca_txctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfdca_txctrl_rawwr(__DN(t) *_dev, int _i, e10k_vf_vfdca_txctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x200c + (_i * 64), _regval);
}

static inline void e10k_vf_vfdca_txctrl_wr(__DN(t) *_dev, int _i, e10k_vf_vfdca_txctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfdca_txctrl_wr(__DN(t) *_dev, int _i, e10k_vf_vfdca_txctrl_t _regval)
{
    _regval = (_regval & 0xff002a20);
    // No MB1 fields present
    _regval = (_regval | (0xffd5df & mackerel_read_addr_32(_dev->base, 0x200c + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0x200c + (_i * 64), _regval);
}

static inline int e10k_vf_vfdca_txctrl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vf_vfdca_txctrl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vf_vfdca_txctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x200c + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vfdca_txctrl", _i, "VF Tx DCA Control Registers");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdesc_dca =\t%" PRIx8 "\t(Descriptor DCA Enable)\n", e10k_vf_vfdca_txctrl_txdesc_dca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdesc_rdro =\t%" PRIx8 "\t(Tx Descriptor Read Relax Order Enable)\n", e10k_vf_vfdca_txctrl_txdesc_rdro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdesc_wbro =\t%" PRIx8 "\t(Relax Order Enable of Tx Descriptor well as head pointer write back)\n", e10k_vf_vfdca_txctrl_txdesc_wbro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdata_rdro =\t%" PRIx8 "\t(Tx Data Read Relax Order Enable)\n", e10k_vf_vfdca_txctrl_txdata_rdro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpuid =\t%" PRIx8 "\t(Physical ID)\n", e10k_vf_vfdca_txctrl_cpuid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_vfdca_txctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfdca_txctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vf_vfdca_txctrl_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_vf_vfdca_txctrl_txdesc_dca_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_txctrl_txdesc_dca_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vfdca_txctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x200c + (_i * 64));
    return(e10k_vf_vfdca_txctrl_txdesc_dca_extract(_regval));
}

static inline uint8_t e10k_vf_vfdca_txctrl_txdesc_rdro_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_txctrl_txdesc_rdro_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vfdca_txctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x200c + (_i * 64));
    return(e10k_vf_vfdca_txctrl_txdesc_rdro_extract(_regval));
}

static inline uint8_t e10k_vf_vfdca_txctrl_txdesc_wbro_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_txctrl_txdesc_wbro_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vfdca_txctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x200c + (_i * 64));
    return(e10k_vf_vfdca_txctrl_txdesc_wbro_extract(_regval));
}

static inline uint8_t e10k_vf_vfdca_txctrl_txdata_rdro_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_txctrl_txdata_rdro_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vfdca_txctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x200c + (_i * 64));
    return(e10k_vf_vfdca_txctrl_txdata_rdro_extract(_regval));
}

static inline uint8_t e10k_vf_vfdca_txctrl_cpuid_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_vf_vfdca_txctrl_cpuid_rdf(__DN(t) *_dev, int _i)
{
    e10k_vf_vfdca_txctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x200c + (_i * 64));
    return(e10k_vf_vfdca_txctrl_cpuid_extract(_regval));
}

static inline void e10k_vf_vfdca_txctrl_txdesc_dca_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfdca_txctrl_txdesc_dca_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vfdca_txctrl_t _regval = 0x20 & (((e10k_vf_vfdca_txctrl_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x200c + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfdca_txctrl_txdesc_rdro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfdca_txctrl_txdesc_rdro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vfdca_txctrl_t _regval = 0x200 & (((e10k_vf_vfdca_txctrl_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0x200c + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfdca_txctrl_txdesc_wbro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfdca_txctrl_txdesc_wbro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vfdca_txctrl_t _regval = 0x800 & (((e10k_vf_vfdca_txctrl_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfffff7ff & mackerel_read_addr_32(_dev->base, 0x200c + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfdca_txctrl_txdata_rdro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfdca_txctrl_txdata_rdro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vfdca_txctrl_t _regval = 0x2000 & (((e10k_vf_vfdca_txctrl_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffdfff & mackerel_read_addr_32(_dev->base, 0x200c + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_vf_vfdca_txctrl_cpuid_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vf_vfdca_txctrl_cpuid_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_vf_vfdca_txctrl_t _regval = 0xff000000 & (((e10k_vf_vfdca_txctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0xffffff & mackerel_read_addr_32(_dev->base, 0x200c + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200c + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register vfgprc: VF Good packets received count
 * Type: e10k_vf.uint32 (primitive type)
 */
static inline uint32_t e10k_vf_vfgprc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfgprc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x101c));
}

static inline uint32_t e10k_vf_vfgprc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfgprc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x101c));
}

static inline void e10k_vf_vfgprc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfgprc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x101c, _regval);
}

// Register vfgprc is not writeable
static inline int e10k_vf_vfgprc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfgprc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x101c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfgprc (VF Good packets received count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register vfgptc: VF Good packets trasmitted count
 * Type: e10k_vf.uint32 (primitive type)
 */
static inline uint32_t e10k_vf_vfgptc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfgptc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x201c));
}

static inline uint32_t e10k_vf_vfgptc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfgptc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x201c));
}

static inline void e10k_vf_vfgptc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfgptc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x201c, _regval);
}

// Register vfgptc is not writeable
static inline int e10k_vf_vfgptc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfgptc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x201c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfgptc (VF Good packets trasmitted count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register vfgorc_lsb: VF Good Octets Received Count Low
 * Type: e10k_vf.uint32 (primitive type)
 */
static inline uint32_t e10k_vf_vfgorc_lsb_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfgorc_lsb_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1020));
}

static inline uint32_t e10k_vf_vfgorc_lsb_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfgorc_lsb_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1020));
}

static inline void e10k_vf_vfgorc_lsb_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfgorc_lsb_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1020, _regval);
}

// Register vfgorc_lsb is not writeable
static inline int e10k_vf_vfgorc_lsb_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfgorc_lsb_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1020);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfgorc_lsb (VF Good Octets Received Count Low): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register vfgorc_msb: VF Good Octets Received Count High
 * Type: e10k_vf.uint32 (primitive type)
 */
static inline uint32_t e10k_vf_vfgorc_msb_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfgorc_msb_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1024));
}

static inline uint32_t e10k_vf_vfgorc_msb_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfgorc_msb_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1024));
}

static inline void e10k_vf_vfgorc_msb_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfgorc_msb_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1024, _regval);
}

// Register vfgorc_msb is not writeable
static inline int e10k_vf_vfgorc_msb_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfgorc_msb_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1024);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfgorc_msb (VF Good Octets Received Count High): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register vfgotc_lsb: VF Good Octets Transmitted Count Low
 * Type: e10k_vf.uint32 (primitive type)
 */
static inline uint32_t e10k_vf_vfgotc_lsb_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfgotc_lsb_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2020));
}

static inline uint32_t e10k_vf_vfgotc_lsb_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfgotc_lsb_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2020));
}

static inline void e10k_vf_vfgotc_lsb_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfgotc_lsb_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2020, _regval);
}

// Register vfgotc_lsb is not writeable
static inline int e10k_vf_vfgotc_lsb_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfgotc_lsb_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2020);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfgotc_lsb (VF Good Octets Transmitted Count Low): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register vfgotc_msb: VF Good Octets Transmitted Count High
 * Type: e10k_vf.uint32 (primitive type)
 */
static inline uint32_t e10k_vf_vfgotc_msb_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfgotc_msb_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2024));
}

static inline uint32_t e10k_vf_vfgotc_msb_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfgotc_msb_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2024));
}

static inline void e10k_vf_vfgotc_msb_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfgotc_msb_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2024, _regval);
}

// Register vfgotc_msb is not writeable
static inline int e10k_vf_vfgotc_msb_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfgotc_msb_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2024);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfgotc_msb (VF Good Octets Transmitted Count High): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register vfmprc: VF Multicast Packets Received Count
 * Type: e10k_vf.uint32 (primitive type)
 */
static inline uint32_t e10k_vf_vfmprc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfmprc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1034));
}

static inline uint32_t e10k_vf_vfmprc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_vf_vfmprc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1034));
}

static inline void e10k_vf_vfmprc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_vf_vfmprc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1034, _regval);
}

// Register vfmprc is not writeable
static inline int e10k_vf_vfmprc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_vfmprc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1034);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vfmprc (VF Multicast Packets Received Count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vf_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vf_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device e10k_vf (Intel 82599 10 GbE Controller Virtual Function):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfstatus_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vflinks_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfrxmemwrap_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfeicr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfeics_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfeims_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfeimc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfeiam_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfeitr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfivar_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfivar_misc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfrscint_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfpbacl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfrdbal_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfrdbah_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfrdlen_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfrdh_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfrdt_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfrxdctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfsrrctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfpsrtype_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfrscctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vftdbal_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vftdbah_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vftdlen_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vftdh_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vftdt_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vftxdctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vftdwbal_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vftdwbah_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfdca_rxctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfdca_txctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfgprc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfgptc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfgorc_lsb_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfgorc_msb_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfgotc_lsb_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfgotc_msb_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vf_vfmprc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device e10k_vf\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __e10k_vf_DEV_H
