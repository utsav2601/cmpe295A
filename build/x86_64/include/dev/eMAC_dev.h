/*
 * DEVICE DEFINITION: Xilinx IPblock
 * 
 * Copyright (c) 2007, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich.
 *  Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED: DO NOT EDIT!
 */

#ifndef __eMAC_H
#define __eMAC_H

#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR
#define __DN(x) eMAC ## _ ## x
#ifdef eMAC_PREFIX
#define __DP(x) __DP1(x,eMAC_PREFIX)
#define __DP1(x1,x2) __DP2(x1,x2)
#define __DP2(x1,x2) x2 ## x1
#else
#define __DP(x) eMAC##_ ##x
#endif
#define __STR(x) #x
#define __XTR(x) __STR(x)

/*
 * Register type: Flow control Configuration register (0)
 */

/*
 * Dump of fields for register type: eMAC_eMAC_receiver_conf_0_t
 *   PAUSE_FRAME_ADDR_LOW (size 32, offset 0):	 RW	  Pause Frame Ethernet MAC Address [31:0]. This address is used to match the Ethernet MAC against the destination address of any incoming flow control frames. It is also used by the flow control block as the source address for any outbound flow control frames. The address is ordered so the first byte transmitted/received is the lowest positioned byte in the register; for example, a MAC address of AA-BB-CC-DD-EE-FF is stored in address [47:0] as 0xFFEEDDCCBBAA.
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_eMAC_receiver_conf_0_t {
    uint32_t	PAUSE_FRAME_ADDR_LOW	:32;
} __attribute__ ((packed))
 eMAC_eMAC_receiver_conf_0_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_eMAC_receiver_conf_0_t, sizeof(uint32_t));

typedef union eMAC_eMAC_receiver_conf_0_un {
    eMAC_eMAC_receiver_conf_0_t	val;
    uint32_t	raw;
}
 eMAC_eMAC_receiver_conf_0_un;
static inline int eMAC_eMAC_receiver_conf_0_prtval( char * s, size_t sz, eMAC_eMAC_receiver_conf_0_t v ) __attribute__ ((always_inline));
static inline int eMAC_eMAC_receiver_conf_0_prtval( char * s, size_t sz, eMAC_eMAC_receiver_conf_0_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " PAUSE_FRAME_ADDR_LOW=0x%0"PRIx32" (Pause Frame Ethernet MAC Address [31:0]. This address is used to match the Ethernet MAC against the destination address of any incoming flow control frames. It is also used by the flow control block as the source address for any outbound flow control frames. The address is ordered so the first byte transmitted/received is the lowest positioned byte in the register; for example, a MAC address of AA-BB-CC-DD-EE-FF is stored in address [47:0] as 0xFFEEDDCCBBAA.)\n", (uint32_t)(v.PAUSE_FRAME_ADDR_LOW));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Flow control Configuration register (1)
 */

/*
 * Dump of fields for register type: eMAC_eMAC_receiver_conf_1_t
 *   PAUSE_FRAME_ADDR_LOW (size 16, offset 0):	 RW	  Pause frame Ethernet MAC Address [47:32].
 *   _anon16 (size 9, offset 16):	 MBZ	  _
 *   LT_DIS (size 1, offset 25):	 RW	  Length/Type Check disable. When this bit is 1, it disables the Length/Type field check on the frame.
 *   HD (size 1, offset 26):	 RW	  Half-duplex mode. When this bit is 1, the receiver operates in half-duplex mode. When the bit is 0, the receiver operates in full-duplex mode.
 *   VLAN (size 1, offset 27):	 RW	  VLAN enable. When this bit is 1, the receiver accepts VLAN tagged frames. The maximum payload length increases by four bytes.
 *   RX (size 1, offset 28):	 RW	  Receive enable. When this bit is 1, the receiver block is enabled to operate. When the bit is 0, the receiver ignores activity on the physical interface receive port.
 *   FCS (size 1, offset 29):	 RW	  In-band FCS enable. When this bit is 1, the receiver passes the FCS field up to the client. When this bit is 0, the FCS field is not passed to the client. In either case, the FCS is verified on the frame.
 *   JUM (size 1, offset 30):	 RW	  Jumbo frame enable. When this bit is 1, the Ethernet MAC receiver accepts frames over the maximum length specified in IEEE Std 802.3-2002 specification. When this bit is 0, the receiver only accepts frames up to the specified maximum.
 *   RST (size 1, offset 31):	 RW	  Reset. When this bit is 1, the receiver is reset. The bit automatically reverts to 0. This reset also sets all of the receiver configuration registers to their default values.
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_eMAC_receiver_conf_1_t {
    uint16_t	PAUSE_FRAME_ADDR_LOW	:16;
    uint16_t	_anon16	:9;
    uint8_t	LT_DIS	:1;
    uint8_t	HD	:1;
    uint8_t	VLAN	:1;
    uint8_t	RX	:1;
    uint8_t	FCS	:1;
    uint8_t	JUM	:1;
    uint8_t	RST	:1;
} __attribute__ ((packed))
 eMAC_eMAC_receiver_conf_1_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_eMAC_receiver_conf_1_t, sizeof(uint32_t));

typedef union eMAC_eMAC_receiver_conf_1_un {
    eMAC_eMAC_receiver_conf_1_t	val;
    uint32_t	raw;
}
 eMAC_eMAC_receiver_conf_1_un;
static inline int eMAC_eMAC_receiver_conf_1_prtval( char * s, size_t sz, eMAC_eMAC_receiver_conf_1_t v ) __attribute__ ((always_inline));
static inline int eMAC_eMAC_receiver_conf_1_prtval( char * s, size_t sz, eMAC_eMAC_receiver_conf_1_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " PAUSE_FRAME_ADDR_LOW=0x%0"PRIx16" (Pause frame Ethernet MAC Address [47:32].)\n", (uint16_t)(v.PAUSE_FRAME_ADDR_LOW));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " LT_DIS=0x%"PRIx8" (Length/Type Check disable. When this bit is 1, it disables the Length/Type field check on the frame.)\n", (uint8_t)(v.LT_DIS));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " HD=0x%"PRIx8" (Half-duplex mode. When this bit is 1, the receiver operates in half-duplex mode. When the bit is 0, the receiver operates in full-duplex mode.)\n", (uint8_t)(v.HD));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " VLAN=0x%"PRIx8" (VLAN enable. When this bit is 1, the receiver accepts VLAN tagged frames. The maximum payload length increases by four bytes.)\n", (uint8_t)(v.VLAN));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " RX=0x%"PRIx8" (Receive enable. When this bit is 1, the receiver block is enabled to operate. When the bit is 0, the receiver ignores activity on the physical interface receive port.)\n", (uint8_t)(v.RX));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " FCS=0x%"PRIx8" (In-band FCS enable. When this bit is 1, the receiver passes the FCS field up to the client. When this bit is 0, the FCS field is not passed to the client. In either case, the FCS is verified on the frame.)\n", (uint8_t)(v.FCS));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " JUM=0x%"PRIx8" (Jumbo frame enable. When this bit is 1, the Ethernet MAC receiver accepts frames over the maximum length specified in IEEE Std 802.3-2002 specification. When this bit is 0, the receiver only accepts frames up to the specified maximum.)\n", (uint8_t)(v.JUM));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " RST=0x%"PRIx8" (Reset. When this bit is 1, the receiver is reset. The bit automatically reverts to 0. This reset also sets all of the receiver configuration registers to their default values.)\n", (uint8_t)(v.RST));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: eMAC Transmiter Configuration register
 */

/*
 * Dump of fields for register type: eMAC_eMAC_transmiter_conf_t
 *   _anon0 (size 25, offset 0):	 MBZ	  _
 *   IFG (size 1, offset 25):	 RW	  IFG adjustment enable. When this bit is 1, the transmitter reads the value of CLIENTEMAC#TXIFGDELAY at the start of frame transmission and adjusts the IFG.
 *   HD (size 1, offset 26):	 RW	  Half-duplex mode (applicable in 10/100 Mb/s mode only). When this bit is 1, the transmitter operates in half-duplex mode. When this bit is 0, the transmitter operates in full-duplex mode.
 *   VLAN (size 1, offset 27):	 RW	  VLAN enable. When this bit is 1, the transmitter allows transmission of the VLAN tagged frames.
 *   TX (size 1, offset 28):	 RW	  Transmit enable. When this bit is 1, the transmitter is enabled for operation.
 *   FCS (size 1, offset 29):	 RW	  In-band FCS enable. When this bit is 1, the Ethernet MAC transmitter is ready for the FCS field from the client.
 *   JUM (size 1, offset 30):	 RW	  Jumbo frame enable. When this bit is 1, the transmitter sends frames greater than the maximum length specified in IEEE Std 802.3-2002. When this bit is 0, it only sends frames less than the specified maximum length.
 *   RST (size 1, offset 31):	 RW	  Reset. When this bit is 1, the transmitter is reset. The bit automatically reverts to 0. This reset also sets all of the transmitter configuration registers to their default values.
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_eMAC_transmiter_conf_t {
    uint32_t	_anon0	:25;
    uint8_t	IFG	:1;
    uint8_t	HD	:1;
    uint8_t	VLAN	:1;
    uint8_t	TX	:1;
    uint8_t	FCS	:1;
    uint8_t	JUM	:1;
    uint8_t	RST	:1;
} __attribute__ ((packed))
 eMAC_eMAC_transmiter_conf_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_eMAC_transmiter_conf_t, sizeof(uint32_t));

typedef union eMAC_eMAC_transmiter_conf_un {
    eMAC_eMAC_transmiter_conf_t	val;
    uint32_t	raw;
}
 eMAC_eMAC_transmiter_conf_un;
static inline int eMAC_eMAC_transmiter_conf_prtval( char * s, size_t sz, eMAC_eMAC_transmiter_conf_t v ) __attribute__ ((always_inline));
static inline int eMAC_eMAC_transmiter_conf_prtval( char * s, size_t sz, eMAC_eMAC_transmiter_conf_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " IFG=0x%"PRIx8" (IFG adjustment enable. When this bit is 1, the transmitter reads the value of CLIENTEMAC#TXIFGDELAY at the start of frame transmission and adjusts the IFG.)\n", (uint8_t)(v.IFG));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " HD=0x%"PRIx8" (Half-duplex mode (applicable in 10/100 Mb/s mode only). When this bit is 1, the transmitter operates in half-duplex mode. When this bit is 0, the transmitter operates in full-duplex mode.)\n", (uint8_t)(v.HD));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " VLAN=0x%"PRIx8" (VLAN enable. When this bit is 1, the transmitter allows transmission of the VLAN tagged frames.)\n", (uint8_t)(v.VLAN));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " TX=0x%"PRIx8" (Transmit enable. When this bit is 1, the transmitter is enabled for operation.)\n", (uint8_t)(v.TX));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " FCS=0x%"PRIx8" (In-band FCS enable. When this bit is 1, the Ethernet MAC transmitter is ready for the FCS field from the client.)\n", (uint8_t)(v.FCS));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " JUM=0x%"PRIx8" (Jumbo frame enable. When this bit is 1, the transmitter sends frames greater than the maximum length specified in IEEE Std 802.3-2002. When this bit is 0, it only sends frames less than the specified maximum length.)\n", (uint8_t)(v.JUM));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " RST=0x%"PRIx8" (Reset. When this bit is 1, the transmitter is reset. The bit automatically reverts to 0. This reset also sets all of the transmitter configuration registers to their default values.)\n", (uint8_t)(v.RST));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Flow control Configuration register
 */

/*
 * Dump of fields for register type: eMAC_eMAC_flow_control_conf_t
 *   _anon0 (size 29, offset 0):	 MBZ	  _
 *   RX_FC_enable (size 1, offset 29):	 RW	  Flow control enable (RX). When this bit is 1, the received flow control frames inhibit transmitter operation. When this bit is 0, the flow control frame is passed to the client.
 *   TX_FC_enable (size 1, offset 30):	 RW	  Flow control enable (TX). When this bit is 1, the CLIENTEMAC#PAUSEREQ signal is asserted and a flow control frame is sent from the transmitter. When this bit is 0, the CLIENTEMAC#PAUSEREQ signal has no effect.
 *   _anon31 (size 1, offset 31):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_eMAC_flow_control_conf_t {
    uint32_t	_anon0	:29;
    uint8_t	RX_FC_enable	:1;
    uint8_t	TX_FC_enable	:1;
    uint8_t	_anon31	:1;
} __attribute__ ((packed))
 eMAC_eMAC_flow_control_conf_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_eMAC_flow_control_conf_t, sizeof(uint32_t));

typedef union eMAC_eMAC_flow_control_conf_un {
    eMAC_eMAC_flow_control_conf_t	val;
    uint32_t	raw;
}
 eMAC_eMAC_flow_control_conf_un;
static inline int eMAC_eMAC_flow_control_conf_prtval( char * s, size_t sz, eMAC_eMAC_flow_control_conf_t v ) __attribute__ ((always_inline));
static inline int eMAC_eMAC_flow_control_conf_prtval( char * s, size_t sz, eMAC_eMAC_flow_control_conf_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " RX_FC_enable=0x%"PRIx8" (Flow control enable (RX). When this bit is 1, the received flow control frames inhibit transmitter operation. When this bit is 0, the flow control frame is passed to the client.)\n", (uint8_t)(v.RX_FC_enable));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " TX_FC_enable=0x%"PRIx8" (Flow control enable (TX). When this bit is 1, the CLIENTEMAC#PAUSEREQ signal is asserted and a flow control frame is sent from the transmitter. When this bit is 0, the CLIENTEMAC#PAUSEREQ signal has no effect.)\n", (uint8_t)(v.TX_FC_enable));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Ethernet MAC Mode Configuration register
 */

/*
 * Dump of fields for register type: eMAC_eMAC_ethernet_mac_conf_t
 *   _anon0 (size 24, offset 0):	 MBZ	  _
 *   RX16 (size 1, offset 24):	 RO	  Receive 16-bit Client Interface enable. When this bit is 1, the receive data client interface is 16 bits wide. When this bit is 0, the receive data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.
 *   TX16 (size 1, offset 25):	 RO	  Transmit 16-bit Client Interface enable. When this bit is 1, the transmit data client interface is 16 bits wide. When this bit is 0, the transmit data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.
 *   HOST (size 1, offset 26):	 RO	  Host Interface enable. When this bit is 1, the host interface is enabled. When this bit is 0, the host interface is disabled.
 *   GPCS (size 1, offset 27):	 RO	  1000BASE-X mode enable. When this bit is 1, the Ethernet MAC is configured in 1000BASE-X mode.
 *   SGMII (size 1, offset 28):	 RO	  SGMII mode enable. When this bit is 1, the Ethernet MAC is configured in SGMII mode.
 *   RGMII (size 1, offset 29):	 RO	  RGMII mode enable. When this bit is 1, the Ethernet MAC is configured in RGMII mode.
 *   LINK_SPEED (size 2, offset 30):	 RW	  Speed selection. The speed of the Ethernet MAC is defined by the following values: 10 = 1000 Mb/s, 01 = 100 Mb/s, 00 = 10 Mb/s, 11 = N/A
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_eMAC_ethernet_mac_conf_t {
    uint32_t	_anon0	:24;
    uint8_t	RX16	:1;
    uint8_t	TX16	:1;
    uint8_t	HOST	:1;
    uint8_t	GPCS	:1;
    uint8_t	SGMII	:1;
    uint8_t	RGMII	:1;
    uint8_t	LINK_SPEED	:2;
} __attribute__ ((packed))
 eMAC_eMAC_ethernet_mac_conf_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_eMAC_ethernet_mac_conf_t, sizeof(uint32_t));

typedef union eMAC_eMAC_ethernet_mac_conf_un {
    eMAC_eMAC_ethernet_mac_conf_t	val;
    uint32_t	raw;
}
 eMAC_eMAC_ethernet_mac_conf_un;
static inline int eMAC_eMAC_ethernet_mac_conf_prtval( char * s, size_t sz, eMAC_eMAC_ethernet_mac_conf_t v ) __attribute__ ((always_inline));
static inline int eMAC_eMAC_ethernet_mac_conf_prtval( char * s, size_t sz, eMAC_eMAC_ethernet_mac_conf_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " RX16=0x%"PRIx8" (Receive 16-bit Client Interface enable. When this bit is 1, the receive data client interface is 16 bits wide. When this bit is 0, the receive data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.)\n", (uint8_t)(v.RX16));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " TX16=0x%"PRIx8" (Transmit 16-bit Client Interface enable. When this bit is 1, the transmit data client interface is 16 bits wide. When this bit is 0, the transmit data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.)\n", (uint8_t)(v.TX16));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " HOST=0x%"PRIx8" (Host Interface enable. When this bit is 1, the host interface is enabled. When this bit is 0, the host interface is disabled.)\n", (uint8_t)(v.HOST));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " GPCS=0x%"PRIx8" (1000BASE-X mode enable. When this bit is 1, the Ethernet MAC is configured in 1000BASE-X mode.)\n", (uint8_t)(v.GPCS));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " SGMII=0x%"PRIx8" (SGMII mode enable. When this bit is 1, the Ethernet MAC is configured in SGMII mode.)\n", (uint8_t)(v.SGMII));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " RGMII=0x%"PRIx8" (RGMII mode enable. When this bit is 1, the Ethernet MAC is configured in RGMII mode.)\n", (uint8_t)(v.RGMII));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " LINK_SPEED=0x%"PRIx8" (Speed selection. The speed of the Ethernet MAC is defined by the following values: 10 = 1000 Mb/s, 01 = 100 Mb/s, 00 = 10 Mb/s, 11 = N/A)\n", (uint8_t)(v.LINK_SPEED));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Address filter mode Configuration register
 */

/*
 * Dump of fields for register type: eMAC_eMAC_address_filter_mode_t
 *   _anon0 (size 31, offset 0):	 MBZ	  _
 *   PM (size 1, offset 31):	 RW	  Promiscuous Mode enable. When this bit is 1, the Address Filter block is disabled. When this bit is 0, the Address Filter block is enabled.
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_eMAC_address_filter_mode_t {
    uint32_t	_anon0	:31;
    uint8_t	PM	:1;
} __attribute__ ((packed))
 eMAC_eMAC_address_filter_mode_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_eMAC_address_filter_mode_t, sizeof(uint32_t));

typedef union eMAC_eMAC_address_filter_mode_un {
    eMAC_eMAC_address_filter_mode_t	val;
    uint32_t	raw;
}
 eMAC_eMAC_address_filter_mode_un;
static inline int eMAC_eMAC_address_filter_mode_prtval( char * s, size_t sz, eMAC_eMAC_address_filter_mode_t v ) __attribute__ ((always_inline));
static inline int eMAC_eMAC_address_filter_mode_prtval( char * s, size_t sz, eMAC_eMAC_address_filter_mode_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " PM=0x%"PRIx8" (Promiscuous Mode enable. When this bit is 1, the Address Filter block is disabled. When this bit is 0, the Address Filter block is enabled.)\n", (uint8_t)(v.PM));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: RX Frame Dropped Channel
 */

/*
 * Dump of fields for register type: eMAC_RX_frame_dropped_t
 *   status (size 1, offset 0):	 RW	  Set when frame dropped due to RX buffer overflow in DDR3
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_RX_frame_dropped_t {
    uint8_t	status	:1;
    uint32_t	_anon1	:31;
} __attribute__ ((packed))
 eMAC_RX_frame_dropped_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_RX_frame_dropped_t, sizeof(uint32_t));

typedef union eMAC_RX_frame_dropped_un {
    eMAC_RX_frame_dropped_t	val;
    uint32_t	raw;
}
 eMAC_RX_frame_dropped_un;
static inline int eMAC_RX_frame_dropped_prtval( char * s, size_t sz, eMAC_RX_frame_dropped_t v ) __attribute__ ((always_inline));
static inline int eMAC_RX_frame_dropped_prtval( char * s, size_t sz, eMAC_RX_frame_dropped_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " status=0x%"PRIx8" (Set when frame dropped due to RX buffer overflow in DDR3)\n", (uint8_t)(v.status));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: TX FIFO buffer full
 */

/*
 * Dump of fields for register type: eMAC_TX_FIFO_buff_full_t
 *   status (size 1, offset 0):	 RO	  Set in case of an overflow of TX fifo buffer in eMAC IP block
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_TX_FIFO_buff_full_t {
    uint8_t	status	:1;
    uint32_t	_anon1	:31;
} __attribute__ ((packed))
 eMAC_TX_FIFO_buff_full_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_TX_FIFO_buff_full_t, sizeof(uint32_t));

typedef union eMAC_TX_FIFO_buff_full_un {
    eMAC_TX_FIFO_buff_full_t	val;
    uint32_t	raw;
}
 eMAC_TX_FIFO_buff_full_un;
static inline int eMAC_TX_FIFO_buff_full_prtval( char * s, size_t sz, eMAC_TX_FIFO_buff_full_t v ) __attribute__ ((always_inline));
static inline int eMAC_TX_FIFO_buff_full_prtval( char * s, size_t sz, eMAC_TX_FIFO_buff_full_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " status=0x%"PRIx8" (Set in case of an overflow of TX fifo buffer in eMAC IP block)\n", (uint8_t)(v.status));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: RX FIFO buffer full
 */

/*
 * Dump of fields for register type: eMAC_RX_FIFO_buff_full_t
 *   status (size 1, offset 0):	 RO	  Set in case of an overflow of RX fifo buffer in eMAC IP block
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_RX_FIFO_buff_full_t {
    uint8_t	status	:1;
    uint32_t	_anon1	:31;
} __attribute__ ((packed))
 eMAC_RX_FIFO_buff_full_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_RX_FIFO_buff_full_t, sizeof(uint32_t));

typedef union eMAC_RX_FIFO_buff_full_un {
    eMAC_RX_FIFO_buff_full_t	val;
    uint32_t	raw;
}
 eMAC_RX_FIFO_buff_full_un;
static inline int eMAC_RX_FIFO_buff_full_prtval( char * s, size_t sz, eMAC_RX_FIFO_buff_full_t v ) __attribute__ ((always_inline));
static inline int eMAC_RX_FIFO_buff_full_prtval( char * s, size_t sz, eMAC_RX_FIFO_buff_full_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " status=0x%"PRIx8" (Set in case of an overflow of RX fifo buffer in eMAC IP block)\n", (uint8_t)(v.status));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: TX EMAC not ready
 */

/*
 * Dump of fields for register type: eMAC_TX_EMAC_Not_Ready_t
 *   status (size 1, offset 0):	 RO	  eMAC does not accept frames
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_TX_EMAC_Not_Ready_t {
    uint8_t	status	:1;
    uint32_t	_anon1	:31;
} __attribute__ ((packed))
 eMAC_TX_EMAC_Not_Ready_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_TX_EMAC_Not_Ready_t, sizeof(uint32_t));

typedef union eMAC_TX_EMAC_Not_Ready_un {
    eMAC_TX_EMAC_Not_Ready_t	val;
    uint32_t	raw;
}
 eMAC_TX_EMAC_Not_Ready_un;
static inline int eMAC_TX_EMAC_Not_Ready_prtval( char * s, size_t sz, eMAC_TX_EMAC_Not_Ready_t v ) __attribute__ ((always_inline));
static inline int eMAC_TX_EMAC_Not_Ready_prtval( char * s, size_t sz, eMAC_TX_EMAC_Not_Ready_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " status=0x%"PRIx8" (eMAC does not accept frames)\n", (uint8_t)(v.status));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: RX MAC address error
 */

/*
 * Dump of fields for register type: eMAC_RX_MAC_Addr_Err_t
 *   status (size 1, offset 0):	 RO	  MAC address not found in table
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_RX_MAC_Addr_Err_t {
    uint8_t	status	:1;
    uint32_t	_anon1	:31;
} __attribute__ ((packed))
 eMAC_RX_MAC_Addr_Err_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_RX_MAC_Addr_Err_t, sizeof(uint32_t));

typedef union eMAC_RX_MAC_Addr_Err_un {
    eMAC_RX_MAC_Addr_Err_t	val;
    uint32_t	raw;
}
 eMAC_RX_MAC_Addr_Err_un;
static inline int eMAC_RX_MAC_Addr_Err_prtval( char * s, size_t sz, eMAC_RX_MAC_Addr_Err_t v ) __attribute__ ((always_inline));
static inline int eMAC_RX_MAC_Addr_Err_prtval( char * s, size_t sz, eMAC_RX_MAC_Addr_Err_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " status=0x%"PRIx8" (MAC address not found in table)\n", (uint8_t)(v.status));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: RX MAC address lower part
 */

/*
 * Dump of fields for register type: eMAC_RX_MAC_Lower_t
 *   mac_low (size 32, offset 0):	 RO	  Lower 32 bits of MAC address that has not been found
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_RX_MAC_Lower_t {
    uint32_t	mac_low	:32;
} __attribute__ ((packed))
 eMAC_RX_MAC_Lower_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_RX_MAC_Lower_t, sizeof(uint32_t));

typedef union eMAC_RX_MAC_Lower_un {
    eMAC_RX_MAC_Lower_t	val;
    uint32_t	raw;
}
 eMAC_RX_MAC_Lower_un;
static inline int eMAC_RX_MAC_Lower_prtval( char * s, size_t sz, eMAC_RX_MAC_Lower_t v ) __attribute__ ((always_inline));
static inline int eMAC_RX_MAC_Lower_prtval( char * s, size_t sz, eMAC_RX_MAC_Lower_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mac_low=0x%0"PRIx32" (Lower 32 bits of MAC address that has not been found)\n", (uint32_t)(v.mac_low));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: RX MAC address higher part
 */

/*
 * Dump of fields for register type: eMAC_RX_MAC_Higher_t
 *   mac_high (size 16, offset 0):	 RO	  Upper 16 bits of MAC address that has not been found
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_RX_MAC_Higher_t {
    uint16_t	mac_high	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 eMAC_RX_MAC_Higher_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_RX_MAC_Higher_t, sizeof(uint32_t));

typedef union eMAC_RX_MAC_Higher_un {
    eMAC_RX_MAC_Higher_t	val;
    uint32_t	raw;
}
 eMAC_RX_MAC_Higher_un;
static inline int eMAC_RX_MAC_Higher_prtval( char * s, size_t sz, eMAC_RX_MAC_Higher_t v ) __attribute__ ((always_inline));
static inline int eMAC_RX_MAC_Higher_prtval( char * s, size_t sz, eMAC_RX_MAC_Higher_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mac_high=0x%0"PRIx16" (Upper 16 bits of MAC address that has not been found)\n", (uint16_t)(v.mac_high));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: eMAC config MAC base address (high)
 */

/*
 * Dump of fields for register type: eMAC_eMAC_MAC_base_addr_upper_t
 *   mac_upper (size 16, offset 0):	 RW	  Upper 16 bits of base MAC address
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_eMAC_MAC_base_addr_upper_t {
    uint16_t	mac_upper	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 eMAC_eMAC_MAC_base_addr_upper_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_eMAC_MAC_base_addr_upper_t, sizeof(uint32_t));

typedef union eMAC_eMAC_MAC_base_addr_upper_un {
    eMAC_eMAC_MAC_base_addr_upper_t	val;
    uint32_t	raw;
}
 eMAC_eMAC_MAC_base_addr_upper_un;
static inline int eMAC_eMAC_MAC_base_addr_upper_prtval( char * s, size_t sz, eMAC_eMAC_MAC_base_addr_upper_t v ) __attribute__ ((always_inline));
static inline int eMAC_eMAC_MAC_base_addr_upper_prtval( char * s, size_t sz, eMAC_eMAC_MAC_base_addr_upper_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mac_upper=0x%0"PRIx16" (Upper 16 bits of base MAC address)\n", (uint16_t)(v.mac_upper));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: eMAC config MAC base address (low)
 */

/*
 * Dump of fields for register type: eMAC_eMAC_MAC_base_addr_lower_t
 *   mac_lower (size 32, offset 0):	 RW	  Lower 32 bits of base MAC address
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_eMAC_MAC_base_addr_lower_t {
    uint32_t	mac_lower	:32;
} __attribute__ ((packed))
 eMAC_eMAC_MAC_base_addr_lower_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_eMAC_MAC_base_addr_lower_t, sizeof(uint32_t));

typedef union eMAC_eMAC_MAC_base_addr_lower_un {
    eMAC_eMAC_MAC_base_addr_lower_t	val;
    uint32_t	raw;
}
 eMAC_eMAC_MAC_base_addr_lower_un;
static inline int eMAC_eMAC_MAC_base_addr_lower_prtval( char * s, size_t sz, eMAC_eMAC_MAC_base_addr_lower_t v ) __attribute__ ((always_inline));
static inline int eMAC_eMAC_MAC_base_addr_lower_prtval( char * s, size_t sz, eMAC_eMAC_MAC_base_addr_lower_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mac_lower=0x%0"PRIx32" (Lower 32 bits of base MAC address)\n", (uint32_t)(v.mac_lower));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: eMAC config Start IP Address of SCC network
 */

/*
 * Dump of fields for register type: eMAC_eMAC_start_IP_SCC_network_t
 *   ip (size 32, offset 0):	 RW	  IP Address for SCC Core 0. IPs for other cores are assigned in order
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_eMAC_start_IP_SCC_network_t {
    uint32_t	ip	:32;
} __attribute__ ((packed))
 eMAC_eMAC_start_IP_SCC_network_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_eMAC_start_IP_SCC_network_t, sizeof(uint32_t));

typedef union eMAC_eMAC_start_IP_SCC_network_un {
    eMAC_eMAC_start_IP_SCC_network_t	val;
    uint32_t	raw;
}
 eMAC_eMAC_start_IP_SCC_network_un;
static inline int eMAC_eMAC_start_IP_SCC_network_prtval( char * s, size_t sz, eMAC_eMAC_start_IP_SCC_network_t v ) __attribute__ ((always_inline));
static inline int eMAC_eMAC_start_IP_SCC_network_prtval( char * s, size_t sz, eMAC_eMAC_start_IP_SCC_network_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ip=0x%0"PRIx32" (IP Address for SCC Core 0. IPs for other cores are assigned in order)\n", (uint32_t)(v.ip));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: eMAC config Host IP Address
 */

/*
 * Dump of fields for register type: eMAC_eMAC_host_IP_addr_t
 *   ip (size 32, offset 0):	 RW	  IP Address of Host computer where /shared is mounted
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_eMAC_host_IP_addr_t {
    uint32_t	ip	:32;
} __attribute__ ((packed))
 eMAC_eMAC_host_IP_addr_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_eMAC_host_IP_addr_t, sizeof(uint32_t));

typedef union eMAC_eMAC_host_IP_addr_un {
    eMAC_eMAC_host_IP_addr_t	val;
    uint32_t	raw;
}
 eMAC_eMAC_host_IP_addr_un;
static inline int eMAC_eMAC_host_IP_addr_prtval( char * s, size_t sz, eMAC_eMAC_host_IP_addr_t v ) __attribute__ ((always_inline));
static inline int eMAC_eMAC_host_IP_addr_prtval( char * s, size_t sz, eMAC_eMAC_host_IP_addr_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ip=0x%0"PRIx32" (IP Address of Host computer where /shared is mounted)\n", (uint32_t)(v.ip));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: eMAC config Host gateway Address
 */

/*
 * Dump of fields for register type: eMAC_eMAC_host_GW_addr_t
 *   ip (size 32, offset 0):	 RW	  Gateway of Host computer
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_eMAC_host_GW_addr_t {
    uint32_t	ip	:32;
} __attribute__ ((packed))
 eMAC_eMAC_host_GW_addr_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_eMAC_host_GW_addr_t, sizeof(uint32_t));

typedef union eMAC_eMAC_host_GW_addr_un {
    eMAC_eMAC_host_GW_addr_t	val;
    uint32_t	raw;
}
 eMAC_eMAC_host_GW_addr_un;
static inline int eMAC_eMAC_host_GW_addr_prtval( char * s, size_t sz, eMAC_eMAC_host_GW_addr_t v ) __attribute__ ((always_inline));
static inline int eMAC_eMAC_host_GW_addr_prtval( char * s, size_t sz, eMAC_eMAC_host_GW_addr_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ip=0x%0"PRIx32" (Gateway of Host computer)\n", (uint32_t)(v.ip));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: RX control RX Buffer Start Address
 */

/*
 * Dump of fields for register type: eMAC_RX_Buffer_start_addr_t
 *   ADDR (size 29, offset 0):	 RW	  Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.
 *   _anon29 (size 3, offset 29):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_RX_Buffer_start_addr_t {
    uint32_t	ADDR	:29;
    uint8_t	_anon29	:3;
} __attribute__ ((packed))
 eMAC_RX_Buffer_start_addr_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_RX_Buffer_start_addr_t, sizeof(uint32_t));

typedef union eMAC_RX_Buffer_start_addr_un {
    eMAC_RX_Buffer_start_addr_t	val;
    uint32_t	raw;
}
 eMAC_RX_Buffer_start_addr_un;
static inline int eMAC_RX_Buffer_start_addr_prtval( char * s, size_t sz, eMAC_RX_Buffer_start_addr_t v ) __attribute__ ((always_inline));
static inline int eMAC_RX_Buffer_start_addr_prtval( char * s, size_t sz, eMAC_RX_Buffer_start_addr_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ADDR=0x%0"PRIx32" (Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.)\n", (uint32_t)(v.ADDR));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: RX control RX Buffer Read Index
 */

/*
 * Dump of fields for register type: eMAC_RX_Buffer_read_index_t
 *   rid (size 16, offset 0):	 RW	  Read index of RX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_RX_Buffer_read_index_t {
    uint16_t	rid	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 eMAC_RX_Buffer_read_index_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_RX_Buffer_read_index_t, sizeof(uint32_t));

typedef union eMAC_RX_Buffer_read_index_un {
    eMAC_RX_Buffer_read_index_t	val;
    uint32_t	raw;
}
 eMAC_RX_Buffer_read_index_un;
static inline int eMAC_RX_Buffer_read_index_prtval( char * s, size_t sz, eMAC_RX_Buffer_read_index_t v ) __attribute__ ((always_inline));
static inline int eMAC_RX_Buffer_read_index_prtval( char * s, size_t sz, eMAC_RX_Buffer_read_index_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rid=0x%0"PRIx16" (Read index of RX buffer Points to 32 byte entry in the buffer.)\n", (uint16_t)(v.rid));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: RX control RX Buffer Write Index
 */

/*
 * Dump of fields for register type: eMAC_RX_Buffer_write_index_t
 *   wid (size 16, offset 0):	 RO	  Write index of RX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_RX_Buffer_write_index_t {
    uint16_t	wid	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 eMAC_RX_Buffer_write_index_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_RX_Buffer_write_index_t, sizeof(uint32_t));

typedef union eMAC_RX_Buffer_write_index_un {
    eMAC_RX_Buffer_write_index_t	val;
    uint32_t	raw;
}
 eMAC_RX_Buffer_write_index_un;
static inline int eMAC_RX_Buffer_write_index_prtval( char * s, size_t sz, eMAC_RX_Buffer_write_index_t v ) __attribute__ ((always_inline));
static inline int eMAC_RX_Buffer_write_index_prtval( char * s, size_t sz, eMAC_RX_Buffer_write_index_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wid=0x%0"PRIx16" (Write index of RX buffer Points to 32 byte entry in the buffer.)\n", (uint16_t)(v.wid));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: RX control RX Buffer Last Index
 */

/*
 * Dump of fields for register type: eMAC_RX_Buffer_last_index_t
 *   lid (size 16, offset 0):	 RW	  Last valid index in buffer. .Buffer size = last index * 32 bytes
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_RX_Buffer_last_index_t {
    uint16_t	lid	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 eMAC_RX_Buffer_last_index_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_RX_Buffer_last_index_t, sizeof(uint32_t));

typedef union eMAC_RX_Buffer_last_index_un {
    eMAC_RX_Buffer_last_index_t	val;
    uint32_t	raw;
}
 eMAC_RX_Buffer_last_index_un;
static inline int eMAC_RX_Buffer_last_index_prtval( char * s, size_t sz, eMAC_RX_Buffer_last_index_t v ) __attribute__ ((always_inline));
static inline int eMAC_RX_Buffer_last_index_prtval( char * s, size_t sz, eMAC_RX_Buffer_last_index_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lid=0x%0"PRIx16" (Last valid index in buffer. .Buffer size = last index * 32 bytes)\n", (uint16_t)(v.lid));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: RX control RX routing related
 */

/*
 * Dump of fields for register type: eMAC_RX_routing_t
 *   broute (size 8, offset 0):	 RW	  Route to the tile where the MC for this buffer is located
 *   bdest (size 3, offset 8):	 RW	  Defines the port at which the MC is connected
 *   _anon11 (size 5, offset 11):	 MBZ	  _
 *   iroute (size 8, offset 16):	 RW	  Route to the tile where the core for this buffer is located
 *   idest (size 3, offset 24):	 RW	  Selects core 0 or core 1 in the tile
 *   _anon27 (size 5, offset 27):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_RX_routing_t {
    uint8_t	broute	:8;
    uint8_t	bdest	:3;
    uint8_t	_anon11	:5;
    uint8_t	iroute	:8;
    uint8_t	idest	:3;
    uint8_t	_anon27	:5;
} __attribute__ ((packed))
 eMAC_RX_routing_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_RX_routing_t, sizeof(uint32_t));

typedef union eMAC_RX_routing_un {
    eMAC_RX_routing_t	val;
    uint32_t	raw;
}
 eMAC_RX_routing_un;
static inline int eMAC_RX_routing_prtval( char * s, size_t sz, eMAC_RX_routing_t v ) __attribute__ ((always_inline));
static inline int eMAC_RX_routing_prtval( char * s, size_t sz, eMAC_RX_routing_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " broute=0x%"PRIx8" (Route to the tile where the MC for this buffer is located)\n", (uint8_t)(v.broute));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " bdest=0x%"PRIx8" (Defines the port at which the MC is connected)\n", (uint8_t)(v.bdest));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " iroute=0x%"PRIx8" (Route to the tile where the core for this buffer is located)\n", (uint8_t)(v.iroute));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " idest=0x%"PRIx8" (Selects core 0 or core 1 in the tile)\n", (uint8_t)(v.idest));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: RX Network Port MAC Address (high)
 */

/*
 * Dump of fields for register type: eMAC_RX_net_port_MAC_high_t
 *   mac_hi (size 16, offset 0):	 RW	  Higher 16 bits of MAC addresses
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_RX_net_port_MAC_high_t {
    uint16_t	mac_hi	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 eMAC_RX_net_port_MAC_high_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_RX_net_port_MAC_high_t, sizeof(uint32_t));

typedef union eMAC_RX_net_port_MAC_high_un {
    eMAC_RX_net_port_MAC_high_t	val;
    uint32_t	raw;
}
 eMAC_RX_net_port_MAC_high_un;
static inline int eMAC_RX_net_port_MAC_high_prtval( char * s, size_t sz, eMAC_RX_net_port_MAC_high_t v ) __attribute__ ((always_inline));
static inline int eMAC_RX_net_port_MAC_high_prtval( char * s, size_t sz, eMAC_RX_net_port_MAC_high_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mac_hi=0x%0"PRIx16" (Higher 16 bits of MAC addresses)\n", (uint16_t)(v.mac_hi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: RX Network Port MAC Address (low)
 */

/*
 * Dump of fields for register type: eMAC_RX_net_port_MAC_low_t
 *   mac_lo (size 32, offset 0):	 RW	  Lower 32 bits of MAC addresses
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_RX_net_port_MAC_low_t {
    uint32_t	mac_lo	:32;
} __attribute__ ((packed))
 eMAC_RX_net_port_MAC_low_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_RX_net_port_MAC_low_t, sizeof(uint32_t));

typedef union eMAC_RX_net_port_MAC_low_un {
    eMAC_RX_net_port_MAC_low_t	val;
    uint32_t	raw;
}
 eMAC_RX_net_port_MAC_low_un;
static inline int eMAC_RX_net_port_MAC_low_prtval( char * s, size_t sz, eMAC_RX_net_port_MAC_low_t v ) __attribute__ ((always_inline));
static inline int eMAC_RX_net_port_MAC_low_prtval( char * s, size_t sz, eMAC_RX_net_port_MAC_low_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mac_lo=0x%0"PRIx32" (Lower 32 bits of MAC addresses)\n", (uint32_t)(v.mac_lo));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: RX Network Port Enable
 */

/*
 * Dump of fields for register type: eMAC_RX_net_port_enable_t
 *   enable (size 1, offset 0):	 RW	  1 - Enabled, 0 - Disabled
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_RX_net_port_enable_t {
    uint8_t	enable	:1;
    uint32_t	_anon1	:31;
} __attribute__ ((packed))
 eMAC_RX_net_port_enable_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_RX_net_port_enable_t, sizeof(uint32_t));

typedef union eMAC_RX_net_port_enable_un {
    eMAC_RX_net_port_enable_t	val;
    uint32_t	raw;
}
 eMAC_RX_net_port_enable_un;
static inline int eMAC_RX_net_port_enable_prtval( char * s, size_t sz, eMAC_RX_net_port_enable_t v ) __attribute__ ((always_inline));
static inline int eMAC_RX_net_port_enable_prtval( char * s, size_t sz, eMAC_RX_net_port_enable_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " enable=0x%"PRIx8" (1 - Enabled, 0 - Disabled)\n", (uint8_t)(v.enable));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: TX control TX Buffer Start Address
 */

/*
 * Dump of fields for register type: eMAC_TX_Buffer_start_addr_t
 *   ADDR (size 29, offset 0):	 RW	  Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.
 *   _anon29 (size 3, offset 29):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_TX_Buffer_start_addr_t {
    uint32_t	ADDR	:29;
    uint8_t	_anon29	:3;
} __attribute__ ((packed))
 eMAC_TX_Buffer_start_addr_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_TX_Buffer_start_addr_t, sizeof(uint32_t));

typedef union eMAC_TX_Buffer_start_addr_un {
    eMAC_TX_Buffer_start_addr_t	val;
    uint32_t	raw;
}
 eMAC_TX_Buffer_start_addr_un;
static inline int eMAC_TX_Buffer_start_addr_prtval( char * s, size_t sz, eMAC_TX_Buffer_start_addr_t v ) __attribute__ ((always_inline));
static inline int eMAC_TX_Buffer_start_addr_prtval( char * s, size_t sz, eMAC_TX_Buffer_start_addr_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ADDR=0x%0"PRIx32" (Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.)\n", (uint32_t)(v.ADDR));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: TX control TX Buffer Read Index
 */

/*
 * Dump of fields for register type: eMAC_TX_Buffer_read_index_t
 *   rid (size 16, offset 0):	 RO	  Read index of TX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_TX_Buffer_read_index_t {
    uint16_t	rid	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 eMAC_TX_Buffer_read_index_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_TX_Buffer_read_index_t, sizeof(uint32_t));

typedef union eMAC_TX_Buffer_read_index_un {
    eMAC_TX_Buffer_read_index_t	val;
    uint32_t	raw;
}
 eMAC_TX_Buffer_read_index_un;
static inline int eMAC_TX_Buffer_read_index_prtval( char * s, size_t sz, eMAC_TX_Buffer_read_index_t v ) __attribute__ ((always_inline));
static inline int eMAC_TX_Buffer_read_index_prtval( char * s, size_t sz, eMAC_TX_Buffer_read_index_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rid=0x%0"PRIx16" (Read index of TX buffer Points to 32 byte entry in the buffer.)\n", (uint16_t)(v.rid));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: TX control TX Buffer Write Index
 */

/*
 * Dump of fields for register type: eMAC_TX_Buffer_write_index_t
 *   wid (size 16, offset 0):	 RW	  Write index of TX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_TX_Buffer_write_index_t {
    uint16_t	wid	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 eMAC_TX_Buffer_write_index_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_TX_Buffer_write_index_t, sizeof(uint32_t));

typedef union eMAC_TX_Buffer_write_index_un {
    eMAC_TX_Buffer_write_index_t	val;
    uint32_t	raw;
}
 eMAC_TX_Buffer_write_index_un;
static inline int eMAC_TX_Buffer_write_index_prtval( char * s, size_t sz, eMAC_TX_Buffer_write_index_t v ) __attribute__ ((always_inline));
static inline int eMAC_TX_Buffer_write_index_prtval( char * s, size_t sz, eMAC_TX_Buffer_write_index_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wid=0x%0"PRIx16" (Write index of TX buffer Points to 32 byte entry in the buffer.)\n", (uint16_t)(v.wid));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: TX control TX Buffer Last Index
 */

/*
 * Dump of fields for register type: eMAC_TX_Buffer_last_index_t
 *   lid (size 16, offset 0):	 RW	  Last valid index in buffer. .Buffer size = last index * 32 bytes
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_TX_Buffer_last_index_t {
    uint16_t	lid	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 eMAC_TX_Buffer_last_index_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_TX_Buffer_last_index_t, sizeof(uint32_t));

typedef union eMAC_TX_Buffer_last_index_un {
    eMAC_TX_Buffer_last_index_t	val;
    uint32_t	raw;
}
 eMAC_TX_Buffer_last_index_un;
static inline int eMAC_TX_Buffer_last_index_prtval( char * s, size_t sz, eMAC_TX_Buffer_last_index_t v ) __attribute__ ((always_inline));
static inline int eMAC_TX_Buffer_last_index_prtval( char * s, size_t sz, eMAC_TX_Buffer_last_index_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lid=0x%0"PRIx16" (Last valid index in buffer. .Buffer size = last index * 32 bytes)\n", (uint16_t)(v.lid));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: TX control RX routing related
 */

/*
 * Dump of fields for register type: eMAC_TX_routing_t
 *   broute (size 8, offset 0):	 RW	  Route to the tile where the MC for this buffer is located
 *   bdest (size 3, offset 8):	 RW	  Defines the port at which the MC is connected
 *   _anon11 (size 21, offset 11):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_TX_routing_t {
    uint8_t	broute	:8;
    uint8_t	bdest	:3;
    uint32_t	_anon11	:21;
} __attribute__ ((packed))
 eMAC_TX_routing_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_TX_routing_t, sizeof(uint32_t));

typedef union eMAC_TX_routing_un {
    eMAC_TX_routing_t	val;
    uint32_t	raw;
}
 eMAC_TX_routing_un;
static inline int eMAC_TX_routing_prtval( char * s, size_t sz, eMAC_TX_routing_t v ) __attribute__ ((always_inline));
static inline int eMAC_TX_routing_prtval( char * s, size_t sz, eMAC_TX_routing_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " broute=0x%"PRIx8" (Route to the tile where the MC for this buffer is located)\n", (uint8_t)(v.broute));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " bdest=0x%"PRIx8" (Defines the port at which the MC is connected)\n", (uint8_t)(v.bdest));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: TX Network Port Enable
 */

/*
 * Dump of fields for register type: eMAC_TX_net_port_enable_t
 *   enable (size 1, offset 0):	 RW	  1 - Enabled, 0 - Disabled
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct eMAC_TX_net_port_enable_t {
    uint8_t	enable	:1;
    uint32_t	_anon1	:31;
} __attribute__ ((packed))
 eMAC_TX_net_port_enable_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(eMAC_TX_net_port_enable_t, sizeof(uint32_t));

typedef union eMAC_TX_net_port_enable_un {
    eMAC_TX_net_port_enable_t	val;
    uint32_t	raw;
}
 eMAC_TX_net_port_enable_un;
static inline int eMAC_TX_net_port_enable_prtval( char * s, size_t sz, eMAC_TX_net_port_enable_t v ) __attribute__ ((always_inline));
static inline int eMAC_TX_net_port_enable_prtval( char * s, size_t sz, eMAC_TX_net_port_enable_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " enable=0x%"PRIx8" (1 - Enabled, 0 - Disabled)\n", (uint8_t)(v.enable));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Device representation structure
 */
typedef struct __DN(t) {
    // Device arguments
    mackerel_addr_t	base;
    // Shadow registers
}
 __DN(t);

/*
 * Device Initialization function
 */
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_addr_t base ) __attribute__ ((always_inline));
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_addr_t base )
{
    /* Setting up device arguments*/
    _dev->base = base;
    /* Setting up shadow registers*/
}

// Include access functions for user-defined spaces
#include "eMAC_spaces.h"

/*
 * Register eMAC0_receiver_conf_0 (eMAC0_receiver_conf_0); type eMAC.eMAC_receiver_conf_0 (Flow control Configuration register (0))
 */

/*
 * Dump of fields for register: eMAC0_receiver_conf_0
 *   PAUSE_FRAME_ADDR_LOW (size 32, offset 0):	 RW	  Pause Frame Ethernet MAC Address [31:0]. This address is used to match the Ethernet MAC against the destination address of any incoming flow control frames. It is also used by the flow control block as the source address for any outbound flow control frames. The address is ordered so the first byte transmitted/received is the lowest positioned byte in the register; for example, a MAC address of AA-BB-CC-DD-EE-FF is stored in address [47:0] as 0xFFEEDDCCBBAA.
 */

static inline uint32_t __DP(eMAC0_receiver_conf_0_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_receiver_conf_0_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x3200));
}

static inline eMAC_eMAC_receiver_conf_0_t __DP(eMAC0_receiver_conf_0_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_receiver_conf_0_t __DP(eMAC0_receiver_conf_0_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_receiver_conf_0_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3200));
    return u.val;
}

static inline void __DP(eMAC0_receiver_conf_0_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_receiver_conf_0_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x3200),val);
}

static inline void __DP(eMAC0_receiver_conf_0_wr)( __DN(t) * _dev, eMAC_eMAC_receiver_conf_0_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_receiver_conf_0_wr)( __DN(t) * _dev, eMAC_eMAC_receiver_conf_0_t val )
{
    eMAC_eMAC_receiver_conf_0_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0x3200),u.raw);
}

static inline void __DP(eMAC0_receiver_conf_0_PAUSE_FRAME_ADDR_LOW_wrf)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_receiver_conf_0_PAUSE_FRAME_ADDR_LOW_wrf)( __DN(t) * _dev, uint32_t val )
{
    eMAC_eMAC_receiver_conf_0_un  u;
    u.val.PAUSE_FRAME_ADDR_LOW = val;
    mackerel_write_addr_32(_dev->base,(0x3200),u.raw);
}


static inline int __DP(eMAC0_receiver_conf_0_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_receiver_conf_0_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_receiver_conf_0_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3200));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC0_receiver_conf_0 (eMAC0_receiver_conf_0):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.PAUSE_FRAME_ADDR_LOW;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " PAUSE_FRAME_ADDR_LOW =\t0x%0"PRIx32" (Pause Frame Ethernet MAC Address [31:0]. This address is used to match the Ethernet MAC against the destination address of any incoming flow control frames. It is also used by the flow control block as the source address for any outbound flow control frames. The address is ordered so the first byte transmitted/received is the lowest positioned byte in the register; for example, a MAC address of AA-BB-CC-DD-EE-FF is stored in address [47:0] as 0xFFEEDDCCBBAA.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_receiver_conf_1 (eMAC0_receiver_conf_1); type eMAC.eMAC_receiver_conf_1 (Flow control Configuration register (1))
 */

/*
 * Dump of fields for register: eMAC0_receiver_conf_1
 *   PAUSE_FRAME_ADDR_LOW (size 16, offset 0):	 RW	  Pause frame Ethernet MAC Address [47:32].
 *   _anon16 (size 9, offset 16):	 MBZ	  _
 *   LT_DIS (size 1, offset 25):	 RW	  Length/Type Check disable. When this bit is 1, it disables the Length/Type field check on the frame.
 *   HD (size 1, offset 26):	 RW	  Half-duplex mode. When this bit is 1, the receiver operates in half-duplex mode. When the bit is 0, the receiver operates in full-duplex mode.
 *   VLAN (size 1, offset 27):	 RW	  VLAN enable. When this bit is 1, the receiver accepts VLAN tagged frames. The maximum payload length increases by four bytes.
 *   RX (size 1, offset 28):	 RW	  Receive enable. When this bit is 1, the receiver block is enabled to operate. When the bit is 0, the receiver ignores activity on the physical interface receive port.
 *   FCS (size 1, offset 29):	 RW	  In-band FCS enable. When this bit is 1, the receiver passes the FCS field up to the client. When this bit is 0, the FCS field is not passed to the client. In either case, the FCS is verified on the frame.
 *   JUM (size 1, offset 30):	 RW	  Jumbo frame enable. When this bit is 1, the Ethernet MAC receiver accepts frames over the maximum length specified in IEEE Std 802.3-2002 specification. When this bit is 0, the receiver only accepts frames up to the specified maximum.
 *   RST (size 1, offset 31):	 RW	  Reset. When this bit is 1, the receiver is reset. The bit automatically reverts to 0. This reset also sets all of the receiver configuration registers to their default values.
 */

static inline uint32_t __DP(eMAC0_receiver_conf_1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_receiver_conf_1_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x3240));
}

static inline eMAC_eMAC_receiver_conf_1_t __DP(eMAC0_receiver_conf_1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_receiver_conf_1_t __DP(eMAC0_receiver_conf_1_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3240));
    return u.val;
}

static inline void __DP(eMAC0_receiver_conf_1_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_receiver_conf_1_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x3240),val);
}

static inline void __DP(eMAC0_receiver_conf_1_wr)( __DN(t) * _dev, eMAC_eMAC_receiver_conf_1_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_receiver_conf_1_wr)( __DN(t) * _dev, eMAC_eMAC_receiver_conf_1_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x3240),u.raw);
}

static inline void __DP(eMAC0_receiver_conf_1_PAUSE_FRAME_ADDR_LOW_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_receiver_conf_1_PAUSE_FRAME_ADDR_LOW_wrf)( __DN(t) * _dev, uint16_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3240));
    u.val._anon16 	= 0;
    u.val.PAUSE_FRAME_ADDR_LOW = val;
    mackerel_write_addr_32(_dev->base,(0x3240),u.raw);
}

static inline void __DP(eMAC0_receiver_conf_1_LT_DIS_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_receiver_conf_1_LT_DIS_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3240));
    u.val._anon16 	= 0;
    u.val.LT_DIS = val;
    mackerel_write_addr_32(_dev->base,(0x3240),u.raw);
}

static inline void __DP(eMAC0_receiver_conf_1_HD_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_receiver_conf_1_HD_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3240));
    u.val._anon16 	= 0;
    u.val.HD = val;
    mackerel_write_addr_32(_dev->base,(0x3240),u.raw);
}

static inline void __DP(eMAC0_receiver_conf_1_VLAN_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_receiver_conf_1_VLAN_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3240));
    u.val._anon16 	= 0;
    u.val.VLAN = val;
    mackerel_write_addr_32(_dev->base,(0x3240),u.raw);
}

static inline void __DP(eMAC0_receiver_conf_1_RX_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_receiver_conf_1_RX_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3240));
    u.val._anon16 	= 0;
    u.val.RX = val;
    mackerel_write_addr_32(_dev->base,(0x3240),u.raw);
}

static inline void __DP(eMAC0_receiver_conf_1_FCS_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_receiver_conf_1_FCS_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3240));
    u.val._anon16 	= 0;
    u.val.FCS = val;
    mackerel_write_addr_32(_dev->base,(0x3240),u.raw);
}

static inline void __DP(eMAC0_receiver_conf_1_JUM_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_receiver_conf_1_JUM_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3240));
    u.val._anon16 	= 0;
    u.val.JUM = val;
    mackerel_write_addr_32(_dev->base,(0x3240),u.raw);
}

static inline void __DP(eMAC0_receiver_conf_1_RST_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_receiver_conf_1_RST_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3240));
    u.val._anon16 	= 0;
    u.val.RST = val;
    mackerel_write_addr_32(_dev->base,(0x3240),u.raw);
}


static inline int __DP(eMAC0_receiver_conf_1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_receiver_conf_1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3240));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC0_receiver_conf_1 (eMAC0_receiver_conf_1):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.PAUSE_FRAME_ADDR_LOW;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " PAUSE_FRAME_ADDR_LOW =\t0x%0"PRIx16" (Pause frame Ethernet MAC Address [47:32].", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.LT_DIS;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " LT_DIS =\t0x%"PRIx8" (Length/Type Check disable. When this bit is 1, it disables the Length/Type field check on the frame.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.HD;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " HD =\t0x%"PRIx8" (Half-duplex mode. When this bit is 1, the receiver operates in half-duplex mode. When the bit is 0, the receiver operates in full-duplex mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.VLAN;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " VLAN =\t0x%"PRIx8" (VLAN enable. When this bit is 1, the receiver accepts VLAN tagged frames. The maximum payload length increases by four bytes.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.RX;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RX =\t0x%"PRIx8" (Receive enable. When this bit is 1, the receiver block is enabled to operate. When the bit is 0, the receiver ignores activity on the physical interface receive port.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.FCS;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " FCS =\t0x%"PRIx8" (In-band FCS enable. When this bit is 1, the receiver passes the FCS field up to the client. When this bit is 0, the FCS field is not passed to the client. In either case, the FCS is verified on the frame.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.JUM;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " JUM =\t0x%"PRIx8" (Jumbo frame enable. When this bit is 1, the Ethernet MAC receiver accepts frames over the maximum length specified in IEEE Std 802.3-2002 specification. When this bit is 0, the receiver only accepts frames up to the specified maximum.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.RST;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RST =\t0x%"PRIx8" (Reset. When this bit is 1, the receiver is reset. The bit automatically reverts to 0. This reset also sets all of the receiver configuration registers to their default values.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_transmiter_conf (eMAC0_transmiter_conf); type eMAC.eMAC_transmiter_conf (eMAC Transmiter Configuration register)
 */

/*
 * Dump of fields for register: eMAC0_transmiter_conf
 *   _anon0 (size 25, offset 0):	 MBZ	  _
 *   IFG (size 1, offset 25):	 RW	  IFG adjustment enable. When this bit is 1, the transmitter reads the value of CLIENTEMAC#TXIFGDELAY at the start of frame transmission and adjusts the IFG.
 *   HD (size 1, offset 26):	 RW	  Half-duplex mode (applicable in 10/100 Mb/s mode only). When this bit is 1, the transmitter operates in half-duplex mode. When this bit is 0, the transmitter operates in full-duplex mode.
 *   VLAN (size 1, offset 27):	 RW	  VLAN enable. When this bit is 1, the transmitter allows transmission of the VLAN tagged frames.
 *   TX (size 1, offset 28):	 RW	  Transmit enable. When this bit is 1, the transmitter is enabled for operation.
 *   FCS (size 1, offset 29):	 RW	  In-band FCS enable. When this bit is 1, the Ethernet MAC transmitter is ready for the FCS field from the client.
 *   JUM (size 1, offset 30):	 RW	  Jumbo frame enable. When this bit is 1, the transmitter sends frames greater than the maximum length specified in IEEE Std 802.3-2002. When this bit is 0, it only sends frames less than the specified maximum length.
 *   RST (size 1, offset 31):	 RW	  Reset. When this bit is 1, the transmitter is reset. The bit automatically reverts to 0. This reset also sets all of the transmitter configuration registers to their default values.
 */

static inline uint32_t __DP(eMAC0_transmiter_conf_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_transmiter_conf_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x3280));
}

static inline eMAC_eMAC_transmiter_conf_t __DP(eMAC0_transmiter_conf_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_transmiter_conf_t __DP(eMAC0_transmiter_conf_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3280));
    return u.val;
}

static inline void __DP(eMAC0_transmiter_conf_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_transmiter_conf_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x3280),val);
}

static inline void __DP(eMAC0_transmiter_conf_wr)( __DN(t) * _dev, eMAC_eMAC_transmiter_conf_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_transmiter_conf_wr)( __DN(t) * _dev, eMAC_eMAC_transmiter_conf_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    mackerel_write_addr_32(_dev->base,(0x3280),u.raw);
}

static inline void __DP(eMAC0_transmiter_conf_IFG_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_transmiter_conf_IFG_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3280));
    u.val._anon0 	= 0;
    u.val.IFG = val;
    mackerel_write_addr_32(_dev->base,(0x3280),u.raw);
}

static inline void __DP(eMAC0_transmiter_conf_HD_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_transmiter_conf_HD_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3280));
    u.val._anon0 	= 0;
    u.val.HD = val;
    mackerel_write_addr_32(_dev->base,(0x3280),u.raw);
}

static inline void __DP(eMAC0_transmiter_conf_VLAN_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_transmiter_conf_VLAN_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3280));
    u.val._anon0 	= 0;
    u.val.VLAN = val;
    mackerel_write_addr_32(_dev->base,(0x3280),u.raw);
}

static inline void __DP(eMAC0_transmiter_conf_TX_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_transmiter_conf_TX_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3280));
    u.val._anon0 	= 0;
    u.val.TX = val;
    mackerel_write_addr_32(_dev->base,(0x3280),u.raw);
}

static inline void __DP(eMAC0_transmiter_conf_FCS_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_transmiter_conf_FCS_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3280));
    u.val._anon0 	= 0;
    u.val.FCS = val;
    mackerel_write_addr_32(_dev->base,(0x3280),u.raw);
}

static inline void __DP(eMAC0_transmiter_conf_JUM_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_transmiter_conf_JUM_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3280));
    u.val._anon0 	= 0;
    u.val.JUM = val;
    mackerel_write_addr_32(_dev->base,(0x3280),u.raw);
}

static inline void __DP(eMAC0_transmiter_conf_RST_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_transmiter_conf_RST_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3280));
    u.val._anon0 	= 0;
    u.val.RST = val;
    mackerel_write_addr_32(_dev->base,(0x3280),u.raw);
}


static inline int __DP(eMAC0_transmiter_conf_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_transmiter_conf_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3280));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC0_transmiter_conf (eMAC0_transmiter_conf):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.IFG;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " IFG =\t0x%"PRIx8" (IFG adjustment enable. When this bit is 1, the transmitter reads the value of CLIENTEMAC#TXIFGDELAY at the start of frame transmission and adjusts the IFG.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.HD;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " HD =\t0x%"PRIx8" (Half-duplex mode (applicable in 10/100 Mb/s mode only). When this bit is 1, the transmitter operates in half-duplex mode. When this bit is 0, the transmitter operates in full-duplex mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.VLAN;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " VLAN =\t0x%"PRIx8" (VLAN enable. When this bit is 1, the transmitter allows transmission of the VLAN tagged frames.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.TX;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " TX =\t0x%"PRIx8" (Transmit enable. When this bit is 1, the transmitter is enabled for operation.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.FCS;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " FCS =\t0x%"PRIx8" (In-band FCS enable. When this bit is 1, the Ethernet MAC transmitter is ready for the FCS field from the client.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.JUM;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " JUM =\t0x%"PRIx8" (Jumbo frame enable. When this bit is 1, the transmitter sends frames greater than the maximum length specified in IEEE Std 802.3-2002. When this bit is 0, it only sends frames less than the specified maximum length.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.RST;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RST =\t0x%"PRIx8" (Reset. When this bit is 1, the transmitter is reset. The bit automatically reverts to 0. This reset also sets all of the transmitter configuration registers to their default values.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_flow_control_conf (eMAC0_flow_control_conf); type eMAC.eMAC_flow_control_conf (Flow control Configuration register)
 */

/*
 * Dump of fields for register: eMAC0_flow_control_conf
 *   _anon0 (size 29, offset 0):	 MBZ	  _
 *   RX_FC_enable (size 1, offset 29):	 RW	  Flow control enable (RX). When this bit is 1, the received flow control frames inhibit transmitter operation. When this bit is 0, the flow control frame is passed to the client.
 *   TX_FC_enable (size 1, offset 30):	 RW	  Flow control enable (TX). When this bit is 1, the CLIENTEMAC#PAUSEREQ signal is asserted and a flow control frame is sent from the transmitter. When this bit is 0, the CLIENTEMAC#PAUSEREQ signal has no effect.
 *   _anon31 (size 1, offset 31):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC0_flow_control_conf_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_flow_control_conf_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x32c0));
}

static inline eMAC_eMAC_flow_control_conf_t __DP(eMAC0_flow_control_conf_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_flow_control_conf_t __DP(eMAC0_flow_control_conf_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_flow_control_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x32c0));
    return u.val;
}

static inline void __DP(eMAC0_flow_control_conf_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_flow_control_conf_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x32c0),val);
}

static inline void __DP(eMAC0_flow_control_conf_wr)( __DN(t) * _dev, eMAC_eMAC_flow_control_conf_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_flow_control_conf_wr)( __DN(t) * _dev, eMAC_eMAC_flow_control_conf_t val )
{
    eMAC_eMAC_flow_control_conf_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    u.val._anon31 	= 0;
    mackerel_write_addr_32(_dev->base,(0x32c0),u.raw);
}

static inline void __DP(eMAC0_flow_control_conf_RX_FC_enable_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_flow_control_conf_RX_FC_enable_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_flow_control_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x32c0));
    u.val._anon0 	= 0;
    u.val._anon31 	= 0;
    u.val.RX_FC_enable = val;
    mackerel_write_addr_32(_dev->base,(0x32c0),u.raw);
}

static inline void __DP(eMAC0_flow_control_conf_TX_FC_enable_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_flow_control_conf_TX_FC_enable_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_flow_control_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x32c0));
    u.val._anon0 	= 0;
    u.val._anon31 	= 0;
    u.val.TX_FC_enable = val;
    mackerel_write_addr_32(_dev->base,(0x32c0),u.raw);
}


static inline int __DP(eMAC0_flow_control_conf_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_flow_control_conf_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_flow_control_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x32c0));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC0_flow_control_conf (eMAC0_flow_control_conf):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.RX_FC_enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RX_FC_enable =\t0x%"PRIx8" (Flow control enable (RX). When this bit is 1, the received flow control frames inhibit transmitter operation. When this bit is 0, the flow control frame is passed to the client.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.TX_FC_enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " TX_FC_enable =\t0x%"PRIx8" (Flow control enable (TX). When this bit is 1, the CLIENTEMAC#PAUSEREQ signal is asserted and a flow control frame is sent from the transmitter. When this bit is 0, the CLIENTEMAC#PAUSEREQ signal has no effect.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC0_ethernet_mac_conf (eMAC0_ethernet_mac_conf); type eMAC.eMAC_ethernet_mac_conf (Ethernet MAC Mode Configuration register)
 */

/*
 * Dump of fields for register: eMAC0_ethernet_mac_conf
 *   _anon0 (size 24, offset 0):	 MBZ	  _
 *   RX16 (size 1, offset 24):	 RO	  Receive 16-bit Client Interface enable. When this bit is 1, the receive data client interface is 16 bits wide. When this bit is 0, the receive data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.
 *   TX16 (size 1, offset 25):	 RO	  Transmit 16-bit Client Interface enable. When this bit is 1, the transmit data client interface is 16 bits wide. When this bit is 0, the transmit data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.
 *   HOST (size 1, offset 26):	 RO	  Host Interface enable. When this bit is 1, the host interface is enabled. When this bit is 0, the host interface is disabled.
 *   GPCS (size 1, offset 27):	 RO	  1000BASE-X mode enable. When this bit is 1, the Ethernet MAC is configured in 1000BASE-X mode.
 *   SGMII (size 1, offset 28):	 RO	  SGMII mode enable. When this bit is 1, the Ethernet MAC is configured in SGMII mode.
 *   RGMII (size 1, offset 29):	 RO	  RGMII mode enable. When this bit is 1, the Ethernet MAC is configured in RGMII mode.
 *   LINK_SPEED (size 2, offset 30):	 RW	  Speed selection. The speed of the Ethernet MAC is defined by the following values: 10 = 1000 Mb/s, 01 = 100 Mb/s, 00 = 10 Mb/s, 11 = N/A
 */

static inline uint32_t __DP(eMAC0_ethernet_mac_conf_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_ethernet_mac_conf_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x3300));
}

static inline eMAC_eMAC_ethernet_mac_conf_t __DP(eMAC0_ethernet_mac_conf_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_ethernet_mac_conf_t __DP(eMAC0_ethernet_mac_conf_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_ethernet_mac_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3300));
    return u.val;
}

static inline void __DP(eMAC0_ethernet_mac_conf_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_ethernet_mac_conf_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x3300),val);
}

static inline void __DP(eMAC0_ethernet_mac_conf_wr)( __DN(t) * _dev, eMAC_eMAC_ethernet_mac_conf_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_ethernet_mac_conf_wr)( __DN(t) * _dev, eMAC_eMAC_ethernet_mac_conf_t val )
{
    eMAC_eMAC_ethernet_mac_conf_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    mackerel_write_addr_32(_dev->base,(0x3300),u.raw);
}

static inline void __DP(eMAC0_ethernet_mac_conf_LINK_SPEED_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_ethernet_mac_conf_LINK_SPEED_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_ethernet_mac_conf_un  u;
    u.val._anon0 	= 0;
    u.val.LINK_SPEED = val;
    mackerel_write_addr_32(_dev->base,(0x3300),u.raw);
}


static inline int __DP(eMAC0_ethernet_mac_conf_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_ethernet_mac_conf_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_ethernet_mac_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3300));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC0_ethernet_mac_conf (eMAC0_ethernet_mac_conf):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.RX16;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RX16 =\t0x%"PRIx8" (Receive 16-bit Client Interface enable. When this bit is 1, the receive data client interface is 16 bits wide. When this bit is 0, the receive data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.TX16;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " TX16 =\t0x%"PRIx8" (Transmit 16-bit Client Interface enable. When this bit is 1, the transmit data client interface is 16 bits wide. When this bit is 0, the transmit data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.HOST;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " HOST =\t0x%"PRIx8" (Host Interface enable. When this bit is 1, the host interface is enabled. When this bit is 0, the host interface is disabled.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.GPCS;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " GPCS =\t0x%"PRIx8" (1000BASE-X mode enable. When this bit is 1, the Ethernet MAC is configured in 1000BASE-X mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.SGMII;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " SGMII =\t0x%"PRIx8" (SGMII mode enable. When this bit is 1, the Ethernet MAC is configured in SGMII mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.RGMII;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RGMII =\t0x%"PRIx8" (RGMII mode enable. When this bit is 1, the Ethernet MAC is configured in RGMII mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.LINK_SPEED;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " LINK_SPEED =\t0x%"PRIx8" (Speed selection. The speed of the Ethernet MAC is defined by the following values: 10 = 1000 Mb/s, 01 = 100 Mb/s, 00 = 10 Mb/s, 11 = N/A", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_address_filter_mode (eMAC0_address_filter_mode); type eMAC.eMAC_address_filter_mode (Address filter mode Configuration register)
 */

/*
 * Dump of fields for register: eMAC0_address_filter_mode
 *   _anon0 (size 31, offset 0):	 MBZ	  _
 *   PM (size 1, offset 31):	 RW	  Promiscuous Mode enable. When this bit is 1, the Address Filter block is disabled. When this bit is 0, the Address Filter block is enabled.
 */

static inline uint32_t __DP(eMAC0_address_filter_mode_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_address_filter_mode_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x3900));
}

static inline eMAC_eMAC_address_filter_mode_t __DP(eMAC0_address_filter_mode_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_address_filter_mode_t __DP(eMAC0_address_filter_mode_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_address_filter_mode_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3900));
    return u.val;
}

static inline void __DP(eMAC0_address_filter_mode_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_address_filter_mode_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x3900),val);
}

static inline void __DP(eMAC0_address_filter_mode_wr)( __DN(t) * _dev, eMAC_eMAC_address_filter_mode_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_address_filter_mode_wr)( __DN(t) * _dev, eMAC_eMAC_address_filter_mode_t val )
{
    eMAC_eMAC_address_filter_mode_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    mackerel_write_addr_32(_dev->base,(0x3900),u.raw);
}

static inline void __DP(eMAC0_address_filter_mode_PM_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_address_filter_mode_PM_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_address_filter_mode_un  u;
    u.val._anon0 	= 0;
    u.val.PM = val;
    mackerel_write_addr_32(_dev->base,(0x3900),u.raw);
}


static inline int __DP(eMAC0_address_filter_mode_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_address_filter_mode_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_address_filter_mode_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3900));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC0_address_filter_mode (eMAC0_address_filter_mode):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.PM;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " PM =\t0x%"PRIx8" (Promiscuous Mode enable. When this bit is 1, the Address Filter block is disabled. When this bit is 0, the Address Filter block is enabled.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_receiver_conf_0 (eMAC1_receiver_conf_0); type eMAC.eMAC_receiver_conf_0 (Flow control Configuration register (0))
 */

/*
 * Dump of fields for register: eMAC1_receiver_conf_0
 *   PAUSE_FRAME_ADDR_LOW (size 32, offset 0):	 RW	  Pause Frame Ethernet MAC Address [31:0]. This address is used to match the Ethernet MAC against the destination address of any incoming flow control frames. It is also used by the flow control block as the source address for any outbound flow control frames. The address is ordered so the first byte transmitted/received is the lowest positioned byte in the register; for example, a MAC address of AA-BB-CC-DD-EE-FF is stored in address [47:0] as 0xFFEEDDCCBBAA.
 */

static inline uint32_t __DP(eMAC1_receiver_conf_0_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_receiver_conf_0_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4200));
}

static inline eMAC_eMAC_receiver_conf_0_t __DP(eMAC1_receiver_conf_0_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_receiver_conf_0_t __DP(eMAC1_receiver_conf_0_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_receiver_conf_0_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4200));
    return u.val;
}

static inline void __DP(eMAC1_receiver_conf_0_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_receiver_conf_0_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x4200),val);
}

static inline void __DP(eMAC1_receiver_conf_0_wr)( __DN(t) * _dev, eMAC_eMAC_receiver_conf_0_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_receiver_conf_0_wr)( __DN(t) * _dev, eMAC_eMAC_receiver_conf_0_t val )
{
    eMAC_eMAC_receiver_conf_0_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0x4200),u.raw);
}

static inline void __DP(eMAC1_receiver_conf_0_PAUSE_FRAME_ADDR_LOW_wrf)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_receiver_conf_0_PAUSE_FRAME_ADDR_LOW_wrf)( __DN(t) * _dev, uint32_t val )
{
    eMAC_eMAC_receiver_conf_0_un  u;
    u.val.PAUSE_FRAME_ADDR_LOW = val;
    mackerel_write_addr_32(_dev->base,(0x4200),u.raw);
}


static inline int __DP(eMAC1_receiver_conf_0_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_receiver_conf_0_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_receiver_conf_0_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4200));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC1_receiver_conf_0 (eMAC1_receiver_conf_0):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.PAUSE_FRAME_ADDR_LOW;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " PAUSE_FRAME_ADDR_LOW =\t0x%0"PRIx32" (Pause Frame Ethernet MAC Address [31:0]. This address is used to match the Ethernet MAC against the destination address of any incoming flow control frames. It is also used by the flow control block as the source address for any outbound flow control frames. The address is ordered so the first byte transmitted/received is the lowest positioned byte in the register; for example, a MAC address of AA-BB-CC-DD-EE-FF is stored in address [47:0] as 0xFFEEDDCCBBAA.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_receiver_conf_1 (eMAC1_receiver_conf_1); type eMAC.eMAC_receiver_conf_1 (Flow control Configuration register (1))
 */

/*
 * Dump of fields for register: eMAC1_receiver_conf_1
 *   PAUSE_FRAME_ADDR_LOW (size 16, offset 0):	 RW	  Pause frame Ethernet MAC Address [47:32].
 *   _anon16 (size 9, offset 16):	 MBZ	  _
 *   LT_DIS (size 1, offset 25):	 RW	  Length/Type Check disable. When this bit is 1, it disables the Length/Type field check on the frame.
 *   HD (size 1, offset 26):	 RW	  Half-duplex mode. When this bit is 1, the receiver operates in half-duplex mode. When the bit is 0, the receiver operates in full-duplex mode.
 *   VLAN (size 1, offset 27):	 RW	  VLAN enable. When this bit is 1, the receiver accepts VLAN tagged frames. The maximum payload length increases by four bytes.
 *   RX (size 1, offset 28):	 RW	  Receive enable. When this bit is 1, the receiver block is enabled to operate. When the bit is 0, the receiver ignores activity on the physical interface receive port.
 *   FCS (size 1, offset 29):	 RW	  In-band FCS enable. When this bit is 1, the receiver passes the FCS field up to the client. When this bit is 0, the FCS field is not passed to the client. In either case, the FCS is verified on the frame.
 *   JUM (size 1, offset 30):	 RW	  Jumbo frame enable. When this bit is 1, the Ethernet MAC receiver accepts frames over the maximum length specified in IEEE Std 802.3-2002 specification. When this bit is 0, the receiver only accepts frames up to the specified maximum.
 *   RST (size 1, offset 31):	 RW	  Reset. When this bit is 1, the receiver is reset. The bit automatically reverts to 0. This reset also sets all of the receiver configuration registers to their default values.
 */

static inline uint32_t __DP(eMAC1_receiver_conf_1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_receiver_conf_1_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4240));
}

static inline eMAC_eMAC_receiver_conf_1_t __DP(eMAC1_receiver_conf_1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_receiver_conf_1_t __DP(eMAC1_receiver_conf_1_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4240));
    return u.val;
}

static inline void __DP(eMAC1_receiver_conf_1_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_receiver_conf_1_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x4240),val);
}

static inline void __DP(eMAC1_receiver_conf_1_wr)( __DN(t) * _dev, eMAC_eMAC_receiver_conf_1_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_receiver_conf_1_wr)( __DN(t) * _dev, eMAC_eMAC_receiver_conf_1_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x4240),u.raw);
}

static inline void __DP(eMAC1_receiver_conf_1_PAUSE_FRAME_ADDR_LOW_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_receiver_conf_1_PAUSE_FRAME_ADDR_LOW_wrf)( __DN(t) * _dev, uint16_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4240));
    u.val._anon16 	= 0;
    u.val.PAUSE_FRAME_ADDR_LOW = val;
    mackerel_write_addr_32(_dev->base,(0x4240),u.raw);
}

static inline void __DP(eMAC1_receiver_conf_1_LT_DIS_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_receiver_conf_1_LT_DIS_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4240));
    u.val._anon16 	= 0;
    u.val.LT_DIS = val;
    mackerel_write_addr_32(_dev->base,(0x4240),u.raw);
}

static inline void __DP(eMAC1_receiver_conf_1_HD_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_receiver_conf_1_HD_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4240));
    u.val._anon16 	= 0;
    u.val.HD = val;
    mackerel_write_addr_32(_dev->base,(0x4240),u.raw);
}

static inline void __DP(eMAC1_receiver_conf_1_VLAN_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_receiver_conf_1_VLAN_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4240));
    u.val._anon16 	= 0;
    u.val.VLAN = val;
    mackerel_write_addr_32(_dev->base,(0x4240),u.raw);
}

static inline void __DP(eMAC1_receiver_conf_1_RX_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_receiver_conf_1_RX_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4240));
    u.val._anon16 	= 0;
    u.val.RX = val;
    mackerel_write_addr_32(_dev->base,(0x4240),u.raw);
}

static inline void __DP(eMAC1_receiver_conf_1_FCS_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_receiver_conf_1_FCS_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4240));
    u.val._anon16 	= 0;
    u.val.FCS = val;
    mackerel_write_addr_32(_dev->base,(0x4240),u.raw);
}

static inline void __DP(eMAC1_receiver_conf_1_JUM_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_receiver_conf_1_JUM_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4240));
    u.val._anon16 	= 0;
    u.val.JUM = val;
    mackerel_write_addr_32(_dev->base,(0x4240),u.raw);
}

static inline void __DP(eMAC1_receiver_conf_1_RST_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_receiver_conf_1_RST_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4240));
    u.val._anon16 	= 0;
    u.val.RST = val;
    mackerel_write_addr_32(_dev->base,(0x4240),u.raw);
}


static inline int __DP(eMAC1_receiver_conf_1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_receiver_conf_1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4240));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC1_receiver_conf_1 (eMAC1_receiver_conf_1):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.PAUSE_FRAME_ADDR_LOW;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " PAUSE_FRAME_ADDR_LOW =\t0x%0"PRIx16" (Pause frame Ethernet MAC Address [47:32].", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.LT_DIS;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " LT_DIS =\t0x%"PRIx8" (Length/Type Check disable. When this bit is 1, it disables the Length/Type field check on the frame.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.HD;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " HD =\t0x%"PRIx8" (Half-duplex mode. When this bit is 1, the receiver operates in half-duplex mode. When the bit is 0, the receiver operates in full-duplex mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.VLAN;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " VLAN =\t0x%"PRIx8" (VLAN enable. When this bit is 1, the receiver accepts VLAN tagged frames. The maximum payload length increases by four bytes.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.RX;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RX =\t0x%"PRIx8" (Receive enable. When this bit is 1, the receiver block is enabled to operate. When the bit is 0, the receiver ignores activity on the physical interface receive port.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.FCS;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " FCS =\t0x%"PRIx8" (In-band FCS enable. When this bit is 1, the receiver passes the FCS field up to the client. When this bit is 0, the FCS field is not passed to the client. In either case, the FCS is verified on the frame.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.JUM;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " JUM =\t0x%"PRIx8" (Jumbo frame enable. When this bit is 1, the Ethernet MAC receiver accepts frames over the maximum length specified in IEEE Std 802.3-2002 specification. When this bit is 0, the receiver only accepts frames up to the specified maximum.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.RST;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RST =\t0x%"PRIx8" (Reset. When this bit is 1, the receiver is reset. The bit automatically reverts to 0. This reset also sets all of the receiver configuration registers to their default values.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_transmiter_conf (eMAC1_transmiter_conf); type eMAC.eMAC_transmiter_conf (eMAC Transmiter Configuration register)
 */

/*
 * Dump of fields for register: eMAC1_transmiter_conf
 *   _anon0 (size 25, offset 0):	 MBZ	  _
 *   IFG (size 1, offset 25):	 RW	  IFG adjustment enable. When this bit is 1, the transmitter reads the value of CLIENTEMAC#TXIFGDELAY at the start of frame transmission and adjusts the IFG.
 *   HD (size 1, offset 26):	 RW	  Half-duplex mode (applicable in 10/100 Mb/s mode only). When this bit is 1, the transmitter operates in half-duplex mode. When this bit is 0, the transmitter operates in full-duplex mode.
 *   VLAN (size 1, offset 27):	 RW	  VLAN enable. When this bit is 1, the transmitter allows transmission of the VLAN tagged frames.
 *   TX (size 1, offset 28):	 RW	  Transmit enable. When this bit is 1, the transmitter is enabled for operation.
 *   FCS (size 1, offset 29):	 RW	  In-band FCS enable. When this bit is 1, the Ethernet MAC transmitter is ready for the FCS field from the client.
 *   JUM (size 1, offset 30):	 RW	  Jumbo frame enable. When this bit is 1, the transmitter sends frames greater than the maximum length specified in IEEE Std 802.3-2002. When this bit is 0, it only sends frames less than the specified maximum length.
 *   RST (size 1, offset 31):	 RW	  Reset. When this bit is 1, the transmitter is reset. The bit automatically reverts to 0. This reset also sets all of the transmitter configuration registers to their default values.
 */

static inline uint32_t __DP(eMAC1_transmiter_conf_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_transmiter_conf_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4280));
}

static inline eMAC_eMAC_transmiter_conf_t __DP(eMAC1_transmiter_conf_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_transmiter_conf_t __DP(eMAC1_transmiter_conf_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4280));
    return u.val;
}

static inline void __DP(eMAC1_transmiter_conf_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_transmiter_conf_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x4280),val);
}

static inline void __DP(eMAC1_transmiter_conf_wr)( __DN(t) * _dev, eMAC_eMAC_transmiter_conf_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_transmiter_conf_wr)( __DN(t) * _dev, eMAC_eMAC_transmiter_conf_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    mackerel_write_addr_32(_dev->base,(0x4280),u.raw);
}

static inline void __DP(eMAC1_transmiter_conf_IFG_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_transmiter_conf_IFG_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4280));
    u.val._anon0 	= 0;
    u.val.IFG = val;
    mackerel_write_addr_32(_dev->base,(0x4280),u.raw);
}

static inline void __DP(eMAC1_transmiter_conf_HD_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_transmiter_conf_HD_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4280));
    u.val._anon0 	= 0;
    u.val.HD = val;
    mackerel_write_addr_32(_dev->base,(0x4280),u.raw);
}

static inline void __DP(eMAC1_transmiter_conf_VLAN_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_transmiter_conf_VLAN_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4280));
    u.val._anon0 	= 0;
    u.val.VLAN = val;
    mackerel_write_addr_32(_dev->base,(0x4280),u.raw);
}

static inline void __DP(eMAC1_transmiter_conf_TX_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_transmiter_conf_TX_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4280));
    u.val._anon0 	= 0;
    u.val.TX = val;
    mackerel_write_addr_32(_dev->base,(0x4280),u.raw);
}

static inline void __DP(eMAC1_transmiter_conf_FCS_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_transmiter_conf_FCS_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4280));
    u.val._anon0 	= 0;
    u.val.FCS = val;
    mackerel_write_addr_32(_dev->base,(0x4280),u.raw);
}

static inline void __DP(eMAC1_transmiter_conf_JUM_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_transmiter_conf_JUM_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4280));
    u.val._anon0 	= 0;
    u.val.JUM = val;
    mackerel_write_addr_32(_dev->base,(0x4280),u.raw);
}

static inline void __DP(eMAC1_transmiter_conf_RST_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_transmiter_conf_RST_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4280));
    u.val._anon0 	= 0;
    u.val.RST = val;
    mackerel_write_addr_32(_dev->base,(0x4280),u.raw);
}


static inline int __DP(eMAC1_transmiter_conf_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_transmiter_conf_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4280));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC1_transmiter_conf (eMAC1_transmiter_conf):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.IFG;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " IFG =\t0x%"PRIx8" (IFG adjustment enable. When this bit is 1, the transmitter reads the value of CLIENTEMAC#TXIFGDELAY at the start of frame transmission and adjusts the IFG.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.HD;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " HD =\t0x%"PRIx8" (Half-duplex mode (applicable in 10/100 Mb/s mode only). When this bit is 1, the transmitter operates in half-duplex mode. When this bit is 0, the transmitter operates in full-duplex mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.VLAN;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " VLAN =\t0x%"PRIx8" (VLAN enable. When this bit is 1, the transmitter allows transmission of the VLAN tagged frames.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.TX;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " TX =\t0x%"PRIx8" (Transmit enable. When this bit is 1, the transmitter is enabled for operation.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.FCS;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " FCS =\t0x%"PRIx8" (In-band FCS enable. When this bit is 1, the Ethernet MAC transmitter is ready for the FCS field from the client.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.JUM;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " JUM =\t0x%"PRIx8" (Jumbo frame enable. When this bit is 1, the transmitter sends frames greater than the maximum length specified in IEEE Std 802.3-2002. When this bit is 0, it only sends frames less than the specified maximum length.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.RST;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RST =\t0x%"PRIx8" (Reset. When this bit is 1, the transmitter is reset. The bit automatically reverts to 0. This reset also sets all of the transmitter configuration registers to their default values.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_flow_control_conf (eMAC1_flow_control_conf); type eMAC.eMAC_flow_control_conf (Flow control Configuration register)
 */

/*
 * Dump of fields for register: eMAC1_flow_control_conf
 *   _anon0 (size 29, offset 0):	 MBZ	  _
 *   RX_FC_enable (size 1, offset 29):	 RW	  Flow control enable (RX). When this bit is 1, the received flow control frames inhibit transmitter operation. When this bit is 0, the flow control frame is passed to the client.
 *   TX_FC_enable (size 1, offset 30):	 RW	  Flow control enable (TX). When this bit is 1, the CLIENTEMAC#PAUSEREQ signal is asserted and a flow control frame is sent from the transmitter. When this bit is 0, the CLIENTEMAC#PAUSEREQ signal has no effect.
 *   _anon31 (size 1, offset 31):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC1_flow_control_conf_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_flow_control_conf_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x42c0));
}

static inline eMAC_eMAC_flow_control_conf_t __DP(eMAC1_flow_control_conf_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_flow_control_conf_t __DP(eMAC1_flow_control_conf_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_flow_control_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x42c0));
    return u.val;
}

static inline void __DP(eMAC1_flow_control_conf_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_flow_control_conf_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x42c0),val);
}

static inline void __DP(eMAC1_flow_control_conf_wr)( __DN(t) * _dev, eMAC_eMAC_flow_control_conf_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_flow_control_conf_wr)( __DN(t) * _dev, eMAC_eMAC_flow_control_conf_t val )
{
    eMAC_eMAC_flow_control_conf_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    u.val._anon31 	= 0;
    mackerel_write_addr_32(_dev->base,(0x42c0),u.raw);
}

static inline void __DP(eMAC1_flow_control_conf_RX_FC_enable_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_flow_control_conf_RX_FC_enable_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_flow_control_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x42c0));
    u.val._anon0 	= 0;
    u.val._anon31 	= 0;
    u.val.RX_FC_enable = val;
    mackerel_write_addr_32(_dev->base,(0x42c0),u.raw);
}

static inline void __DP(eMAC1_flow_control_conf_TX_FC_enable_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_flow_control_conf_TX_FC_enable_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_flow_control_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x42c0));
    u.val._anon0 	= 0;
    u.val._anon31 	= 0;
    u.val.TX_FC_enable = val;
    mackerel_write_addr_32(_dev->base,(0x42c0),u.raw);
}


static inline int __DP(eMAC1_flow_control_conf_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_flow_control_conf_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_flow_control_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x42c0));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC1_flow_control_conf (eMAC1_flow_control_conf):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.RX_FC_enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RX_FC_enable =\t0x%"PRIx8" (Flow control enable (RX). When this bit is 1, the received flow control frames inhibit transmitter operation. When this bit is 0, the flow control frame is passed to the client.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.TX_FC_enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " TX_FC_enable =\t0x%"PRIx8" (Flow control enable (TX). When this bit is 1, the CLIENTEMAC#PAUSEREQ signal is asserted and a flow control frame is sent from the transmitter. When this bit is 0, the CLIENTEMAC#PAUSEREQ signal has no effect.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC1_ethernet_mac_conf (eMAC1_ethernet_mac_conf); type eMAC.eMAC_ethernet_mac_conf (Ethernet MAC Mode Configuration register)
 */

/*
 * Dump of fields for register: eMAC1_ethernet_mac_conf
 *   _anon0 (size 24, offset 0):	 MBZ	  _
 *   RX16 (size 1, offset 24):	 RO	  Receive 16-bit Client Interface enable. When this bit is 1, the receive data client interface is 16 bits wide. When this bit is 0, the receive data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.
 *   TX16 (size 1, offset 25):	 RO	  Transmit 16-bit Client Interface enable. When this bit is 1, the transmit data client interface is 16 bits wide. When this bit is 0, the transmit data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.
 *   HOST (size 1, offset 26):	 RO	  Host Interface enable. When this bit is 1, the host interface is enabled. When this bit is 0, the host interface is disabled.
 *   GPCS (size 1, offset 27):	 RO	  1000BASE-X mode enable. When this bit is 1, the Ethernet MAC is configured in 1000BASE-X mode.
 *   SGMII (size 1, offset 28):	 RO	  SGMII mode enable. When this bit is 1, the Ethernet MAC is configured in SGMII mode.
 *   RGMII (size 1, offset 29):	 RO	  RGMII mode enable. When this bit is 1, the Ethernet MAC is configured in RGMII mode.
 *   LINK_SPEED (size 2, offset 30):	 RW	  Speed selection. The speed of the Ethernet MAC is defined by the following values: 10 = 1000 Mb/s, 01 = 100 Mb/s, 00 = 10 Mb/s, 11 = N/A
 */

static inline uint32_t __DP(eMAC1_ethernet_mac_conf_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_ethernet_mac_conf_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4300));
}

static inline eMAC_eMAC_ethernet_mac_conf_t __DP(eMAC1_ethernet_mac_conf_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_ethernet_mac_conf_t __DP(eMAC1_ethernet_mac_conf_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_ethernet_mac_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4300));
    return u.val;
}

static inline void __DP(eMAC1_ethernet_mac_conf_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_ethernet_mac_conf_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x4300),val);
}

static inline void __DP(eMAC1_ethernet_mac_conf_wr)( __DN(t) * _dev, eMAC_eMAC_ethernet_mac_conf_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_ethernet_mac_conf_wr)( __DN(t) * _dev, eMAC_eMAC_ethernet_mac_conf_t val )
{
    eMAC_eMAC_ethernet_mac_conf_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    mackerel_write_addr_32(_dev->base,(0x4300),u.raw);
}

static inline void __DP(eMAC1_ethernet_mac_conf_LINK_SPEED_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_ethernet_mac_conf_LINK_SPEED_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_ethernet_mac_conf_un  u;
    u.val._anon0 	= 0;
    u.val.LINK_SPEED = val;
    mackerel_write_addr_32(_dev->base,(0x4300),u.raw);
}


static inline int __DP(eMAC1_ethernet_mac_conf_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_ethernet_mac_conf_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_ethernet_mac_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4300));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC1_ethernet_mac_conf (eMAC1_ethernet_mac_conf):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.RX16;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RX16 =\t0x%"PRIx8" (Receive 16-bit Client Interface enable. When this bit is 1, the receive data client interface is 16 bits wide. When this bit is 0, the receive data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.TX16;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " TX16 =\t0x%"PRIx8" (Transmit 16-bit Client Interface enable. When this bit is 1, the transmit data client interface is 16 bits wide. When this bit is 0, the transmit data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.HOST;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " HOST =\t0x%"PRIx8" (Host Interface enable. When this bit is 1, the host interface is enabled. When this bit is 0, the host interface is disabled.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.GPCS;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " GPCS =\t0x%"PRIx8" (1000BASE-X mode enable. When this bit is 1, the Ethernet MAC is configured in 1000BASE-X mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.SGMII;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " SGMII =\t0x%"PRIx8" (SGMII mode enable. When this bit is 1, the Ethernet MAC is configured in SGMII mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.RGMII;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RGMII =\t0x%"PRIx8" (RGMII mode enable. When this bit is 1, the Ethernet MAC is configured in RGMII mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.LINK_SPEED;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " LINK_SPEED =\t0x%"PRIx8" (Speed selection. The speed of the Ethernet MAC is defined by the following values: 10 = 1000 Mb/s, 01 = 100 Mb/s, 00 = 10 Mb/s, 11 = N/A", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_address_filter_mode (eMAC1_address_filter_mode); type eMAC.eMAC_address_filter_mode (Address filter mode Configuration register)
 */

/*
 * Dump of fields for register: eMAC1_address_filter_mode
 *   _anon0 (size 31, offset 0):	 MBZ	  _
 *   PM (size 1, offset 31):	 RW	  Promiscuous Mode enable. When this bit is 1, the Address Filter block is disabled. When this bit is 0, the Address Filter block is enabled.
 */

static inline uint32_t __DP(eMAC1_address_filter_mode_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_address_filter_mode_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4900));
}

static inline eMAC_eMAC_address_filter_mode_t __DP(eMAC1_address_filter_mode_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_address_filter_mode_t __DP(eMAC1_address_filter_mode_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_address_filter_mode_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4900));
    return u.val;
}

static inline void __DP(eMAC1_address_filter_mode_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_address_filter_mode_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x4900),val);
}

static inline void __DP(eMAC1_address_filter_mode_wr)( __DN(t) * _dev, eMAC_eMAC_address_filter_mode_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_address_filter_mode_wr)( __DN(t) * _dev, eMAC_eMAC_address_filter_mode_t val )
{
    eMAC_eMAC_address_filter_mode_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    mackerel_write_addr_32(_dev->base,(0x4900),u.raw);
}

static inline void __DP(eMAC1_address_filter_mode_PM_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_address_filter_mode_PM_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_address_filter_mode_un  u;
    u.val._anon0 	= 0;
    u.val.PM = val;
    mackerel_write_addr_32(_dev->base,(0x4900),u.raw);
}


static inline int __DP(eMAC1_address_filter_mode_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_address_filter_mode_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_address_filter_mode_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x4900));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC1_address_filter_mode (eMAC1_address_filter_mode):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.PM;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " PM =\t0x%"PRIx8" (Promiscuous Mode enable. When this bit is 1, the Address Filter block is disabled. When this bit is 0, the Address Filter block is enabled.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_receiver_conf_0 (eMAC2_receiver_conf_0); type eMAC.eMAC_receiver_conf_0 (Flow control Configuration register (0))
 */

/*
 * Dump of fields for register: eMAC2_receiver_conf_0
 *   PAUSE_FRAME_ADDR_LOW (size 32, offset 0):	 RW	  Pause Frame Ethernet MAC Address [31:0]. This address is used to match the Ethernet MAC against the destination address of any incoming flow control frames. It is also used by the flow control block as the source address for any outbound flow control frames. The address is ordered so the first byte transmitted/received is the lowest positioned byte in the register; for example, a MAC address of AA-BB-CC-DD-EE-FF is stored in address [47:0] as 0xFFEEDDCCBBAA.
 */

static inline uint32_t __DP(eMAC2_receiver_conf_0_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_receiver_conf_0_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5200));
}

static inline eMAC_eMAC_receiver_conf_0_t __DP(eMAC2_receiver_conf_0_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_receiver_conf_0_t __DP(eMAC2_receiver_conf_0_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_receiver_conf_0_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5200));
    return u.val;
}

static inline void __DP(eMAC2_receiver_conf_0_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_receiver_conf_0_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5200),val);
}

static inline void __DP(eMAC2_receiver_conf_0_wr)( __DN(t) * _dev, eMAC_eMAC_receiver_conf_0_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_receiver_conf_0_wr)( __DN(t) * _dev, eMAC_eMAC_receiver_conf_0_t val )
{
    eMAC_eMAC_receiver_conf_0_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0x5200),u.raw);
}

static inline void __DP(eMAC2_receiver_conf_0_PAUSE_FRAME_ADDR_LOW_wrf)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_receiver_conf_0_PAUSE_FRAME_ADDR_LOW_wrf)( __DN(t) * _dev, uint32_t val )
{
    eMAC_eMAC_receiver_conf_0_un  u;
    u.val.PAUSE_FRAME_ADDR_LOW = val;
    mackerel_write_addr_32(_dev->base,(0x5200),u.raw);
}


static inline int __DP(eMAC2_receiver_conf_0_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_receiver_conf_0_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_receiver_conf_0_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5200));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC2_receiver_conf_0 (eMAC2_receiver_conf_0):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.PAUSE_FRAME_ADDR_LOW;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " PAUSE_FRAME_ADDR_LOW =\t0x%0"PRIx32" (Pause Frame Ethernet MAC Address [31:0]. This address is used to match the Ethernet MAC against the destination address of any incoming flow control frames. It is also used by the flow control block as the source address for any outbound flow control frames. The address is ordered so the first byte transmitted/received is the lowest positioned byte in the register; for example, a MAC address of AA-BB-CC-DD-EE-FF is stored in address [47:0] as 0xFFEEDDCCBBAA.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_receiver_conf_1 (eMAC2_receiver_conf_1); type eMAC.eMAC_receiver_conf_1 (Flow control Configuration register (1))
 */

/*
 * Dump of fields for register: eMAC2_receiver_conf_1
 *   PAUSE_FRAME_ADDR_LOW (size 16, offset 0):	 RW	  Pause frame Ethernet MAC Address [47:32].
 *   _anon16 (size 9, offset 16):	 MBZ	  _
 *   LT_DIS (size 1, offset 25):	 RW	  Length/Type Check disable. When this bit is 1, it disables the Length/Type field check on the frame.
 *   HD (size 1, offset 26):	 RW	  Half-duplex mode. When this bit is 1, the receiver operates in half-duplex mode. When the bit is 0, the receiver operates in full-duplex mode.
 *   VLAN (size 1, offset 27):	 RW	  VLAN enable. When this bit is 1, the receiver accepts VLAN tagged frames. The maximum payload length increases by four bytes.
 *   RX (size 1, offset 28):	 RW	  Receive enable. When this bit is 1, the receiver block is enabled to operate. When the bit is 0, the receiver ignores activity on the physical interface receive port.
 *   FCS (size 1, offset 29):	 RW	  In-band FCS enable. When this bit is 1, the receiver passes the FCS field up to the client. When this bit is 0, the FCS field is not passed to the client. In either case, the FCS is verified on the frame.
 *   JUM (size 1, offset 30):	 RW	  Jumbo frame enable. When this bit is 1, the Ethernet MAC receiver accepts frames over the maximum length specified in IEEE Std 802.3-2002 specification. When this bit is 0, the receiver only accepts frames up to the specified maximum.
 *   RST (size 1, offset 31):	 RW	  Reset. When this bit is 1, the receiver is reset. The bit automatically reverts to 0. This reset also sets all of the receiver configuration registers to their default values.
 */

static inline uint32_t __DP(eMAC2_receiver_conf_1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_receiver_conf_1_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5240));
}

static inline eMAC_eMAC_receiver_conf_1_t __DP(eMAC2_receiver_conf_1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_receiver_conf_1_t __DP(eMAC2_receiver_conf_1_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5240));
    return u.val;
}

static inline void __DP(eMAC2_receiver_conf_1_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_receiver_conf_1_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5240),val);
}

static inline void __DP(eMAC2_receiver_conf_1_wr)( __DN(t) * _dev, eMAC_eMAC_receiver_conf_1_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_receiver_conf_1_wr)( __DN(t) * _dev, eMAC_eMAC_receiver_conf_1_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x5240),u.raw);
}

static inline void __DP(eMAC2_receiver_conf_1_PAUSE_FRAME_ADDR_LOW_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_receiver_conf_1_PAUSE_FRAME_ADDR_LOW_wrf)( __DN(t) * _dev, uint16_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5240));
    u.val._anon16 	= 0;
    u.val.PAUSE_FRAME_ADDR_LOW = val;
    mackerel_write_addr_32(_dev->base,(0x5240),u.raw);
}

static inline void __DP(eMAC2_receiver_conf_1_LT_DIS_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_receiver_conf_1_LT_DIS_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5240));
    u.val._anon16 	= 0;
    u.val.LT_DIS = val;
    mackerel_write_addr_32(_dev->base,(0x5240),u.raw);
}

static inline void __DP(eMAC2_receiver_conf_1_HD_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_receiver_conf_1_HD_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5240));
    u.val._anon16 	= 0;
    u.val.HD = val;
    mackerel_write_addr_32(_dev->base,(0x5240),u.raw);
}

static inline void __DP(eMAC2_receiver_conf_1_VLAN_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_receiver_conf_1_VLAN_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5240));
    u.val._anon16 	= 0;
    u.val.VLAN = val;
    mackerel_write_addr_32(_dev->base,(0x5240),u.raw);
}

static inline void __DP(eMAC2_receiver_conf_1_RX_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_receiver_conf_1_RX_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5240));
    u.val._anon16 	= 0;
    u.val.RX = val;
    mackerel_write_addr_32(_dev->base,(0x5240),u.raw);
}

static inline void __DP(eMAC2_receiver_conf_1_FCS_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_receiver_conf_1_FCS_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5240));
    u.val._anon16 	= 0;
    u.val.FCS = val;
    mackerel_write_addr_32(_dev->base,(0x5240),u.raw);
}

static inline void __DP(eMAC2_receiver_conf_1_JUM_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_receiver_conf_1_JUM_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5240));
    u.val._anon16 	= 0;
    u.val.JUM = val;
    mackerel_write_addr_32(_dev->base,(0x5240),u.raw);
}

static inline void __DP(eMAC2_receiver_conf_1_RST_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_receiver_conf_1_RST_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5240));
    u.val._anon16 	= 0;
    u.val.RST = val;
    mackerel_write_addr_32(_dev->base,(0x5240),u.raw);
}


static inline int __DP(eMAC2_receiver_conf_1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_receiver_conf_1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5240));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC2_receiver_conf_1 (eMAC2_receiver_conf_1):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.PAUSE_FRAME_ADDR_LOW;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " PAUSE_FRAME_ADDR_LOW =\t0x%0"PRIx16" (Pause frame Ethernet MAC Address [47:32].", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.LT_DIS;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " LT_DIS =\t0x%"PRIx8" (Length/Type Check disable. When this bit is 1, it disables the Length/Type field check on the frame.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.HD;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " HD =\t0x%"PRIx8" (Half-duplex mode. When this bit is 1, the receiver operates in half-duplex mode. When the bit is 0, the receiver operates in full-duplex mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.VLAN;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " VLAN =\t0x%"PRIx8" (VLAN enable. When this bit is 1, the receiver accepts VLAN tagged frames. The maximum payload length increases by four bytes.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.RX;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RX =\t0x%"PRIx8" (Receive enable. When this bit is 1, the receiver block is enabled to operate. When the bit is 0, the receiver ignores activity on the physical interface receive port.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.FCS;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " FCS =\t0x%"PRIx8" (In-band FCS enable. When this bit is 1, the receiver passes the FCS field up to the client. When this bit is 0, the FCS field is not passed to the client. In either case, the FCS is verified on the frame.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.JUM;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " JUM =\t0x%"PRIx8" (Jumbo frame enable. When this bit is 1, the Ethernet MAC receiver accepts frames over the maximum length specified in IEEE Std 802.3-2002 specification. When this bit is 0, the receiver only accepts frames up to the specified maximum.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.RST;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RST =\t0x%"PRIx8" (Reset. When this bit is 1, the receiver is reset. The bit automatically reverts to 0. This reset also sets all of the receiver configuration registers to their default values.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_transmiter_conf (eMAC2_transmiter_conf); type eMAC.eMAC_transmiter_conf (eMAC Transmiter Configuration register)
 */

/*
 * Dump of fields for register: eMAC2_transmiter_conf
 *   _anon0 (size 25, offset 0):	 MBZ	  _
 *   IFG (size 1, offset 25):	 RW	  IFG adjustment enable. When this bit is 1, the transmitter reads the value of CLIENTEMAC#TXIFGDELAY at the start of frame transmission and adjusts the IFG.
 *   HD (size 1, offset 26):	 RW	  Half-duplex mode (applicable in 10/100 Mb/s mode only). When this bit is 1, the transmitter operates in half-duplex mode. When this bit is 0, the transmitter operates in full-duplex mode.
 *   VLAN (size 1, offset 27):	 RW	  VLAN enable. When this bit is 1, the transmitter allows transmission of the VLAN tagged frames.
 *   TX (size 1, offset 28):	 RW	  Transmit enable. When this bit is 1, the transmitter is enabled for operation.
 *   FCS (size 1, offset 29):	 RW	  In-band FCS enable. When this bit is 1, the Ethernet MAC transmitter is ready for the FCS field from the client.
 *   JUM (size 1, offset 30):	 RW	  Jumbo frame enable. When this bit is 1, the transmitter sends frames greater than the maximum length specified in IEEE Std 802.3-2002. When this bit is 0, it only sends frames less than the specified maximum length.
 *   RST (size 1, offset 31):	 RW	  Reset. When this bit is 1, the transmitter is reset. The bit automatically reverts to 0. This reset also sets all of the transmitter configuration registers to their default values.
 */

static inline uint32_t __DP(eMAC2_transmiter_conf_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_transmiter_conf_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5280));
}

static inline eMAC_eMAC_transmiter_conf_t __DP(eMAC2_transmiter_conf_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_transmiter_conf_t __DP(eMAC2_transmiter_conf_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5280));
    return u.val;
}

static inline void __DP(eMAC2_transmiter_conf_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_transmiter_conf_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5280),val);
}

static inline void __DP(eMAC2_transmiter_conf_wr)( __DN(t) * _dev, eMAC_eMAC_transmiter_conf_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_transmiter_conf_wr)( __DN(t) * _dev, eMAC_eMAC_transmiter_conf_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    mackerel_write_addr_32(_dev->base,(0x5280),u.raw);
}

static inline void __DP(eMAC2_transmiter_conf_IFG_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_transmiter_conf_IFG_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5280));
    u.val._anon0 	= 0;
    u.val.IFG = val;
    mackerel_write_addr_32(_dev->base,(0x5280),u.raw);
}

static inline void __DP(eMAC2_transmiter_conf_HD_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_transmiter_conf_HD_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5280));
    u.val._anon0 	= 0;
    u.val.HD = val;
    mackerel_write_addr_32(_dev->base,(0x5280),u.raw);
}

static inline void __DP(eMAC2_transmiter_conf_VLAN_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_transmiter_conf_VLAN_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5280));
    u.val._anon0 	= 0;
    u.val.VLAN = val;
    mackerel_write_addr_32(_dev->base,(0x5280),u.raw);
}

static inline void __DP(eMAC2_transmiter_conf_TX_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_transmiter_conf_TX_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5280));
    u.val._anon0 	= 0;
    u.val.TX = val;
    mackerel_write_addr_32(_dev->base,(0x5280),u.raw);
}

static inline void __DP(eMAC2_transmiter_conf_FCS_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_transmiter_conf_FCS_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5280));
    u.val._anon0 	= 0;
    u.val.FCS = val;
    mackerel_write_addr_32(_dev->base,(0x5280),u.raw);
}

static inline void __DP(eMAC2_transmiter_conf_JUM_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_transmiter_conf_JUM_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5280));
    u.val._anon0 	= 0;
    u.val.JUM = val;
    mackerel_write_addr_32(_dev->base,(0x5280),u.raw);
}

static inline void __DP(eMAC2_transmiter_conf_RST_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_transmiter_conf_RST_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5280));
    u.val._anon0 	= 0;
    u.val.RST = val;
    mackerel_write_addr_32(_dev->base,(0x5280),u.raw);
}


static inline int __DP(eMAC2_transmiter_conf_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_transmiter_conf_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5280));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC2_transmiter_conf (eMAC2_transmiter_conf):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.IFG;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " IFG =\t0x%"PRIx8" (IFG adjustment enable. When this bit is 1, the transmitter reads the value of CLIENTEMAC#TXIFGDELAY at the start of frame transmission and adjusts the IFG.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.HD;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " HD =\t0x%"PRIx8" (Half-duplex mode (applicable in 10/100 Mb/s mode only). When this bit is 1, the transmitter operates in half-duplex mode. When this bit is 0, the transmitter operates in full-duplex mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.VLAN;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " VLAN =\t0x%"PRIx8" (VLAN enable. When this bit is 1, the transmitter allows transmission of the VLAN tagged frames.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.TX;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " TX =\t0x%"PRIx8" (Transmit enable. When this bit is 1, the transmitter is enabled for operation.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.FCS;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " FCS =\t0x%"PRIx8" (In-band FCS enable. When this bit is 1, the Ethernet MAC transmitter is ready for the FCS field from the client.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.JUM;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " JUM =\t0x%"PRIx8" (Jumbo frame enable. When this bit is 1, the transmitter sends frames greater than the maximum length specified in IEEE Std 802.3-2002. When this bit is 0, it only sends frames less than the specified maximum length.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.RST;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RST =\t0x%"PRIx8" (Reset. When this bit is 1, the transmitter is reset. The bit automatically reverts to 0. This reset also sets all of the transmitter configuration registers to their default values.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_flow_control_conf (eMAC2_flow_control_conf); type eMAC.eMAC_flow_control_conf (Flow control Configuration register)
 */

/*
 * Dump of fields for register: eMAC2_flow_control_conf
 *   _anon0 (size 29, offset 0):	 MBZ	  _
 *   RX_FC_enable (size 1, offset 29):	 RW	  Flow control enable (RX). When this bit is 1, the received flow control frames inhibit transmitter operation. When this bit is 0, the flow control frame is passed to the client.
 *   TX_FC_enable (size 1, offset 30):	 RW	  Flow control enable (TX). When this bit is 1, the CLIENTEMAC#PAUSEREQ signal is asserted and a flow control frame is sent from the transmitter. When this bit is 0, the CLIENTEMAC#PAUSEREQ signal has no effect.
 *   _anon31 (size 1, offset 31):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC2_flow_control_conf_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_flow_control_conf_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x52c0));
}

static inline eMAC_eMAC_flow_control_conf_t __DP(eMAC2_flow_control_conf_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_flow_control_conf_t __DP(eMAC2_flow_control_conf_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_flow_control_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x52c0));
    return u.val;
}

static inline void __DP(eMAC2_flow_control_conf_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_flow_control_conf_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x52c0),val);
}

static inline void __DP(eMAC2_flow_control_conf_wr)( __DN(t) * _dev, eMAC_eMAC_flow_control_conf_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_flow_control_conf_wr)( __DN(t) * _dev, eMAC_eMAC_flow_control_conf_t val )
{
    eMAC_eMAC_flow_control_conf_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    u.val._anon31 	= 0;
    mackerel_write_addr_32(_dev->base,(0x52c0),u.raw);
}

static inline void __DP(eMAC2_flow_control_conf_RX_FC_enable_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_flow_control_conf_RX_FC_enable_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_flow_control_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x52c0));
    u.val._anon0 	= 0;
    u.val._anon31 	= 0;
    u.val.RX_FC_enable = val;
    mackerel_write_addr_32(_dev->base,(0x52c0),u.raw);
}

static inline void __DP(eMAC2_flow_control_conf_TX_FC_enable_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_flow_control_conf_TX_FC_enable_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_flow_control_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x52c0));
    u.val._anon0 	= 0;
    u.val._anon31 	= 0;
    u.val.TX_FC_enable = val;
    mackerel_write_addr_32(_dev->base,(0x52c0),u.raw);
}


static inline int __DP(eMAC2_flow_control_conf_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_flow_control_conf_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_flow_control_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x52c0));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC2_flow_control_conf (eMAC2_flow_control_conf):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.RX_FC_enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RX_FC_enable =\t0x%"PRIx8" (Flow control enable (RX). When this bit is 1, the received flow control frames inhibit transmitter operation. When this bit is 0, the flow control frame is passed to the client.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.TX_FC_enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " TX_FC_enable =\t0x%"PRIx8" (Flow control enable (TX). When this bit is 1, the CLIENTEMAC#PAUSEREQ signal is asserted and a flow control frame is sent from the transmitter. When this bit is 0, the CLIENTEMAC#PAUSEREQ signal has no effect.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC2_ethernet_mac_conf (eMAC2_ethernet_mac_conf); type eMAC.eMAC_ethernet_mac_conf (Ethernet MAC Mode Configuration register)
 */

/*
 * Dump of fields for register: eMAC2_ethernet_mac_conf
 *   _anon0 (size 24, offset 0):	 MBZ	  _
 *   RX16 (size 1, offset 24):	 RO	  Receive 16-bit Client Interface enable. When this bit is 1, the receive data client interface is 16 bits wide. When this bit is 0, the receive data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.
 *   TX16 (size 1, offset 25):	 RO	  Transmit 16-bit Client Interface enable. When this bit is 1, the transmit data client interface is 16 bits wide. When this bit is 0, the transmit data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.
 *   HOST (size 1, offset 26):	 RO	  Host Interface enable. When this bit is 1, the host interface is enabled. When this bit is 0, the host interface is disabled.
 *   GPCS (size 1, offset 27):	 RO	  1000BASE-X mode enable. When this bit is 1, the Ethernet MAC is configured in 1000BASE-X mode.
 *   SGMII (size 1, offset 28):	 RO	  SGMII mode enable. When this bit is 1, the Ethernet MAC is configured in SGMII mode.
 *   RGMII (size 1, offset 29):	 RO	  RGMII mode enable. When this bit is 1, the Ethernet MAC is configured in RGMII mode.
 *   LINK_SPEED (size 2, offset 30):	 RW	  Speed selection. The speed of the Ethernet MAC is defined by the following values: 10 = 1000 Mb/s, 01 = 100 Mb/s, 00 = 10 Mb/s, 11 = N/A
 */

static inline uint32_t __DP(eMAC2_ethernet_mac_conf_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_ethernet_mac_conf_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5300));
}

static inline eMAC_eMAC_ethernet_mac_conf_t __DP(eMAC2_ethernet_mac_conf_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_ethernet_mac_conf_t __DP(eMAC2_ethernet_mac_conf_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_ethernet_mac_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5300));
    return u.val;
}

static inline void __DP(eMAC2_ethernet_mac_conf_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_ethernet_mac_conf_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5300),val);
}

static inline void __DP(eMAC2_ethernet_mac_conf_wr)( __DN(t) * _dev, eMAC_eMAC_ethernet_mac_conf_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_ethernet_mac_conf_wr)( __DN(t) * _dev, eMAC_eMAC_ethernet_mac_conf_t val )
{
    eMAC_eMAC_ethernet_mac_conf_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    mackerel_write_addr_32(_dev->base,(0x5300),u.raw);
}

static inline void __DP(eMAC2_ethernet_mac_conf_LINK_SPEED_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_ethernet_mac_conf_LINK_SPEED_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_ethernet_mac_conf_un  u;
    u.val._anon0 	= 0;
    u.val.LINK_SPEED = val;
    mackerel_write_addr_32(_dev->base,(0x5300),u.raw);
}


static inline int __DP(eMAC2_ethernet_mac_conf_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_ethernet_mac_conf_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_ethernet_mac_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5300));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC2_ethernet_mac_conf (eMAC2_ethernet_mac_conf):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.RX16;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RX16 =\t0x%"PRIx8" (Receive 16-bit Client Interface enable. When this bit is 1, the receive data client interface is 16 bits wide. When this bit is 0, the receive data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.TX16;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " TX16 =\t0x%"PRIx8" (Transmit 16-bit Client Interface enable. When this bit is 1, the transmit data client interface is 16 bits wide. When this bit is 0, the transmit data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.HOST;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " HOST =\t0x%"PRIx8" (Host Interface enable. When this bit is 1, the host interface is enabled. When this bit is 0, the host interface is disabled.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.GPCS;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " GPCS =\t0x%"PRIx8" (1000BASE-X mode enable. When this bit is 1, the Ethernet MAC is configured in 1000BASE-X mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.SGMII;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " SGMII =\t0x%"PRIx8" (SGMII mode enable. When this bit is 1, the Ethernet MAC is configured in SGMII mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.RGMII;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RGMII =\t0x%"PRIx8" (RGMII mode enable. When this bit is 1, the Ethernet MAC is configured in RGMII mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.LINK_SPEED;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " LINK_SPEED =\t0x%"PRIx8" (Speed selection. The speed of the Ethernet MAC is defined by the following values: 10 = 1000 Mb/s, 01 = 100 Mb/s, 00 = 10 Mb/s, 11 = N/A", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_address_filter_mode (eMAC2_address_filter_mode); type eMAC.eMAC_address_filter_mode (Address filter mode Configuration register)
 */

/*
 * Dump of fields for register: eMAC2_address_filter_mode
 *   _anon0 (size 31, offset 0):	 MBZ	  _
 *   PM (size 1, offset 31):	 RW	  Promiscuous Mode enable. When this bit is 1, the Address Filter block is disabled. When this bit is 0, the Address Filter block is enabled.
 */

static inline uint32_t __DP(eMAC2_address_filter_mode_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_address_filter_mode_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x5900));
}

static inline eMAC_eMAC_address_filter_mode_t __DP(eMAC2_address_filter_mode_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_address_filter_mode_t __DP(eMAC2_address_filter_mode_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_address_filter_mode_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5900));
    return u.val;
}

static inline void __DP(eMAC2_address_filter_mode_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_address_filter_mode_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x5900),val);
}

static inline void __DP(eMAC2_address_filter_mode_wr)( __DN(t) * _dev, eMAC_eMAC_address_filter_mode_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_address_filter_mode_wr)( __DN(t) * _dev, eMAC_eMAC_address_filter_mode_t val )
{
    eMAC_eMAC_address_filter_mode_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    mackerel_write_addr_32(_dev->base,(0x5900),u.raw);
}

static inline void __DP(eMAC2_address_filter_mode_PM_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_address_filter_mode_PM_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_address_filter_mode_un  u;
    u.val._anon0 	= 0;
    u.val.PM = val;
    mackerel_write_addr_32(_dev->base,(0x5900),u.raw);
}


static inline int __DP(eMAC2_address_filter_mode_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_address_filter_mode_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_address_filter_mode_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x5900));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC2_address_filter_mode (eMAC2_address_filter_mode):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.PM;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " PM =\t0x%"PRIx8" (Promiscuous Mode enable. When this bit is 1, the Address Filter block is disabled. When this bit is 0, the Address Filter block is enabled.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_receiver_conf_0 (eMAC3_receiver_conf_0); type eMAC.eMAC_receiver_conf_0 (Flow control Configuration register (0))
 */

/*
 * Dump of fields for register: eMAC3_receiver_conf_0
 *   PAUSE_FRAME_ADDR_LOW (size 32, offset 0):	 RW	  Pause Frame Ethernet MAC Address [31:0]. This address is used to match the Ethernet MAC against the destination address of any incoming flow control frames. It is also used by the flow control block as the source address for any outbound flow control frames. The address is ordered so the first byte transmitted/received is the lowest positioned byte in the register; for example, a MAC address of AA-BB-CC-DD-EE-FF is stored in address [47:0] as 0xFFEEDDCCBBAA.
 */

static inline uint32_t __DP(eMAC3_receiver_conf_0_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_receiver_conf_0_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x6200));
}

static inline eMAC_eMAC_receiver_conf_0_t __DP(eMAC3_receiver_conf_0_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_receiver_conf_0_t __DP(eMAC3_receiver_conf_0_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_receiver_conf_0_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6200));
    return u.val;
}

static inline void __DP(eMAC3_receiver_conf_0_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_receiver_conf_0_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x6200),val);
}

static inline void __DP(eMAC3_receiver_conf_0_wr)( __DN(t) * _dev, eMAC_eMAC_receiver_conf_0_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_receiver_conf_0_wr)( __DN(t) * _dev, eMAC_eMAC_receiver_conf_0_t val )
{
    eMAC_eMAC_receiver_conf_0_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0x6200),u.raw);
}

static inline void __DP(eMAC3_receiver_conf_0_PAUSE_FRAME_ADDR_LOW_wrf)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_receiver_conf_0_PAUSE_FRAME_ADDR_LOW_wrf)( __DN(t) * _dev, uint32_t val )
{
    eMAC_eMAC_receiver_conf_0_un  u;
    u.val.PAUSE_FRAME_ADDR_LOW = val;
    mackerel_write_addr_32(_dev->base,(0x6200),u.raw);
}


static inline int __DP(eMAC3_receiver_conf_0_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_receiver_conf_0_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_receiver_conf_0_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6200));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC3_receiver_conf_0 (eMAC3_receiver_conf_0):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.PAUSE_FRAME_ADDR_LOW;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " PAUSE_FRAME_ADDR_LOW =\t0x%0"PRIx32" (Pause Frame Ethernet MAC Address [31:0]. This address is used to match the Ethernet MAC against the destination address of any incoming flow control frames. It is also used by the flow control block as the source address for any outbound flow control frames. The address is ordered so the first byte transmitted/received is the lowest positioned byte in the register; for example, a MAC address of AA-BB-CC-DD-EE-FF is stored in address [47:0] as 0xFFEEDDCCBBAA.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_receiver_conf_1 (eMAC3_receiver_conf_1); type eMAC.eMAC_receiver_conf_1 (Flow control Configuration register (1))
 */

/*
 * Dump of fields for register: eMAC3_receiver_conf_1
 *   PAUSE_FRAME_ADDR_LOW (size 16, offset 0):	 RW	  Pause frame Ethernet MAC Address [47:32].
 *   _anon16 (size 9, offset 16):	 MBZ	  _
 *   LT_DIS (size 1, offset 25):	 RW	  Length/Type Check disable. When this bit is 1, it disables the Length/Type field check on the frame.
 *   HD (size 1, offset 26):	 RW	  Half-duplex mode. When this bit is 1, the receiver operates in half-duplex mode. When the bit is 0, the receiver operates in full-duplex mode.
 *   VLAN (size 1, offset 27):	 RW	  VLAN enable. When this bit is 1, the receiver accepts VLAN tagged frames. The maximum payload length increases by four bytes.
 *   RX (size 1, offset 28):	 RW	  Receive enable. When this bit is 1, the receiver block is enabled to operate. When the bit is 0, the receiver ignores activity on the physical interface receive port.
 *   FCS (size 1, offset 29):	 RW	  In-band FCS enable. When this bit is 1, the receiver passes the FCS field up to the client. When this bit is 0, the FCS field is not passed to the client. In either case, the FCS is verified on the frame.
 *   JUM (size 1, offset 30):	 RW	  Jumbo frame enable. When this bit is 1, the Ethernet MAC receiver accepts frames over the maximum length specified in IEEE Std 802.3-2002 specification. When this bit is 0, the receiver only accepts frames up to the specified maximum.
 *   RST (size 1, offset 31):	 RW	  Reset. When this bit is 1, the receiver is reset. The bit automatically reverts to 0. This reset also sets all of the receiver configuration registers to their default values.
 */

static inline uint32_t __DP(eMAC3_receiver_conf_1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_receiver_conf_1_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x6240));
}

static inline eMAC_eMAC_receiver_conf_1_t __DP(eMAC3_receiver_conf_1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_receiver_conf_1_t __DP(eMAC3_receiver_conf_1_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6240));
    return u.val;
}

static inline void __DP(eMAC3_receiver_conf_1_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_receiver_conf_1_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x6240),val);
}

static inline void __DP(eMAC3_receiver_conf_1_wr)( __DN(t) * _dev, eMAC_eMAC_receiver_conf_1_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_receiver_conf_1_wr)( __DN(t) * _dev, eMAC_eMAC_receiver_conf_1_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x6240),u.raw);
}

static inline void __DP(eMAC3_receiver_conf_1_PAUSE_FRAME_ADDR_LOW_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_receiver_conf_1_PAUSE_FRAME_ADDR_LOW_wrf)( __DN(t) * _dev, uint16_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6240));
    u.val._anon16 	= 0;
    u.val.PAUSE_FRAME_ADDR_LOW = val;
    mackerel_write_addr_32(_dev->base,(0x6240),u.raw);
}

static inline void __DP(eMAC3_receiver_conf_1_LT_DIS_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_receiver_conf_1_LT_DIS_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6240));
    u.val._anon16 	= 0;
    u.val.LT_DIS = val;
    mackerel_write_addr_32(_dev->base,(0x6240),u.raw);
}

static inline void __DP(eMAC3_receiver_conf_1_HD_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_receiver_conf_1_HD_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6240));
    u.val._anon16 	= 0;
    u.val.HD = val;
    mackerel_write_addr_32(_dev->base,(0x6240),u.raw);
}

static inline void __DP(eMAC3_receiver_conf_1_VLAN_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_receiver_conf_1_VLAN_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6240));
    u.val._anon16 	= 0;
    u.val.VLAN = val;
    mackerel_write_addr_32(_dev->base,(0x6240),u.raw);
}

static inline void __DP(eMAC3_receiver_conf_1_RX_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_receiver_conf_1_RX_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6240));
    u.val._anon16 	= 0;
    u.val.RX = val;
    mackerel_write_addr_32(_dev->base,(0x6240),u.raw);
}

static inline void __DP(eMAC3_receiver_conf_1_FCS_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_receiver_conf_1_FCS_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6240));
    u.val._anon16 	= 0;
    u.val.FCS = val;
    mackerel_write_addr_32(_dev->base,(0x6240),u.raw);
}

static inline void __DP(eMAC3_receiver_conf_1_JUM_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_receiver_conf_1_JUM_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6240));
    u.val._anon16 	= 0;
    u.val.JUM = val;
    mackerel_write_addr_32(_dev->base,(0x6240),u.raw);
}

static inline void __DP(eMAC3_receiver_conf_1_RST_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_receiver_conf_1_RST_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6240));
    u.val._anon16 	= 0;
    u.val.RST = val;
    mackerel_write_addr_32(_dev->base,(0x6240),u.raw);
}


static inline int __DP(eMAC3_receiver_conf_1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_receiver_conf_1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_receiver_conf_1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6240));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC3_receiver_conf_1 (eMAC3_receiver_conf_1):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.PAUSE_FRAME_ADDR_LOW;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " PAUSE_FRAME_ADDR_LOW =\t0x%0"PRIx16" (Pause frame Ethernet MAC Address [47:32].", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.LT_DIS;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " LT_DIS =\t0x%"PRIx8" (Length/Type Check disable. When this bit is 1, it disables the Length/Type field check on the frame.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.HD;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " HD =\t0x%"PRIx8" (Half-duplex mode. When this bit is 1, the receiver operates in half-duplex mode. When the bit is 0, the receiver operates in full-duplex mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.VLAN;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " VLAN =\t0x%"PRIx8" (VLAN enable. When this bit is 1, the receiver accepts VLAN tagged frames. The maximum payload length increases by four bytes.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.RX;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RX =\t0x%"PRIx8" (Receive enable. When this bit is 1, the receiver block is enabled to operate. When the bit is 0, the receiver ignores activity on the physical interface receive port.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.FCS;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " FCS =\t0x%"PRIx8" (In-band FCS enable. When this bit is 1, the receiver passes the FCS field up to the client. When this bit is 0, the FCS field is not passed to the client. In either case, the FCS is verified on the frame.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.JUM;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " JUM =\t0x%"PRIx8" (Jumbo frame enable. When this bit is 1, the Ethernet MAC receiver accepts frames over the maximum length specified in IEEE Std 802.3-2002 specification. When this bit is 0, the receiver only accepts frames up to the specified maximum.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.RST;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RST =\t0x%"PRIx8" (Reset. When this bit is 1, the receiver is reset. The bit automatically reverts to 0. This reset also sets all of the receiver configuration registers to their default values.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_transmiter_conf (eMAC3_transmiter_conf); type eMAC.eMAC_transmiter_conf (eMAC Transmiter Configuration register)
 */

/*
 * Dump of fields for register: eMAC3_transmiter_conf
 *   _anon0 (size 25, offset 0):	 MBZ	  _
 *   IFG (size 1, offset 25):	 RW	  IFG adjustment enable. When this bit is 1, the transmitter reads the value of CLIENTEMAC#TXIFGDELAY at the start of frame transmission and adjusts the IFG.
 *   HD (size 1, offset 26):	 RW	  Half-duplex mode (applicable in 10/100 Mb/s mode only). When this bit is 1, the transmitter operates in half-duplex mode. When this bit is 0, the transmitter operates in full-duplex mode.
 *   VLAN (size 1, offset 27):	 RW	  VLAN enable. When this bit is 1, the transmitter allows transmission of the VLAN tagged frames.
 *   TX (size 1, offset 28):	 RW	  Transmit enable. When this bit is 1, the transmitter is enabled for operation.
 *   FCS (size 1, offset 29):	 RW	  In-band FCS enable. When this bit is 1, the Ethernet MAC transmitter is ready for the FCS field from the client.
 *   JUM (size 1, offset 30):	 RW	  Jumbo frame enable. When this bit is 1, the transmitter sends frames greater than the maximum length specified in IEEE Std 802.3-2002. When this bit is 0, it only sends frames less than the specified maximum length.
 *   RST (size 1, offset 31):	 RW	  Reset. When this bit is 1, the transmitter is reset. The bit automatically reverts to 0. This reset also sets all of the transmitter configuration registers to their default values.
 */

static inline uint32_t __DP(eMAC3_transmiter_conf_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_transmiter_conf_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x6280));
}

static inline eMAC_eMAC_transmiter_conf_t __DP(eMAC3_transmiter_conf_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_transmiter_conf_t __DP(eMAC3_transmiter_conf_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6280));
    return u.val;
}

static inline void __DP(eMAC3_transmiter_conf_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_transmiter_conf_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x6280),val);
}

static inline void __DP(eMAC3_transmiter_conf_wr)( __DN(t) * _dev, eMAC_eMAC_transmiter_conf_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_transmiter_conf_wr)( __DN(t) * _dev, eMAC_eMAC_transmiter_conf_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    mackerel_write_addr_32(_dev->base,(0x6280),u.raw);
}

static inline void __DP(eMAC3_transmiter_conf_IFG_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_transmiter_conf_IFG_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6280));
    u.val._anon0 	= 0;
    u.val.IFG = val;
    mackerel_write_addr_32(_dev->base,(0x6280),u.raw);
}

static inline void __DP(eMAC3_transmiter_conf_HD_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_transmiter_conf_HD_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6280));
    u.val._anon0 	= 0;
    u.val.HD = val;
    mackerel_write_addr_32(_dev->base,(0x6280),u.raw);
}

static inline void __DP(eMAC3_transmiter_conf_VLAN_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_transmiter_conf_VLAN_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6280));
    u.val._anon0 	= 0;
    u.val.VLAN = val;
    mackerel_write_addr_32(_dev->base,(0x6280),u.raw);
}

static inline void __DP(eMAC3_transmiter_conf_TX_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_transmiter_conf_TX_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6280));
    u.val._anon0 	= 0;
    u.val.TX = val;
    mackerel_write_addr_32(_dev->base,(0x6280),u.raw);
}

static inline void __DP(eMAC3_transmiter_conf_FCS_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_transmiter_conf_FCS_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6280));
    u.val._anon0 	= 0;
    u.val.FCS = val;
    mackerel_write_addr_32(_dev->base,(0x6280),u.raw);
}

static inline void __DP(eMAC3_transmiter_conf_JUM_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_transmiter_conf_JUM_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6280));
    u.val._anon0 	= 0;
    u.val.JUM = val;
    mackerel_write_addr_32(_dev->base,(0x6280),u.raw);
}

static inline void __DP(eMAC3_transmiter_conf_RST_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_transmiter_conf_RST_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6280));
    u.val._anon0 	= 0;
    u.val.RST = val;
    mackerel_write_addr_32(_dev->base,(0x6280),u.raw);
}


static inline int __DP(eMAC3_transmiter_conf_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_transmiter_conf_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_transmiter_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6280));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC3_transmiter_conf (eMAC3_transmiter_conf):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.IFG;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " IFG =\t0x%"PRIx8" (IFG adjustment enable. When this bit is 1, the transmitter reads the value of CLIENTEMAC#TXIFGDELAY at the start of frame transmission and adjusts the IFG.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.HD;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " HD =\t0x%"PRIx8" (Half-duplex mode (applicable in 10/100 Mb/s mode only). When this bit is 1, the transmitter operates in half-duplex mode. When this bit is 0, the transmitter operates in full-duplex mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.VLAN;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " VLAN =\t0x%"PRIx8" (VLAN enable. When this bit is 1, the transmitter allows transmission of the VLAN tagged frames.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.TX;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " TX =\t0x%"PRIx8" (Transmit enable. When this bit is 1, the transmitter is enabled for operation.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.FCS;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " FCS =\t0x%"PRIx8" (In-band FCS enable. When this bit is 1, the Ethernet MAC transmitter is ready for the FCS field from the client.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.JUM;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " JUM =\t0x%"PRIx8" (Jumbo frame enable. When this bit is 1, the transmitter sends frames greater than the maximum length specified in IEEE Std 802.3-2002. When this bit is 0, it only sends frames less than the specified maximum length.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.RST;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RST =\t0x%"PRIx8" (Reset. When this bit is 1, the transmitter is reset. The bit automatically reverts to 0. This reset also sets all of the transmitter configuration registers to their default values.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_flow_control_conf (eMAC3_flow_control_conf); type eMAC.eMAC_flow_control_conf (Flow control Configuration register)
 */

/*
 * Dump of fields for register: eMAC3_flow_control_conf
 *   _anon0 (size 29, offset 0):	 MBZ	  _
 *   RX_FC_enable (size 1, offset 29):	 RW	  Flow control enable (RX). When this bit is 1, the received flow control frames inhibit transmitter operation. When this bit is 0, the flow control frame is passed to the client.
 *   TX_FC_enable (size 1, offset 30):	 RW	  Flow control enable (TX). When this bit is 1, the CLIENTEMAC#PAUSEREQ signal is asserted and a flow control frame is sent from the transmitter. When this bit is 0, the CLIENTEMAC#PAUSEREQ signal has no effect.
 *   _anon31 (size 1, offset 31):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC3_flow_control_conf_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_flow_control_conf_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x62c0));
}

static inline eMAC_eMAC_flow_control_conf_t __DP(eMAC3_flow_control_conf_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_flow_control_conf_t __DP(eMAC3_flow_control_conf_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_flow_control_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x62c0));
    return u.val;
}

static inline void __DP(eMAC3_flow_control_conf_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_flow_control_conf_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x62c0),val);
}

static inline void __DP(eMAC3_flow_control_conf_wr)( __DN(t) * _dev, eMAC_eMAC_flow_control_conf_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_flow_control_conf_wr)( __DN(t) * _dev, eMAC_eMAC_flow_control_conf_t val )
{
    eMAC_eMAC_flow_control_conf_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    u.val._anon31 	= 0;
    mackerel_write_addr_32(_dev->base,(0x62c0),u.raw);
}

static inline void __DP(eMAC3_flow_control_conf_RX_FC_enable_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_flow_control_conf_RX_FC_enable_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_flow_control_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x62c0));
    u.val._anon0 	= 0;
    u.val._anon31 	= 0;
    u.val.RX_FC_enable = val;
    mackerel_write_addr_32(_dev->base,(0x62c0),u.raw);
}

static inline void __DP(eMAC3_flow_control_conf_TX_FC_enable_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_flow_control_conf_TX_FC_enable_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_flow_control_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x62c0));
    u.val._anon0 	= 0;
    u.val._anon31 	= 0;
    u.val.TX_FC_enable = val;
    mackerel_write_addr_32(_dev->base,(0x62c0),u.raw);
}


static inline int __DP(eMAC3_flow_control_conf_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_flow_control_conf_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_flow_control_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x62c0));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC3_flow_control_conf (eMAC3_flow_control_conf):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.RX_FC_enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RX_FC_enable =\t0x%"PRIx8" (Flow control enable (RX). When this bit is 1, the received flow control frames inhibit transmitter operation. When this bit is 0, the flow control frame is passed to the client.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.TX_FC_enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " TX_FC_enable =\t0x%"PRIx8" (Flow control enable (TX). When this bit is 1, the CLIENTEMAC#PAUSEREQ signal is asserted and a flow control frame is sent from the transmitter. When this bit is 0, the CLIENTEMAC#PAUSEREQ signal has no effect.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC3_ethernet_mac_conf (eMAC3_ethernet_mac_conf); type eMAC.eMAC_ethernet_mac_conf (Ethernet MAC Mode Configuration register)
 */

/*
 * Dump of fields for register: eMAC3_ethernet_mac_conf
 *   _anon0 (size 24, offset 0):	 MBZ	  _
 *   RX16 (size 1, offset 24):	 RO	  Receive 16-bit Client Interface enable. When this bit is 1, the receive data client interface is 16 bits wide. When this bit is 0, the receive data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.
 *   TX16 (size 1, offset 25):	 RO	  Transmit 16-bit Client Interface enable. When this bit is 1, the transmit data client interface is 16 bits wide. When this bit is 0, the transmit data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.
 *   HOST (size 1, offset 26):	 RO	  Host Interface enable. When this bit is 1, the host interface is enabled. When this bit is 0, the host interface is disabled.
 *   GPCS (size 1, offset 27):	 RO	  1000BASE-X mode enable. When this bit is 1, the Ethernet MAC is configured in 1000BASE-X mode.
 *   SGMII (size 1, offset 28):	 RO	  SGMII mode enable. When this bit is 1, the Ethernet MAC is configured in SGMII mode.
 *   RGMII (size 1, offset 29):	 RO	  RGMII mode enable. When this bit is 1, the Ethernet MAC is configured in RGMII mode.
 *   LINK_SPEED (size 2, offset 30):	 RW	  Speed selection. The speed of the Ethernet MAC is defined by the following values: 10 = 1000 Mb/s, 01 = 100 Mb/s, 00 = 10 Mb/s, 11 = N/A
 */

static inline uint32_t __DP(eMAC3_ethernet_mac_conf_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_ethernet_mac_conf_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x6300));
}

static inline eMAC_eMAC_ethernet_mac_conf_t __DP(eMAC3_ethernet_mac_conf_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_ethernet_mac_conf_t __DP(eMAC3_ethernet_mac_conf_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_ethernet_mac_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6300));
    return u.val;
}

static inline void __DP(eMAC3_ethernet_mac_conf_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_ethernet_mac_conf_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x6300),val);
}

static inline void __DP(eMAC3_ethernet_mac_conf_wr)( __DN(t) * _dev, eMAC_eMAC_ethernet_mac_conf_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_ethernet_mac_conf_wr)( __DN(t) * _dev, eMAC_eMAC_ethernet_mac_conf_t val )
{
    eMAC_eMAC_ethernet_mac_conf_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    mackerel_write_addr_32(_dev->base,(0x6300),u.raw);
}

static inline void __DP(eMAC3_ethernet_mac_conf_LINK_SPEED_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_ethernet_mac_conf_LINK_SPEED_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_ethernet_mac_conf_un  u;
    u.val._anon0 	= 0;
    u.val.LINK_SPEED = val;
    mackerel_write_addr_32(_dev->base,(0x6300),u.raw);
}


static inline int __DP(eMAC3_ethernet_mac_conf_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_ethernet_mac_conf_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_ethernet_mac_conf_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6300));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC3_ethernet_mac_conf (eMAC3_ethernet_mac_conf):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.RX16;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RX16 =\t0x%"PRIx8" (Receive 16-bit Client Interface enable. When this bit is 1, the receive data client interface is 16 bits wide. When this bit is 0, the receive data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.TX16;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " TX16 =\t0x%"PRIx8" (Transmit 16-bit Client Interface enable. When this bit is 1, the transmit data client interface is 16 bits wide. When this bit is 0, the transmit data client interface is 8 bits wide. This bit is valid only when using 1000BASE-X PCS/PMA mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.HOST;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " HOST =\t0x%"PRIx8" (Host Interface enable. When this bit is 1, the host interface is enabled. When this bit is 0, the host interface is disabled.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.GPCS;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " GPCS =\t0x%"PRIx8" (1000BASE-X mode enable. When this bit is 1, the Ethernet MAC is configured in 1000BASE-X mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.SGMII;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " SGMII =\t0x%"PRIx8" (SGMII mode enable. When this bit is 1, the Ethernet MAC is configured in SGMII mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.RGMII;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " RGMII =\t0x%"PRIx8" (RGMII mode enable. When this bit is 1, the Ethernet MAC is configured in RGMII mode.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.LINK_SPEED;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " LINK_SPEED =\t0x%"PRIx8" (Speed selection. The speed of the Ethernet MAC is defined by the following values: 10 = 1000 Mb/s, 01 = 100 Mb/s, 00 = 10 Mb/s, 11 = N/A", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_address_filter_mode (eMAC3_address_filter_mode); type eMAC.eMAC_address_filter_mode (Address filter mode Configuration register)
 */

/*
 * Dump of fields for register: eMAC3_address_filter_mode
 *   _anon0 (size 31, offset 0):	 MBZ	  _
 *   PM (size 1, offset 31):	 RW	  Promiscuous Mode enable. When this bit is 1, the Address Filter block is disabled. When this bit is 0, the Address Filter block is enabled.
 */

static inline uint32_t __DP(eMAC3_address_filter_mode_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_address_filter_mode_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x6900));
}

static inline eMAC_eMAC_address_filter_mode_t __DP(eMAC3_address_filter_mode_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_address_filter_mode_t __DP(eMAC3_address_filter_mode_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_address_filter_mode_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6900));
    return u.val;
}

static inline void __DP(eMAC3_address_filter_mode_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_address_filter_mode_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x6900),val);
}

static inline void __DP(eMAC3_address_filter_mode_wr)( __DN(t) * _dev, eMAC_eMAC_address_filter_mode_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_address_filter_mode_wr)( __DN(t) * _dev, eMAC_eMAC_address_filter_mode_t val )
{
    eMAC_eMAC_address_filter_mode_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    mackerel_write_addr_32(_dev->base,(0x6900),u.raw);
}

static inline void __DP(eMAC3_address_filter_mode_PM_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_address_filter_mode_PM_wrf)( __DN(t) * _dev, uint8_t val )
{
    eMAC_eMAC_address_filter_mode_un  u;
    u.val._anon0 	= 0;
    u.val.PM = val;
    mackerel_write_addr_32(_dev->base,(0x6900),u.raw);
}


static inline int __DP(eMAC3_address_filter_mode_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_address_filter_mode_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_address_filter_mode_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x6900));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC3_address_filter_mode (eMAC3_address_filter_mode):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.PM;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " PM =\t0x%"PRIx8" (Promiscuous Mode enable. When this bit is 1, the Address Filter block is disabled. When this bit is 0, the Address Filter block is enabled.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_RX_frame_dropped (eMAC0_RX_frame_dropped); type eMAC.RX_frame_dropped (RX Frame Dropped Channel)
 */

/*
 * Dump of fields for register: eMAC0_RX_frame_dropped
 *   status (size 1, offset 0):	 RW	  Set when frame dropped due to RX buffer overflow in DDR3
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
static const int __DP(eMAC0_RX_frame_dropped_length) = 0x2f;
static inline uint32_t __DP(eMAC0_RX_frame_dropped_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_RX_frame_dropped_rd_raw)( __DN(t) * _dev, int _i )
{
    return __DP(one_byte_read_32)(_dev, (0x7000) + (_i));
}

static inline eMAC_RX_frame_dropped_t __DP(eMAC0_RX_frame_dropped_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_frame_dropped_t __DP(eMAC0_RX_frame_dropped_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_frame_dropped_un  u;
    u.raw = __DP(one_byte_read_32)(_dev, (0x7000) + (_i));
    return u.val;
}

static inline void __DP(eMAC0_RX_frame_dropped_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_frame_dropped_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    __DP(one_byte_write_32)(_dev, (0x7000) + (_i),val);
}

static inline void __DP(eMAC0_RX_frame_dropped_wr)( __DN(t) * _dev, int _i, eMAC_RX_frame_dropped_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_frame_dropped_wr)( __DN(t) * _dev, int _i, eMAC_RX_frame_dropped_t val )
{
    eMAC_RX_frame_dropped_un  u;
    u.val = val;
    u.val._anon1 	= 0;
    __DP(one_byte_write_32)(_dev, (0x7000) + (_i),u.raw);
}

static inline void __DP(eMAC0_RX_frame_dropped_status_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_frame_dropped_status_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_frame_dropped_un  u;
    u.val._anon1 	= 0;
    u.val.status = val;
    __DP(one_byte_write_32)(_dev, (0x7000) + (_i),u.raw);
}


static inline int __DP(eMAC0_RX_frame_dropped_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_frame_dropped_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_frame_dropped_un  u;
    u.raw = __DP(one_byte_read_32)(_dev, (0x7000) + (_i));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC0_RX_frame_dropped[%d] (eMAC0_RX_frame_dropped):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (Set when frame dropped due to RX buffer overflow in DDR3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC0_RX_frame_dropped_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_frame_dropped_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2f; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC0_RX_frame_dropped_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_TX_FIFO_BUFF_FULL (eMAC0_TX_FIFO_BUFF_FULL); type eMAC.TX_FIFO_buff_full (TX FIFO buffer full)
 */

/*
 * Dump of fields for register: eMAC0_TX_FIFO_BUFF_FULL
 *   status (size 1, offset 0):	 RO	  Set in case of an overflow of TX fifo buffer in eMAC IP block
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC0_TX_FIFO_BUFF_FULL_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_TX_FIFO_BUFF_FULL_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7030));
}

static inline eMAC_TX_FIFO_buff_full_t __DP(eMAC0_TX_FIFO_BUFF_FULL_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_TX_FIFO_buff_full_t __DP(eMAC0_TX_FIFO_BUFF_FULL_rd)( __DN(t) * _dev )
{
    eMAC_TX_FIFO_buff_full_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7030));
    return u.val;
}

// Register eMAC0_TX_FIFO_BUFF_FULL is not writeable


static inline int __DP(eMAC0_TX_FIFO_BUFF_FULL_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_TX_FIFO_BUFF_FULL_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_FIFO_buff_full_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7030));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC0_TX_FIFO_BUFF_FULL (eMAC0_TX_FIFO_BUFF_FULL):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (Set in case of an overflow of TX fifo buffer in eMAC IP block", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC0_RX_FIFO_BUFF_FULL (eMAC0_RX_FIFO_BUFF_FULL); type eMAC.RX_FIFO_buff_full (RX FIFO buffer full)
 */

/*
 * Dump of fields for register: eMAC0_RX_FIFO_BUFF_FULL
 *   status (size 1, offset 0):	 RO	  Set in case of an overflow of RX fifo buffer in eMAC IP block
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC0_RX_FIFO_BUFF_FULL_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_RX_FIFO_BUFF_FULL_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7034));
}

static inline eMAC_RX_FIFO_buff_full_t __DP(eMAC0_RX_FIFO_BUFF_FULL_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_RX_FIFO_buff_full_t __DP(eMAC0_RX_FIFO_BUFF_FULL_rd)( __DN(t) * _dev )
{
    eMAC_RX_FIFO_buff_full_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7034));
    return u.val;
}

// Register eMAC0_RX_FIFO_BUFF_FULL is not writeable


static inline int __DP(eMAC0_RX_FIFO_BUFF_FULL_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_FIFO_BUFF_FULL_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_FIFO_buff_full_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7034));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC0_RX_FIFO_BUFF_FULL (eMAC0_RX_FIFO_BUFF_FULL):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (Set in case of an overflow of RX fifo buffer in eMAC IP block", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC0_TX_EMAC_NOT_READY (eMAC0_TX_EMAC_NOT_READY); type eMAC.TX_EMAC_Not_Ready (TX EMAC not ready)
 */

/*
 * Dump of fields for register: eMAC0_TX_EMAC_NOT_READY
 *   status (size 1, offset 0):	 RO	  eMAC does not accept frames
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC0_TX_EMAC_NOT_READY_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_TX_EMAC_NOT_READY_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7038));
}

static inline eMAC_TX_EMAC_Not_Ready_t __DP(eMAC0_TX_EMAC_NOT_READY_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_TX_EMAC_Not_Ready_t __DP(eMAC0_TX_EMAC_NOT_READY_rd)( __DN(t) * _dev )
{
    eMAC_TX_EMAC_Not_Ready_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7038));
    return u.val;
}

// Register eMAC0_TX_EMAC_NOT_READY is not writeable


static inline int __DP(eMAC0_TX_EMAC_NOT_READY_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_TX_EMAC_NOT_READY_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_EMAC_Not_Ready_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7038));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC0_TX_EMAC_NOT_READY (eMAC0_TX_EMAC_NOT_READY):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (eMAC does not accept frames", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC0_RX_MAC_ADDR_ERR (eMAC0_RX_MAC_ADDR_ERR); type eMAC.RX_MAC_Addr_Err (RX MAC address error)
 */

/*
 * Dump of fields for register: eMAC0_RX_MAC_ADDR_ERR
 *   status (size 1, offset 0):	 RO	  MAC address not found in table
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC0_RX_MAC_ADDR_ERR_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_RX_MAC_ADDR_ERR_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x703c));
}

static inline eMAC_RX_MAC_Addr_Err_t __DP(eMAC0_RX_MAC_ADDR_ERR_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_RX_MAC_Addr_Err_t __DP(eMAC0_RX_MAC_ADDR_ERR_rd)( __DN(t) * _dev )
{
    eMAC_RX_MAC_Addr_Err_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x703c));
    return u.val;
}

// Register eMAC0_RX_MAC_ADDR_ERR is not writeable


static inline int __DP(eMAC0_RX_MAC_ADDR_ERR_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_MAC_ADDR_ERR_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_MAC_Addr_Err_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x703c));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC0_RX_MAC_ADDR_ERR (eMAC0_RX_MAC_ADDR_ERR):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (MAC address not found in table", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC0_RX_MAC_LOWER (eMAC0_RX_MAC_LOWER); type eMAC.RX_MAC_Lower (RX MAC address lower part)
 */

/*
 * Dump of fields for register: eMAC0_RX_MAC_LOWER
 *   mac_low (size 32, offset 0):	 RO	  Lower 32 bits of MAC address that has not been found
 */

static inline uint32_t __DP(eMAC0_RX_MAC_LOWER_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_RX_MAC_LOWER_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7040));
}

static inline eMAC_RX_MAC_Lower_t __DP(eMAC0_RX_MAC_LOWER_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_RX_MAC_Lower_t __DP(eMAC0_RX_MAC_LOWER_rd)( __DN(t) * _dev )
{
    eMAC_RX_MAC_Lower_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7040));
    return u.val;
}

// Register eMAC0_RX_MAC_LOWER is not writeable


static inline int __DP(eMAC0_RX_MAC_LOWER_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_MAC_LOWER_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_MAC_Lower_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7040));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC0_RX_MAC_LOWER (eMAC0_RX_MAC_LOWER):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.mac_low;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_low =\t0x%0"PRIx32" (Lower 32 bits of MAC address that has not been found", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_RX_MAC_HIGHER (eMAC0_RX_MAC_HIGHER); type eMAC.RX_MAC_Higher (RX MAC address higher part)
 */

/*
 * Dump of fields for register: eMAC0_RX_MAC_HIGHER
 *   mac_high (size 16, offset 0):	 RO	  Upper 16 bits of MAC address that has not been found
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC0_RX_MAC_HIGHER_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_RX_MAC_HIGHER_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7044));
}

static inline eMAC_RX_MAC_Higher_t __DP(eMAC0_RX_MAC_HIGHER_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_RX_MAC_Higher_t __DP(eMAC0_RX_MAC_HIGHER_rd)( __DN(t) * _dev )
{
    eMAC_RX_MAC_Higher_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7044));
    return u.val;
}

// Register eMAC0_RX_MAC_HIGHER is not writeable


static inline int __DP(eMAC0_RX_MAC_HIGHER_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_MAC_HIGHER_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_MAC_Higher_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7044));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC0_RX_MAC_HIGHER (eMAC0_RX_MAC_HIGHER):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.mac_high;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_high =\t0x%0"PRIx16" (Upper 16 bits of MAC address that has not been found", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC1_RX_frame_dropped (eMAC1_RX_frame_dropped); type eMAC.RX_frame_dropped (RX Frame Dropped Channel)
 */

/*
 * Dump of fields for register: eMAC1_RX_frame_dropped
 *   status (size 1, offset 0):	 RW	  Set when frame dropped due to RX buffer overflow in DDR3
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
static const int __DP(eMAC1_RX_frame_dropped_length) = 0x2f;
static inline uint32_t __DP(eMAC1_RX_frame_dropped_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_RX_frame_dropped_rd_raw)( __DN(t) * _dev, int _i )
{
    return __DP(one_byte_read_32)(_dev, (0x7100) + (_i));
}

static inline eMAC_RX_frame_dropped_t __DP(eMAC1_RX_frame_dropped_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_frame_dropped_t __DP(eMAC1_RX_frame_dropped_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_frame_dropped_un  u;
    u.raw = __DP(one_byte_read_32)(_dev, (0x7100) + (_i));
    return u.val;
}

static inline void __DP(eMAC1_RX_frame_dropped_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_frame_dropped_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    __DP(one_byte_write_32)(_dev, (0x7100) + (_i),val);
}

static inline void __DP(eMAC1_RX_frame_dropped_wr)( __DN(t) * _dev, int _i, eMAC_RX_frame_dropped_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_frame_dropped_wr)( __DN(t) * _dev, int _i, eMAC_RX_frame_dropped_t val )
{
    eMAC_RX_frame_dropped_un  u;
    u.val = val;
    u.val._anon1 	= 0;
    __DP(one_byte_write_32)(_dev, (0x7100) + (_i),u.raw);
}

static inline void __DP(eMAC1_RX_frame_dropped_status_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_frame_dropped_status_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_frame_dropped_un  u;
    u.val._anon1 	= 0;
    u.val.status = val;
    __DP(one_byte_write_32)(_dev, (0x7100) + (_i),u.raw);
}


static inline int __DP(eMAC1_RX_frame_dropped_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_frame_dropped_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_frame_dropped_un  u;
    u.raw = __DP(one_byte_read_32)(_dev, (0x7100) + (_i));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC1_RX_frame_dropped[%d] (eMAC1_RX_frame_dropped):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (Set when frame dropped due to RX buffer overflow in DDR3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC1_RX_frame_dropped_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_frame_dropped_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2f; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC1_RX_frame_dropped_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_TX_FIFO_BUFF_FULL (eMAC1_TX_FIFO_BUFF_FULL); type eMAC.TX_FIFO_buff_full (TX FIFO buffer full)
 */

/*
 * Dump of fields for register: eMAC1_TX_FIFO_BUFF_FULL
 *   status (size 1, offset 0):	 RO	  Set in case of an overflow of TX fifo buffer in eMAC IP block
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC1_TX_FIFO_BUFF_FULL_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_TX_FIFO_BUFF_FULL_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7130));
}

static inline eMAC_TX_FIFO_buff_full_t __DP(eMAC1_TX_FIFO_BUFF_FULL_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_TX_FIFO_buff_full_t __DP(eMAC1_TX_FIFO_BUFF_FULL_rd)( __DN(t) * _dev )
{
    eMAC_TX_FIFO_buff_full_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7130));
    return u.val;
}

// Register eMAC1_TX_FIFO_BUFF_FULL is not writeable


static inline int __DP(eMAC1_TX_FIFO_BUFF_FULL_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_TX_FIFO_BUFF_FULL_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_FIFO_buff_full_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7130));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC1_TX_FIFO_BUFF_FULL (eMAC1_TX_FIFO_BUFF_FULL):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (Set in case of an overflow of TX fifo buffer in eMAC IP block", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC1_RX_FIFO_BUFF_FULL (eMAC1_RX_FIFO_BUFF_FULL); type eMAC.RX_FIFO_buff_full (RX FIFO buffer full)
 */

/*
 * Dump of fields for register: eMAC1_RX_FIFO_BUFF_FULL
 *   status (size 1, offset 0):	 RO	  Set in case of an overflow of RX fifo buffer in eMAC IP block
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC1_RX_FIFO_BUFF_FULL_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_RX_FIFO_BUFF_FULL_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7134));
}

static inline eMAC_RX_FIFO_buff_full_t __DP(eMAC1_RX_FIFO_BUFF_FULL_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_RX_FIFO_buff_full_t __DP(eMAC1_RX_FIFO_BUFF_FULL_rd)( __DN(t) * _dev )
{
    eMAC_RX_FIFO_buff_full_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7134));
    return u.val;
}

// Register eMAC1_RX_FIFO_BUFF_FULL is not writeable


static inline int __DP(eMAC1_RX_FIFO_BUFF_FULL_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_FIFO_BUFF_FULL_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_FIFO_buff_full_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7134));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC1_RX_FIFO_BUFF_FULL (eMAC1_RX_FIFO_BUFF_FULL):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (Set in case of an overflow of RX fifo buffer in eMAC IP block", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC1_TX_EMAC_NOT_READY (eMAC1_TX_EMAC_NOT_READY); type eMAC.TX_EMAC_Not_Ready (TX EMAC not ready)
 */

/*
 * Dump of fields for register: eMAC1_TX_EMAC_NOT_READY
 *   status (size 1, offset 0):	 RO	  eMAC does not accept frames
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC1_TX_EMAC_NOT_READY_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_TX_EMAC_NOT_READY_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7138));
}

static inline eMAC_TX_EMAC_Not_Ready_t __DP(eMAC1_TX_EMAC_NOT_READY_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_TX_EMAC_Not_Ready_t __DP(eMAC1_TX_EMAC_NOT_READY_rd)( __DN(t) * _dev )
{
    eMAC_TX_EMAC_Not_Ready_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7138));
    return u.val;
}

// Register eMAC1_TX_EMAC_NOT_READY is not writeable


static inline int __DP(eMAC1_TX_EMAC_NOT_READY_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_TX_EMAC_NOT_READY_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_EMAC_Not_Ready_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7138));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC1_TX_EMAC_NOT_READY (eMAC1_TX_EMAC_NOT_READY):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (eMAC does not accept frames", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC1_RX_MAC_ADDR_ERR (eMAC1_RX_MAC_ADDR_ERR); type eMAC.RX_MAC_Addr_Err (RX MAC address error)
 */

/*
 * Dump of fields for register: eMAC1_RX_MAC_ADDR_ERR
 *   status (size 1, offset 0):	 RO	  MAC address not found in table
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC1_RX_MAC_ADDR_ERR_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_RX_MAC_ADDR_ERR_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x713c));
}

static inline eMAC_RX_MAC_Addr_Err_t __DP(eMAC1_RX_MAC_ADDR_ERR_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_RX_MAC_Addr_Err_t __DP(eMAC1_RX_MAC_ADDR_ERR_rd)( __DN(t) * _dev )
{
    eMAC_RX_MAC_Addr_Err_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x713c));
    return u.val;
}

// Register eMAC1_RX_MAC_ADDR_ERR is not writeable


static inline int __DP(eMAC1_RX_MAC_ADDR_ERR_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_MAC_ADDR_ERR_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_MAC_Addr_Err_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x713c));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC1_RX_MAC_ADDR_ERR (eMAC1_RX_MAC_ADDR_ERR):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (MAC address not found in table", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC1_RX_MAC_LOWER (eMAC1_RX_MAC_LOWER); type eMAC.RX_MAC_Lower (RX MAC address lower part)
 */

/*
 * Dump of fields for register: eMAC1_RX_MAC_LOWER
 *   mac_low (size 32, offset 0):	 RO	  Lower 32 bits of MAC address that has not been found
 */

static inline uint32_t __DP(eMAC1_RX_MAC_LOWER_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_RX_MAC_LOWER_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7140));
}

static inline eMAC_RX_MAC_Lower_t __DP(eMAC1_RX_MAC_LOWER_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_RX_MAC_Lower_t __DP(eMAC1_RX_MAC_LOWER_rd)( __DN(t) * _dev )
{
    eMAC_RX_MAC_Lower_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7140));
    return u.val;
}

// Register eMAC1_RX_MAC_LOWER is not writeable


static inline int __DP(eMAC1_RX_MAC_LOWER_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_MAC_LOWER_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_MAC_Lower_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7140));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC1_RX_MAC_LOWER (eMAC1_RX_MAC_LOWER):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.mac_low;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_low =\t0x%0"PRIx32" (Lower 32 bits of MAC address that has not been found", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_RX_MAC_HIGHER (eMAC1_RX_MAC_HIGHER); type eMAC.RX_MAC_Higher (RX MAC address higher part)
 */

/*
 * Dump of fields for register: eMAC1_RX_MAC_HIGHER
 *   mac_high (size 16, offset 0):	 RO	  Upper 16 bits of MAC address that has not been found
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC1_RX_MAC_HIGHER_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_RX_MAC_HIGHER_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7144));
}

static inline eMAC_RX_MAC_Higher_t __DP(eMAC1_RX_MAC_HIGHER_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_RX_MAC_Higher_t __DP(eMAC1_RX_MAC_HIGHER_rd)( __DN(t) * _dev )
{
    eMAC_RX_MAC_Higher_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7144));
    return u.val;
}

// Register eMAC1_RX_MAC_HIGHER is not writeable


static inline int __DP(eMAC1_RX_MAC_HIGHER_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_MAC_HIGHER_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_MAC_Higher_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7144));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC1_RX_MAC_HIGHER (eMAC1_RX_MAC_HIGHER):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.mac_high;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_high =\t0x%0"PRIx16" (Upper 16 bits of MAC address that has not been found", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC2_RX_frame_dropped (eMAC2_RX_frame_dropped); type eMAC.RX_frame_dropped (RX Frame Dropped Channel)
 */

/*
 * Dump of fields for register: eMAC2_RX_frame_dropped
 *   status (size 1, offset 0):	 RW	  Set when frame dropped due to RX buffer overflow in DDR3
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
static const int __DP(eMAC2_RX_frame_dropped_length) = 0x2f;
static inline uint32_t __DP(eMAC2_RX_frame_dropped_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_RX_frame_dropped_rd_raw)( __DN(t) * _dev, int _i )
{
    return __DP(one_byte_read_32)(_dev, (0x7200) + (_i));
}

static inline eMAC_RX_frame_dropped_t __DP(eMAC2_RX_frame_dropped_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_frame_dropped_t __DP(eMAC2_RX_frame_dropped_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_frame_dropped_un  u;
    u.raw = __DP(one_byte_read_32)(_dev, (0x7200) + (_i));
    return u.val;
}

static inline void __DP(eMAC2_RX_frame_dropped_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_frame_dropped_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    __DP(one_byte_write_32)(_dev, (0x7200) + (_i),val);
}

static inline void __DP(eMAC2_RX_frame_dropped_wr)( __DN(t) * _dev, int _i, eMAC_RX_frame_dropped_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_frame_dropped_wr)( __DN(t) * _dev, int _i, eMAC_RX_frame_dropped_t val )
{
    eMAC_RX_frame_dropped_un  u;
    u.val = val;
    u.val._anon1 	= 0;
    __DP(one_byte_write_32)(_dev, (0x7200) + (_i),u.raw);
}

static inline void __DP(eMAC2_RX_frame_dropped_status_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_frame_dropped_status_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_frame_dropped_un  u;
    u.val._anon1 	= 0;
    u.val.status = val;
    __DP(one_byte_write_32)(_dev, (0x7200) + (_i),u.raw);
}


static inline int __DP(eMAC2_RX_frame_dropped_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_frame_dropped_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_frame_dropped_un  u;
    u.raw = __DP(one_byte_read_32)(_dev, (0x7200) + (_i));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC2_RX_frame_dropped[%d] (eMAC2_RX_frame_dropped):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (Set when frame dropped due to RX buffer overflow in DDR3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC2_RX_frame_dropped_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_frame_dropped_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2f; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC2_RX_frame_dropped_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_TX_FIFO_BUFF_FULL (eMAC2_TX_FIFO_BUFF_FULL); type eMAC.TX_FIFO_buff_full (TX FIFO buffer full)
 */

/*
 * Dump of fields for register: eMAC2_TX_FIFO_BUFF_FULL
 *   status (size 1, offset 0):	 RO	  Set in case of an overflow of TX fifo buffer in eMAC IP block
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC2_TX_FIFO_BUFF_FULL_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_TX_FIFO_BUFF_FULL_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7230));
}

static inline eMAC_TX_FIFO_buff_full_t __DP(eMAC2_TX_FIFO_BUFF_FULL_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_TX_FIFO_buff_full_t __DP(eMAC2_TX_FIFO_BUFF_FULL_rd)( __DN(t) * _dev )
{
    eMAC_TX_FIFO_buff_full_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7230));
    return u.val;
}

// Register eMAC2_TX_FIFO_BUFF_FULL is not writeable


static inline int __DP(eMAC2_TX_FIFO_BUFF_FULL_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_TX_FIFO_BUFF_FULL_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_FIFO_buff_full_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7230));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC2_TX_FIFO_BUFF_FULL (eMAC2_TX_FIFO_BUFF_FULL):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (Set in case of an overflow of TX fifo buffer in eMAC IP block", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC2_RX_FIFO_BUFF_FULL (eMAC2_RX_FIFO_BUFF_FULL); type eMAC.RX_FIFO_buff_full (RX FIFO buffer full)
 */

/*
 * Dump of fields for register: eMAC2_RX_FIFO_BUFF_FULL
 *   status (size 1, offset 0):	 RO	  Set in case of an overflow of RX fifo buffer in eMAC IP block
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC2_RX_FIFO_BUFF_FULL_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_RX_FIFO_BUFF_FULL_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7234));
}

static inline eMAC_RX_FIFO_buff_full_t __DP(eMAC2_RX_FIFO_BUFF_FULL_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_RX_FIFO_buff_full_t __DP(eMAC2_RX_FIFO_BUFF_FULL_rd)( __DN(t) * _dev )
{
    eMAC_RX_FIFO_buff_full_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7234));
    return u.val;
}

// Register eMAC2_RX_FIFO_BUFF_FULL is not writeable


static inline int __DP(eMAC2_RX_FIFO_BUFF_FULL_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_FIFO_BUFF_FULL_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_FIFO_buff_full_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7234));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC2_RX_FIFO_BUFF_FULL (eMAC2_RX_FIFO_BUFF_FULL):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (Set in case of an overflow of RX fifo buffer in eMAC IP block", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC2_TX_EMAC_NOT_READY (eMAC2_TX_EMAC_NOT_READY); type eMAC.TX_EMAC_Not_Ready (TX EMAC not ready)
 */

/*
 * Dump of fields for register: eMAC2_TX_EMAC_NOT_READY
 *   status (size 1, offset 0):	 RO	  eMAC does not accept frames
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC2_TX_EMAC_NOT_READY_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_TX_EMAC_NOT_READY_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7238));
}

static inline eMAC_TX_EMAC_Not_Ready_t __DP(eMAC2_TX_EMAC_NOT_READY_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_TX_EMAC_Not_Ready_t __DP(eMAC2_TX_EMAC_NOT_READY_rd)( __DN(t) * _dev )
{
    eMAC_TX_EMAC_Not_Ready_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7238));
    return u.val;
}

// Register eMAC2_TX_EMAC_NOT_READY is not writeable


static inline int __DP(eMAC2_TX_EMAC_NOT_READY_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_TX_EMAC_NOT_READY_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_EMAC_Not_Ready_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7238));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC2_TX_EMAC_NOT_READY (eMAC2_TX_EMAC_NOT_READY):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (eMAC does not accept frames", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC2_RX_MAC_ADDR_ERR (eMAC2_RX_MAC_ADDR_ERR); type eMAC.RX_MAC_Addr_Err (RX MAC address error)
 */

/*
 * Dump of fields for register: eMAC2_RX_MAC_ADDR_ERR
 *   status (size 1, offset 0):	 RO	  MAC address not found in table
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC2_RX_MAC_ADDR_ERR_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_RX_MAC_ADDR_ERR_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x723c));
}

static inline eMAC_RX_MAC_Addr_Err_t __DP(eMAC2_RX_MAC_ADDR_ERR_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_RX_MAC_Addr_Err_t __DP(eMAC2_RX_MAC_ADDR_ERR_rd)( __DN(t) * _dev )
{
    eMAC_RX_MAC_Addr_Err_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x723c));
    return u.val;
}

// Register eMAC2_RX_MAC_ADDR_ERR is not writeable


static inline int __DP(eMAC2_RX_MAC_ADDR_ERR_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_MAC_ADDR_ERR_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_MAC_Addr_Err_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x723c));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC2_RX_MAC_ADDR_ERR (eMAC2_RX_MAC_ADDR_ERR):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (MAC address not found in table", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC2_RX_MAC_LOWER (eMAC2_RX_MAC_LOWER); type eMAC.RX_MAC_Lower (RX MAC address lower part)
 */

/*
 * Dump of fields for register: eMAC2_RX_MAC_LOWER
 *   mac_low (size 32, offset 0):	 RO	  Lower 32 bits of MAC address that has not been found
 */

static inline uint32_t __DP(eMAC2_RX_MAC_LOWER_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_RX_MAC_LOWER_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7240));
}

static inline eMAC_RX_MAC_Lower_t __DP(eMAC2_RX_MAC_LOWER_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_RX_MAC_Lower_t __DP(eMAC2_RX_MAC_LOWER_rd)( __DN(t) * _dev )
{
    eMAC_RX_MAC_Lower_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7240));
    return u.val;
}

// Register eMAC2_RX_MAC_LOWER is not writeable


static inline int __DP(eMAC2_RX_MAC_LOWER_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_MAC_LOWER_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_MAC_Lower_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7240));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC2_RX_MAC_LOWER (eMAC2_RX_MAC_LOWER):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.mac_low;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_low =\t0x%0"PRIx32" (Lower 32 bits of MAC address that has not been found", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_RX_MAC_HIGHER (eMAC2_RX_MAC_HIGHER); type eMAC.RX_MAC_Higher (RX MAC address higher part)
 */

/*
 * Dump of fields for register: eMAC2_RX_MAC_HIGHER
 *   mac_high (size 16, offset 0):	 RO	  Upper 16 bits of MAC address that has not been found
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC2_RX_MAC_HIGHER_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_RX_MAC_HIGHER_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7244));
}

static inline eMAC_RX_MAC_Higher_t __DP(eMAC2_RX_MAC_HIGHER_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_RX_MAC_Higher_t __DP(eMAC2_RX_MAC_HIGHER_rd)( __DN(t) * _dev )
{
    eMAC_RX_MAC_Higher_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7244));
    return u.val;
}

// Register eMAC2_RX_MAC_HIGHER is not writeable


static inline int __DP(eMAC2_RX_MAC_HIGHER_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_MAC_HIGHER_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_MAC_Higher_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7244));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC2_RX_MAC_HIGHER (eMAC2_RX_MAC_HIGHER):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.mac_high;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_high =\t0x%0"PRIx16" (Upper 16 bits of MAC address that has not been found", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC3_RX_frame_dropped (eMAC3_RX_frame_dropped); type eMAC.RX_frame_dropped (RX Frame Dropped Channel)
 */

/*
 * Dump of fields for register: eMAC3_RX_frame_dropped
 *   status (size 1, offset 0):	 RW	  Set when frame dropped due to RX buffer overflow in DDR3
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
static const int __DP(eMAC3_RX_frame_dropped_length) = 0x2f;
static inline uint32_t __DP(eMAC3_RX_frame_dropped_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_RX_frame_dropped_rd_raw)( __DN(t) * _dev, int _i )
{
    return __DP(one_byte_read_32)(_dev, (0x7300) + (_i));
}

static inline eMAC_RX_frame_dropped_t __DP(eMAC3_RX_frame_dropped_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_frame_dropped_t __DP(eMAC3_RX_frame_dropped_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_frame_dropped_un  u;
    u.raw = __DP(one_byte_read_32)(_dev, (0x7300) + (_i));
    return u.val;
}

static inline void __DP(eMAC3_RX_frame_dropped_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_frame_dropped_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    __DP(one_byte_write_32)(_dev, (0x7300) + (_i),val);
}

static inline void __DP(eMAC3_RX_frame_dropped_wr)( __DN(t) * _dev, int _i, eMAC_RX_frame_dropped_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_frame_dropped_wr)( __DN(t) * _dev, int _i, eMAC_RX_frame_dropped_t val )
{
    eMAC_RX_frame_dropped_un  u;
    u.val = val;
    u.val._anon1 	= 0;
    __DP(one_byte_write_32)(_dev, (0x7300) + (_i),u.raw);
}

static inline void __DP(eMAC3_RX_frame_dropped_status_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_frame_dropped_status_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_frame_dropped_un  u;
    u.val._anon1 	= 0;
    u.val.status = val;
    __DP(one_byte_write_32)(_dev, (0x7300) + (_i),u.raw);
}


static inline int __DP(eMAC3_RX_frame_dropped_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_frame_dropped_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_frame_dropped_un  u;
    u.raw = __DP(one_byte_read_32)(_dev, (0x7300) + (_i));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC3_RX_frame_dropped[%d] (eMAC3_RX_frame_dropped):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (Set when frame dropped due to RX buffer overflow in DDR3", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC3_RX_frame_dropped_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_frame_dropped_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x2f; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC3_RX_frame_dropped_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_TX_FIFO_BUFF_FULL (eMAC3_TX_FIFO_BUFF_FULL); type eMAC.TX_FIFO_buff_full (TX FIFO buffer full)
 */

/*
 * Dump of fields for register: eMAC3_TX_FIFO_BUFF_FULL
 *   status (size 1, offset 0):	 RO	  Set in case of an overflow of TX fifo buffer in eMAC IP block
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC3_TX_FIFO_BUFF_FULL_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_TX_FIFO_BUFF_FULL_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7330));
}

static inline eMAC_TX_FIFO_buff_full_t __DP(eMAC3_TX_FIFO_BUFF_FULL_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_TX_FIFO_buff_full_t __DP(eMAC3_TX_FIFO_BUFF_FULL_rd)( __DN(t) * _dev )
{
    eMAC_TX_FIFO_buff_full_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7330));
    return u.val;
}

// Register eMAC3_TX_FIFO_BUFF_FULL is not writeable


static inline int __DP(eMAC3_TX_FIFO_BUFF_FULL_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_TX_FIFO_BUFF_FULL_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_FIFO_buff_full_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7330));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC3_TX_FIFO_BUFF_FULL (eMAC3_TX_FIFO_BUFF_FULL):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (Set in case of an overflow of TX fifo buffer in eMAC IP block", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC3_RX_FIFO_BUFF_FULL (eMAC3_RX_FIFO_BUFF_FULL); type eMAC.RX_FIFO_buff_full (RX FIFO buffer full)
 */

/*
 * Dump of fields for register: eMAC3_RX_FIFO_BUFF_FULL
 *   status (size 1, offset 0):	 RO	  Set in case of an overflow of RX fifo buffer in eMAC IP block
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC3_RX_FIFO_BUFF_FULL_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_RX_FIFO_BUFF_FULL_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7334));
}

static inline eMAC_RX_FIFO_buff_full_t __DP(eMAC3_RX_FIFO_BUFF_FULL_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_RX_FIFO_buff_full_t __DP(eMAC3_RX_FIFO_BUFF_FULL_rd)( __DN(t) * _dev )
{
    eMAC_RX_FIFO_buff_full_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7334));
    return u.val;
}

// Register eMAC3_RX_FIFO_BUFF_FULL is not writeable


static inline int __DP(eMAC3_RX_FIFO_BUFF_FULL_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_FIFO_BUFF_FULL_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_FIFO_buff_full_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7334));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC3_RX_FIFO_BUFF_FULL (eMAC3_RX_FIFO_BUFF_FULL):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (Set in case of an overflow of RX fifo buffer in eMAC IP block", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC3_TX_EMAC_NOT_READY (eMAC3_TX_EMAC_NOT_READY); type eMAC.TX_EMAC_Not_Ready (TX EMAC not ready)
 */

/*
 * Dump of fields for register: eMAC3_TX_EMAC_NOT_READY
 *   status (size 1, offset 0):	 RO	  eMAC does not accept frames
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC3_TX_EMAC_NOT_READY_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_TX_EMAC_NOT_READY_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7338));
}

static inline eMAC_TX_EMAC_Not_Ready_t __DP(eMAC3_TX_EMAC_NOT_READY_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_TX_EMAC_Not_Ready_t __DP(eMAC3_TX_EMAC_NOT_READY_rd)( __DN(t) * _dev )
{
    eMAC_TX_EMAC_Not_Ready_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7338));
    return u.val;
}

// Register eMAC3_TX_EMAC_NOT_READY is not writeable


static inline int __DP(eMAC3_TX_EMAC_NOT_READY_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_TX_EMAC_NOT_READY_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_EMAC_Not_Ready_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7338));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC3_TX_EMAC_NOT_READY (eMAC3_TX_EMAC_NOT_READY):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (eMAC does not accept frames", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC3_RX_MAC_ADDR_ERR (eMAC3_RX_MAC_ADDR_ERR); type eMAC.RX_MAC_Addr_Err (RX MAC address error)
 */

/*
 * Dump of fields for register: eMAC3_RX_MAC_ADDR_ERR
 *   status (size 1, offset 0):	 RO	  MAC address not found in table
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC3_RX_MAC_ADDR_ERR_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_RX_MAC_ADDR_ERR_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x733c));
}

static inline eMAC_RX_MAC_Addr_Err_t __DP(eMAC3_RX_MAC_ADDR_ERR_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_RX_MAC_Addr_Err_t __DP(eMAC3_RX_MAC_ADDR_ERR_rd)( __DN(t) * _dev )
{
    eMAC_RX_MAC_Addr_Err_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x733c));
    return u.val;
}

// Register eMAC3_RX_MAC_ADDR_ERR is not writeable


static inline int __DP(eMAC3_RX_MAC_ADDR_ERR_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_MAC_ADDR_ERR_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_MAC_Addr_Err_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x733c));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC3_RX_MAC_ADDR_ERR (eMAC3_RX_MAC_ADDR_ERR):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (MAC address not found in table", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC3_RX_MAC_LOWER (eMAC3_RX_MAC_LOWER); type eMAC.RX_MAC_Lower (RX MAC address lower part)
 */

/*
 * Dump of fields for register: eMAC3_RX_MAC_LOWER
 *   mac_low (size 32, offset 0):	 RO	  Lower 32 bits of MAC address that has not been found
 */

static inline uint32_t __DP(eMAC3_RX_MAC_LOWER_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_RX_MAC_LOWER_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7340));
}

static inline eMAC_RX_MAC_Lower_t __DP(eMAC3_RX_MAC_LOWER_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_RX_MAC_Lower_t __DP(eMAC3_RX_MAC_LOWER_rd)( __DN(t) * _dev )
{
    eMAC_RX_MAC_Lower_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7340));
    return u.val;
}

// Register eMAC3_RX_MAC_LOWER is not writeable


static inline int __DP(eMAC3_RX_MAC_LOWER_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_MAC_LOWER_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_MAC_Lower_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7340));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC3_RX_MAC_LOWER (eMAC3_RX_MAC_LOWER):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.mac_low;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_low =\t0x%0"PRIx32" (Lower 32 bits of MAC address that has not been found", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_RX_MAC_HIGHER (eMAC3_RX_MAC_HIGHER); type eMAC.RX_MAC_Higher (RX MAC address higher part)
 */

/*
 * Dump of fields for register: eMAC3_RX_MAC_HIGHER
 *   mac_high (size 16, offset 0):	 RO	  Upper 16 bits of MAC address that has not been found
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC3_RX_MAC_HIGHER_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_RX_MAC_HIGHER_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7344));
}

static inline eMAC_RX_MAC_Higher_t __DP(eMAC3_RX_MAC_HIGHER_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_RX_MAC_Higher_t __DP(eMAC3_RX_MAC_HIGHER_rd)( __DN(t) * _dev )
{
    eMAC_RX_MAC_Higher_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7344));
    return u.val;
}

// Register eMAC3_RX_MAC_HIGHER is not writeable


static inline int __DP(eMAC3_RX_MAC_HIGHER_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_MAC_HIGHER_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_MAC_Higher_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7344));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC3_RX_MAC_HIGHER (eMAC3_RX_MAC_HIGHER):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.mac_high;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_high =\t0x%0"PRIx16" (Upper 16 bits of MAC address that has not been found", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC_MAC_base_addr_upper_reg (eMAC_MAC_base_addr_upper_reg); type eMAC.eMAC_MAC_base_addr_upper (eMAC config MAC base address (high))
 */

/*
 * Dump of fields for register: eMAC_MAC_base_addr_upper_reg
 *   mac_upper (size 16, offset 0):	 RW	  Upper 16 bits of base MAC address
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */

static inline uint32_t __DP(eMAC_MAC_base_addr_upper_reg_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC_MAC_base_addr_upper_reg_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7e00));
}

static inline eMAC_eMAC_MAC_base_addr_upper_t __DP(eMAC_MAC_base_addr_upper_reg_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_MAC_base_addr_upper_t __DP(eMAC_MAC_base_addr_upper_reg_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_MAC_base_addr_upper_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7e00));
    return u.val;
}

static inline void __DP(eMAC_MAC_base_addr_upper_reg_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC_MAC_base_addr_upper_reg_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x7e00),val);
}

static inline void __DP(eMAC_MAC_base_addr_upper_reg_wr)( __DN(t) * _dev, eMAC_eMAC_MAC_base_addr_upper_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC_MAC_base_addr_upper_reg_wr)( __DN(t) * _dev, eMAC_eMAC_MAC_base_addr_upper_t val )
{
    eMAC_eMAC_MAC_base_addr_upper_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x7e00),u.raw);
}

static inline void __DP(eMAC_MAC_base_addr_upper_reg_mac_upper_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC_MAC_base_addr_upper_reg_mac_upper_wrf)( __DN(t) * _dev, uint16_t val )
{
    eMAC_eMAC_MAC_base_addr_upper_un  u;
    u.val._anon16 	= 0;
    u.val.mac_upper = val;
    mackerel_write_addr_32(_dev->base,(0x7e00),u.raw);
}


static inline int __DP(eMAC_MAC_base_addr_upper_reg_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC_MAC_base_addr_upper_reg_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_MAC_base_addr_upper_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7e00));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC_MAC_base_addr_upper_reg (eMAC_MAC_base_addr_upper_reg):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.mac_upper;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_upper =\t0x%0"PRIx16" (Upper 16 bits of base MAC address", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register eMAC_MAC_base_addr_lower_reg (eMAC_MAC_base_addr_lower_reg); type eMAC.eMAC_MAC_base_addr_lower (eMAC config MAC base address (low))
 */

/*
 * Dump of fields for register: eMAC_MAC_base_addr_lower_reg
 *   mac_lower (size 32, offset 0):	 RW	  Lower 32 bits of base MAC address
 */

static inline uint32_t __DP(eMAC_MAC_base_addr_lower_reg_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC_MAC_base_addr_lower_reg_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7e04));
}

static inline eMAC_eMAC_MAC_base_addr_lower_t __DP(eMAC_MAC_base_addr_lower_reg_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_MAC_base_addr_lower_t __DP(eMAC_MAC_base_addr_lower_reg_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_MAC_base_addr_lower_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7e04));
    return u.val;
}

static inline void __DP(eMAC_MAC_base_addr_lower_reg_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC_MAC_base_addr_lower_reg_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x7e04),val);
}

static inline void __DP(eMAC_MAC_base_addr_lower_reg_wr)( __DN(t) * _dev, eMAC_eMAC_MAC_base_addr_lower_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC_MAC_base_addr_lower_reg_wr)( __DN(t) * _dev, eMAC_eMAC_MAC_base_addr_lower_t val )
{
    eMAC_eMAC_MAC_base_addr_lower_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0x7e04),u.raw);
}

static inline void __DP(eMAC_MAC_base_addr_lower_reg_mac_lower_wrf)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC_MAC_base_addr_lower_reg_mac_lower_wrf)( __DN(t) * _dev, uint32_t val )
{
    eMAC_eMAC_MAC_base_addr_lower_un  u;
    u.val.mac_lower = val;
    mackerel_write_addr_32(_dev->base,(0x7e04),u.raw);
}


static inline int __DP(eMAC_MAC_base_addr_lower_reg_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC_MAC_base_addr_lower_reg_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_MAC_base_addr_lower_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7e04));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC_MAC_base_addr_lower_reg (eMAC_MAC_base_addr_lower_reg):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.mac_lower;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_lower =\t0x%0"PRIx32" (Lower 32 bits of base MAC address", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC_start_IP_SCC_network_reg (eMAC_start_IP_SCC_network_reg); type eMAC.eMAC_start_IP_SCC_network (eMAC config Start IP Address of SCC network)
 */

/*
 * Dump of fields for register: eMAC_start_IP_SCC_network_reg
 *   ip (size 32, offset 0):	 RW	  IP Address for SCC Core 0. IPs for other cores are assigned in order
 */

static inline uint32_t __DP(eMAC_start_IP_SCC_network_reg_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC_start_IP_SCC_network_reg_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7e08));
}

static inline eMAC_eMAC_start_IP_SCC_network_t __DP(eMAC_start_IP_SCC_network_reg_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_start_IP_SCC_network_t __DP(eMAC_start_IP_SCC_network_reg_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_start_IP_SCC_network_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7e08));
    return u.val;
}

static inline void __DP(eMAC_start_IP_SCC_network_reg_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC_start_IP_SCC_network_reg_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x7e08),val);
}

static inline void __DP(eMAC_start_IP_SCC_network_reg_wr)( __DN(t) * _dev, eMAC_eMAC_start_IP_SCC_network_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC_start_IP_SCC_network_reg_wr)( __DN(t) * _dev, eMAC_eMAC_start_IP_SCC_network_t val )
{
    eMAC_eMAC_start_IP_SCC_network_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0x7e08),u.raw);
}

static inline void __DP(eMAC_start_IP_SCC_network_reg_ip_wrf)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC_start_IP_SCC_network_reg_ip_wrf)( __DN(t) * _dev, uint32_t val )
{
    eMAC_eMAC_start_IP_SCC_network_un  u;
    u.val.ip = val;
    mackerel_write_addr_32(_dev->base,(0x7e08),u.raw);
}


static inline int __DP(eMAC_start_IP_SCC_network_reg_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC_start_IP_SCC_network_reg_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_start_IP_SCC_network_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7e08));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC_start_IP_SCC_network_reg (eMAC_start_IP_SCC_network_reg):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.ip;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ip =\t0x%0"PRIx32" (IP Address for SCC Core 0. IPs for other cores are assigned in order", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC_host_IP_addr_reg (eMAC_host_IP_addr_reg); type eMAC.eMAC_host_IP_addr (eMAC config Host IP Address)
 */

/*
 * Dump of fields for register: eMAC_host_IP_addr_reg
 *   ip (size 32, offset 0):	 RW	  IP Address of Host computer where /shared is mounted
 */

static inline uint32_t __DP(eMAC_host_IP_addr_reg_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC_host_IP_addr_reg_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7e0c));
}

static inline eMAC_eMAC_host_IP_addr_t __DP(eMAC_host_IP_addr_reg_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_host_IP_addr_t __DP(eMAC_host_IP_addr_reg_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_host_IP_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7e0c));
    return u.val;
}

static inline void __DP(eMAC_host_IP_addr_reg_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC_host_IP_addr_reg_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x7e0c),val);
}

static inline void __DP(eMAC_host_IP_addr_reg_wr)( __DN(t) * _dev, eMAC_eMAC_host_IP_addr_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC_host_IP_addr_reg_wr)( __DN(t) * _dev, eMAC_eMAC_host_IP_addr_t val )
{
    eMAC_eMAC_host_IP_addr_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0x7e0c),u.raw);
}

static inline void __DP(eMAC_host_IP_addr_reg_ip_wrf)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC_host_IP_addr_reg_ip_wrf)( __DN(t) * _dev, uint32_t val )
{
    eMAC_eMAC_host_IP_addr_un  u;
    u.val.ip = val;
    mackerel_write_addr_32(_dev->base,(0x7e0c),u.raw);
}


static inline int __DP(eMAC_host_IP_addr_reg_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC_host_IP_addr_reg_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_host_IP_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7e0c));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC_host_IP_addr_reg (eMAC_host_IP_addr_reg):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.ip;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ip =\t0x%0"PRIx32" (IP Address of Host computer where /shared is mounted", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC_host_GW_addr_reg (eMAC_host_GW_addr_reg); type eMAC.eMAC_host_GW_addr (eMAC config Host gateway Address)
 */

/*
 * Dump of fields for register: eMAC_host_GW_addr_reg
 *   ip (size 32, offset 0):	 RW	  Gateway of Host computer
 */

static inline uint32_t __DP(eMAC_host_GW_addr_reg_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC_host_GW_addr_reg_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x7e10));
}

static inline eMAC_eMAC_host_GW_addr_t __DP(eMAC_host_GW_addr_reg_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline eMAC_eMAC_host_GW_addr_t __DP(eMAC_host_GW_addr_reg_rd)( __DN(t) * _dev )
{
    eMAC_eMAC_host_GW_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7e10));
    return u.val;
}

static inline void __DP(eMAC_host_GW_addr_reg_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC_host_GW_addr_reg_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x7e10),val);
}

static inline void __DP(eMAC_host_GW_addr_reg_wr)( __DN(t) * _dev, eMAC_eMAC_host_GW_addr_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC_host_GW_addr_reg_wr)( __DN(t) * _dev, eMAC_eMAC_host_GW_addr_t val )
{
    eMAC_eMAC_host_GW_addr_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0x7e10),u.raw);
}

static inline void __DP(eMAC_host_GW_addr_reg_ip_wrf)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC_host_GW_addr_reg_ip_wrf)( __DN(t) * _dev, uint32_t val )
{
    eMAC_eMAC_host_GW_addr_un  u;
    u.val.ip = val;
    mackerel_write_addr_32(_dev->base,(0x7e10),u.raw);
}


static inline int __DP(eMAC_host_GW_addr_reg_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC_host_GW_addr_reg_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    eMAC_eMAC_host_GW_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x7e10));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eMAC_host_GW_addr_reg (eMAC_host_GW_addr_reg):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.ip;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ip =\t0x%0"PRIx32" (Gateway of Host computer", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_RX_Buffer_start_addr (eMAC0_RX_Buffer_start_addr); type eMAC.RX_Buffer_start_addr (RX control RX Buffer Start Address)
 */

/*
 * Dump of fields for register: eMAC0_RX_Buffer_start_addr
 *   ADDR (size 29, offset 0):	 RW	  Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.
 *   _anon29 (size 3, offset 29):	 MBZ	  _
 */
static const int __DP(eMAC0_RX_Buffer_start_addr_length) = 0x30;
static inline uint32_t __DP(eMAC0_RX_Buffer_start_addr_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_RX_Buffer_start_addr_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x9000) + (_i *(32/8)));
}

static inline eMAC_RX_Buffer_start_addr_t __DP(eMAC0_RX_Buffer_start_addr_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_Buffer_start_addr_t __DP(eMAC0_RX_Buffer_start_addr_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_Buffer_start_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9000) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC0_RX_Buffer_start_addr_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_Buffer_start_addr_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x9000) + (_i *(32/8)),val);
}

static inline void __DP(eMAC0_RX_Buffer_start_addr_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_start_addr_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_Buffer_start_addr_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_start_addr_t val )
{
    eMAC_RX_Buffer_start_addr_un  u;
    u.val = val;
    u.val._anon29 	= 0;
    mackerel_write_addr_32(_dev->base,(0x9000) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC0_RX_Buffer_start_addr_ADDR_wrf)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_Buffer_start_addr_ADDR_wrf)( __DN(t) * _dev, int _i, uint32_t val )
{
    eMAC_RX_Buffer_start_addr_un  u;
    u.val._anon29 	= 0;
    u.val.ADDR = val;
    mackerel_write_addr_32(_dev->base,(0x9000) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC0_RX_Buffer_start_addr_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_Buffer_start_addr_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_Buffer_start_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9000) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC0_RX_Buffer_start_addr[%d] (eMAC0_RX_Buffer_start_addr):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.ADDR;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ADDR =\t0x%0"PRIx32" (Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC0_RX_Buffer_start_addr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_Buffer_start_addr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC0_RX_Buffer_start_addr_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_RX_Buffer_read_index (eMAC0_RX_Buffer_read_index); type eMAC.RX_Buffer_read_index (RX control RX Buffer Read Index)
 */

/*
 * Dump of fields for register: eMAC0_RX_Buffer_read_index
 *   rid (size 16, offset 0):	 RW	  Read index of RX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC0_RX_Buffer_read_index_length) = 0x30;
static inline uint32_t __DP(eMAC0_RX_Buffer_read_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_RX_Buffer_read_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x9100) + (_i *(32/8)));
}

static inline eMAC_RX_Buffer_read_index_t __DP(eMAC0_RX_Buffer_read_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_Buffer_read_index_t __DP(eMAC0_RX_Buffer_read_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_Buffer_read_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9100) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC0_RX_Buffer_read_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_Buffer_read_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x9100) + (_i *(32/8)),val);
}

static inline void __DP(eMAC0_RX_Buffer_read_index_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_read_index_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_Buffer_read_index_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_read_index_t val )
{
    eMAC_RX_Buffer_read_index_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x9100) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC0_RX_Buffer_read_index_rid_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_Buffer_read_index_rid_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_RX_Buffer_read_index_un  u;
    u.val._anon16 	= 0;
    u.val.rid = val;
    mackerel_write_addr_32(_dev->base,(0x9100) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC0_RX_Buffer_read_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_Buffer_read_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_Buffer_read_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9100) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC0_RX_Buffer_read_index[%d] (eMAC0_RX_Buffer_read_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.rid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rid =\t0x%0"PRIx16" (Read index of RX buffer Points to 32 byte entry in the buffer.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC0_RX_Buffer_read_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_Buffer_read_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC0_RX_Buffer_read_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_RX_Buffer_write_index (eMAC0_RX_Buffer_write_index); type eMAC.RX_Buffer_write_index (RX control RX Buffer Write Index)
 */

/*
 * Dump of fields for register: eMAC0_RX_Buffer_write_index
 *   wid (size 16, offset 0):	 RO	  Write index of RX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC0_RX_Buffer_write_index_length) = 0x30;
static inline uint32_t __DP(eMAC0_RX_Buffer_write_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_RX_Buffer_write_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x9200) + (_i *(32/8)));
}

static inline eMAC_RX_Buffer_write_index_t __DP(eMAC0_RX_Buffer_write_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_Buffer_write_index_t __DP(eMAC0_RX_Buffer_write_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_Buffer_write_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9200) + (_i *(32/8)));
    return u.val;
}

// Register eMAC0_RX_Buffer_write_index is not writeable


static inline int __DP(eMAC0_RX_Buffer_write_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_Buffer_write_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_Buffer_write_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9200) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC0_RX_Buffer_write_index[%d] (eMAC0_RX_Buffer_write_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.wid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wid =\t0x%0"PRIx16" (Write index of RX buffer Points to 32 byte entry in the buffer.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC0_RX_Buffer_write_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_Buffer_write_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC0_RX_Buffer_write_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_RX_Buffer_last_index (eMAC0_RX_Buffer_last_index); type eMAC.RX_Buffer_last_index (RX control RX Buffer Last Index)
 */

/*
 * Dump of fields for register: eMAC0_RX_Buffer_last_index
 *   lid (size 16, offset 0):	 RW	  Last valid index in buffer. .Buffer size = last index * 32 bytes
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC0_RX_Buffer_last_index_length) = 0x30;
static inline uint32_t __DP(eMAC0_RX_Buffer_last_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_RX_Buffer_last_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x9300) + (_i *(32/8)));
}

static inline eMAC_RX_Buffer_last_index_t __DP(eMAC0_RX_Buffer_last_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_Buffer_last_index_t __DP(eMAC0_RX_Buffer_last_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_Buffer_last_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9300) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC0_RX_Buffer_last_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_Buffer_last_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x9300) + (_i *(32/8)),val);
}

static inline void __DP(eMAC0_RX_Buffer_last_index_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_last_index_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_Buffer_last_index_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_last_index_t val )
{
    eMAC_RX_Buffer_last_index_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x9300) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC0_RX_Buffer_last_index_lid_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_Buffer_last_index_lid_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_RX_Buffer_last_index_un  u;
    u.val._anon16 	= 0;
    u.val.lid = val;
    mackerel_write_addr_32(_dev->base,(0x9300) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC0_RX_Buffer_last_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_Buffer_last_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_Buffer_last_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9300) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC0_RX_Buffer_last_index[%d] (eMAC0_RX_Buffer_last_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.lid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lid =\t0x%0"PRIx16" (Last valid index in buffer. .Buffer size = last index * 32 bytes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC0_RX_Buffer_last_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_Buffer_last_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC0_RX_Buffer_last_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_RX_routing (eMAC0_RX_routing); type eMAC.RX_routing (RX control RX routing related)
 */

/*
 * Dump of fields for register: eMAC0_RX_routing
 *   broute (size 8, offset 0):	 RW	  Route to the tile where the MC for this buffer is located
 *   bdest (size 3, offset 8):	 RW	  Defines the port at which the MC is connected
 *   _anon11 (size 5, offset 11):	 MBZ	  _
 *   iroute (size 8, offset 16):	 RW	  Route to the tile where the core for this buffer is located
 *   idest (size 3, offset 24):	 RW	  Selects core 0 or core 1 in the tile
 *   _anon27 (size 5, offset 27):	 MBZ	  _
 */
static const int __DP(eMAC0_RX_routing_length) = 0x30;
static inline uint32_t __DP(eMAC0_RX_routing_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_RX_routing_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x9500) + (_i *(32/8)));
}

static inline eMAC_RX_routing_t __DP(eMAC0_RX_routing_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_routing_t __DP(eMAC0_RX_routing_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9500) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC0_RX_routing_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_routing_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x9500) + (_i *(32/8)),val);
}

static inline void __DP(eMAC0_RX_routing_wr)( __DN(t) * _dev, int _i, eMAC_RX_routing_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_routing_wr)( __DN(t) * _dev, int _i, eMAC_RX_routing_t val )
{
    eMAC_RX_routing_un  u;
    u.val = val;
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    mackerel_write_addr_32(_dev->base,(0x9500) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC0_RX_routing_broute_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_routing_broute_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9500) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    u.val.broute = val;
    mackerel_write_addr_32(_dev->base,(0x9500) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC0_RX_routing_bdest_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_routing_bdest_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9500) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    u.val.bdest = val;
    mackerel_write_addr_32(_dev->base,(0x9500) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC0_RX_routing_iroute_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_routing_iroute_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9500) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    u.val.iroute = val;
    mackerel_write_addr_32(_dev->base,(0x9500) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC0_RX_routing_idest_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_routing_idest_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9500) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    u.val.idest = val;
    mackerel_write_addr_32(_dev->base,(0x9500) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC0_RX_routing_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_routing_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9500) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC0_RX_routing[%d] (eMAC0_RX_routing):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.broute;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " broute =\t0x%"PRIx8" (Route to the tile where the MC for this buffer is located", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.bdest;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bdest =\t0x%"PRIx8" (Defines the port at which the MC is connected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.iroute;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " iroute =\t0x%"PRIx8" (Route to the tile where the core for this buffer is located", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.idest;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " idest =\t0x%"PRIx8" (Selects core 0 or core 1 in the tile", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC0_RX_routing_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_routing_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC0_RX_routing_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_RX_net_port_MAC_high (eMAC0_RX_net_port_MAC_high); type eMAC.RX_net_port_MAC_high (RX Network Port MAC Address (high))
 */

/*
 * Dump of fields for register: eMAC0_RX_net_port_MAC_high
 *   mac_hi (size 16, offset 0):	 RW	  Higher 16 bits of MAC addresses
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC0_RX_net_port_MAC_high_length) = 0x30;
static inline uint32_t __DP(eMAC0_RX_net_port_MAC_high_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_RX_net_port_MAC_high_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x9600) + (_i *(32/8)));
}

static inline eMAC_RX_net_port_MAC_high_t __DP(eMAC0_RX_net_port_MAC_high_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_net_port_MAC_high_t __DP(eMAC0_RX_net_port_MAC_high_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_net_port_MAC_high_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9600) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC0_RX_net_port_MAC_high_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_net_port_MAC_high_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x9600) + (_i *(32/8)),val);
}

static inline void __DP(eMAC0_RX_net_port_MAC_high_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_MAC_high_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_net_port_MAC_high_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_MAC_high_t val )
{
    eMAC_RX_net_port_MAC_high_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x9600) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC0_RX_net_port_MAC_high_mac_hi_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_net_port_MAC_high_mac_hi_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_RX_net_port_MAC_high_un  u;
    u.val._anon16 	= 0;
    u.val.mac_hi = val;
    mackerel_write_addr_32(_dev->base,(0x9600) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC0_RX_net_port_MAC_high_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_net_port_MAC_high_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_net_port_MAC_high_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9600) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC0_RX_net_port_MAC_high[%d] (eMAC0_RX_net_port_MAC_high):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.mac_hi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_hi =\t0x%0"PRIx16" (Higher 16 bits of MAC addresses", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC0_RX_net_port_MAC_high_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_net_port_MAC_high_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC0_RX_net_port_MAC_high_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_RX_net_port_MAC_low (eMAC0_RX_net_port_MAC_low); type eMAC.RX_net_port_MAC_low (RX Network Port MAC Address (low))
 */

/*
 * Dump of fields for register: eMAC0_RX_net_port_MAC_low
 *   mac_lo (size 32, offset 0):	 RW	  Lower 32 bits of MAC addresses
 */
static const int __DP(eMAC0_RX_net_port_MAC_low_length) = 0x30;
static inline uint32_t __DP(eMAC0_RX_net_port_MAC_low_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_RX_net_port_MAC_low_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x9700) + (_i *(32/8)));
}

static inline eMAC_RX_net_port_MAC_low_t __DP(eMAC0_RX_net_port_MAC_low_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_net_port_MAC_low_t __DP(eMAC0_RX_net_port_MAC_low_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_net_port_MAC_low_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9700) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC0_RX_net_port_MAC_low_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_net_port_MAC_low_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x9700) + (_i *(32/8)),val);
}

static inline void __DP(eMAC0_RX_net_port_MAC_low_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_MAC_low_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_net_port_MAC_low_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_MAC_low_t val )
{
    eMAC_RX_net_port_MAC_low_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0x9700) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC0_RX_net_port_MAC_low_mac_lo_wrf)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_net_port_MAC_low_mac_lo_wrf)( __DN(t) * _dev, int _i, uint32_t val )
{
    eMAC_RX_net_port_MAC_low_un  u;
    u.val.mac_lo = val;
    mackerel_write_addr_32(_dev->base,(0x9700) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC0_RX_net_port_MAC_low_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_net_port_MAC_low_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_net_port_MAC_low_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9700) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC0_RX_net_port_MAC_low[%d] (eMAC0_RX_net_port_MAC_low):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.mac_lo;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_lo =\t0x%0"PRIx32" (Lower 32 bits of MAC addresses", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}
static inline int __DP(eMAC0_RX_net_port_MAC_low_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_net_port_MAC_low_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC0_RX_net_port_MAC_low_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_RX_net_port_enable (eMAC0_RX_net_port_enable); type eMAC.RX_net_port_enable (RX Network Port Enable)
 */

/*
 * Dump of fields for register: eMAC0_RX_net_port_enable
 *   enable (size 1, offset 0):	 RW	  1 - Enabled, 0 - Disabled
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
static const int __DP(eMAC0_RX_net_port_enable_length) = 0x30;
static inline uint32_t __DP(eMAC0_RX_net_port_enable_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_RX_net_port_enable_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x9800) + (_i *(32/8)));
}

static inline eMAC_RX_net_port_enable_t __DP(eMAC0_RX_net_port_enable_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_net_port_enable_t __DP(eMAC0_RX_net_port_enable_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_net_port_enable_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9800) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC0_RX_net_port_enable_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_net_port_enable_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x9800) + (_i *(32/8)),val);
}

static inline void __DP(eMAC0_RX_net_port_enable_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_enable_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_net_port_enable_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_enable_t val )
{
    eMAC_RX_net_port_enable_un  u;
    u.val = val;
    u.val._anon1 	= 0;
    mackerel_write_addr_32(_dev->base,(0x9800) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC0_RX_net_port_enable_enable_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_RX_net_port_enable_enable_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_net_port_enable_un  u;
    u.val._anon1 	= 0;
    u.val.enable = val;
    mackerel_write_addr_32(_dev->base,(0x9800) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC0_RX_net_port_enable_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_net_port_enable_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_net_port_enable_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9800) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC0_RX_net_port_enable[%d] (eMAC0_RX_net_port_enable):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " enable =\t0x%"PRIx8" (1 - Enabled, 0 - Disabled", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC0_RX_net_port_enable_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_RX_net_port_enable_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC0_RX_net_port_enable_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_TX_Buffer_start_addr (eMAC0_TX_Buffer_start_addr); type eMAC.TX_Buffer_start_addr (TX control TX Buffer Start Address)
 */

/*
 * Dump of fields for register: eMAC0_TX_Buffer_start_addr
 *   ADDR (size 29, offset 0):	 RW	  Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.
 *   _anon29 (size 3, offset 29):	 MBZ	  _
 */
static const int __DP(eMAC0_TX_Buffer_start_addr_length) = 0x30;
static inline uint32_t __DP(eMAC0_TX_Buffer_start_addr_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_TX_Buffer_start_addr_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x9900) + (_i *(32/8)));
}

static inline eMAC_TX_Buffer_start_addr_t __DP(eMAC0_TX_Buffer_start_addr_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_Buffer_start_addr_t __DP(eMAC0_TX_Buffer_start_addr_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_Buffer_start_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9900) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC0_TX_Buffer_start_addr_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_TX_Buffer_start_addr_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x9900) + (_i *(32/8)),val);
}

static inline void __DP(eMAC0_TX_Buffer_start_addr_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_start_addr_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_TX_Buffer_start_addr_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_start_addr_t val )
{
    eMAC_TX_Buffer_start_addr_un  u;
    u.val = val;
    u.val._anon29 	= 0;
    mackerel_write_addr_32(_dev->base,(0x9900) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC0_TX_Buffer_start_addr_ADDR_wrf)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_TX_Buffer_start_addr_ADDR_wrf)( __DN(t) * _dev, int _i, uint32_t val )
{
    eMAC_TX_Buffer_start_addr_un  u;
    u.val._anon29 	= 0;
    u.val.ADDR = val;
    mackerel_write_addr_32(_dev->base,(0x9900) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC0_TX_Buffer_start_addr_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_TX_Buffer_start_addr_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_Buffer_start_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9900) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC0_TX_Buffer_start_addr[%d] (eMAC0_TX_Buffer_start_addr):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.ADDR;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ADDR =\t0x%0"PRIx32" (Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC0_TX_Buffer_start_addr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_TX_Buffer_start_addr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC0_TX_Buffer_start_addr_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_TX_Buffer_read_index (eMAC0_TX_Buffer_read_index); type eMAC.TX_Buffer_read_index (TX control TX Buffer Read Index)
 */

/*
 * Dump of fields for register: eMAC0_TX_Buffer_read_index
 *   rid (size 16, offset 0):	 RO	  Read index of TX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC0_TX_Buffer_read_index_length) = 0x30;
static inline uint32_t __DP(eMAC0_TX_Buffer_read_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_TX_Buffer_read_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x9a00) + (_i *(32/8)));
}

static inline eMAC_TX_Buffer_read_index_t __DP(eMAC0_TX_Buffer_read_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_Buffer_read_index_t __DP(eMAC0_TX_Buffer_read_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_Buffer_read_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9a00) + (_i *(32/8)));
    return u.val;
}

// Register eMAC0_TX_Buffer_read_index is not writeable


static inline int __DP(eMAC0_TX_Buffer_read_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_TX_Buffer_read_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_Buffer_read_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9a00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC0_TX_Buffer_read_index[%d] (eMAC0_TX_Buffer_read_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.rid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rid =\t0x%0"PRIx16" (Read index of TX buffer Points to 32 byte entry in the buffer.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC0_TX_Buffer_read_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_TX_Buffer_read_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC0_TX_Buffer_read_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_TX_Buffer_write_index (eMAC0_TX_Buffer_write_index); type eMAC.TX_Buffer_write_index (TX control TX Buffer Write Index)
 */

/*
 * Dump of fields for register: eMAC0_TX_Buffer_write_index
 *   wid (size 16, offset 0):	 RW	  Write index of TX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC0_TX_Buffer_write_index_length) = 0x30;
static inline uint32_t __DP(eMAC0_TX_Buffer_write_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_TX_Buffer_write_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x9b00) + (_i *(32/8)));
}

static inline eMAC_TX_Buffer_write_index_t __DP(eMAC0_TX_Buffer_write_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_Buffer_write_index_t __DP(eMAC0_TX_Buffer_write_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_Buffer_write_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9b00) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC0_TX_Buffer_write_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_TX_Buffer_write_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x9b00) + (_i *(32/8)),val);
}

static inline void __DP(eMAC0_TX_Buffer_write_index_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_write_index_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_TX_Buffer_write_index_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_write_index_t val )
{
    eMAC_TX_Buffer_write_index_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x9b00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC0_TX_Buffer_write_index_wid_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_TX_Buffer_write_index_wid_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_TX_Buffer_write_index_un  u;
    u.val._anon16 	= 0;
    u.val.wid = val;
    mackerel_write_addr_32(_dev->base,(0x9b00) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC0_TX_Buffer_write_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_TX_Buffer_write_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_Buffer_write_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9b00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC0_TX_Buffer_write_index[%d] (eMAC0_TX_Buffer_write_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.wid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wid =\t0x%0"PRIx16" (Write index of TX buffer Points to 32 byte entry in the buffer.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC0_TX_Buffer_write_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_TX_Buffer_write_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC0_TX_Buffer_write_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_TX_Buffer_last_index (eMAC0_TX_Buffer_last_index); type eMAC.TX_Buffer_last_index (TX control TX Buffer Last Index)
 */

/*
 * Dump of fields for register: eMAC0_TX_Buffer_last_index
 *   lid (size 16, offset 0):	 RW	  Last valid index in buffer. .Buffer size = last index * 32 bytes
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC0_TX_Buffer_last_index_length) = 0x30;
static inline uint32_t __DP(eMAC0_TX_Buffer_last_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_TX_Buffer_last_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x9c00) + (_i *(32/8)));
}

static inline eMAC_TX_Buffer_last_index_t __DP(eMAC0_TX_Buffer_last_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_Buffer_last_index_t __DP(eMAC0_TX_Buffer_last_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_Buffer_last_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9c00) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC0_TX_Buffer_last_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_TX_Buffer_last_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x9c00) + (_i *(32/8)),val);
}

static inline void __DP(eMAC0_TX_Buffer_last_index_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_last_index_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_TX_Buffer_last_index_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_last_index_t val )
{
    eMAC_TX_Buffer_last_index_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0x9c00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC0_TX_Buffer_last_index_lid_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_TX_Buffer_last_index_lid_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_TX_Buffer_last_index_un  u;
    u.val._anon16 	= 0;
    u.val.lid = val;
    mackerel_write_addr_32(_dev->base,(0x9c00) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC0_TX_Buffer_last_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_TX_Buffer_last_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_Buffer_last_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9c00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC0_TX_Buffer_last_index[%d] (eMAC0_TX_Buffer_last_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.lid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lid =\t0x%0"PRIx16" (Last valid index in buffer. .Buffer size = last index * 32 bytes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC0_TX_Buffer_last_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_TX_Buffer_last_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC0_TX_Buffer_last_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_TX_routing (eMAC0_TX_routing); type eMAC.TX_routing (TX control RX routing related)
 */

/*
 * Dump of fields for register: eMAC0_TX_routing
 *   broute (size 8, offset 0):	 RW	  Route to the tile where the MC for this buffer is located
 *   bdest (size 3, offset 8):	 RW	  Defines the port at which the MC is connected
 *   _anon11 (size 21, offset 11):	 MBZ	  _
 */
static const int __DP(eMAC0_TX_routing_length) = 0x30;
static inline uint32_t __DP(eMAC0_TX_routing_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_TX_routing_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x9d00) + (_i *(32/8)));
}

static inline eMAC_TX_routing_t __DP(eMAC0_TX_routing_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_routing_t __DP(eMAC0_TX_routing_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9d00) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC0_TX_routing_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_TX_routing_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x9d00) + (_i *(32/8)),val);
}

static inline void __DP(eMAC0_TX_routing_wr)( __DN(t) * _dev, int _i, eMAC_TX_routing_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_TX_routing_wr)( __DN(t) * _dev, int _i, eMAC_TX_routing_t val )
{
    eMAC_TX_routing_un  u;
    u.val = val;
    u.val._anon11 	= 0;
    mackerel_write_addr_32(_dev->base,(0x9d00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC0_TX_routing_broute_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_TX_routing_broute_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_TX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9d00) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val.broute = val;
    mackerel_write_addr_32(_dev->base,(0x9d00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC0_TX_routing_bdest_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_TX_routing_bdest_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_TX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9d00) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val.bdest = val;
    mackerel_write_addr_32(_dev->base,(0x9d00) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC0_TX_routing_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_TX_routing_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9d00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC0_TX_routing[%d] (eMAC0_TX_routing):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.broute;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " broute =\t0x%"PRIx8" (Route to the tile where the MC for this buffer is located", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.bdest;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bdest =\t0x%"PRIx8" (Defines the port at which the MC is connected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC0_TX_routing_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_TX_routing_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC0_TX_routing_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC0_TX_net_port_enable (eMAC0_TX_net_port_enable); type eMAC.TX_net_port_enable (TX Network Port Enable)
 */

/*
 * Dump of fields for register: eMAC0_TX_net_port_enable
 *   enable (size 1, offset 0):	 RW	  1 - Enabled, 0 - Disabled
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
static const int __DP(eMAC0_TX_net_port_enable_length) = 0x30;
static inline uint32_t __DP(eMAC0_TX_net_port_enable_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC0_TX_net_port_enable_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0x9e00) + (_i *(32/8)));
}

static inline eMAC_TX_net_port_enable_t __DP(eMAC0_TX_net_port_enable_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_net_port_enable_t __DP(eMAC0_TX_net_port_enable_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_net_port_enable_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9e00) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC0_TX_net_port_enable_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_TX_net_port_enable_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x9e00) + (_i *(32/8)),val);
}

static inline void __DP(eMAC0_TX_net_port_enable_wr)( __DN(t) * _dev, int _i, eMAC_TX_net_port_enable_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_TX_net_port_enable_wr)( __DN(t) * _dev, int _i, eMAC_TX_net_port_enable_t val )
{
    eMAC_TX_net_port_enable_un  u;
    u.val = val;
    u.val._anon1 	= 0;
    mackerel_write_addr_32(_dev->base,(0x9e00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC0_TX_net_port_enable_enable_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC0_TX_net_port_enable_enable_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_TX_net_port_enable_un  u;
    u.val._anon1 	= 0;
    u.val.enable = val;
    mackerel_write_addr_32(_dev->base,(0x9e00) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC0_TX_net_port_enable_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_TX_net_port_enable_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_net_port_enable_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x9e00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC0_TX_net_port_enable[%d] (eMAC0_TX_net_port_enable):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " enable =\t0x%"PRIx8" (1 - Enabled, 0 - Disabled", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC0_TX_net_port_enable_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC0_TX_net_port_enable_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC0_TX_net_port_enable_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_RX_Buffer_start_addr (eMAC1_RX_Buffer_start_addr); type eMAC.RX_Buffer_start_addr (RX control RX Buffer Start Address)
 */

/*
 * Dump of fields for register: eMAC1_RX_Buffer_start_addr
 *   ADDR (size 29, offset 0):	 RW	  Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.
 *   _anon29 (size 3, offset 29):	 MBZ	  _
 */
static const int __DP(eMAC1_RX_Buffer_start_addr_length) = 0x30;
static inline uint32_t __DP(eMAC1_RX_Buffer_start_addr_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_RX_Buffer_start_addr_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xa000) + (_i *(32/8)));
}

static inline eMAC_RX_Buffer_start_addr_t __DP(eMAC1_RX_Buffer_start_addr_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_Buffer_start_addr_t __DP(eMAC1_RX_Buffer_start_addr_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_Buffer_start_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa000) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC1_RX_Buffer_start_addr_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_Buffer_start_addr_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xa000) + (_i *(32/8)),val);
}

static inline void __DP(eMAC1_RX_Buffer_start_addr_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_start_addr_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_Buffer_start_addr_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_start_addr_t val )
{
    eMAC_RX_Buffer_start_addr_un  u;
    u.val = val;
    u.val._anon29 	= 0;
    mackerel_write_addr_32(_dev->base,(0xa000) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC1_RX_Buffer_start_addr_ADDR_wrf)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_Buffer_start_addr_ADDR_wrf)( __DN(t) * _dev, int _i, uint32_t val )
{
    eMAC_RX_Buffer_start_addr_un  u;
    u.val._anon29 	= 0;
    u.val.ADDR = val;
    mackerel_write_addr_32(_dev->base,(0xa000) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC1_RX_Buffer_start_addr_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_Buffer_start_addr_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_Buffer_start_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa000) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC1_RX_Buffer_start_addr[%d] (eMAC1_RX_Buffer_start_addr):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.ADDR;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ADDR =\t0x%0"PRIx32" (Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC1_RX_Buffer_start_addr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_Buffer_start_addr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC1_RX_Buffer_start_addr_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_RX_Buffer_read_index (eMAC1_RX_Buffer_read_index); type eMAC.RX_Buffer_read_index (RX control RX Buffer Read Index)
 */

/*
 * Dump of fields for register: eMAC1_RX_Buffer_read_index
 *   rid (size 16, offset 0):	 RW	  Read index of RX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC1_RX_Buffer_read_index_length) = 0x30;
static inline uint32_t __DP(eMAC1_RX_Buffer_read_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_RX_Buffer_read_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xa100) + (_i *(32/8)));
}

static inline eMAC_RX_Buffer_read_index_t __DP(eMAC1_RX_Buffer_read_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_Buffer_read_index_t __DP(eMAC1_RX_Buffer_read_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_Buffer_read_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa100) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC1_RX_Buffer_read_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_Buffer_read_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xa100) + (_i *(32/8)),val);
}

static inline void __DP(eMAC1_RX_Buffer_read_index_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_read_index_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_Buffer_read_index_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_read_index_t val )
{
    eMAC_RX_Buffer_read_index_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xa100) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC1_RX_Buffer_read_index_rid_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_Buffer_read_index_rid_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_RX_Buffer_read_index_un  u;
    u.val._anon16 	= 0;
    u.val.rid = val;
    mackerel_write_addr_32(_dev->base,(0xa100) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC1_RX_Buffer_read_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_Buffer_read_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_Buffer_read_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa100) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC1_RX_Buffer_read_index[%d] (eMAC1_RX_Buffer_read_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.rid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rid =\t0x%0"PRIx16" (Read index of RX buffer Points to 32 byte entry in the buffer.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC1_RX_Buffer_read_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_Buffer_read_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC1_RX_Buffer_read_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_RX_Buffer_write_index (eMAC1_RX_Buffer_write_index); type eMAC.RX_Buffer_write_index (RX control RX Buffer Write Index)
 */

/*
 * Dump of fields for register: eMAC1_RX_Buffer_write_index
 *   wid (size 16, offset 0):	 RO	  Write index of RX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC1_RX_Buffer_write_index_length) = 0x30;
static inline uint32_t __DP(eMAC1_RX_Buffer_write_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_RX_Buffer_write_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xa200) + (_i *(32/8)));
}

static inline eMAC_RX_Buffer_write_index_t __DP(eMAC1_RX_Buffer_write_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_Buffer_write_index_t __DP(eMAC1_RX_Buffer_write_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_Buffer_write_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa200) + (_i *(32/8)));
    return u.val;
}

// Register eMAC1_RX_Buffer_write_index is not writeable


static inline int __DP(eMAC1_RX_Buffer_write_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_Buffer_write_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_Buffer_write_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa200) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC1_RX_Buffer_write_index[%d] (eMAC1_RX_Buffer_write_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.wid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wid =\t0x%0"PRIx16" (Write index of RX buffer Points to 32 byte entry in the buffer.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC1_RX_Buffer_write_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_Buffer_write_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC1_RX_Buffer_write_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_RX_Buffer_last_index (eMAC1_RX_Buffer_last_index); type eMAC.RX_Buffer_last_index (RX control RX Buffer Last Index)
 */

/*
 * Dump of fields for register: eMAC1_RX_Buffer_last_index
 *   lid (size 16, offset 0):	 RW	  Last valid index in buffer. .Buffer size = last index * 32 bytes
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC1_RX_Buffer_last_index_length) = 0x30;
static inline uint32_t __DP(eMAC1_RX_Buffer_last_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_RX_Buffer_last_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xa300) + (_i *(32/8)));
}

static inline eMAC_RX_Buffer_last_index_t __DP(eMAC1_RX_Buffer_last_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_Buffer_last_index_t __DP(eMAC1_RX_Buffer_last_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_Buffer_last_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa300) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC1_RX_Buffer_last_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_Buffer_last_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xa300) + (_i *(32/8)),val);
}

static inline void __DP(eMAC1_RX_Buffer_last_index_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_last_index_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_Buffer_last_index_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_last_index_t val )
{
    eMAC_RX_Buffer_last_index_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xa300) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC1_RX_Buffer_last_index_lid_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_Buffer_last_index_lid_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_RX_Buffer_last_index_un  u;
    u.val._anon16 	= 0;
    u.val.lid = val;
    mackerel_write_addr_32(_dev->base,(0xa300) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC1_RX_Buffer_last_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_Buffer_last_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_Buffer_last_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa300) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC1_RX_Buffer_last_index[%d] (eMAC1_RX_Buffer_last_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.lid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lid =\t0x%0"PRIx16" (Last valid index in buffer. .Buffer size = last index * 32 bytes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC1_RX_Buffer_last_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_Buffer_last_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC1_RX_Buffer_last_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_RX_routing (eMAC1_RX_routing); type eMAC.RX_routing (RX control RX routing related)
 */

/*
 * Dump of fields for register: eMAC1_RX_routing
 *   broute (size 8, offset 0):	 RW	  Route to the tile where the MC for this buffer is located
 *   bdest (size 3, offset 8):	 RW	  Defines the port at which the MC is connected
 *   _anon11 (size 5, offset 11):	 MBZ	  _
 *   iroute (size 8, offset 16):	 RW	  Route to the tile where the core for this buffer is located
 *   idest (size 3, offset 24):	 RW	  Selects core 0 or core 1 in the tile
 *   _anon27 (size 5, offset 27):	 MBZ	  _
 */
static const int __DP(eMAC1_RX_routing_length) = 0x30;
static inline uint32_t __DP(eMAC1_RX_routing_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_RX_routing_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xa500) + (_i *(32/8)));
}

static inline eMAC_RX_routing_t __DP(eMAC1_RX_routing_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_routing_t __DP(eMAC1_RX_routing_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa500) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC1_RX_routing_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_routing_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xa500) + (_i *(32/8)),val);
}

static inline void __DP(eMAC1_RX_routing_wr)( __DN(t) * _dev, int _i, eMAC_RX_routing_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_routing_wr)( __DN(t) * _dev, int _i, eMAC_RX_routing_t val )
{
    eMAC_RX_routing_un  u;
    u.val = val;
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    mackerel_write_addr_32(_dev->base,(0xa500) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC1_RX_routing_broute_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_routing_broute_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa500) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    u.val.broute = val;
    mackerel_write_addr_32(_dev->base,(0xa500) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC1_RX_routing_bdest_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_routing_bdest_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa500) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    u.val.bdest = val;
    mackerel_write_addr_32(_dev->base,(0xa500) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC1_RX_routing_iroute_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_routing_iroute_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa500) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    u.val.iroute = val;
    mackerel_write_addr_32(_dev->base,(0xa500) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC1_RX_routing_idest_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_routing_idest_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa500) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    u.val.idest = val;
    mackerel_write_addr_32(_dev->base,(0xa500) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC1_RX_routing_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_routing_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa500) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC1_RX_routing[%d] (eMAC1_RX_routing):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.broute;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " broute =\t0x%"PRIx8" (Route to the tile where the MC for this buffer is located", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.bdest;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bdest =\t0x%"PRIx8" (Defines the port at which the MC is connected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.iroute;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " iroute =\t0x%"PRIx8" (Route to the tile where the core for this buffer is located", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.idest;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " idest =\t0x%"PRIx8" (Selects core 0 or core 1 in the tile", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC1_RX_routing_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_routing_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC1_RX_routing_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_RX_net_port_MAC_high (eMAC1_RX_net_port_MAC_high); type eMAC.RX_net_port_MAC_high (RX Network Port MAC Address (high))
 */

/*
 * Dump of fields for register: eMAC1_RX_net_port_MAC_high
 *   mac_hi (size 16, offset 0):	 RW	  Higher 16 bits of MAC addresses
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC1_RX_net_port_MAC_high_length) = 0x30;
static inline uint32_t __DP(eMAC1_RX_net_port_MAC_high_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_RX_net_port_MAC_high_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xa600) + (_i *(32/8)));
}

static inline eMAC_RX_net_port_MAC_high_t __DP(eMAC1_RX_net_port_MAC_high_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_net_port_MAC_high_t __DP(eMAC1_RX_net_port_MAC_high_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_net_port_MAC_high_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa600) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC1_RX_net_port_MAC_high_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_net_port_MAC_high_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xa600) + (_i *(32/8)),val);
}

static inline void __DP(eMAC1_RX_net_port_MAC_high_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_MAC_high_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_net_port_MAC_high_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_MAC_high_t val )
{
    eMAC_RX_net_port_MAC_high_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xa600) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC1_RX_net_port_MAC_high_mac_hi_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_net_port_MAC_high_mac_hi_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_RX_net_port_MAC_high_un  u;
    u.val._anon16 	= 0;
    u.val.mac_hi = val;
    mackerel_write_addr_32(_dev->base,(0xa600) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC1_RX_net_port_MAC_high_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_net_port_MAC_high_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_net_port_MAC_high_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa600) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC1_RX_net_port_MAC_high[%d] (eMAC1_RX_net_port_MAC_high):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.mac_hi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_hi =\t0x%0"PRIx16" (Higher 16 bits of MAC addresses", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC1_RX_net_port_MAC_high_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_net_port_MAC_high_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC1_RX_net_port_MAC_high_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_RX_net_port_MAC_low (eMAC1_RX_net_port_MAC_low); type eMAC.RX_net_port_MAC_low (RX Network Port MAC Address (low))
 */

/*
 * Dump of fields for register: eMAC1_RX_net_port_MAC_low
 *   mac_lo (size 32, offset 0):	 RW	  Lower 32 bits of MAC addresses
 */
static const int __DP(eMAC1_RX_net_port_MAC_low_length) = 0x30;
static inline uint32_t __DP(eMAC1_RX_net_port_MAC_low_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_RX_net_port_MAC_low_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xa700) + (_i *(32/8)));
}

static inline eMAC_RX_net_port_MAC_low_t __DP(eMAC1_RX_net_port_MAC_low_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_net_port_MAC_low_t __DP(eMAC1_RX_net_port_MAC_low_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_net_port_MAC_low_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa700) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC1_RX_net_port_MAC_low_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_net_port_MAC_low_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xa700) + (_i *(32/8)),val);
}

static inline void __DP(eMAC1_RX_net_port_MAC_low_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_MAC_low_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_net_port_MAC_low_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_MAC_low_t val )
{
    eMAC_RX_net_port_MAC_low_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0xa700) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC1_RX_net_port_MAC_low_mac_lo_wrf)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_net_port_MAC_low_mac_lo_wrf)( __DN(t) * _dev, int _i, uint32_t val )
{
    eMAC_RX_net_port_MAC_low_un  u;
    u.val.mac_lo = val;
    mackerel_write_addr_32(_dev->base,(0xa700) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC1_RX_net_port_MAC_low_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_net_port_MAC_low_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_net_port_MAC_low_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa700) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC1_RX_net_port_MAC_low[%d] (eMAC1_RX_net_port_MAC_low):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.mac_lo;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_lo =\t0x%0"PRIx32" (Lower 32 bits of MAC addresses", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}
static inline int __DP(eMAC1_RX_net_port_MAC_low_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_net_port_MAC_low_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC1_RX_net_port_MAC_low_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_RX_net_port_enable (eMAC1_RX_net_port_enable); type eMAC.RX_net_port_enable (RX Network Port Enable)
 */

/*
 * Dump of fields for register: eMAC1_RX_net_port_enable
 *   enable (size 1, offset 0):	 RW	  1 - Enabled, 0 - Disabled
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
static const int __DP(eMAC1_RX_net_port_enable_length) = 0x30;
static inline uint32_t __DP(eMAC1_RX_net_port_enable_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_RX_net_port_enable_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xa800) + (_i *(32/8)));
}

static inline eMAC_RX_net_port_enable_t __DP(eMAC1_RX_net_port_enable_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_net_port_enable_t __DP(eMAC1_RX_net_port_enable_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_net_port_enable_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa800) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC1_RX_net_port_enable_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_net_port_enable_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xa800) + (_i *(32/8)),val);
}

static inline void __DP(eMAC1_RX_net_port_enable_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_enable_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_net_port_enable_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_enable_t val )
{
    eMAC_RX_net_port_enable_un  u;
    u.val = val;
    u.val._anon1 	= 0;
    mackerel_write_addr_32(_dev->base,(0xa800) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC1_RX_net_port_enable_enable_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_RX_net_port_enable_enable_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_net_port_enable_un  u;
    u.val._anon1 	= 0;
    u.val.enable = val;
    mackerel_write_addr_32(_dev->base,(0xa800) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC1_RX_net_port_enable_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_net_port_enable_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_net_port_enable_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa800) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC1_RX_net_port_enable[%d] (eMAC1_RX_net_port_enable):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " enable =\t0x%"PRIx8" (1 - Enabled, 0 - Disabled", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC1_RX_net_port_enable_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_RX_net_port_enable_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC1_RX_net_port_enable_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_TX_Buffer_start_addr (eMAC1_TX_Buffer_start_addr); type eMAC.TX_Buffer_start_addr (TX control TX Buffer Start Address)
 */

/*
 * Dump of fields for register: eMAC1_TX_Buffer_start_addr
 *   ADDR (size 29, offset 0):	 RW	  Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.
 *   _anon29 (size 3, offset 29):	 MBZ	  _
 */
static const int __DP(eMAC1_TX_Buffer_start_addr_length) = 0x30;
static inline uint32_t __DP(eMAC1_TX_Buffer_start_addr_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_TX_Buffer_start_addr_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xa900) + (_i *(32/8)));
}

static inline eMAC_TX_Buffer_start_addr_t __DP(eMAC1_TX_Buffer_start_addr_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_Buffer_start_addr_t __DP(eMAC1_TX_Buffer_start_addr_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_Buffer_start_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa900) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC1_TX_Buffer_start_addr_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_TX_Buffer_start_addr_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xa900) + (_i *(32/8)),val);
}

static inline void __DP(eMAC1_TX_Buffer_start_addr_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_start_addr_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_TX_Buffer_start_addr_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_start_addr_t val )
{
    eMAC_TX_Buffer_start_addr_un  u;
    u.val = val;
    u.val._anon29 	= 0;
    mackerel_write_addr_32(_dev->base,(0xa900) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC1_TX_Buffer_start_addr_ADDR_wrf)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_TX_Buffer_start_addr_ADDR_wrf)( __DN(t) * _dev, int _i, uint32_t val )
{
    eMAC_TX_Buffer_start_addr_un  u;
    u.val._anon29 	= 0;
    u.val.ADDR = val;
    mackerel_write_addr_32(_dev->base,(0xa900) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC1_TX_Buffer_start_addr_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_TX_Buffer_start_addr_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_Buffer_start_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xa900) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC1_TX_Buffer_start_addr[%d] (eMAC1_TX_Buffer_start_addr):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.ADDR;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ADDR =\t0x%0"PRIx32" (Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC1_TX_Buffer_start_addr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_TX_Buffer_start_addr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC1_TX_Buffer_start_addr_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_TX_Buffer_read_index (eMAC1_TX_Buffer_read_index); type eMAC.TX_Buffer_read_index (TX control TX Buffer Read Index)
 */

/*
 * Dump of fields for register: eMAC1_TX_Buffer_read_index
 *   rid (size 16, offset 0):	 RO	  Read index of TX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC1_TX_Buffer_read_index_length) = 0x30;
static inline uint32_t __DP(eMAC1_TX_Buffer_read_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_TX_Buffer_read_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xaa00) + (_i *(32/8)));
}

static inline eMAC_TX_Buffer_read_index_t __DP(eMAC1_TX_Buffer_read_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_Buffer_read_index_t __DP(eMAC1_TX_Buffer_read_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_Buffer_read_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xaa00) + (_i *(32/8)));
    return u.val;
}

// Register eMAC1_TX_Buffer_read_index is not writeable


static inline int __DP(eMAC1_TX_Buffer_read_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_TX_Buffer_read_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_Buffer_read_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xaa00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC1_TX_Buffer_read_index[%d] (eMAC1_TX_Buffer_read_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.rid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rid =\t0x%0"PRIx16" (Read index of TX buffer Points to 32 byte entry in the buffer.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC1_TX_Buffer_read_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_TX_Buffer_read_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC1_TX_Buffer_read_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_TX_Buffer_write_index (eMAC1_TX_Buffer_write_index); type eMAC.TX_Buffer_write_index (TX control TX Buffer Write Index)
 */

/*
 * Dump of fields for register: eMAC1_TX_Buffer_write_index
 *   wid (size 16, offset 0):	 RW	  Write index of TX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC1_TX_Buffer_write_index_length) = 0x30;
static inline uint32_t __DP(eMAC1_TX_Buffer_write_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_TX_Buffer_write_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xab00) + (_i *(32/8)));
}

static inline eMAC_TX_Buffer_write_index_t __DP(eMAC1_TX_Buffer_write_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_Buffer_write_index_t __DP(eMAC1_TX_Buffer_write_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_Buffer_write_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xab00) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC1_TX_Buffer_write_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_TX_Buffer_write_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xab00) + (_i *(32/8)),val);
}

static inline void __DP(eMAC1_TX_Buffer_write_index_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_write_index_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_TX_Buffer_write_index_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_write_index_t val )
{
    eMAC_TX_Buffer_write_index_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xab00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC1_TX_Buffer_write_index_wid_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_TX_Buffer_write_index_wid_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_TX_Buffer_write_index_un  u;
    u.val._anon16 	= 0;
    u.val.wid = val;
    mackerel_write_addr_32(_dev->base,(0xab00) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC1_TX_Buffer_write_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_TX_Buffer_write_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_Buffer_write_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xab00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC1_TX_Buffer_write_index[%d] (eMAC1_TX_Buffer_write_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.wid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wid =\t0x%0"PRIx16" (Write index of TX buffer Points to 32 byte entry in the buffer.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC1_TX_Buffer_write_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_TX_Buffer_write_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC1_TX_Buffer_write_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_TX_Buffer_last_index (eMAC1_TX_Buffer_last_index); type eMAC.TX_Buffer_last_index (TX control TX Buffer Last Index)
 */

/*
 * Dump of fields for register: eMAC1_TX_Buffer_last_index
 *   lid (size 16, offset 0):	 RW	  Last valid index in buffer. .Buffer size = last index * 32 bytes
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC1_TX_Buffer_last_index_length) = 0x30;
static inline uint32_t __DP(eMAC1_TX_Buffer_last_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_TX_Buffer_last_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xac00) + (_i *(32/8)));
}

static inline eMAC_TX_Buffer_last_index_t __DP(eMAC1_TX_Buffer_last_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_Buffer_last_index_t __DP(eMAC1_TX_Buffer_last_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_Buffer_last_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xac00) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC1_TX_Buffer_last_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_TX_Buffer_last_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xac00) + (_i *(32/8)),val);
}

static inline void __DP(eMAC1_TX_Buffer_last_index_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_last_index_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_TX_Buffer_last_index_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_last_index_t val )
{
    eMAC_TX_Buffer_last_index_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xac00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC1_TX_Buffer_last_index_lid_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_TX_Buffer_last_index_lid_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_TX_Buffer_last_index_un  u;
    u.val._anon16 	= 0;
    u.val.lid = val;
    mackerel_write_addr_32(_dev->base,(0xac00) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC1_TX_Buffer_last_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_TX_Buffer_last_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_Buffer_last_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xac00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC1_TX_Buffer_last_index[%d] (eMAC1_TX_Buffer_last_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.lid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lid =\t0x%0"PRIx16" (Last valid index in buffer. .Buffer size = last index * 32 bytes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC1_TX_Buffer_last_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_TX_Buffer_last_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC1_TX_Buffer_last_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_TX_routing (eMAC1_TX_routing); type eMAC.TX_routing (TX control RX routing related)
 */

/*
 * Dump of fields for register: eMAC1_TX_routing
 *   broute (size 8, offset 0):	 RW	  Route to the tile where the MC for this buffer is located
 *   bdest (size 3, offset 8):	 RW	  Defines the port at which the MC is connected
 *   _anon11 (size 21, offset 11):	 MBZ	  _
 */
static const int __DP(eMAC1_TX_routing_length) = 0x30;
static inline uint32_t __DP(eMAC1_TX_routing_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_TX_routing_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xad00) + (_i *(32/8)));
}

static inline eMAC_TX_routing_t __DP(eMAC1_TX_routing_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_routing_t __DP(eMAC1_TX_routing_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xad00) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC1_TX_routing_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_TX_routing_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xad00) + (_i *(32/8)),val);
}

static inline void __DP(eMAC1_TX_routing_wr)( __DN(t) * _dev, int _i, eMAC_TX_routing_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_TX_routing_wr)( __DN(t) * _dev, int _i, eMAC_TX_routing_t val )
{
    eMAC_TX_routing_un  u;
    u.val = val;
    u.val._anon11 	= 0;
    mackerel_write_addr_32(_dev->base,(0xad00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC1_TX_routing_broute_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_TX_routing_broute_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_TX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xad00) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val.broute = val;
    mackerel_write_addr_32(_dev->base,(0xad00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC1_TX_routing_bdest_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_TX_routing_bdest_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_TX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xad00) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val.bdest = val;
    mackerel_write_addr_32(_dev->base,(0xad00) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC1_TX_routing_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_TX_routing_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xad00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC1_TX_routing[%d] (eMAC1_TX_routing):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.broute;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " broute =\t0x%"PRIx8" (Route to the tile where the MC for this buffer is located", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.bdest;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bdest =\t0x%"PRIx8" (Defines the port at which the MC is connected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC1_TX_routing_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_TX_routing_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC1_TX_routing_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC1_TX_net_port_enable (eMAC1_TX_net_port_enable); type eMAC.TX_net_port_enable (TX Network Port Enable)
 */

/*
 * Dump of fields for register: eMAC1_TX_net_port_enable
 *   enable (size 1, offset 0):	 RW	  1 - Enabled, 0 - Disabled
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
static const int __DP(eMAC1_TX_net_port_enable_length) = 0x30;
static inline uint32_t __DP(eMAC1_TX_net_port_enable_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC1_TX_net_port_enable_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xae00) + (_i *(32/8)));
}

static inline eMAC_TX_net_port_enable_t __DP(eMAC1_TX_net_port_enable_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_net_port_enable_t __DP(eMAC1_TX_net_port_enable_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_net_port_enable_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xae00) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC1_TX_net_port_enable_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_TX_net_port_enable_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xae00) + (_i *(32/8)),val);
}

static inline void __DP(eMAC1_TX_net_port_enable_wr)( __DN(t) * _dev, int _i, eMAC_TX_net_port_enable_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_TX_net_port_enable_wr)( __DN(t) * _dev, int _i, eMAC_TX_net_port_enable_t val )
{
    eMAC_TX_net_port_enable_un  u;
    u.val = val;
    u.val._anon1 	= 0;
    mackerel_write_addr_32(_dev->base,(0xae00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC1_TX_net_port_enable_enable_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC1_TX_net_port_enable_enable_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_TX_net_port_enable_un  u;
    u.val._anon1 	= 0;
    u.val.enable = val;
    mackerel_write_addr_32(_dev->base,(0xae00) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC1_TX_net_port_enable_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_TX_net_port_enable_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_net_port_enable_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xae00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC1_TX_net_port_enable[%d] (eMAC1_TX_net_port_enable):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " enable =\t0x%"PRIx8" (1 - Enabled, 0 - Disabled", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC1_TX_net_port_enable_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC1_TX_net_port_enable_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC1_TX_net_port_enable_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_RX_Buffer_start_addr (eMAC2_RX_Buffer_start_addr); type eMAC.RX_Buffer_start_addr (RX control RX Buffer Start Address)
 */

/*
 * Dump of fields for register: eMAC2_RX_Buffer_start_addr
 *   ADDR (size 29, offset 0):	 RW	  Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.
 *   _anon29 (size 3, offset 29):	 MBZ	  _
 */
static const int __DP(eMAC2_RX_Buffer_start_addr_length) = 0x30;
static inline uint32_t __DP(eMAC2_RX_Buffer_start_addr_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_RX_Buffer_start_addr_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xb000) + (_i *(32/8)));
}

static inline eMAC_RX_Buffer_start_addr_t __DP(eMAC2_RX_Buffer_start_addr_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_Buffer_start_addr_t __DP(eMAC2_RX_Buffer_start_addr_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_Buffer_start_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb000) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC2_RX_Buffer_start_addr_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_Buffer_start_addr_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xb000) + (_i *(32/8)),val);
}

static inline void __DP(eMAC2_RX_Buffer_start_addr_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_start_addr_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_Buffer_start_addr_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_start_addr_t val )
{
    eMAC_RX_Buffer_start_addr_un  u;
    u.val = val;
    u.val._anon29 	= 0;
    mackerel_write_addr_32(_dev->base,(0xb000) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC2_RX_Buffer_start_addr_ADDR_wrf)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_Buffer_start_addr_ADDR_wrf)( __DN(t) * _dev, int _i, uint32_t val )
{
    eMAC_RX_Buffer_start_addr_un  u;
    u.val._anon29 	= 0;
    u.val.ADDR = val;
    mackerel_write_addr_32(_dev->base,(0xb000) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC2_RX_Buffer_start_addr_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_Buffer_start_addr_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_Buffer_start_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb000) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC2_RX_Buffer_start_addr[%d] (eMAC2_RX_Buffer_start_addr):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.ADDR;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ADDR =\t0x%0"PRIx32" (Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC2_RX_Buffer_start_addr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_Buffer_start_addr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC2_RX_Buffer_start_addr_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_RX_Buffer_read_index (eMAC2_RX_Buffer_read_index); type eMAC.RX_Buffer_read_index (RX control RX Buffer Read Index)
 */

/*
 * Dump of fields for register: eMAC2_RX_Buffer_read_index
 *   rid (size 16, offset 0):	 RW	  Read index of RX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC2_RX_Buffer_read_index_length) = 0x30;
static inline uint32_t __DP(eMAC2_RX_Buffer_read_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_RX_Buffer_read_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xb100) + (_i *(32/8)));
}

static inline eMAC_RX_Buffer_read_index_t __DP(eMAC2_RX_Buffer_read_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_Buffer_read_index_t __DP(eMAC2_RX_Buffer_read_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_Buffer_read_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb100) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC2_RX_Buffer_read_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_Buffer_read_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xb100) + (_i *(32/8)),val);
}

static inline void __DP(eMAC2_RX_Buffer_read_index_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_read_index_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_Buffer_read_index_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_read_index_t val )
{
    eMAC_RX_Buffer_read_index_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xb100) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC2_RX_Buffer_read_index_rid_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_Buffer_read_index_rid_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_RX_Buffer_read_index_un  u;
    u.val._anon16 	= 0;
    u.val.rid = val;
    mackerel_write_addr_32(_dev->base,(0xb100) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC2_RX_Buffer_read_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_Buffer_read_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_Buffer_read_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb100) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC2_RX_Buffer_read_index[%d] (eMAC2_RX_Buffer_read_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.rid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rid =\t0x%0"PRIx16" (Read index of RX buffer Points to 32 byte entry in the buffer.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC2_RX_Buffer_read_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_Buffer_read_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC2_RX_Buffer_read_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_RX_Buffer_write_index (eMAC2_RX_Buffer_write_index); type eMAC.RX_Buffer_write_index (RX control RX Buffer Write Index)
 */

/*
 * Dump of fields for register: eMAC2_RX_Buffer_write_index
 *   wid (size 16, offset 0):	 RO	  Write index of RX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC2_RX_Buffer_write_index_length) = 0x30;
static inline uint32_t __DP(eMAC2_RX_Buffer_write_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_RX_Buffer_write_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xb200) + (_i *(32/8)));
}

static inline eMAC_RX_Buffer_write_index_t __DP(eMAC2_RX_Buffer_write_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_Buffer_write_index_t __DP(eMAC2_RX_Buffer_write_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_Buffer_write_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb200) + (_i *(32/8)));
    return u.val;
}

// Register eMAC2_RX_Buffer_write_index is not writeable


static inline int __DP(eMAC2_RX_Buffer_write_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_Buffer_write_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_Buffer_write_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb200) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC2_RX_Buffer_write_index[%d] (eMAC2_RX_Buffer_write_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.wid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wid =\t0x%0"PRIx16" (Write index of RX buffer Points to 32 byte entry in the buffer.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC2_RX_Buffer_write_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_Buffer_write_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC2_RX_Buffer_write_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_RX_Buffer_last_index (eMAC2_RX_Buffer_last_index); type eMAC.RX_Buffer_last_index (RX control RX Buffer Last Index)
 */

/*
 * Dump of fields for register: eMAC2_RX_Buffer_last_index
 *   lid (size 16, offset 0):	 RW	  Last valid index in buffer. .Buffer size = last index * 32 bytes
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC2_RX_Buffer_last_index_length) = 0x30;
static inline uint32_t __DP(eMAC2_RX_Buffer_last_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_RX_Buffer_last_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xb300) + (_i *(32/8)));
}

static inline eMAC_RX_Buffer_last_index_t __DP(eMAC2_RX_Buffer_last_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_Buffer_last_index_t __DP(eMAC2_RX_Buffer_last_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_Buffer_last_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb300) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC2_RX_Buffer_last_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_Buffer_last_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xb300) + (_i *(32/8)),val);
}

static inline void __DP(eMAC2_RX_Buffer_last_index_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_last_index_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_Buffer_last_index_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_last_index_t val )
{
    eMAC_RX_Buffer_last_index_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xb300) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC2_RX_Buffer_last_index_lid_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_Buffer_last_index_lid_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_RX_Buffer_last_index_un  u;
    u.val._anon16 	= 0;
    u.val.lid = val;
    mackerel_write_addr_32(_dev->base,(0xb300) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC2_RX_Buffer_last_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_Buffer_last_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_Buffer_last_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb300) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC2_RX_Buffer_last_index[%d] (eMAC2_RX_Buffer_last_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.lid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lid =\t0x%0"PRIx16" (Last valid index in buffer. .Buffer size = last index * 32 bytes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC2_RX_Buffer_last_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_Buffer_last_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC2_RX_Buffer_last_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_RX_routing (eMAC2_RX_routing); type eMAC.RX_routing (RX control RX routing related)
 */

/*
 * Dump of fields for register: eMAC2_RX_routing
 *   broute (size 8, offset 0):	 RW	  Route to the tile where the MC for this buffer is located
 *   bdest (size 3, offset 8):	 RW	  Defines the port at which the MC is connected
 *   _anon11 (size 5, offset 11):	 MBZ	  _
 *   iroute (size 8, offset 16):	 RW	  Route to the tile where the core for this buffer is located
 *   idest (size 3, offset 24):	 RW	  Selects core 0 or core 1 in the tile
 *   _anon27 (size 5, offset 27):	 MBZ	  _
 */
static const int __DP(eMAC2_RX_routing_length) = 0x30;
static inline uint32_t __DP(eMAC2_RX_routing_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_RX_routing_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xb500) + (_i *(32/8)));
}

static inline eMAC_RX_routing_t __DP(eMAC2_RX_routing_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_routing_t __DP(eMAC2_RX_routing_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb500) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC2_RX_routing_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_routing_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xb500) + (_i *(32/8)),val);
}

static inline void __DP(eMAC2_RX_routing_wr)( __DN(t) * _dev, int _i, eMAC_RX_routing_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_routing_wr)( __DN(t) * _dev, int _i, eMAC_RX_routing_t val )
{
    eMAC_RX_routing_un  u;
    u.val = val;
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    mackerel_write_addr_32(_dev->base,(0xb500) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC2_RX_routing_broute_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_routing_broute_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb500) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    u.val.broute = val;
    mackerel_write_addr_32(_dev->base,(0xb500) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC2_RX_routing_bdest_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_routing_bdest_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb500) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    u.val.bdest = val;
    mackerel_write_addr_32(_dev->base,(0xb500) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC2_RX_routing_iroute_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_routing_iroute_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb500) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    u.val.iroute = val;
    mackerel_write_addr_32(_dev->base,(0xb500) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC2_RX_routing_idest_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_routing_idest_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb500) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    u.val.idest = val;
    mackerel_write_addr_32(_dev->base,(0xb500) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC2_RX_routing_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_routing_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb500) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC2_RX_routing[%d] (eMAC2_RX_routing):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.broute;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " broute =\t0x%"PRIx8" (Route to the tile where the MC for this buffer is located", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.bdest;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bdest =\t0x%"PRIx8" (Defines the port at which the MC is connected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.iroute;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " iroute =\t0x%"PRIx8" (Route to the tile where the core for this buffer is located", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.idest;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " idest =\t0x%"PRIx8" (Selects core 0 or core 1 in the tile", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC2_RX_routing_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_routing_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC2_RX_routing_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_RX_net_port_MAC_high (eMAC2_RX_net_port_MAC_high); type eMAC.RX_net_port_MAC_high (RX Network Port MAC Address (high))
 */

/*
 * Dump of fields for register: eMAC2_RX_net_port_MAC_high
 *   mac_hi (size 16, offset 0):	 RW	  Higher 16 bits of MAC addresses
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC2_RX_net_port_MAC_high_length) = 0x30;
static inline uint32_t __DP(eMAC2_RX_net_port_MAC_high_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_RX_net_port_MAC_high_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xb600) + (_i *(32/8)));
}

static inline eMAC_RX_net_port_MAC_high_t __DP(eMAC2_RX_net_port_MAC_high_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_net_port_MAC_high_t __DP(eMAC2_RX_net_port_MAC_high_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_net_port_MAC_high_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb600) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC2_RX_net_port_MAC_high_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_net_port_MAC_high_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xb600) + (_i *(32/8)),val);
}

static inline void __DP(eMAC2_RX_net_port_MAC_high_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_MAC_high_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_net_port_MAC_high_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_MAC_high_t val )
{
    eMAC_RX_net_port_MAC_high_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xb600) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC2_RX_net_port_MAC_high_mac_hi_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_net_port_MAC_high_mac_hi_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_RX_net_port_MAC_high_un  u;
    u.val._anon16 	= 0;
    u.val.mac_hi = val;
    mackerel_write_addr_32(_dev->base,(0xb600) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC2_RX_net_port_MAC_high_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_net_port_MAC_high_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_net_port_MAC_high_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb600) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC2_RX_net_port_MAC_high[%d] (eMAC2_RX_net_port_MAC_high):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.mac_hi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_hi =\t0x%0"PRIx16" (Higher 16 bits of MAC addresses", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC2_RX_net_port_MAC_high_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_net_port_MAC_high_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC2_RX_net_port_MAC_high_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_RX_net_port_MAC_low (eMAC2_RX_net_port_MAC_low); type eMAC.RX_net_port_MAC_low (RX Network Port MAC Address (low))
 */

/*
 * Dump of fields for register: eMAC2_RX_net_port_MAC_low
 *   mac_lo (size 32, offset 0):	 RW	  Lower 32 bits of MAC addresses
 */
static const int __DP(eMAC2_RX_net_port_MAC_low_length) = 0x30;
static inline uint32_t __DP(eMAC2_RX_net_port_MAC_low_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_RX_net_port_MAC_low_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xb700) + (_i *(32/8)));
}

static inline eMAC_RX_net_port_MAC_low_t __DP(eMAC2_RX_net_port_MAC_low_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_net_port_MAC_low_t __DP(eMAC2_RX_net_port_MAC_low_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_net_port_MAC_low_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb700) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC2_RX_net_port_MAC_low_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_net_port_MAC_low_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xb700) + (_i *(32/8)),val);
}

static inline void __DP(eMAC2_RX_net_port_MAC_low_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_MAC_low_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_net_port_MAC_low_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_MAC_low_t val )
{
    eMAC_RX_net_port_MAC_low_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0xb700) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC2_RX_net_port_MAC_low_mac_lo_wrf)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_net_port_MAC_low_mac_lo_wrf)( __DN(t) * _dev, int _i, uint32_t val )
{
    eMAC_RX_net_port_MAC_low_un  u;
    u.val.mac_lo = val;
    mackerel_write_addr_32(_dev->base,(0xb700) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC2_RX_net_port_MAC_low_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_net_port_MAC_low_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_net_port_MAC_low_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb700) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC2_RX_net_port_MAC_low[%d] (eMAC2_RX_net_port_MAC_low):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.mac_lo;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_lo =\t0x%0"PRIx32" (Lower 32 bits of MAC addresses", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}
static inline int __DP(eMAC2_RX_net_port_MAC_low_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_net_port_MAC_low_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC2_RX_net_port_MAC_low_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_RX_net_port_enable (eMAC2_RX_net_port_enable); type eMAC.RX_net_port_enable (RX Network Port Enable)
 */

/*
 * Dump of fields for register: eMAC2_RX_net_port_enable
 *   enable (size 1, offset 0):	 RW	  1 - Enabled, 0 - Disabled
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
static const int __DP(eMAC2_RX_net_port_enable_length) = 0x30;
static inline uint32_t __DP(eMAC2_RX_net_port_enable_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_RX_net_port_enable_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xb800) + (_i *(32/8)));
}

static inline eMAC_RX_net_port_enable_t __DP(eMAC2_RX_net_port_enable_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_net_port_enable_t __DP(eMAC2_RX_net_port_enable_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_net_port_enable_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb800) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC2_RX_net_port_enable_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_net_port_enable_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xb800) + (_i *(32/8)),val);
}

static inline void __DP(eMAC2_RX_net_port_enable_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_enable_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_net_port_enable_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_enable_t val )
{
    eMAC_RX_net_port_enable_un  u;
    u.val = val;
    u.val._anon1 	= 0;
    mackerel_write_addr_32(_dev->base,(0xb800) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC2_RX_net_port_enable_enable_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_RX_net_port_enable_enable_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_net_port_enable_un  u;
    u.val._anon1 	= 0;
    u.val.enable = val;
    mackerel_write_addr_32(_dev->base,(0xb800) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC2_RX_net_port_enable_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_net_port_enable_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_net_port_enable_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb800) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC2_RX_net_port_enable[%d] (eMAC2_RX_net_port_enable):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " enable =\t0x%"PRIx8" (1 - Enabled, 0 - Disabled", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC2_RX_net_port_enable_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_RX_net_port_enable_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC2_RX_net_port_enable_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_TX_Buffer_start_addr (eMAC2_TX_Buffer_start_addr); type eMAC.TX_Buffer_start_addr (TX control TX Buffer Start Address)
 */

/*
 * Dump of fields for register: eMAC2_TX_Buffer_start_addr
 *   ADDR (size 29, offset 0):	 RW	  Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.
 *   _anon29 (size 3, offset 29):	 MBZ	  _
 */
static const int __DP(eMAC2_TX_Buffer_start_addr_length) = 0x30;
static inline uint32_t __DP(eMAC2_TX_Buffer_start_addr_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_TX_Buffer_start_addr_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xb900) + (_i *(32/8)));
}

static inline eMAC_TX_Buffer_start_addr_t __DP(eMAC2_TX_Buffer_start_addr_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_Buffer_start_addr_t __DP(eMAC2_TX_Buffer_start_addr_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_Buffer_start_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb900) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC2_TX_Buffer_start_addr_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_TX_Buffer_start_addr_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xb900) + (_i *(32/8)),val);
}

static inline void __DP(eMAC2_TX_Buffer_start_addr_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_start_addr_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_TX_Buffer_start_addr_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_start_addr_t val )
{
    eMAC_TX_Buffer_start_addr_un  u;
    u.val = val;
    u.val._anon29 	= 0;
    mackerel_write_addr_32(_dev->base,(0xb900) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC2_TX_Buffer_start_addr_ADDR_wrf)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_TX_Buffer_start_addr_ADDR_wrf)( __DN(t) * _dev, int _i, uint32_t val )
{
    eMAC_TX_Buffer_start_addr_un  u;
    u.val._anon29 	= 0;
    u.val.ADDR = val;
    mackerel_write_addr_32(_dev->base,(0xb900) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC2_TX_Buffer_start_addr_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_TX_Buffer_start_addr_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_Buffer_start_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xb900) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC2_TX_Buffer_start_addr[%d] (eMAC2_TX_Buffer_start_addr):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.ADDR;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ADDR =\t0x%0"PRIx32" (Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC2_TX_Buffer_start_addr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_TX_Buffer_start_addr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC2_TX_Buffer_start_addr_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_TX_Buffer_read_index (eMAC2_TX_Buffer_read_index); type eMAC.TX_Buffer_read_index (TX control TX Buffer Read Index)
 */

/*
 * Dump of fields for register: eMAC2_TX_Buffer_read_index
 *   rid (size 16, offset 0):	 RO	  Read index of TX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC2_TX_Buffer_read_index_length) = 0x30;
static inline uint32_t __DP(eMAC2_TX_Buffer_read_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_TX_Buffer_read_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xba00) + (_i *(32/8)));
}

static inline eMAC_TX_Buffer_read_index_t __DP(eMAC2_TX_Buffer_read_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_Buffer_read_index_t __DP(eMAC2_TX_Buffer_read_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_Buffer_read_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xba00) + (_i *(32/8)));
    return u.val;
}

// Register eMAC2_TX_Buffer_read_index is not writeable


static inline int __DP(eMAC2_TX_Buffer_read_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_TX_Buffer_read_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_Buffer_read_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xba00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC2_TX_Buffer_read_index[%d] (eMAC2_TX_Buffer_read_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.rid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rid =\t0x%0"PRIx16" (Read index of TX buffer Points to 32 byte entry in the buffer.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC2_TX_Buffer_read_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_TX_Buffer_read_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC2_TX_Buffer_read_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_TX_Buffer_write_index (eMAC2_TX_Buffer_write_index); type eMAC.TX_Buffer_write_index (TX control TX Buffer Write Index)
 */

/*
 * Dump of fields for register: eMAC2_TX_Buffer_write_index
 *   wid (size 16, offset 0):	 RW	  Write index of TX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC2_TX_Buffer_write_index_length) = 0x30;
static inline uint32_t __DP(eMAC2_TX_Buffer_write_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_TX_Buffer_write_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xbb00) + (_i *(32/8)));
}

static inline eMAC_TX_Buffer_write_index_t __DP(eMAC2_TX_Buffer_write_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_Buffer_write_index_t __DP(eMAC2_TX_Buffer_write_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_Buffer_write_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xbb00) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC2_TX_Buffer_write_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_TX_Buffer_write_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xbb00) + (_i *(32/8)),val);
}

static inline void __DP(eMAC2_TX_Buffer_write_index_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_write_index_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_TX_Buffer_write_index_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_write_index_t val )
{
    eMAC_TX_Buffer_write_index_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xbb00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC2_TX_Buffer_write_index_wid_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_TX_Buffer_write_index_wid_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_TX_Buffer_write_index_un  u;
    u.val._anon16 	= 0;
    u.val.wid = val;
    mackerel_write_addr_32(_dev->base,(0xbb00) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC2_TX_Buffer_write_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_TX_Buffer_write_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_Buffer_write_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xbb00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC2_TX_Buffer_write_index[%d] (eMAC2_TX_Buffer_write_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.wid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wid =\t0x%0"PRIx16" (Write index of TX buffer Points to 32 byte entry in the buffer.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC2_TX_Buffer_write_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_TX_Buffer_write_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC2_TX_Buffer_write_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_TX_Buffer_last_index (eMAC2_TX_Buffer_last_index); type eMAC.TX_Buffer_last_index (TX control TX Buffer Last Index)
 */

/*
 * Dump of fields for register: eMAC2_TX_Buffer_last_index
 *   lid (size 16, offset 0):	 RW	  Last valid index in buffer. .Buffer size = last index * 32 bytes
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC2_TX_Buffer_last_index_length) = 0x30;
static inline uint32_t __DP(eMAC2_TX_Buffer_last_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_TX_Buffer_last_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xbc00) + (_i *(32/8)));
}

static inline eMAC_TX_Buffer_last_index_t __DP(eMAC2_TX_Buffer_last_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_Buffer_last_index_t __DP(eMAC2_TX_Buffer_last_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_Buffer_last_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xbc00) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC2_TX_Buffer_last_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_TX_Buffer_last_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xbc00) + (_i *(32/8)),val);
}

static inline void __DP(eMAC2_TX_Buffer_last_index_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_last_index_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_TX_Buffer_last_index_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_last_index_t val )
{
    eMAC_TX_Buffer_last_index_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xbc00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC2_TX_Buffer_last_index_lid_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_TX_Buffer_last_index_lid_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_TX_Buffer_last_index_un  u;
    u.val._anon16 	= 0;
    u.val.lid = val;
    mackerel_write_addr_32(_dev->base,(0xbc00) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC2_TX_Buffer_last_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_TX_Buffer_last_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_Buffer_last_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xbc00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC2_TX_Buffer_last_index[%d] (eMAC2_TX_Buffer_last_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.lid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lid =\t0x%0"PRIx16" (Last valid index in buffer. .Buffer size = last index * 32 bytes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC2_TX_Buffer_last_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_TX_Buffer_last_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC2_TX_Buffer_last_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_TX_routing (eMAC2_TX_routing); type eMAC.TX_routing (TX control RX routing related)
 */

/*
 * Dump of fields for register: eMAC2_TX_routing
 *   broute (size 8, offset 0):	 RW	  Route to the tile where the MC for this buffer is located
 *   bdest (size 3, offset 8):	 RW	  Defines the port at which the MC is connected
 *   _anon11 (size 21, offset 11):	 MBZ	  _
 */
static const int __DP(eMAC2_TX_routing_length) = 0x30;
static inline uint32_t __DP(eMAC2_TX_routing_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_TX_routing_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xbd00) + (_i *(32/8)));
}

static inline eMAC_TX_routing_t __DP(eMAC2_TX_routing_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_routing_t __DP(eMAC2_TX_routing_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xbd00) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC2_TX_routing_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_TX_routing_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xbd00) + (_i *(32/8)),val);
}

static inline void __DP(eMAC2_TX_routing_wr)( __DN(t) * _dev, int _i, eMAC_TX_routing_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_TX_routing_wr)( __DN(t) * _dev, int _i, eMAC_TX_routing_t val )
{
    eMAC_TX_routing_un  u;
    u.val = val;
    u.val._anon11 	= 0;
    mackerel_write_addr_32(_dev->base,(0xbd00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC2_TX_routing_broute_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_TX_routing_broute_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_TX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xbd00) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val.broute = val;
    mackerel_write_addr_32(_dev->base,(0xbd00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC2_TX_routing_bdest_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_TX_routing_bdest_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_TX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xbd00) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val.bdest = val;
    mackerel_write_addr_32(_dev->base,(0xbd00) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC2_TX_routing_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_TX_routing_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xbd00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC2_TX_routing[%d] (eMAC2_TX_routing):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.broute;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " broute =\t0x%"PRIx8" (Route to the tile where the MC for this buffer is located", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.bdest;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bdest =\t0x%"PRIx8" (Defines the port at which the MC is connected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC2_TX_routing_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_TX_routing_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC2_TX_routing_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC2_TX_net_port_enable (eMAC2_TX_net_port_enable); type eMAC.TX_net_port_enable (TX Network Port Enable)
 */

/*
 * Dump of fields for register: eMAC2_TX_net_port_enable
 *   enable (size 1, offset 0):	 RW	  1 - Enabled, 0 - Disabled
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
static const int __DP(eMAC2_TX_net_port_enable_length) = 0x30;
static inline uint32_t __DP(eMAC2_TX_net_port_enable_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC2_TX_net_port_enable_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xbe00) + (_i *(32/8)));
}

static inline eMAC_TX_net_port_enable_t __DP(eMAC2_TX_net_port_enable_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_net_port_enable_t __DP(eMAC2_TX_net_port_enable_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_net_port_enable_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xbe00) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC2_TX_net_port_enable_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_TX_net_port_enable_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xbe00) + (_i *(32/8)),val);
}

static inline void __DP(eMAC2_TX_net_port_enable_wr)( __DN(t) * _dev, int _i, eMAC_TX_net_port_enable_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_TX_net_port_enable_wr)( __DN(t) * _dev, int _i, eMAC_TX_net_port_enable_t val )
{
    eMAC_TX_net_port_enable_un  u;
    u.val = val;
    u.val._anon1 	= 0;
    mackerel_write_addr_32(_dev->base,(0xbe00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC2_TX_net_port_enable_enable_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC2_TX_net_port_enable_enable_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_TX_net_port_enable_un  u;
    u.val._anon1 	= 0;
    u.val.enable = val;
    mackerel_write_addr_32(_dev->base,(0xbe00) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC2_TX_net_port_enable_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_TX_net_port_enable_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_net_port_enable_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xbe00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC2_TX_net_port_enable[%d] (eMAC2_TX_net_port_enable):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " enable =\t0x%"PRIx8" (1 - Enabled, 0 - Disabled", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC2_TX_net_port_enable_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC2_TX_net_port_enable_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC2_TX_net_port_enable_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_RX_Buffer_start_addr (eMAC3_RX_Buffer_start_addr); type eMAC.RX_Buffer_start_addr (RX control RX Buffer Start Address)
 */

/*
 * Dump of fields for register: eMAC3_RX_Buffer_start_addr
 *   ADDR (size 29, offset 0):	 RW	  Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.
 *   _anon29 (size 3, offset 29):	 MBZ	  _
 */
static const int __DP(eMAC3_RX_Buffer_start_addr_length) = 0x30;
static inline uint32_t __DP(eMAC3_RX_Buffer_start_addr_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_RX_Buffer_start_addr_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xc000) + (_i *(32/8)));
}

static inline eMAC_RX_Buffer_start_addr_t __DP(eMAC3_RX_Buffer_start_addr_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_Buffer_start_addr_t __DP(eMAC3_RX_Buffer_start_addr_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_Buffer_start_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc000) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC3_RX_Buffer_start_addr_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_Buffer_start_addr_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xc000) + (_i *(32/8)),val);
}

static inline void __DP(eMAC3_RX_Buffer_start_addr_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_start_addr_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_Buffer_start_addr_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_start_addr_t val )
{
    eMAC_RX_Buffer_start_addr_un  u;
    u.val = val;
    u.val._anon29 	= 0;
    mackerel_write_addr_32(_dev->base,(0xc000) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC3_RX_Buffer_start_addr_ADDR_wrf)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_Buffer_start_addr_ADDR_wrf)( __DN(t) * _dev, int _i, uint32_t val )
{
    eMAC_RX_Buffer_start_addr_un  u;
    u.val._anon29 	= 0;
    u.val.ADDR = val;
    mackerel_write_addr_32(_dev->base,(0xc000) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC3_RX_Buffer_start_addr_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_Buffer_start_addr_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_Buffer_start_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc000) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC3_RX_Buffer_start_addr[%d] (eMAC3_RX_Buffer_start_addr):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.ADDR;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ADDR =\t0x%0"PRIx32" (Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC3_RX_Buffer_start_addr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_Buffer_start_addr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC3_RX_Buffer_start_addr_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_RX_Buffer_read_index (eMAC3_RX_Buffer_read_index); type eMAC.RX_Buffer_read_index (RX control RX Buffer Read Index)
 */

/*
 * Dump of fields for register: eMAC3_RX_Buffer_read_index
 *   rid (size 16, offset 0):	 RW	  Read index of RX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC3_RX_Buffer_read_index_length) = 0x30;
static inline uint32_t __DP(eMAC3_RX_Buffer_read_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_RX_Buffer_read_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xc100) + (_i *(32/8)));
}

static inline eMAC_RX_Buffer_read_index_t __DP(eMAC3_RX_Buffer_read_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_Buffer_read_index_t __DP(eMAC3_RX_Buffer_read_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_Buffer_read_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc100) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC3_RX_Buffer_read_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_Buffer_read_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xc100) + (_i *(32/8)),val);
}

static inline void __DP(eMAC3_RX_Buffer_read_index_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_read_index_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_Buffer_read_index_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_read_index_t val )
{
    eMAC_RX_Buffer_read_index_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xc100) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC3_RX_Buffer_read_index_rid_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_Buffer_read_index_rid_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_RX_Buffer_read_index_un  u;
    u.val._anon16 	= 0;
    u.val.rid = val;
    mackerel_write_addr_32(_dev->base,(0xc100) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC3_RX_Buffer_read_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_Buffer_read_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_Buffer_read_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc100) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC3_RX_Buffer_read_index[%d] (eMAC3_RX_Buffer_read_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.rid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rid =\t0x%0"PRIx16" (Read index of RX buffer Points to 32 byte entry in the buffer.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC3_RX_Buffer_read_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_Buffer_read_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC3_RX_Buffer_read_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_RX_Buffer_write_index (eMAC3_RX_Buffer_write_index); type eMAC.RX_Buffer_write_index (RX control RX Buffer Write Index)
 */

/*
 * Dump of fields for register: eMAC3_RX_Buffer_write_index
 *   wid (size 16, offset 0):	 RO	  Write index of RX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC3_RX_Buffer_write_index_length) = 0x30;
static inline uint32_t __DP(eMAC3_RX_Buffer_write_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_RX_Buffer_write_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xc200) + (_i *(32/8)));
}

static inline eMAC_RX_Buffer_write_index_t __DP(eMAC3_RX_Buffer_write_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_Buffer_write_index_t __DP(eMAC3_RX_Buffer_write_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_Buffer_write_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc200) + (_i *(32/8)));
    return u.val;
}

// Register eMAC3_RX_Buffer_write_index is not writeable


static inline int __DP(eMAC3_RX_Buffer_write_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_Buffer_write_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_Buffer_write_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc200) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC3_RX_Buffer_write_index[%d] (eMAC3_RX_Buffer_write_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.wid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wid =\t0x%0"PRIx16" (Write index of RX buffer Points to 32 byte entry in the buffer.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC3_RX_Buffer_write_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_Buffer_write_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC3_RX_Buffer_write_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_RX_Buffer_last_index (eMAC3_RX_Buffer_last_index); type eMAC.RX_Buffer_last_index (RX control RX Buffer Last Index)
 */

/*
 * Dump of fields for register: eMAC3_RX_Buffer_last_index
 *   lid (size 16, offset 0):	 RW	  Last valid index in buffer. .Buffer size = last index * 32 bytes
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC3_RX_Buffer_last_index_length) = 0x30;
static inline uint32_t __DP(eMAC3_RX_Buffer_last_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_RX_Buffer_last_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xc300) + (_i *(32/8)));
}

static inline eMAC_RX_Buffer_last_index_t __DP(eMAC3_RX_Buffer_last_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_Buffer_last_index_t __DP(eMAC3_RX_Buffer_last_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_Buffer_last_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc300) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC3_RX_Buffer_last_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_Buffer_last_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xc300) + (_i *(32/8)),val);
}

static inline void __DP(eMAC3_RX_Buffer_last_index_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_last_index_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_Buffer_last_index_wr)( __DN(t) * _dev, int _i, eMAC_RX_Buffer_last_index_t val )
{
    eMAC_RX_Buffer_last_index_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xc300) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC3_RX_Buffer_last_index_lid_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_Buffer_last_index_lid_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_RX_Buffer_last_index_un  u;
    u.val._anon16 	= 0;
    u.val.lid = val;
    mackerel_write_addr_32(_dev->base,(0xc300) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC3_RX_Buffer_last_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_Buffer_last_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_Buffer_last_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc300) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC3_RX_Buffer_last_index[%d] (eMAC3_RX_Buffer_last_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.lid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lid =\t0x%0"PRIx16" (Last valid index in buffer. .Buffer size = last index * 32 bytes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC3_RX_Buffer_last_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_Buffer_last_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC3_RX_Buffer_last_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_RX_routing (eMAC3_RX_routing); type eMAC.RX_routing (RX control RX routing related)
 */

/*
 * Dump of fields for register: eMAC3_RX_routing
 *   broute (size 8, offset 0):	 RW	  Route to the tile where the MC for this buffer is located
 *   bdest (size 3, offset 8):	 RW	  Defines the port at which the MC is connected
 *   _anon11 (size 5, offset 11):	 MBZ	  _
 *   iroute (size 8, offset 16):	 RW	  Route to the tile where the core for this buffer is located
 *   idest (size 3, offset 24):	 RW	  Selects core 0 or core 1 in the tile
 *   _anon27 (size 5, offset 27):	 MBZ	  _
 */
static const int __DP(eMAC3_RX_routing_length) = 0x30;
static inline uint32_t __DP(eMAC3_RX_routing_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_RX_routing_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xc500) + (_i *(32/8)));
}

static inline eMAC_RX_routing_t __DP(eMAC3_RX_routing_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_routing_t __DP(eMAC3_RX_routing_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc500) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC3_RX_routing_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_routing_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xc500) + (_i *(32/8)),val);
}

static inline void __DP(eMAC3_RX_routing_wr)( __DN(t) * _dev, int _i, eMAC_RX_routing_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_routing_wr)( __DN(t) * _dev, int _i, eMAC_RX_routing_t val )
{
    eMAC_RX_routing_un  u;
    u.val = val;
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    mackerel_write_addr_32(_dev->base,(0xc500) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC3_RX_routing_broute_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_routing_broute_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc500) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    u.val.broute = val;
    mackerel_write_addr_32(_dev->base,(0xc500) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC3_RX_routing_bdest_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_routing_bdest_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc500) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    u.val.bdest = val;
    mackerel_write_addr_32(_dev->base,(0xc500) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC3_RX_routing_iroute_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_routing_iroute_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc500) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    u.val.iroute = val;
    mackerel_write_addr_32(_dev->base,(0xc500) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC3_RX_routing_idest_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_routing_idest_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc500) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val._anon27 	= 0;
    u.val.idest = val;
    mackerel_write_addr_32(_dev->base,(0xc500) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC3_RX_routing_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_routing_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc500) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC3_RX_routing[%d] (eMAC3_RX_routing):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.broute;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " broute =\t0x%"PRIx8" (Route to the tile where the MC for this buffer is located", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.bdest;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bdest =\t0x%"PRIx8" (Defines the port at which the MC is connected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.iroute;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " iroute =\t0x%"PRIx8" (Route to the tile where the core for this buffer is located", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.idest;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " idest =\t0x%"PRIx8" (Selects core 0 or core 1 in the tile", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC3_RX_routing_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_routing_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC3_RX_routing_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_RX_net_port_MAC_high (eMAC3_RX_net_port_MAC_high); type eMAC.RX_net_port_MAC_high (RX Network Port MAC Address (high))
 */

/*
 * Dump of fields for register: eMAC3_RX_net_port_MAC_high
 *   mac_hi (size 16, offset 0):	 RW	  Higher 16 bits of MAC addresses
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC3_RX_net_port_MAC_high_length) = 0x30;
static inline uint32_t __DP(eMAC3_RX_net_port_MAC_high_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_RX_net_port_MAC_high_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xc600) + (_i *(32/8)));
}

static inline eMAC_RX_net_port_MAC_high_t __DP(eMAC3_RX_net_port_MAC_high_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_net_port_MAC_high_t __DP(eMAC3_RX_net_port_MAC_high_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_net_port_MAC_high_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc600) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC3_RX_net_port_MAC_high_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_net_port_MAC_high_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xc600) + (_i *(32/8)),val);
}

static inline void __DP(eMAC3_RX_net_port_MAC_high_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_MAC_high_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_net_port_MAC_high_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_MAC_high_t val )
{
    eMAC_RX_net_port_MAC_high_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xc600) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC3_RX_net_port_MAC_high_mac_hi_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_net_port_MAC_high_mac_hi_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_RX_net_port_MAC_high_un  u;
    u.val._anon16 	= 0;
    u.val.mac_hi = val;
    mackerel_write_addr_32(_dev->base,(0xc600) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC3_RX_net_port_MAC_high_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_net_port_MAC_high_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_net_port_MAC_high_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc600) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC3_RX_net_port_MAC_high[%d] (eMAC3_RX_net_port_MAC_high):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.mac_hi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_hi =\t0x%0"PRIx16" (Higher 16 bits of MAC addresses", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC3_RX_net_port_MAC_high_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_net_port_MAC_high_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC3_RX_net_port_MAC_high_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_RX_net_port_MAC_low (eMAC3_RX_net_port_MAC_low); type eMAC.RX_net_port_MAC_low (RX Network Port MAC Address (low))
 */

/*
 * Dump of fields for register: eMAC3_RX_net_port_MAC_low
 *   mac_lo (size 32, offset 0):	 RW	  Lower 32 bits of MAC addresses
 */
static const int __DP(eMAC3_RX_net_port_MAC_low_length) = 0x30;
static inline uint32_t __DP(eMAC3_RX_net_port_MAC_low_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_RX_net_port_MAC_low_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xc700) + (_i *(32/8)));
}

static inline eMAC_RX_net_port_MAC_low_t __DP(eMAC3_RX_net_port_MAC_low_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_net_port_MAC_low_t __DP(eMAC3_RX_net_port_MAC_low_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_net_port_MAC_low_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc700) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC3_RX_net_port_MAC_low_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_net_port_MAC_low_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xc700) + (_i *(32/8)),val);
}

static inline void __DP(eMAC3_RX_net_port_MAC_low_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_MAC_low_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_net_port_MAC_low_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_MAC_low_t val )
{
    eMAC_RX_net_port_MAC_low_un  u;
    u.val = val;
    mackerel_write_addr_32(_dev->base,(0xc700) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC3_RX_net_port_MAC_low_mac_lo_wrf)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_net_port_MAC_low_mac_lo_wrf)( __DN(t) * _dev, int _i, uint32_t val )
{
    eMAC_RX_net_port_MAC_low_un  u;
    u.val.mac_lo = val;
    mackerel_write_addr_32(_dev->base,(0xc700) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC3_RX_net_port_MAC_low_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_net_port_MAC_low_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_net_port_MAC_low_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc700) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC3_RX_net_port_MAC_low[%d] (eMAC3_RX_net_port_MAC_low):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.mac_lo;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mac_lo =\t0x%0"PRIx32" (Lower 32 bits of MAC addresses", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}
static inline int __DP(eMAC3_RX_net_port_MAC_low_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_net_port_MAC_low_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC3_RX_net_port_MAC_low_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_RX_net_port_enable (eMAC3_RX_net_port_enable); type eMAC.RX_net_port_enable (RX Network Port Enable)
 */

/*
 * Dump of fields for register: eMAC3_RX_net_port_enable
 *   enable (size 1, offset 0):	 RW	  1 - Enabled, 0 - Disabled
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
static const int __DP(eMAC3_RX_net_port_enable_length) = 0x30;
static inline uint32_t __DP(eMAC3_RX_net_port_enable_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_RX_net_port_enable_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xc800) + (_i *(32/8)));
}

static inline eMAC_RX_net_port_enable_t __DP(eMAC3_RX_net_port_enable_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_RX_net_port_enable_t __DP(eMAC3_RX_net_port_enable_rd)( __DN(t) * _dev, int _i )
{
    eMAC_RX_net_port_enable_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc800) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC3_RX_net_port_enable_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_net_port_enable_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xc800) + (_i *(32/8)),val);
}

static inline void __DP(eMAC3_RX_net_port_enable_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_enable_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_net_port_enable_wr)( __DN(t) * _dev, int _i, eMAC_RX_net_port_enable_t val )
{
    eMAC_RX_net_port_enable_un  u;
    u.val = val;
    u.val._anon1 	= 0;
    mackerel_write_addr_32(_dev->base,(0xc800) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC3_RX_net_port_enable_enable_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_RX_net_port_enable_enable_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_RX_net_port_enable_un  u;
    u.val._anon1 	= 0;
    u.val.enable = val;
    mackerel_write_addr_32(_dev->base,(0xc800) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC3_RX_net_port_enable_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_net_port_enable_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_RX_net_port_enable_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc800) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC3_RX_net_port_enable[%d] (eMAC3_RX_net_port_enable):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " enable =\t0x%"PRIx8" (1 - Enabled, 0 - Disabled", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC3_RX_net_port_enable_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_RX_net_port_enable_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC3_RX_net_port_enable_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_TX_Buffer_start_addr (eMAC3_TX_Buffer_start_addr); type eMAC.TX_Buffer_start_addr (TX control TX Buffer Start Address)
 */

/*
 * Dump of fields for register: eMAC3_TX_Buffer_start_addr
 *   ADDR (size 29, offset 0):	 RW	  Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.
 *   _anon29 (size 3, offset 29):	 MBZ	  _
 */
static const int __DP(eMAC3_TX_Buffer_start_addr_length) = 0x30;
static inline uint32_t __DP(eMAC3_TX_Buffer_start_addr_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_TX_Buffer_start_addr_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xc900) + (_i *(32/8)));
}

static inline eMAC_TX_Buffer_start_addr_t __DP(eMAC3_TX_Buffer_start_addr_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_Buffer_start_addr_t __DP(eMAC3_TX_Buffer_start_addr_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_Buffer_start_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc900) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC3_TX_Buffer_start_addr_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_TX_Buffer_start_addr_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xc900) + (_i *(32/8)),val);
}

static inline void __DP(eMAC3_TX_Buffer_start_addr_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_start_addr_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_TX_Buffer_start_addr_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_start_addr_t val )
{
    eMAC_TX_Buffer_start_addr_un  u;
    u.val = val;
    u.val._anon29 	= 0;
    mackerel_write_addr_32(_dev->base,(0xc900) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC3_TX_Buffer_start_addr_ADDR_wrf)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_TX_Buffer_start_addr_ADDR_wrf)( __DN(t) * _dev, int _i, uint32_t val )
{
    eMAC_TX_Buffer_start_addr_un  u;
    u.val._anon29 	= 0;
    u.val.ADDR = val;
    mackerel_write_addr_32(_dev->base,(0xc900) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC3_TX_Buffer_start_addr_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_TX_Buffer_start_addr_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_Buffer_start_addr_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xc900) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC3_TX_Buffer_start_addr[%d] (eMAC3_TX_Buffer_start_addr):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint32_t pv = (uint32_t)u.val.ADDR;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ADDR =\t0x%0"PRIx32" (Upper 29 bit of physical start address [33:5] of memory buffer. Lower 5 bits are always 0 because access granularity to buffer will be always 32 bytes - one cache-line.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC3_TX_Buffer_start_addr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_TX_Buffer_start_addr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC3_TX_Buffer_start_addr_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_TX_Buffer_read_index (eMAC3_TX_Buffer_read_index); type eMAC.TX_Buffer_read_index (TX control TX Buffer Read Index)
 */

/*
 * Dump of fields for register: eMAC3_TX_Buffer_read_index
 *   rid (size 16, offset 0):	 RO	  Read index of TX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC3_TX_Buffer_read_index_length) = 0x30;
static inline uint32_t __DP(eMAC3_TX_Buffer_read_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_TX_Buffer_read_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xca00) + (_i *(32/8)));
}

static inline eMAC_TX_Buffer_read_index_t __DP(eMAC3_TX_Buffer_read_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_Buffer_read_index_t __DP(eMAC3_TX_Buffer_read_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_Buffer_read_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xca00) + (_i *(32/8)));
    return u.val;
}

// Register eMAC3_TX_Buffer_read_index is not writeable


static inline int __DP(eMAC3_TX_Buffer_read_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_TX_Buffer_read_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_Buffer_read_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xca00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC3_TX_Buffer_read_index[%d] (eMAC3_TX_Buffer_read_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.rid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rid =\t0x%0"PRIx16" (Read index of TX buffer Points to 32 byte entry in the buffer.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC3_TX_Buffer_read_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_TX_Buffer_read_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC3_TX_Buffer_read_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_TX_Buffer_write_index (eMAC3_TX_Buffer_write_index); type eMAC.TX_Buffer_write_index (TX control TX Buffer Write Index)
 */

/*
 * Dump of fields for register: eMAC3_TX_Buffer_write_index
 *   wid (size 16, offset 0):	 RW	  Write index of TX buffer Points to 32 byte entry in the buffer.
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC3_TX_Buffer_write_index_length) = 0x30;
static inline uint32_t __DP(eMAC3_TX_Buffer_write_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_TX_Buffer_write_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xcb00) + (_i *(32/8)));
}

static inline eMAC_TX_Buffer_write_index_t __DP(eMAC3_TX_Buffer_write_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_Buffer_write_index_t __DP(eMAC3_TX_Buffer_write_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_Buffer_write_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xcb00) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC3_TX_Buffer_write_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_TX_Buffer_write_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xcb00) + (_i *(32/8)),val);
}

static inline void __DP(eMAC3_TX_Buffer_write_index_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_write_index_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_TX_Buffer_write_index_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_write_index_t val )
{
    eMAC_TX_Buffer_write_index_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xcb00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC3_TX_Buffer_write_index_wid_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_TX_Buffer_write_index_wid_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_TX_Buffer_write_index_un  u;
    u.val._anon16 	= 0;
    u.val.wid = val;
    mackerel_write_addr_32(_dev->base,(0xcb00) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC3_TX_Buffer_write_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_TX_Buffer_write_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_Buffer_write_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xcb00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC3_TX_Buffer_write_index[%d] (eMAC3_TX_Buffer_write_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.wid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wid =\t0x%0"PRIx16" (Write index of TX buffer Points to 32 byte entry in the buffer.", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC3_TX_Buffer_write_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_TX_Buffer_write_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC3_TX_Buffer_write_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_TX_Buffer_last_index (eMAC3_TX_Buffer_last_index); type eMAC.TX_Buffer_last_index (TX control TX Buffer Last Index)
 */

/*
 * Dump of fields for register: eMAC3_TX_Buffer_last_index
 *   lid (size 16, offset 0):	 RW	  Last valid index in buffer. .Buffer size = last index * 32 bytes
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
static const int __DP(eMAC3_TX_Buffer_last_index_length) = 0x30;
static inline uint32_t __DP(eMAC3_TX_Buffer_last_index_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_TX_Buffer_last_index_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xcc00) + (_i *(32/8)));
}

static inline eMAC_TX_Buffer_last_index_t __DP(eMAC3_TX_Buffer_last_index_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_Buffer_last_index_t __DP(eMAC3_TX_Buffer_last_index_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_Buffer_last_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xcc00) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC3_TX_Buffer_last_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_TX_Buffer_last_index_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xcc00) + (_i *(32/8)),val);
}

static inline void __DP(eMAC3_TX_Buffer_last_index_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_last_index_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_TX_Buffer_last_index_wr)( __DN(t) * _dev, int _i, eMAC_TX_Buffer_last_index_t val )
{
    eMAC_TX_Buffer_last_index_un  u;
    u.val = val;
    u.val._anon16 	= 0;
    mackerel_write_addr_32(_dev->base,(0xcc00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC3_TX_Buffer_last_index_lid_wrf)( __DN(t) * _dev, int _i, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_TX_Buffer_last_index_lid_wrf)( __DN(t) * _dev, int _i, uint16_t val )
{
    eMAC_TX_Buffer_last_index_un  u;
    u.val._anon16 	= 0;
    u.val.lid = val;
    mackerel_write_addr_32(_dev->base,(0xcc00) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC3_TX_Buffer_last_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_TX_Buffer_last_index_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_Buffer_last_index_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xcc00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC3_TX_Buffer_last_index[%d] (eMAC3_TX_Buffer_last_index):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.lid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lid =\t0x%0"PRIx16" (Last valid index in buffer. .Buffer size = last index * 32 bytes", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC3_TX_Buffer_last_index_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_TX_Buffer_last_index_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC3_TX_Buffer_last_index_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_TX_routing (eMAC3_TX_routing); type eMAC.TX_routing (TX control RX routing related)
 */

/*
 * Dump of fields for register: eMAC3_TX_routing
 *   broute (size 8, offset 0):	 RW	  Route to the tile where the MC for this buffer is located
 *   bdest (size 3, offset 8):	 RW	  Defines the port at which the MC is connected
 *   _anon11 (size 21, offset 11):	 MBZ	  _
 */
static const int __DP(eMAC3_TX_routing_length) = 0x30;
static inline uint32_t __DP(eMAC3_TX_routing_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_TX_routing_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xcd00) + (_i *(32/8)));
}

static inline eMAC_TX_routing_t __DP(eMAC3_TX_routing_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_routing_t __DP(eMAC3_TX_routing_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xcd00) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC3_TX_routing_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_TX_routing_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xcd00) + (_i *(32/8)),val);
}

static inline void __DP(eMAC3_TX_routing_wr)( __DN(t) * _dev, int _i, eMAC_TX_routing_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_TX_routing_wr)( __DN(t) * _dev, int _i, eMAC_TX_routing_t val )
{
    eMAC_TX_routing_un  u;
    u.val = val;
    u.val._anon11 	= 0;
    mackerel_write_addr_32(_dev->base,(0xcd00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC3_TX_routing_broute_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_TX_routing_broute_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_TX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xcd00) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val.broute = val;
    mackerel_write_addr_32(_dev->base,(0xcd00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC3_TX_routing_bdest_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_TX_routing_bdest_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_TX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xcd00) + (_i *(32/8)));
    u.val._anon11 	= 0;
    u.val.bdest = val;
    mackerel_write_addr_32(_dev->base,(0xcd00) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC3_TX_routing_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_TX_routing_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_routing_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xcd00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC3_TX_routing[%d] (eMAC3_TX_routing):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.broute;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " broute =\t0x%"PRIx8" (Route to the tile where the MC for this buffer is located", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.bdest;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bdest =\t0x%"PRIx8" (Defines the port at which the MC is connected", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC3_TX_routing_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_TX_routing_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC3_TX_routing_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register eMAC3_TX_net_port_enable (eMAC3_TX_net_port_enable); type eMAC.TX_net_port_enable (TX Network Port Enable)
 */

/*
 * Dump of fields for register: eMAC3_TX_net_port_enable
 *   enable (size 1, offset 0):	 RW	  1 - Enabled, 0 - Disabled
 *   _anon1 (size 31, offset 1):	 MBZ	  _
 */
static const int __DP(eMAC3_TX_net_port_enable_length) = 0x30;
static inline uint32_t __DP(eMAC3_TX_net_port_enable_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(eMAC3_TX_net_port_enable_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xce00) + (_i *(32/8)));
}

static inline eMAC_TX_net_port_enable_t __DP(eMAC3_TX_net_port_enable_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline eMAC_TX_net_port_enable_t __DP(eMAC3_TX_net_port_enable_rd)( __DN(t) * _dev, int _i )
{
    eMAC_TX_net_port_enable_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xce00) + (_i *(32/8)));
    return u.val;
}

static inline void __DP(eMAC3_TX_net_port_enable_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_TX_net_port_enable_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xce00) + (_i *(32/8)),val);
}

static inline void __DP(eMAC3_TX_net_port_enable_wr)( __DN(t) * _dev, int _i, eMAC_TX_net_port_enable_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_TX_net_port_enable_wr)( __DN(t) * _dev, int _i, eMAC_TX_net_port_enable_t val )
{
    eMAC_TX_net_port_enable_un  u;
    u.val = val;
    u.val._anon1 	= 0;
    mackerel_write_addr_32(_dev->base,(0xce00) + (_i *(32/8)),u.raw);
}

static inline void __DP(eMAC3_TX_net_port_enable_enable_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eMAC3_TX_net_port_enable_enable_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    eMAC_TX_net_port_enable_un  u;
    u.val._anon1 	= 0;
    u.val.enable = val;
    mackerel_write_addr_32(_dev->base,(0xce00) + (_i *(32/8)),u.raw);
}


static inline int __DP(eMAC3_TX_net_port_enable_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_TX_net_port_enable_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    eMAC_TX_net_port_enable_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0xce00) + (_i *(32/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register eMAC3_TX_net_port_enable[%d] (eMAC3_TX_net_port_enable):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " enable =\t0x%"PRIx8" (1 - Enabled, 0 - Disabled", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}
static inline int __DP(eMAC3_TX_net_port_enable_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eMAC3_TX_net_port_enable_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(eMAC3_TX_net_port_enable_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register PIC_irq_status (PIC_irq_status); type eMAC.uint64
 */
static const int __DP(PIC_irq_status_length) = 0x30;
static inline uint64_t __DP(PIC_irq_status_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint64_t __DP(PIC_irq_status_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_64(_dev->base,(0xd000) + (_i *(64/8)));
}

static inline uint64_t __DP(PIC_irq_status_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint64_t __DP(PIC_irq_status_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_64(_dev->base,(0xd000) + (_i *(64/8)));
}

static inline void __DP(PIC_irq_status_wr_raw)( __DN(t) * _dev, int _i, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(PIC_irq_status_wr_raw)( __DN(t) * _dev, int _i, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0xd000) + (_i *(64/8)),val);
}

static inline void __DP(PIC_irq_status_wr)( __DN(t) * _dev, int _i, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(PIC_irq_status_wr)( __DN(t) * _dev, int _i, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0xd000) + (_i *(64/8)),val);
}


static inline int __DP(PIC_irq_status_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(PIC_irq_status_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register PIC_irq_status[%d] (PIC_irq_status):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0xd000) + (_i *(64/8))));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(PIC_irq_status_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(PIC_irq_status_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(PIC_irq_status_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register PIC_irq_mask (PIC_irq_mask); type eMAC.uint64
 */
static const int __DP(PIC_irq_mask_length) = 0x30;
static inline uint64_t __DP(PIC_irq_mask_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint64_t __DP(PIC_irq_mask_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_64(_dev->base,(0xd200) + (_i *(64/8)));
}

static inline uint64_t __DP(PIC_irq_mask_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint64_t __DP(PIC_irq_mask_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_64(_dev->base,(0xd200) + (_i *(64/8)));
}

static inline void __DP(PIC_irq_mask_wr_raw)( __DN(t) * _dev, int _i, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(PIC_irq_mask_wr_raw)( __DN(t) * _dev, int _i, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0xd200) + (_i *(64/8)),val);
}

static inline void __DP(PIC_irq_mask_wr)( __DN(t) * _dev, int _i, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(PIC_irq_mask_wr)( __DN(t) * _dev, int _i, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0xd200) + (_i *(64/8)),val);
}


static inline int __DP(PIC_irq_mask_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(PIC_irq_mask_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register PIC_irq_mask[%d] (PIC_irq_mask):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0xd200) + (_i *(64/8))));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(PIC_irq_mask_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(PIC_irq_mask_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(PIC_irq_mask_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register PIC_irq_reset (PIC_irq_reset); type eMAC.uint64
 */
static const int __DP(PIC_irq_reset_length) = 0x30;
static inline uint64_t __DP(PIC_irq_reset_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint64_t __DP(PIC_irq_reset_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_64(_dev->base,(0xd400) + (_i *(64/8)));
}

static inline uint64_t __DP(PIC_irq_reset_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint64_t __DP(PIC_irq_reset_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_64(_dev->base,(0xd400) + (_i *(64/8)));
}

static inline void __DP(PIC_irq_reset_wr_raw)( __DN(t) * _dev, int _i, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(PIC_irq_reset_wr_raw)( __DN(t) * _dev, int _i, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0xd400) + (_i *(64/8)),val);
}

static inline void __DP(PIC_irq_reset_wr)( __DN(t) * _dev, int _i, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(PIC_irq_reset_wr)( __DN(t) * _dev, int _i, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0xd400) + (_i *(64/8)),val);
}


static inline int __DP(PIC_irq_reset_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(PIC_irq_reset_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register PIC_irq_reset[%d] (PIC_irq_reset):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0xd400) + (_i *(64/8))));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(PIC_irq_reset_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(PIC_irq_reset_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(PIC_irq_reset_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register PIC_ipi_request (PIC_ipi_request); type eMAC.uint64
 */
static const int __DP(PIC_ipi_request_length) = 0x30;
static inline uint64_t __DP(PIC_ipi_request_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint64_t __DP(PIC_ipi_request_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_64(_dev->base,(0xd600) + (_i *(64/8)));
}

static inline uint64_t __DP(PIC_ipi_request_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint64_t __DP(PIC_ipi_request_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_64(_dev->base,(0xd600) + (_i *(64/8)));
}

static inline void __DP(PIC_ipi_request_wr_raw)( __DN(t) * _dev, int _i, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(PIC_ipi_request_wr_raw)( __DN(t) * _dev, int _i, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0xd600) + (_i *(64/8)),val);
}

static inline void __DP(PIC_ipi_request_wr)( __DN(t) * _dev, int _i, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(PIC_ipi_request_wr)( __DN(t) * _dev, int _i, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0xd600) + (_i *(64/8)),val);
}


static inline int __DP(PIC_ipi_request_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(PIC_ipi_request_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register PIC_ipi_request[%d] (PIC_ipi_request):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0xd600) + (_i *(64/8))));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(PIC_ipi_request_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(PIC_ipi_request_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(PIC_ipi_request_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register PIC_irq_config (PIC_irq_config); type eMAC.uint32
 */
static const int __DP(PIC_irq_config_length) = 0x30;
static inline uint32_t __DP(PIC_irq_config_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(PIC_irq_config_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xd800) + (_i *(32/8)));
}

static inline uint32_t __DP(PIC_irq_config_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(PIC_irq_config_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_addr_32(_dev->base,(0xd800) + (_i *(32/8)));
}

static inline void __DP(PIC_irq_config_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(PIC_irq_config_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xd800) + (_i *(32/8)),val);
}

static inline void __DP(PIC_irq_config_wr)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(PIC_irq_config_wr)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0xd800) + (_i *(32/8)),val);
}


static inline int __DP(PIC_irq_config_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(PIC_irq_config_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register PIC_irq_config[%d] (PIC_irq_config):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0xd800) + (_i *(32/8))));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(PIC_irq_config_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(PIC_irq_config_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x30; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(PIC_irq_config_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register PIC_irq_request_mcpc (PIC_irq_request_mcpc); type eMAC.uint64
 */

static inline uint64_t __DP(PIC_irq_request_mcpc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(PIC_irq_request_mcpc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0xd900));
}

static inline uint64_t __DP(PIC_irq_request_mcpc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint64_t __DP(PIC_irq_request_mcpc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_64(_dev->base,(0xd900));
}

static inline void __DP(PIC_irq_request_mcpc_wr_raw)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(PIC_irq_request_mcpc_wr_raw)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0xd900),val);
}

static inline void __DP(PIC_irq_request_mcpc_wr)( __DN(t) * _dev, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(PIC_irq_request_mcpc_wr)( __DN(t) * _dev, uint64_t val )
{
    mackerel_write_addr_64(_dev->base,(0xd900),val);
}


static inline int __DP(PIC_irq_request_mcpc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(PIC_irq_request_mcpc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register PIC_irq_request_mcpc (PIC_irq_request_mcpc):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx64"\n", mackerel_read_addr_64(_dev->base,(0xd900)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Dump of device eMAC (Xilinx IPblock):\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_receiver_conf_0_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_receiver_conf_1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_transmiter_conf_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_flow_control_conf_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_ethernet_mac_conf_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_address_filter_mode_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_receiver_conf_0_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_receiver_conf_1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_transmiter_conf_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_flow_control_conf_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_ethernet_mac_conf_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_address_filter_mode_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_receiver_conf_0_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_receiver_conf_1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_transmiter_conf_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_flow_control_conf_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_ethernet_mac_conf_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_address_filter_mode_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_receiver_conf_0_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_receiver_conf_1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_transmiter_conf_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_flow_control_conf_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_ethernet_mac_conf_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_address_filter_mode_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_RX_frame_dropped_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_TX_FIFO_BUFF_FULL_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_RX_FIFO_BUFF_FULL_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_TX_EMAC_NOT_READY_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_RX_MAC_ADDR_ERR_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_RX_MAC_LOWER_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_RX_MAC_HIGHER_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_RX_frame_dropped_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_TX_FIFO_BUFF_FULL_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_RX_FIFO_BUFF_FULL_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_TX_EMAC_NOT_READY_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_RX_MAC_ADDR_ERR_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_RX_MAC_LOWER_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_RX_MAC_HIGHER_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_RX_frame_dropped_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_TX_FIFO_BUFF_FULL_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_RX_FIFO_BUFF_FULL_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_TX_EMAC_NOT_READY_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_RX_MAC_ADDR_ERR_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_RX_MAC_LOWER_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_RX_MAC_HIGHER_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_RX_frame_dropped_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_TX_FIFO_BUFF_FULL_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_RX_FIFO_BUFF_FULL_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_TX_EMAC_NOT_READY_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_RX_MAC_ADDR_ERR_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_RX_MAC_LOWER_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_RX_MAC_HIGHER_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC_MAC_base_addr_upper_reg_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC_MAC_base_addr_lower_reg_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC_start_IP_SCC_network_reg_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC_host_IP_addr_reg_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC_host_GW_addr_reg_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_RX_Buffer_start_addr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_RX_Buffer_read_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_RX_Buffer_write_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_RX_Buffer_last_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_RX_routing_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_RX_net_port_MAC_high_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_RX_net_port_MAC_low_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_RX_net_port_enable_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_TX_Buffer_start_addr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_TX_Buffer_read_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_TX_Buffer_write_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_TX_Buffer_last_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_TX_routing_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC0_TX_net_port_enable_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_RX_Buffer_start_addr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_RX_Buffer_read_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_RX_Buffer_write_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_RX_Buffer_last_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_RX_routing_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_RX_net_port_MAC_high_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_RX_net_port_MAC_low_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_RX_net_port_enable_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_TX_Buffer_start_addr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_TX_Buffer_read_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_TX_Buffer_write_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_TX_Buffer_last_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_TX_routing_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC1_TX_net_port_enable_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_RX_Buffer_start_addr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_RX_Buffer_read_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_RX_Buffer_write_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_RX_Buffer_last_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_RX_routing_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_RX_net_port_MAC_high_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_RX_net_port_MAC_low_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_RX_net_port_enable_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_TX_Buffer_start_addr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_TX_Buffer_read_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_TX_Buffer_write_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_TX_Buffer_last_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_TX_routing_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC2_TX_net_port_enable_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_RX_Buffer_start_addr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_RX_Buffer_read_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_RX_Buffer_write_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_RX_Buffer_last_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_RX_routing_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_RX_net_port_MAC_high_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_RX_net_port_MAC_low_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_RX_net_port_enable_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_TX_Buffer_start_addr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_TX_Buffer_read_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_TX_Buffer_write_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_TX_Buffer_last_index_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_TX_routing_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eMAC3_TX_net_port_enable_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(PIC_irq_status_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(PIC_irq_mask_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(PIC_irq_reset_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(PIC_ipi_request_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(PIC_irq_config_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(PIC_irq_request_mcpc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "End of dump of device eMAC\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR


#endif // __eMAC_H
