#ifndef __acpi_ec_DEV_H
#define __acpi_ec_DEV_H 1
/*
 * DEVICE DEFINITION: ACPI embedded controller
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) acpi_ec ## _ ## x
/*
 * Constants defn: acpi_ec.commands (Command encodings)
 *  - width 8 bits
 */
typedef uint8_t acpi_ec_commands_t;
#define acpi_ec_read ((acpi_ec_commands_t)0x80)
#define acpi_ec_write ((acpi_ec_commands_t)0x81)
#define acpi_ec_burst_en ((acpi_ec_commands_t)0x82)
#define acpi_ec_burst_dis ((acpi_ec_commands_t)0x83)
#define acpi_ec_query ((acpi_ec_commands_t)0x84)

static inline char *acpi_ec_commands_describe(acpi_ec_commands_t _e) __attribute__ ((always_inline));
static inline char *acpi_ec_commands_describe(acpi_ec_commands_t _e)
{
    switch (_e) {
    case acpi_ec_read:
        return("read: Read");
    case acpi_ec_write:
        return("write: Write");
    case acpi_ec_burst_en:
        return("burst_en: Burst enable");
    case acpi_ec_burst_dis:
        return("burst_dis: Burst disable");
    case acpi_ec_query:
        return("query: Query");
    default:
        return(NULL);
    }
}

static inline int acpi_ec_commands_prtval(char *_s, size_t _size, acpi_ec_commands_t _e) __attribute__ ((always_inline));
static inline int acpi_ec_commands_prtval(char *_s, size_t _size, acpi_ec_commands_t _e)
{
    char *d = acpi_ec_commands_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "acpi_ec_commands_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: acpi_ec_status_t
 * Description: Status
 * Fields:
 *   obf	(size 1, offset 0, init 0):	NOATTR	Output buffer is full
 *   ibf	(size 1, offset 1, init 0):	NOATTR	Input buffer is full
 *   _anon2	(size 1, offset 2, init 0):	RSVD	_
 *   cmd	(size 1, offset 3, init 0):	NOATTR	Byte in data register is a command byte
 *   burst	(size 1, offset 4, init 0):	NOATTR	Controller is in burst mode
 *   sci_evt	(size 1, offset 5, init 0):	NOATTR	SCI event pending
 *   smi_evt	(size 1, offset 6, init 0):	NOATTR	SMI event pending
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 */
typedef uint8_t acpi_ec_status_t;
#define acpi_ec_status_default 0x0
static inline uint8_t acpi_ec_status_obf_extract(acpi_ec_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t acpi_ec_status_obf_extract(acpi_ec_status_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline acpi_ec_status_t acpi_ec_status_obf_insert(acpi_ec_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline acpi_ec_status_t acpi_ec_status_obf_insert(acpi_ec_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((acpi_ec_status_t )(_fieldval)) << 0)));
}

static inline uint8_t acpi_ec_status_ibf_extract(acpi_ec_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t acpi_ec_status_ibf_extract(acpi_ec_status_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline acpi_ec_status_t acpi_ec_status_ibf_insert(acpi_ec_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline acpi_ec_status_t acpi_ec_status_ibf_insert(acpi_ec_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((acpi_ec_status_t )(_fieldval)) << 1)));
}

static inline uint8_t acpi_ec_status_cmd_extract(acpi_ec_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t acpi_ec_status_cmd_extract(acpi_ec_status_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline acpi_ec_status_t acpi_ec_status_cmd_insert(acpi_ec_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline acpi_ec_status_t acpi_ec_status_cmd_insert(acpi_ec_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((acpi_ec_status_t )(_fieldval)) << 3)));
}

static inline uint8_t acpi_ec_status_burst_extract(acpi_ec_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t acpi_ec_status_burst_extract(acpi_ec_status_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline acpi_ec_status_t acpi_ec_status_burst_insert(acpi_ec_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline acpi_ec_status_t acpi_ec_status_burst_insert(acpi_ec_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((acpi_ec_status_t )(_fieldval)) << 4)));
}

static inline uint8_t acpi_ec_status_sci_evt_extract(acpi_ec_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t acpi_ec_status_sci_evt_extract(acpi_ec_status_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline acpi_ec_status_t acpi_ec_status_sci_evt_insert(acpi_ec_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline acpi_ec_status_t acpi_ec_status_sci_evt_insert(acpi_ec_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdf) | (0x20 & (((acpi_ec_status_t )(_fieldval)) << 5)));
}

static inline uint8_t acpi_ec_status_smi_evt_extract(acpi_ec_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t acpi_ec_status_smi_evt_extract(acpi_ec_status_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline acpi_ec_status_t acpi_ec_status_smi_evt_insert(acpi_ec_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline acpi_ec_status_t acpi_ec_status_smi_evt_insert(acpi_ec_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbf) | (0x40 & (((acpi_ec_status_t )(_fieldval)) << 6)));
}

static inline int acpi_ec_status_prtval(char *_s, size_t _size, acpi_ec_status_t _regval) __attribute__ ((always_inline));
static inline int acpi_ec_status_prtval(char *_s, size_t _size, acpi_ec_status_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " obf =\t%" PRIx8 "\t(Output buffer is full)\n", acpi_ec_status_obf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ibf =\t%" PRIx8 "\t(Input buffer is full)\n", acpi_ec_status_ibf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmd =\t%" PRIx8 "\t(Byte in data register is a command byte)\n", acpi_ec_status_cmd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " burst =\t%" PRIx8 "\t(Controller is in burst mode)\n", acpi_ec_status_burst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sci_evt =\t%" PRIx8 "\t(SCI event pending)\n", acpi_ec_status_sci_evt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smi_evt =\t%" PRIx8 "\t(SMI event pending)\n", acpi_ec_status_smi_evt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_io_t data;
    mackerel_io_t sc;
    acpi_ec_commands_t cmd_shadow;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum acpi_ec_initials {
    acpi_ec_status_initial = 0x0,
    acpi_ec_cmd_initial = 0x0,
    acpi_ec_data_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void acpi_ec_initialize(__DN(t) *_dev, mackerel_io_t data, mackerel_io_t sc) __attribute__ ((always_inline));
static inline void acpi_ec_initialize(__DN(t) *_dev, mackerel_io_t data, mackerel_io_t sc)
{
    _dev->data = data;
    _dev->sc = sc;
}

/*
 * Register status: Status
 * Type: acpi_ec.status (Status)
 *   obf	(size 1, offset 0, init 0):	RO	Output buffer is full
 *   ibf	(size 1, offset 1, init 0):	RO	Input buffer is full
 *   _anon2	(size 1, offset 2, init 0):	RSVD	_
 *   cmd	(size 1, offset 3, init 0):	RO	Byte in data register is a command byte
 *   burst	(size 1, offset 4, init 0):	RO	Controller is in burst mode
 *   sci_evt	(size 1, offset 5, init 0):	RO	SCI event pending
 *   smi_evt	(size 1, offset 6, init 0):	RO	SMI event pending
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 */
static inline acpi_ec_status_t acpi_ec_status_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline acpi_ec_status_t acpi_ec_status_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->sc, 0x0));
}

static inline acpi_ec_status_t acpi_ec_status_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline acpi_ec_status_t acpi_ec_status_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->sc, 0x0));
}

static inline void acpi_ec_status_rawwr(__DN(t) *_dev, acpi_ec_status_t _regval) __attribute__ ((always_inline));
static inline void acpi_ec_status_rawwr(__DN(t) *_dev, acpi_ec_status_t _regval)
{
    mackerel_write_io_8(_dev->sc, 0x0, _regval);
}

// Register status is not writeable
static inline int acpi_ec_status_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int acpi_ec_status_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    acpi_ec_status_t _regval = mackerel_read_io_8(_dev->sc, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register status (Status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " obf =\t%" PRIx8 "\t(Output buffer is full)\n", acpi_ec_status_obf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ibf =\t%" PRIx8 "\t(Input buffer is full)\n", acpi_ec_status_ibf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmd =\t%" PRIx8 "\t(Byte in data register is a command byte)\n", acpi_ec_status_cmd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " burst =\t%" PRIx8 "\t(Controller is in burst mode)\n", acpi_ec_status_burst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sci_evt =\t%" PRIx8 "\t(SCI event pending)\n", acpi_ec_status_sci_evt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smi_evt =\t%" PRIx8 "\t(SMI event pending)\n", acpi_ec_status_smi_evt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    return(_r);
}

static inline uint8_t acpi_ec_status_obf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t acpi_ec_status_obf_rdf(__DN(t) *_dev)
{
    acpi_ec_status_t _regval = mackerel_read_io_8(_dev->sc, 0x0);
    return(acpi_ec_status_obf_extract(_regval));
}

static inline uint8_t acpi_ec_status_ibf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t acpi_ec_status_ibf_rdf(__DN(t) *_dev)
{
    acpi_ec_status_t _regval = mackerel_read_io_8(_dev->sc, 0x0);
    return(acpi_ec_status_ibf_extract(_regval));
}

static inline uint8_t acpi_ec_status_cmd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t acpi_ec_status_cmd_rdf(__DN(t) *_dev)
{
    acpi_ec_status_t _regval = mackerel_read_io_8(_dev->sc, 0x0);
    return(acpi_ec_status_cmd_extract(_regval));
}

static inline uint8_t acpi_ec_status_burst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t acpi_ec_status_burst_rdf(__DN(t) *_dev)
{
    acpi_ec_status_t _regval = mackerel_read_io_8(_dev->sc, 0x0);
    return(acpi_ec_status_burst_extract(_regval));
}

static inline uint8_t acpi_ec_status_sci_evt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t acpi_ec_status_sci_evt_rdf(__DN(t) *_dev)
{
    acpi_ec_status_t _regval = mackerel_read_io_8(_dev->sc, 0x0);
    return(acpi_ec_status_sci_evt_extract(_regval));
}

static inline uint8_t acpi_ec_status_smi_evt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t acpi_ec_status_smi_evt_rdf(__DN(t) *_dev)
{
    acpi_ec_status_t _regval = mackerel_read_io_8(_dev->sc, 0x0);
    return(acpi_ec_status_smi_evt_extract(_regval));
}

/*
 * Register cmd: Command
 * Type: acpi_ec.commands (primitive type)
 */
static inline acpi_ec_commands_t acpi_ec_cmd_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline acpi_ec_commands_t acpi_ec_cmd_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->sc, 0x0));
}

static inline acpi_ec_commands_t acpi_ec_cmd_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline acpi_ec_commands_t acpi_ec_cmd_rd(__DN(t) *_dev)
{
    return(_dev->cmd_shadow);
}

static inline void acpi_ec_cmd_rawwr(__DN(t) *_dev, acpi_ec_commands_t _regval) __attribute__ ((always_inline));
static inline void acpi_ec_cmd_rawwr(__DN(t) *_dev, acpi_ec_commands_t _regval)
{
    mackerel_write_io_8(_dev->sc, 0x0, _regval);
}

static inline void acpi_ec_cmd_wr(__DN(t) *_dev, acpi_ec_commands_t _regval) __attribute__ ((always_inline));
static inline void acpi_ec_cmd_wr(__DN(t) *_dev, acpi_ec_commands_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->sc, 0x0, _regval);
}

static inline int acpi_ec_cmd_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int acpi_ec_cmd_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    acpi_ec_commands_t _regval = _dev->cmd_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cmd (Command): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = acpi_ec_commands_prtval(_s + _r, _avail, _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register data: Data
 * Type: acpi_ec.uint8 (primitive type)
 */
static inline uint8_t acpi_ec_data_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t acpi_ec_data_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->data, 0x0));
}

static inline uint8_t acpi_ec_data_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t acpi_ec_data_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->data, 0x0));
}

static inline void acpi_ec_data_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void acpi_ec_data_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_io_8(_dev->data, 0x0, _regval);
}

static inline void acpi_ec_data_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void acpi_ec_data_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->data, 0x0, _regval);
}

static inline int acpi_ec_data_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int acpi_ec_data_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_io_8(_dev->data, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register data (Data): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int acpi_ec_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int acpi_ec_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device acpi_ec (ACPI embedded controller):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = acpi_ec_status_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = acpi_ec_cmd_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = acpi_ec_data_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device acpi_ec\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __acpi_ec_DEV_H
