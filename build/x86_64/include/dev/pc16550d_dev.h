#ifndef __pc16550d_DEV_H
#define __pc16550d_DEV_H 1
/*
 * DEVICE DEFINITION: PC16550D UART
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) pc16550d ## _ ## x
/*
 * Constants defn: pc16550d.trigger_lvl (RCVR FIFO trigger level)
 *  - no width specified
 */
typedef uint8_t pc16550d_trigger_lvl_t;
#define pc16550d_bytes1 ((pc16550d_trigger_lvl_t)0x0)
#define pc16550d_bytes4 ((pc16550d_trigger_lvl_t)0x1)
#define pc16550d_bytes8 ((pc16550d_trigger_lvl_t)0x2)
#define pc16550d_bytes14 ((pc16550d_trigger_lvl_t)0x3)

static inline char *pc16550d_trigger_lvl_describe(pc16550d_trigger_lvl_t _e) __attribute__ ((always_inline));
static inline char *pc16550d_trigger_lvl_describe(pc16550d_trigger_lvl_t _e)
{
    switch (_e) {
    case pc16550d_bytes1:
        return("bytes1: Every byte");
    case pc16550d_bytes4:
        return("bytes4: Every 4th byte");
    case pc16550d_bytes8:
        return("bytes8: Every 8th byte");
    case pc16550d_bytes14:
        return("bytes14: Every 14th byte");
    default:
        return(NULL);
    }
}

static inline int pc16550d_trigger_lvl_prtval(char *_s, size_t _size, pc16550d_trigger_lvl_t _e) __attribute__ ((always_inline));
static inline int pc16550d_trigger_lvl_prtval(char *_s, size_t _size, pc16550d_trigger_lvl_t _e)
{
    char *d = pc16550d_trigger_lvl_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "pc16550d_trigger_lvl_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: pc16550d.char_len (Character Length)
 *  - no width specified
 */
typedef uint8_t pc16550d_char_len_t;
#define pc16550d_bits5 ((pc16550d_char_len_t)0x0)
#define pc16550d_bits6 ((pc16550d_char_len_t)0x1)
#define pc16550d_bits7 ((pc16550d_char_len_t)0x2)
#define pc16550d_bits8 ((pc16550d_char_len_t)0x3)

static inline char *pc16550d_char_len_describe(pc16550d_char_len_t _e) __attribute__ ((always_inline));
static inline char *pc16550d_char_len_describe(pc16550d_char_len_t _e)
{
    switch (_e) {
    case pc16550d_bits5:
        return("bits5: 5 Bits");
    case pc16550d_bits6:
        return("bits6: 6 Bits");
    case pc16550d_bits7:
        return("bits7: 7 Bits");
    case pc16550d_bits8:
        return("bits8: 8 Bits");
    default:
        return(NULL);
    }
}

static inline int pc16550d_char_len_prtval(char *_s, size_t _size, pc16550d_char_len_t _e) __attribute__ ((always_inline));
static inline int pc16550d_char_len_prtval(char *_s, size_t _size, pc16550d_char_len_t _e)
{
    char *d = pc16550d_char_len_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "pc16550d_char_len_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: pc16550d.irq_id (Interrupt ID)
 *  - no width specified
 */
typedef uint8_t pc16550d_irq_id_t;
#define pc16550d_none ((pc16550d_irq_id_t)0x1)
#define pc16550d_rls ((pc16550d_irq_id_t)0x6)
#define pc16550d_rda ((pc16550d_irq_id_t)0x4)
#define pc16550d_cti ((pc16550d_irq_id_t)0xc)
#define pc16550d_thre ((pc16550d_irq_id_t)0x2)
#define pc16550d_ms ((pc16550d_irq_id_t)0x0)

static inline char *pc16550d_irq_id_describe(pc16550d_irq_id_t _e) __attribute__ ((always_inline));
static inline char *pc16550d_irq_id_describe(pc16550d_irq_id_t _e)
{
    switch (_e) {
    case pc16550d_none:
        return("none: No interrupt pending");
    case pc16550d_rls:
        return("rls: Receiver line status");
    case pc16550d_rda:
        return("rda: Receiver data available");
    case pc16550d_cti:
        return("cti: Character timeout");
    case pc16550d_thre:
        return("thre: Transmitter holding register empty");
    case pc16550d_ms:
        return("ms: Modem status");
    default:
        return(NULL);
    }
}

static inline int pc16550d_irq_id_prtval(char *_s, size_t _size, pc16550d_irq_id_t _e) __attribute__ ((always_inline));
static inline int pc16550d_irq_id_prtval(char *_s, size_t _size, pc16550d_irq_id_t _e)
{
    char *d = pc16550d_irq_id_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "pc16550d_irq_id_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: pc16550d.divisor (Baud Rate Divisor)
 *  - no width specified
 */
typedef uint16_t pc16550d_divisor_t;
#define pc16550d_baud50 ((pc16550d_divisor_t)0x900)
#define pc16550d_baud75 ((pc16550d_divisor_t)0x600)
#define pc16550d_baud110 ((pc16550d_divisor_t)0x417)
#define pc16550d_baud134_5 ((pc16550d_divisor_t)0x359)
#define pc16550d_baud150 ((pc16550d_divisor_t)0x300)
#define pc16550d_baud300 ((pc16550d_divisor_t)0x180)
#define pc16550d_baud600 ((pc16550d_divisor_t)0xc0)
#define pc16550d_baud1200 ((pc16550d_divisor_t)0x60)
#define pc16550d_baud1800 ((pc16550d_divisor_t)0x40)
#define pc16550d_baud2000 ((pc16550d_divisor_t)0x3a)
#define pc16550d_baud2400 ((pc16550d_divisor_t)0x30)
#define pc16550d_baud4800 ((pc16550d_divisor_t)0x18)
#define pc16550d_baud7200 ((pc16550d_divisor_t)0x10)
#define pc16550d_baud9600 ((pc16550d_divisor_t)0xc)
#define pc16550d_baud19200 ((pc16550d_divisor_t)0x6)
#define pc16550d_baud38400 ((pc16550d_divisor_t)0x3)
#define pc16550d_baud57600 ((pc16550d_divisor_t)0x2)
#define pc16550d_baud115200 ((pc16550d_divisor_t)0x1)

static inline char *pc16550d_divisor_describe(pc16550d_divisor_t _e) __attribute__ ((always_inline));
static inline char *pc16550d_divisor_describe(pc16550d_divisor_t _e)
{
    switch (_e) {
    case pc16550d_baud50:
        return("baud50: 50 bps");
    case pc16550d_baud75:
        return("baud75: 75 bps");
    case pc16550d_baud110:
        return("baud110: 110 bps");
    case pc16550d_baud134_5:
        return("baud134_5: 134.5 bps");
    case pc16550d_baud150:
        return("baud150: 150 bps");
    case pc16550d_baud300:
        return("baud300: 300 bps");
    case pc16550d_baud600:
        return("baud600: 600 bps");
    case pc16550d_baud1200:
        return("baud1200: 1200 bps");
    case pc16550d_baud1800:
        return("baud1800: 1800 bps");
    case pc16550d_baud2000:
        return("baud2000: 2000 bps");
    case pc16550d_baud2400:
        return("baud2400: 2400 bps");
    case pc16550d_baud4800:
        return("baud4800: 4800 bps");
    case pc16550d_baud7200:
        return("baud7200: 7200 bps");
    case pc16550d_baud9600:
        return("baud9600: 9600 bps");
    case pc16550d_baud19200:
        return("baud19200: 19200 bps");
    case pc16550d_baud38400:
        return("baud38400: 38400 bps");
    case pc16550d_baud57600:
        return("baud57600: 57600 bps");
    case pc16550d_baud115200:
        return("baud115200: 115200 bps");
    default:
        return(NULL);
    }
}

static inline int pc16550d_divisor_prtval(char *_s, size_t _size, pc16550d_divisor_t _e) __attribute__ ((always_inline));
static inline int pc16550d_divisor_prtval(char *_s, size_t _size, pc16550d_divisor_t _e)
{
    char *d = pc16550d_divisor_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "pc16550d_divisor_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: pc16550d_ier_t
 * Description: Implicit type of Interrupt enable register
 * Fields:
 *   erbfi	(size 1, offset 0, init 0):	RW	Enable received data available interrupt
 *   etbei	(size 1, offset 1, init 0):	RW	Enable transmitter holding register empty interrupt
 *   elsi	(size 1, offset 2, init 0):	RW	Enable receiver line status interrupt
 *   edssi	(size 1, offset 3, init 0):	RW	Enable modem status interrupt
 *   _anon4	(size 4, offset 4, init 0):	MBZ	_
 */
typedef uint8_t pc16550d_ier_t;
#define pc16550d_ier_default 0x0
static inline uint8_t pc16550d_ier_erbfi_extract(pc16550d_ier_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_ier_erbfi_extract(pc16550d_ier_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pc16550d_ier_t pc16550d_ier_erbfi_insert(pc16550d_ier_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_ier_t pc16550d_ier_erbfi_insert(pc16550d_ier_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((pc16550d_ier_t )(_fieldval)) << 0)));
}

static inline uint8_t pc16550d_ier_etbei_extract(pc16550d_ier_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_ier_etbei_extract(pc16550d_ier_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline pc16550d_ier_t pc16550d_ier_etbei_insert(pc16550d_ier_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_ier_t pc16550d_ier_etbei_insert(pc16550d_ier_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((pc16550d_ier_t )(_fieldval)) << 1)));
}

static inline uint8_t pc16550d_ier_elsi_extract(pc16550d_ier_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_ier_elsi_extract(pc16550d_ier_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline pc16550d_ier_t pc16550d_ier_elsi_insert(pc16550d_ier_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_ier_t pc16550d_ier_elsi_insert(pc16550d_ier_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((pc16550d_ier_t )(_fieldval)) << 2)));
}

static inline uint8_t pc16550d_ier_edssi_extract(pc16550d_ier_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_ier_edssi_extract(pc16550d_ier_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline pc16550d_ier_t pc16550d_ier_edssi_insert(pc16550d_ier_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_ier_t pc16550d_ier_edssi_insert(pc16550d_ier_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((pc16550d_ier_t )(_fieldval)) << 3)));
}

static inline int pc16550d_ier_prtval(char *_s, size_t _size, pc16550d_ier_t _regval) __attribute__ ((always_inline));
static inline int pc16550d_ier_prtval(char *_s, size_t _size, pc16550d_ier_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " erbfi =\t%" PRIx8 "\t(Enable received data available interrupt)\n", pc16550d_ier_erbfi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " etbei =\t%" PRIx8 "\t(Enable transmitter holding register empty interrupt)\n", pc16550d_ier_etbei_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " elsi =\t%" PRIx8 "\t(Enable receiver line status interrupt)\n", pc16550d_ier_elsi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " edssi =\t%" PRIx8 "\t(Enable modem status interrupt)\n", pc16550d_ier_edssi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pc16550d_iir_t
 * Description: Implicit type of Interrupt identification register
 * Fields:
 *   iid	(size 4, offset 0, init 0):	RO	Interrupt ID
 *   _anon4	(size 2, offset 4, init 0):	MBZ	_
 *   fifoe	(size 2, offset 6, init 0):	RO	FIFOs enabled
 */
typedef uint8_t pc16550d_iir_t;
#define pc16550d_iir_default 0x0
static inline pc16550d_irq_id_t pc16550d_iir_iid_extract(pc16550d_iir_t _regval) __attribute__ ((always_inline));
static inline pc16550d_irq_id_t pc16550d_iir_iid_extract(pc16550d_iir_t _regval)
{
    return((pc16550d_irq_id_t )((_regval & 0xf) >> 0));
}

static inline pc16550d_iir_t pc16550d_iir_iid_insert(pc16550d_iir_t _regval, pc16550d_irq_id_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_iir_t pc16550d_iir_iid_insert(pc16550d_iir_t _regval, pc16550d_irq_id_t _fieldval)
{
    return((_regval & 0xf0) | (0xf & (((pc16550d_iir_t )(_fieldval)) << 0)));
}

static inline uint8_t pc16550d_iir_fifoe_extract(pc16550d_iir_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_iir_fifoe_extract(pc16550d_iir_t _regval)
{
    return((uint8_t )((_regval & 0xc0) >> 6));
}

static inline pc16550d_iir_t pc16550d_iir_fifoe_insert(pc16550d_iir_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_iir_t pc16550d_iir_fifoe_insert(pc16550d_iir_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x3f) | (0xc0 & (((pc16550d_iir_t )(_fieldval)) << 6)));
}

static inline int pc16550d_iir_prtval(char *_s, size_t _size, pc16550d_iir_t _regval) __attribute__ ((always_inline));
static inline int pc16550d_iir_prtval(char *_s, size_t _size, pc16550d_iir_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iid =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_irq_id_prtval(_s + _r, _avail, pc16550d_iir_iid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interrupt ID)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fifoe =\t%" PRIx8 "\t(FIFOs enabled)\n", pc16550d_iir_fifoe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pc16550d_fcr_t
 * Description: Implicit type of FIFO control register
 * Fields:
 *   fifoe	(size 1, offset 0, init 0):	WO	FIFO enable
 *   rfifo_reset	(size 1, offset 1, init 0):	WO	RCVR FIFO reset
 *   xfifo_reset	(size 1, offset 2, init 0):	WO	XMIT FIFO reset
 *   dma_mode	(size 1, offset 3, init 0):	WO	DMA mode select
 *   _anon4	(size 2, offset 4, init 0):	RSVD	_
 *   rtrigger	(size 2, offset 6, init 0):	WO	RCVR trigger
 */
typedef uint8_t pc16550d_fcr_t;
#define pc16550d_fcr_default 0x0
static inline uint8_t pc16550d_fcr_fifoe_extract(pc16550d_fcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_fcr_fifoe_extract(pc16550d_fcr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pc16550d_fcr_t pc16550d_fcr_fifoe_insert(pc16550d_fcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_fcr_t pc16550d_fcr_fifoe_insert(pc16550d_fcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((pc16550d_fcr_t )(_fieldval)) << 0)));
}

static inline uint8_t pc16550d_fcr_rfifo_reset_extract(pc16550d_fcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_fcr_rfifo_reset_extract(pc16550d_fcr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline pc16550d_fcr_t pc16550d_fcr_rfifo_reset_insert(pc16550d_fcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_fcr_t pc16550d_fcr_rfifo_reset_insert(pc16550d_fcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((pc16550d_fcr_t )(_fieldval)) << 1)));
}

static inline uint8_t pc16550d_fcr_xfifo_reset_extract(pc16550d_fcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_fcr_xfifo_reset_extract(pc16550d_fcr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline pc16550d_fcr_t pc16550d_fcr_xfifo_reset_insert(pc16550d_fcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_fcr_t pc16550d_fcr_xfifo_reset_insert(pc16550d_fcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((pc16550d_fcr_t )(_fieldval)) << 2)));
}

static inline uint8_t pc16550d_fcr_dma_mode_extract(pc16550d_fcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_fcr_dma_mode_extract(pc16550d_fcr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline pc16550d_fcr_t pc16550d_fcr_dma_mode_insert(pc16550d_fcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_fcr_t pc16550d_fcr_dma_mode_insert(pc16550d_fcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((pc16550d_fcr_t )(_fieldval)) << 3)));
}

static inline pc16550d_trigger_lvl_t pc16550d_fcr_rtrigger_extract(pc16550d_fcr_t _regval) __attribute__ ((always_inline));
static inline pc16550d_trigger_lvl_t pc16550d_fcr_rtrigger_extract(pc16550d_fcr_t _regval)
{
    return((pc16550d_trigger_lvl_t )((_regval & 0xc0) >> 6));
}

static inline pc16550d_fcr_t pc16550d_fcr_rtrigger_insert(pc16550d_fcr_t _regval, pc16550d_trigger_lvl_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_fcr_t pc16550d_fcr_rtrigger_insert(pc16550d_fcr_t _regval, pc16550d_trigger_lvl_t _fieldval)
{
    return((_regval & 0x3f) | (0xc0 & (((pc16550d_fcr_t )(_fieldval)) << 6)));
}

static inline int pc16550d_fcr_prtval(char *_s, size_t _size, pc16550d_fcr_t _regval) __attribute__ ((always_inline));
static inline int pc16550d_fcr_prtval(char *_s, size_t _size, pc16550d_fcr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fifoe =\t%" PRIx8 "\t(FIFO enable)\n", pc16550d_fcr_fifoe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rfifo_reset =\t%" PRIx8 "\t(RCVR FIFO reset)\n", pc16550d_fcr_rfifo_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xfifo_reset =\t%" PRIx8 "\t(XMIT FIFO reset)\n", pc16550d_fcr_xfifo_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma_mode =\t%" PRIx8 "\t(DMA mode select)\n", pc16550d_fcr_dma_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtrigger =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_trigger_lvl_prtval(_s + _r, _avail, pc16550d_fcr_rtrigger_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(RCVR trigger)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pc16550d_lcr_t
 * Description: Implicit type of Line control register
 * Fields:
 *   wls	(size 2, offset 0, init 0):	RW	Word length select
 *   stb	(size 1, offset 2, init 0):	RW	Number of stop bits
 *   pen	(size 1, offset 3, init 0):	RW	Parity enable
 *   eps	(size 1, offset 4, init 0):	RW	Even parity select
 *   sp	(size 1, offset 5, init 0):	RW	Stick parity
 *   sb	(size 1, offset 6, init 0):	RW	Set break
 *   dlab	(size 1, offset 7, init 0):	RW	Divisor latch access
 */
typedef uint8_t pc16550d_lcr_t;
#define pc16550d_lcr_default 0x0
static inline pc16550d_char_len_t pc16550d_lcr_wls_extract(pc16550d_lcr_t _regval) __attribute__ ((always_inline));
static inline pc16550d_char_len_t pc16550d_lcr_wls_extract(pc16550d_lcr_t _regval)
{
    return((pc16550d_char_len_t )((_regval & 0x3) >> 0));
}

static inline pc16550d_lcr_t pc16550d_lcr_wls_insert(pc16550d_lcr_t _regval, pc16550d_char_len_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_lcr_t pc16550d_lcr_wls_insert(pc16550d_lcr_t _regval, pc16550d_char_len_t _fieldval)
{
    return((_regval & 0xfc) | (0x3 & (((pc16550d_lcr_t )(_fieldval)) << 0)));
}

static inline uint8_t pc16550d_lcr_stb_extract(pc16550d_lcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lcr_stb_extract(pc16550d_lcr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline pc16550d_lcr_t pc16550d_lcr_stb_insert(pc16550d_lcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_lcr_t pc16550d_lcr_stb_insert(pc16550d_lcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((pc16550d_lcr_t )(_fieldval)) << 2)));
}

static inline uint8_t pc16550d_lcr_pen_extract(pc16550d_lcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lcr_pen_extract(pc16550d_lcr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline pc16550d_lcr_t pc16550d_lcr_pen_insert(pc16550d_lcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_lcr_t pc16550d_lcr_pen_insert(pc16550d_lcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((pc16550d_lcr_t )(_fieldval)) << 3)));
}

static inline uint8_t pc16550d_lcr_eps_extract(pc16550d_lcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lcr_eps_extract(pc16550d_lcr_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline pc16550d_lcr_t pc16550d_lcr_eps_insert(pc16550d_lcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_lcr_t pc16550d_lcr_eps_insert(pc16550d_lcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((pc16550d_lcr_t )(_fieldval)) << 4)));
}

static inline uint8_t pc16550d_lcr_sp_extract(pc16550d_lcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lcr_sp_extract(pc16550d_lcr_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline pc16550d_lcr_t pc16550d_lcr_sp_insert(pc16550d_lcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_lcr_t pc16550d_lcr_sp_insert(pc16550d_lcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdf) | (0x20 & (((pc16550d_lcr_t )(_fieldval)) << 5)));
}

static inline uint8_t pc16550d_lcr_sb_extract(pc16550d_lcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lcr_sb_extract(pc16550d_lcr_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline pc16550d_lcr_t pc16550d_lcr_sb_insert(pc16550d_lcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_lcr_t pc16550d_lcr_sb_insert(pc16550d_lcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbf) | (0x40 & (((pc16550d_lcr_t )(_fieldval)) << 6)));
}

static inline uint8_t pc16550d_lcr_dlab_extract(pc16550d_lcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lcr_dlab_extract(pc16550d_lcr_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline pc16550d_lcr_t pc16550d_lcr_dlab_insert(pc16550d_lcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_lcr_t pc16550d_lcr_dlab_insert(pc16550d_lcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7f) | (0x80 & (((pc16550d_lcr_t )(_fieldval)) << 7)));
}

static inline int pc16550d_lcr_prtval(char *_s, size_t _size, pc16550d_lcr_t _regval) __attribute__ ((always_inline));
static inline int pc16550d_lcr_prtval(char *_s, size_t _size, pc16550d_lcr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wls =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_char_len_prtval(_s + _r, _avail, pc16550d_lcr_wls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Word length select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stb =\t%" PRIx8 "\t(Number of stop bits)\n", pc16550d_lcr_stb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pen =\t%" PRIx8 "\t(Parity enable)\n", pc16550d_lcr_pen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eps =\t%" PRIx8 "\t(Even parity select)\n", pc16550d_lcr_eps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sp =\t%" PRIx8 "\t(Stick parity)\n", pc16550d_lcr_sp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sb =\t%" PRIx8 "\t(Set break)\n", pc16550d_lcr_sb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlab =\t%" PRIx8 "\t(Divisor latch access)\n", pc16550d_lcr_dlab_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pc16550d_mcr_t
 * Description: Implicit type of Modem control register
 * Fields:
 *   dtr	(size 1, offset 0, init 0):	RW	Data terminal ready
 *   rts	(size 1, offset 1, init 0):	RW	Request to send
 *   out	(size 2, offset 2, init 0):	RW	Out
 *   loop	(size 1, offset 4, init 0):	RW	Loop
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 */
typedef uint8_t pc16550d_mcr_t;
#define pc16550d_mcr_default 0x0
static inline uint8_t pc16550d_mcr_dtr_extract(pc16550d_mcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_mcr_dtr_extract(pc16550d_mcr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pc16550d_mcr_t pc16550d_mcr_dtr_insert(pc16550d_mcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_mcr_t pc16550d_mcr_dtr_insert(pc16550d_mcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((pc16550d_mcr_t )(_fieldval)) << 0)));
}

static inline uint8_t pc16550d_mcr_rts_extract(pc16550d_mcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_mcr_rts_extract(pc16550d_mcr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline pc16550d_mcr_t pc16550d_mcr_rts_insert(pc16550d_mcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_mcr_t pc16550d_mcr_rts_insert(pc16550d_mcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((pc16550d_mcr_t )(_fieldval)) << 1)));
}

static inline uint8_t pc16550d_mcr_out_extract(pc16550d_mcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_mcr_out_extract(pc16550d_mcr_t _regval)
{
    return((uint8_t )((_regval & 0xc) >> 2));
}

static inline pc16550d_mcr_t pc16550d_mcr_out_insert(pc16550d_mcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_mcr_t pc16550d_mcr_out_insert(pc16550d_mcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf3) | (0xc & (((pc16550d_mcr_t )(_fieldval)) << 2)));
}

static inline uint8_t pc16550d_mcr_loop_extract(pc16550d_mcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_mcr_loop_extract(pc16550d_mcr_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline pc16550d_mcr_t pc16550d_mcr_loop_insert(pc16550d_mcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_mcr_t pc16550d_mcr_loop_insert(pc16550d_mcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((pc16550d_mcr_t )(_fieldval)) << 4)));
}

static inline int pc16550d_mcr_prtval(char *_s, size_t _size, pc16550d_mcr_t _regval) __attribute__ ((always_inline));
static inline int pc16550d_mcr_prtval(char *_s, size_t _size, pc16550d_mcr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dtr =\t%" PRIx8 "\t(Data terminal ready)\n", pc16550d_mcr_dtr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rts =\t%" PRIx8 "\t(Request to send)\n", pc16550d_mcr_rts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " out =\t%" PRIx8 "\t(Out)\n", pc16550d_mcr_out_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " loop =\t%" PRIx8 "\t(Loop)\n", pc16550d_mcr_loop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pc16550d_lsr_t
 * Description: Implicit type of Line status register
 * Fields:
 *   dr	(size 1, offset 0, init 0):	RW	Data ready
 *   oe	(size 1, offset 1, init 0):	RW	Overrun error
 *   pe	(size 1, offset 2, init 0):	RW	Parity error
 *   fe	(size 1, offset 3, init 0):	RW	Framing error
 *   bi	(size 1, offset 4, init 0):	RW	Break interrupt
 *   thre	(size 1, offset 5, init 0):	RW	Transmitter holding register
 *   temt	(size 1, offset 6, init 0):	RW	Transmitter empty
 *   erfifo	(size 1, offset 7, init 0):	RW	Error in RCVR FIFO
 */
typedef uint8_t pc16550d_lsr_t;
#define pc16550d_lsr_default 0x0
static inline uint8_t pc16550d_lsr_dr_extract(pc16550d_lsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lsr_dr_extract(pc16550d_lsr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pc16550d_lsr_t pc16550d_lsr_dr_insert(pc16550d_lsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_lsr_t pc16550d_lsr_dr_insert(pc16550d_lsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((pc16550d_lsr_t )(_fieldval)) << 0)));
}

static inline uint8_t pc16550d_lsr_oe_extract(pc16550d_lsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lsr_oe_extract(pc16550d_lsr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline pc16550d_lsr_t pc16550d_lsr_oe_insert(pc16550d_lsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_lsr_t pc16550d_lsr_oe_insert(pc16550d_lsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((pc16550d_lsr_t )(_fieldval)) << 1)));
}

static inline uint8_t pc16550d_lsr_pe_extract(pc16550d_lsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lsr_pe_extract(pc16550d_lsr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline pc16550d_lsr_t pc16550d_lsr_pe_insert(pc16550d_lsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_lsr_t pc16550d_lsr_pe_insert(pc16550d_lsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((pc16550d_lsr_t )(_fieldval)) << 2)));
}

static inline uint8_t pc16550d_lsr_fe_extract(pc16550d_lsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lsr_fe_extract(pc16550d_lsr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline pc16550d_lsr_t pc16550d_lsr_fe_insert(pc16550d_lsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_lsr_t pc16550d_lsr_fe_insert(pc16550d_lsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((pc16550d_lsr_t )(_fieldval)) << 3)));
}

static inline uint8_t pc16550d_lsr_bi_extract(pc16550d_lsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lsr_bi_extract(pc16550d_lsr_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline pc16550d_lsr_t pc16550d_lsr_bi_insert(pc16550d_lsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_lsr_t pc16550d_lsr_bi_insert(pc16550d_lsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((pc16550d_lsr_t )(_fieldval)) << 4)));
}

static inline uint8_t pc16550d_lsr_thre_extract(pc16550d_lsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lsr_thre_extract(pc16550d_lsr_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline pc16550d_lsr_t pc16550d_lsr_thre_insert(pc16550d_lsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_lsr_t pc16550d_lsr_thre_insert(pc16550d_lsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdf) | (0x20 & (((pc16550d_lsr_t )(_fieldval)) << 5)));
}

static inline uint8_t pc16550d_lsr_temt_extract(pc16550d_lsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lsr_temt_extract(pc16550d_lsr_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline pc16550d_lsr_t pc16550d_lsr_temt_insert(pc16550d_lsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_lsr_t pc16550d_lsr_temt_insert(pc16550d_lsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbf) | (0x40 & (((pc16550d_lsr_t )(_fieldval)) << 6)));
}

static inline uint8_t pc16550d_lsr_erfifo_extract(pc16550d_lsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lsr_erfifo_extract(pc16550d_lsr_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline pc16550d_lsr_t pc16550d_lsr_erfifo_insert(pc16550d_lsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_lsr_t pc16550d_lsr_erfifo_insert(pc16550d_lsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7f) | (0x80 & (((pc16550d_lsr_t )(_fieldval)) << 7)));
}

static inline int pc16550d_lsr_prtval(char *_s, size_t _size, pc16550d_lsr_t _regval) __attribute__ ((always_inline));
static inline int pc16550d_lsr_prtval(char *_s, size_t _size, pc16550d_lsr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dr =\t%" PRIx8 "\t(Data ready)\n", pc16550d_lsr_dr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oe =\t%" PRIx8 "\t(Overrun error)\n", pc16550d_lsr_oe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pe =\t%" PRIx8 "\t(Parity error)\n", pc16550d_lsr_pe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fe =\t%" PRIx8 "\t(Framing error)\n", pc16550d_lsr_fe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bi =\t%" PRIx8 "\t(Break interrupt)\n", pc16550d_lsr_bi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " thre =\t%" PRIx8 "\t(Transmitter holding register)\n", pc16550d_lsr_thre_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " temt =\t%" PRIx8 "\t(Transmitter empty)\n", pc16550d_lsr_temt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " erfifo =\t%" PRIx8 "\t(Error in RCVR FIFO)\n", pc16550d_lsr_erfifo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: pc16550d_msr_t
 * Description: Implicit type of Modem status register
 * Fields:
 *   dcts	(size 1, offset 0, init 0):	RW	Delta clear to send
 *   ddsr	(size 1, offset 1, init 0):	RW	Delta data set ready
 *   teri	(size 1, offset 2, init 0):	RW	Trailing edge ring indicator
 *   ddcd	(size 1, offset 3, init 0):	RW	Delta data carrier detect
 *   cts	(size 1, offset 4, init 0):	RW	Clear to send
 *   dsr	(size 1, offset 5, init 0):	RW	Data set ready
 *   ri	(size 1, offset 6, init 0):	RW	Ring indicator
 *   dcd	(size 1, offset 7, init 0):	RW	Data carrier detect
 */
typedef uint8_t pc16550d_msr_t;
#define pc16550d_msr_default 0x0
static inline uint8_t pc16550d_msr_dcts_extract(pc16550d_msr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_msr_dcts_extract(pc16550d_msr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline pc16550d_msr_t pc16550d_msr_dcts_insert(pc16550d_msr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_msr_t pc16550d_msr_dcts_insert(pc16550d_msr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((pc16550d_msr_t )(_fieldval)) << 0)));
}

static inline uint8_t pc16550d_msr_ddsr_extract(pc16550d_msr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_msr_ddsr_extract(pc16550d_msr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline pc16550d_msr_t pc16550d_msr_ddsr_insert(pc16550d_msr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_msr_t pc16550d_msr_ddsr_insert(pc16550d_msr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((pc16550d_msr_t )(_fieldval)) << 1)));
}

static inline uint8_t pc16550d_msr_teri_extract(pc16550d_msr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_msr_teri_extract(pc16550d_msr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline pc16550d_msr_t pc16550d_msr_teri_insert(pc16550d_msr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_msr_t pc16550d_msr_teri_insert(pc16550d_msr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((pc16550d_msr_t )(_fieldval)) << 2)));
}

static inline uint8_t pc16550d_msr_ddcd_extract(pc16550d_msr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_msr_ddcd_extract(pc16550d_msr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline pc16550d_msr_t pc16550d_msr_ddcd_insert(pc16550d_msr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_msr_t pc16550d_msr_ddcd_insert(pc16550d_msr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((pc16550d_msr_t )(_fieldval)) << 3)));
}

static inline uint8_t pc16550d_msr_cts_extract(pc16550d_msr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_msr_cts_extract(pc16550d_msr_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline pc16550d_msr_t pc16550d_msr_cts_insert(pc16550d_msr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_msr_t pc16550d_msr_cts_insert(pc16550d_msr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((pc16550d_msr_t )(_fieldval)) << 4)));
}

static inline uint8_t pc16550d_msr_dsr_extract(pc16550d_msr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_msr_dsr_extract(pc16550d_msr_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline pc16550d_msr_t pc16550d_msr_dsr_insert(pc16550d_msr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_msr_t pc16550d_msr_dsr_insert(pc16550d_msr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdf) | (0x20 & (((pc16550d_msr_t )(_fieldval)) << 5)));
}

static inline uint8_t pc16550d_msr_ri_extract(pc16550d_msr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_msr_ri_extract(pc16550d_msr_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline pc16550d_msr_t pc16550d_msr_ri_insert(pc16550d_msr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_msr_t pc16550d_msr_ri_insert(pc16550d_msr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbf) | (0x40 & (((pc16550d_msr_t )(_fieldval)) << 6)));
}

static inline uint8_t pc16550d_msr_dcd_extract(pc16550d_msr_t _regval) __attribute__ ((always_inline));
static inline uint8_t pc16550d_msr_dcd_extract(pc16550d_msr_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline pc16550d_msr_t pc16550d_msr_dcd_insert(pc16550d_msr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline pc16550d_msr_t pc16550d_msr_dcd_insert(pc16550d_msr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7f) | (0x80 & (((pc16550d_msr_t )(_fieldval)) << 7)));
}

static inline int pc16550d_msr_prtval(char *_s, size_t _size, pc16550d_msr_t _regval) __attribute__ ((always_inline));
static inline int pc16550d_msr_prtval(char *_s, size_t _size, pc16550d_msr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcts =\t%" PRIx8 "\t(Delta clear to send)\n", pc16550d_msr_dcts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ddsr =\t%" PRIx8 "\t(Delta data set ready)\n", pc16550d_msr_ddsr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " teri =\t%" PRIx8 "\t(Trailing edge ring indicator)\n", pc16550d_msr_teri_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ddcd =\t%" PRIx8 "\t(Delta data carrier detect)\n", pc16550d_msr_ddcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cts =\t%" PRIx8 "\t(Clear to send)\n", pc16550d_msr_cts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsr =\t%" PRIx8 "\t(Data set ready)\n", pc16550d_msr_dsr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ri =\t%" PRIx8 "\t(Ring indicator)\n", pc16550d_msr_ri_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcd =\t%" PRIx8 "\t(Data carrier detect)\n", pc16550d_msr_dcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_io_t base;
    uint8_t thr_shadow;
    pc16550d_fcr_t fcr_shadow;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum pc16550d_initials {
    pc16550d_rbr_initial = 0x0,
    pc16550d_thr_initial = 0x0,
    pc16550d_ier_initial = 0x0,
    pc16550d_iir_initial = 0x0,
    pc16550d_fcr_initial = 0x0,
    pc16550d_lcr_initial = 0x0,
    pc16550d_mcr_initial = 0x0,
    pc16550d_lsr_initial = 0x0,
    pc16550d_msr_initial = 0x0,
    pc16550d_scr_initial = 0x0,
    pc16550d_dl_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void pc16550d_initialize(__DN(t) *_dev, mackerel_io_t base) __attribute__ ((always_inline));
static inline void pc16550d_initialize(__DN(t) *_dev, mackerel_io_t base)
{
    _dev->base = base;
}

/*
 * Register rbr: Receiver buffer
 * Type: pc16550d.uint8 (primitive type)
 */
static inline uint8_t pc16550d_rbr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_rbr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x0));
}

static inline uint8_t pc16550d_rbr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_rbr_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x0));
}

static inline void pc16550d_rbr_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_rbr_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x0, _regval);
}

// Register rbr is not writeable
static inline int pc16550d_rbr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pc16550d_rbr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_io_8(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rbr (Receiver buffer): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register thr: Transmitter holding
 * Type: pc16550d.uint8 (primitive type)
 */
static inline uint8_t pc16550d_thr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_thr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x0));
}

static inline uint8_t pc16550d_thr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_thr_rd(__DN(t) *_dev)
{
    return(_dev->thr_shadow);
}

static inline void pc16550d_thr_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_thr_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x0, _regval);
}

static inline void pc16550d_thr_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_thr_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->base, 0x0, _regval);
}

static inline int pc16550d_thr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pc16550d_thr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = _dev->thr_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register thr (Transmitter holding): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 " (SHADOW copy)\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ier: Interrupt enable
 * Type: pc16550d.ier (Implicit type of Interrupt enable register)
 *   erbfi	(size 1, offset 0, init 0):	RW	Enable received data available interrupt
 *   etbei	(size 1, offset 1, init 0):	RW	Enable transmitter holding register empty interrupt
 *   elsi	(size 1, offset 2, init 0):	RW	Enable receiver line status interrupt
 *   edssi	(size 1, offset 3, init 0):	RW	Enable modem status interrupt
 *   _anon4	(size 4, offset 4, init 0):	MBZ	_
 */
static inline pc16550d_ier_t pc16550d_ier_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_ier_t pc16550d_ier_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x1));
}

static inline pc16550d_ier_t pc16550d_ier_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_ier_t pc16550d_ier_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x1));
}

static inline void pc16550d_ier_rawwr(__DN(t) *_dev, pc16550d_ier_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_ier_rawwr(__DN(t) *_dev, pc16550d_ier_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x1, _regval);
}

static inline void pc16550d_ier_wr(__DN(t) *_dev, pc16550d_ier_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_ier_wr(__DN(t) *_dev, pc16550d_ier_t _regval)
{
    _regval = (_regval & 0xf);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->base, 0x1, _regval);
}

static inline int pc16550d_ier_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pc16550d_ier_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pc16550d_ier_t _regval = mackerel_read_io_8(_dev->base, 0x1);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ier (Interrupt enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " erbfi =\t%" PRIx8 "\t(Enable received data available interrupt)\n", pc16550d_ier_erbfi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " etbei =\t%" PRIx8 "\t(Enable transmitter holding register empty interrupt)\n", pc16550d_ier_etbei_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " elsi =\t%" PRIx8 "\t(Enable receiver line status interrupt)\n", pc16550d_ier_elsi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " edssi =\t%" PRIx8 "\t(Enable modem status interrupt)\n", pc16550d_ier_edssi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    return(_r);
}

static inline uint8_t pc16550d_ier_erbfi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_ier_erbfi_rdf(__DN(t) *_dev)
{
    pc16550d_ier_t _regval = mackerel_read_io_8(_dev->base, 0x1);
    return(pc16550d_ier_erbfi_extract(_regval));
}

static inline uint8_t pc16550d_ier_etbei_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_ier_etbei_rdf(__DN(t) *_dev)
{
    pc16550d_ier_t _regval = mackerel_read_io_8(_dev->base, 0x1);
    return(pc16550d_ier_etbei_extract(_regval));
}

static inline uint8_t pc16550d_ier_elsi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_ier_elsi_rdf(__DN(t) *_dev)
{
    pc16550d_ier_t _regval = mackerel_read_io_8(_dev->base, 0x1);
    return(pc16550d_ier_elsi_extract(_regval));
}

static inline uint8_t pc16550d_ier_edssi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_ier_edssi_rdf(__DN(t) *_dev)
{
    pc16550d_ier_t _regval = mackerel_read_io_8(_dev->base, 0x1);
    return(pc16550d_ier_edssi_extract(_regval));
}

static inline void pc16550d_ier_erbfi_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_ier_erbfi_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_ier_t _regval = 0x1 & (((pc16550d_ier_t )(_fieldval)) << 0);
    _regval = (_regval | (0xe & mackerel_read_io_8(_dev->base, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xf);
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x1, _regval);
    // No shadow register to write to
}

static inline void pc16550d_ier_etbei_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_ier_etbei_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_ier_t _regval = 0x2 & (((pc16550d_ier_t )(_fieldval)) << 1);
    _regval = (_regval | (0xd & mackerel_read_io_8(_dev->base, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xf);
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x1, _regval);
    // No shadow register to write to
}

static inline void pc16550d_ier_elsi_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_ier_elsi_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_ier_t _regval = 0x4 & (((pc16550d_ier_t )(_fieldval)) << 2);
    _regval = (_regval | (0xb & mackerel_read_io_8(_dev->base, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xf);
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x1, _regval);
    // No shadow register to write to
}

static inline void pc16550d_ier_edssi_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_ier_edssi_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_ier_t _regval = 0x8 & (((pc16550d_ier_t )(_fieldval)) << 3);
    _regval = (_regval | (0x7 & mackerel_read_io_8(_dev->base, 0x1)));
    // No read of register shadow required
    _regval = (_regval & 0xf);
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x1, _regval);
    // No shadow register to write to
}

/*
 * Register iir: Interrupt identification
 * Type: pc16550d.iir (Implicit type of Interrupt identification register)
 *   iid	(size 4, offset 0, init 0):	RO	Interrupt ID
 *   _anon4	(size 2, offset 4, init 0):	MBZ	_
 *   fifoe	(size 2, offset 6, init 0):	RO	FIFOs enabled
 */
static inline pc16550d_iir_t pc16550d_iir_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_iir_t pc16550d_iir_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x2));
}

static inline pc16550d_iir_t pc16550d_iir_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_iir_t pc16550d_iir_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x2));
}

static inline void pc16550d_iir_rawwr(__DN(t) *_dev, pc16550d_iir_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_iir_rawwr(__DN(t) *_dev, pc16550d_iir_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x2, _regval);
}

// Register iir is not writeable
static inline int pc16550d_iir_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pc16550d_iir_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pc16550d_iir_t _regval = mackerel_read_io_8(_dev->base, 0x2);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register iir (Interrupt identification): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iid =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_irq_id_prtval(_s + _r, _avail, pc16550d_iir_iid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interrupt ID)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fifoe =\t%" PRIx8 "\t(FIFOs enabled)\n", pc16550d_iir_fifoe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline pc16550d_irq_id_t pc16550d_iir_iid_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_irq_id_t pc16550d_iir_iid_rdf(__DN(t) *_dev)
{
    pc16550d_iir_t _regval = mackerel_read_io_8(_dev->base, 0x2);
    return(pc16550d_iir_iid_extract(_regval));
}

static inline uint8_t pc16550d_iir_fifoe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_iir_fifoe_rdf(__DN(t) *_dev)
{
    pc16550d_iir_t _regval = mackerel_read_io_8(_dev->base, 0x2);
    return(pc16550d_iir_fifoe_extract(_regval));
}

/*
 * Register fcr: FIFO control
 * Type: pc16550d.fcr (Implicit type of FIFO control register)
 *   fifoe	(size 1, offset 0, init 0):	WO	FIFO enable
 *   rfifo_reset	(size 1, offset 1, init 0):	WO	RCVR FIFO reset
 *   xfifo_reset	(size 1, offset 2, init 0):	WO	XMIT FIFO reset
 *   dma_mode	(size 1, offset 3, init 0):	WO	DMA mode select
 *   _anon4	(size 2, offset 4, init 0):	RSVD	_
 *   rtrigger	(size 2, offset 6, init 0):	WO	RCVR trigger
 */
static inline pc16550d_fcr_t pc16550d_fcr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_fcr_t pc16550d_fcr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x2));
}

static inline pc16550d_fcr_t pc16550d_fcr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_fcr_t pc16550d_fcr_rd(__DN(t) *_dev)
{
    return(_dev->fcr_shadow);
}

static inline void pc16550d_fcr_rawwr(__DN(t) *_dev, pc16550d_fcr_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_fcr_rawwr(__DN(t) *_dev, pc16550d_fcr_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x2, _regval);
}

static inline void pc16550d_fcr_wr(__DN(t) *_dev, pc16550d_fcr_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_fcr_wr(__DN(t) *_dev, pc16550d_fcr_t _regval)
{
    _regval = (_regval & 0xcf);
    // No MB1 fields present
    _regval = (_regval | (0x30 & mackerel_read_io_8(_dev->base, 0x2)));
    mackerel_write_io_8(_dev->base, 0x2, _regval);
}

static inline int pc16550d_fcr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pc16550d_fcr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pc16550d_fcr_t _regval = _dev->fcr_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fcr (FIFO control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fifoe =\t%" PRIx8 "\t(FIFO enable)\n", pc16550d_fcr_fifoe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rfifo_reset =\t%" PRIx8 "\t(RCVR FIFO reset)\n", pc16550d_fcr_rfifo_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xfifo_reset =\t%" PRIx8 "\t(XMIT FIFO reset)\n", pc16550d_fcr_xfifo_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma_mode =\t%" PRIx8 "\t(DMA mode select)\n", pc16550d_fcr_dma_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtrigger =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_trigger_lvl_prtval(_s + _r, _avail, pc16550d_fcr_rtrigger_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(RCVR trigger)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t pc16550d_fcr_fifoe_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_fcr_fifoe_rd_shadow(__DN(t) *_dev)
{
    return(pc16550d_fcr_fifoe_extract(_dev->fcr_shadow));
}

static inline uint8_t pc16550d_fcr_rfifo_reset_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_fcr_rfifo_reset_rd_shadow(__DN(t) *_dev)
{
    return(pc16550d_fcr_rfifo_reset_extract(_dev->fcr_shadow));
}

static inline uint8_t pc16550d_fcr_xfifo_reset_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_fcr_xfifo_reset_rd_shadow(__DN(t) *_dev)
{
    return(pc16550d_fcr_xfifo_reset_extract(_dev->fcr_shadow));
}

static inline uint8_t pc16550d_fcr_dma_mode_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_fcr_dma_mode_rd_shadow(__DN(t) *_dev)
{
    return(pc16550d_fcr_dma_mode_extract(_dev->fcr_shadow));
}

static inline pc16550d_trigger_lvl_t pc16550d_fcr_rtrigger_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_trigger_lvl_t pc16550d_fcr_rtrigger_rd_shadow(__DN(t) *_dev)
{
    return(pc16550d_fcr_rtrigger_extract(_dev->fcr_shadow));
}

static inline void pc16550d_fcr_fifoe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_fcr_fifoe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_fcr_t _regval = 0x1 & (((pc16550d_fcr_t )(_fieldval)) << 0);
    _regval = (_regval | (0x30 & mackerel_read_io_8(_dev->base, 0x2)));
    _regval = (_regval | (0xce & (_dev->fcr_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x2, _regval);
    _dev->fcr_shadow = _regval;
}

static inline void pc16550d_fcr_rfifo_reset_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_fcr_rfifo_reset_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_fcr_t _regval = 0x2 & (((pc16550d_fcr_t )(_fieldval)) << 1);
    _regval = (_regval | (0x30 & mackerel_read_io_8(_dev->base, 0x2)));
    _regval = (_regval | (0xcd & (_dev->fcr_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x2, _regval);
    _dev->fcr_shadow = _regval;
}

static inline void pc16550d_fcr_xfifo_reset_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_fcr_xfifo_reset_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_fcr_t _regval = 0x4 & (((pc16550d_fcr_t )(_fieldval)) << 2);
    _regval = (_regval | (0x30 & mackerel_read_io_8(_dev->base, 0x2)));
    _regval = (_regval | (0xcb & (_dev->fcr_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x2, _regval);
    _dev->fcr_shadow = _regval;
}

static inline void pc16550d_fcr_dma_mode_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_fcr_dma_mode_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_fcr_t _regval = 0x8 & (((pc16550d_fcr_t )(_fieldval)) << 3);
    _regval = (_regval | (0x30 & mackerel_read_io_8(_dev->base, 0x2)));
    _regval = (_regval | (0xc7 & (_dev->fcr_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x2, _regval);
    _dev->fcr_shadow = _regval;
}

static inline void pc16550d_fcr_rtrigger_wrf(__DN(t) *_dev, pc16550d_trigger_lvl_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_fcr_rtrigger_wrf(__DN(t) *_dev, pc16550d_trigger_lvl_t _fieldval)
{
    pc16550d_fcr_t _regval = 0xc0 & (((pc16550d_fcr_t )(_fieldval)) << 6);
    _regval = (_regval | (0x30 & mackerel_read_io_8(_dev->base, 0x2)));
    _regval = (_regval | (0xf & (_dev->fcr_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x2, _regval);
    _dev->fcr_shadow = _regval;
}

/*
 * Register lcr: Line control
 * Type: pc16550d.lcr (Implicit type of Line control register)
 *   wls	(size 2, offset 0, init 0):	RW	Word length select
 *   stb	(size 1, offset 2, init 0):	RW	Number of stop bits
 *   pen	(size 1, offset 3, init 0):	RW	Parity enable
 *   eps	(size 1, offset 4, init 0):	RW	Even parity select
 *   sp	(size 1, offset 5, init 0):	RW	Stick parity
 *   sb	(size 1, offset 6, init 0):	RW	Set break
 *   dlab	(size 1, offset 7, init 0):	RW	Divisor latch access
 */
static inline pc16550d_lcr_t pc16550d_lcr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_lcr_t pc16550d_lcr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x3));
}

static inline pc16550d_lcr_t pc16550d_lcr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_lcr_t pc16550d_lcr_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x3));
}

static inline void pc16550d_lcr_rawwr(__DN(t) *_dev, pc16550d_lcr_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_lcr_rawwr(__DN(t) *_dev, pc16550d_lcr_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x3, _regval);
}

static inline void pc16550d_lcr_wr(__DN(t) *_dev, pc16550d_lcr_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_lcr_wr(__DN(t) *_dev, pc16550d_lcr_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->base, 0x3, _regval);
}

static inline int pc16550d_lcr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pc16550d_lcr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pc16550d_lcr_t _regval = mackerel_read_io_8(_dev->base, 0x3);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lcr (Line control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wls =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_char_len_prtval(_s + _r, _avail, pc16550d_lcr_wls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Word length select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stb =\t%" PRIx8 "\t(Number of stop bits)\n", pc16550d_lcr_stb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pen =\t%" PRIx8 "\t(Parity enable)\n", pc16550d_lcr_pen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eps =\t%" PRIx8 "\t(Even parity select)\n", pc16550d_lcr_eps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sp =\t%" PRIx8 "\t(Stick parity)\n", pc16550d_lcr_sp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sb =\t%" PRIx8 "\t(Set break)\n", pc16550d_lcr_sb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlab =\t%" PRIx8 "\t(Divisor latch access)\n", pc16550d_lcr_dlab_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline pc16550d_char_len_t pc16550d_lcr_wls_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_char_len_t pc16550d_lcr_wls_rdf(__DN(t) *_dev)
{
    pc16550d_lcr_t _regval = mackerel_read_io_8(_dev->base, 0x3);
    return(pc16550d_lcr_wls_extract(_regval));
}

static inline uint8_t pc16550d_lcr_stb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lcr_stb_rdf(__DN(t) *_dev)
{
    pc16550d_lcr_t _regval = mackerel_read_io_8(_dev->base, 0x3);
    return(pc16550d_lcr_stb_extract(_regval));
}

static inline uint8_t pc16550d_lcr_pen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lcr_pen_rdf(__DN(t) *_dev)
{
    pc16550d_lcr_t _regval = mackerel_read_io_8(_dev->base, 0x3);
    return(pc16550d_lcr_pen_extract(_regval));
}

static inline uint8_t pc16550d_lcr_eps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lcr_eps_rdf(__DN(t) *_dev)
{
    pc16550d_lcr_t _regval = mackerel_read_io_8(_dev->base, 0x3);
    return(pc16550d_lcr_eps_extract(_regval));
}

static inline uint8_t pc16550d_lcr_sp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lcr_sp_rdf(__DN(t) *_dev)
{
    pc16550d_lcr_t _regval = mackerel_read_io_8(_dev->base, 0x3);
    return(pc16550d_lcr_sp_extract(_regval));
}

static inline uint8_t pc16550d_lcr_sb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lcr_sb_rdf(__DN(t) *_dev)
{
    pc16550d_lcr_t _regval = mackerel_read_io_8(_dev->base, 0x3);
    return(pc16550d_lcr_sb_extract(_regval));
}

static inline uint8_t pc16550d_lcr_dlab_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lcr_dlab_rdf(__DN(t) *_dev)
{
    pc16550d_lcr_t _regval = mackerel_read_io_8(_dev->base, 0x3);
    return(pc16550d_lcr_dlab_extract(_regval));
}

static inline void pc16550d_lcr_wls_wrf(__DN(t) *_dev, pc16550d_char_len_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_lcr_wls_wrf(__DN(t) *_dev, pc16550d_char_len_t _fieldval)
{
    pc16550d_lcr_t _regval = 0x3 & (((pc16550d_lcr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfc & mackerel_read_io_8(_dev->base, 0x3)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x3, _regval);
    // No shadow register to write to
}

static inline void pc16550d_lcr_stb_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_lcr_stb_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_lcr_t _regval = 0x4 & (((pc16550d_lcr_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfb & mackerel_read_io_8(_dev->base, 0x3)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x3, _regval);
    // No shadow register to write to
}

static inline void pc16550d_lcr_pen_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_lcr_pen_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_lcr_t _regval = 0x8 & (((pc16550d_lcr_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf7 & mackerel_read_io_8(_dev->base, 0x3)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x3, _regval);
    // No shadow register to write to
}

static inline void pc16550d_lcr_eps_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_lcr_eps_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_lcr_t _regval = 0x10 & (((pc16550d_lcr_t )(_fieldval)) << 4);
    _regval = (_regval | (0xef & mackerel_read_io_8(_dev->base, 0x3)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x3, _regval);
    // No shadow register to write to
}

static inline void pc16550d_lcr_sp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_lcr_sp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_lcr_t _regval = 0x20 & (((pc16550d_lcr_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdf & mackerel_read_io_8(_dev->base, 0x3)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x3, _regval);
    // No shadow register to write to
}

static inline void pc16550d_lcr_sb_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_lcr_sb_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_lcr_t _regval = 0x40 & (((pc16550d_lcr_t )(_fieldval)) << 6);
    _regval = (_regval | (0xbf & mackerel_read_io_8(_dev->base, 0x3)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x3, _regval);
    // No shadow register to write to
}

static inline void pc16550d_lcr_dlab_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_lcr_dlab_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_lcr_t _regval = 0x80 & (((pc16550d_lcr_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7f & mackerel_read_io_8(_dev->base, 0x3)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x3, _regval);
    // No shadow register to write to
}

/*
 * Register mcr: Modem control
 * Type: pc16550d.mcr (Implicit type of Modem control register)
 *   dtr	(size 1, offset 0, init 0):	RW	Data terminal ready
 *   rts	(size 1, offset 1, init 0):	RW	Request to send
 *   out	(size 2, offset 2, init 0):	RW	Out
 *   loop	(size 1, offset 4, init 0):	RW	Loop
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 */
static inline pc16550d_mcr_t pc16550d_mcr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_mcr_t pc16550d_mcr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x4));
}

static inline pc16550d_mcr_t pc16550d_mcr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_mcr_t pc16550d_mcr_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x4));
}

static inline void pc16550d_mcr_rawwr(__DN(t) *_dev, pc16550d_mcr_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_mcr_rawwr(__DN(t) *_dev, pc16550d_mcr_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x4, _regval);
}

static inline void pc16550d_mcr_wr(__DN(t) *_dev, pc16550d_mcr_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_mcr_wr(__DN(t) *_dev, pc16550d_mcr_t _regval)
{
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->base, 0x4, _regval);
}

static inline int pc16550d_mcr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pc16550d_mcr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pc16550d_mcr_t _regval = mackerel_read_io_8(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mcr (Modem control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dtr =\t%" PRIx8 "\t(Data terminal ready)\n", pc16550d_mcr_dtr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rts =\t%" PRIx8 "\t(Request to send)\n", pc16550d_mcr_rts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " out =\t%" PRIx8 "\t(Out)\n", pc16550d_mcr_out_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " loop =\t%" PRIx8 "\t(Loop)\n", pc16550d_mcr_loop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline uint8_t pc16550d_mcr_dtr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_mcr_dtr_rdf(__DN(t) *_dev)
{
    pc16550d_mcr_t _regval = mackerel_read_io_8(_dev->base, 0x4);
    return(pc16550d_mcr_dtr_extract(_regval));
}

static inline uint8_t pc16550d_mcr_rts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_mcr_rts_rdf(__DN(t) *_dev)
{
    pc16550d_mcr_t _regval = mackerel_read_io_8(_dev->base, 0x4);
    return(pc16550d_mcr_rts_extract(_regval));
}

static inline uint8_t pc16550d_mcr_out_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_mcr_out_rdf(__DN(t) *_dev)
{
    pc16550d_mcr_t _regval = mackerel_read_io_8(_dev->base, 0x4);
    return(pc16550d_mcr_out_extract(_regval));
}

static inline uint8_t pc16550d_mcr_loop_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_mcr_loop_rdf(__DN(t) *_dev)
{
    pc16550d_mcr_t _regval = mackerel_read_io_8(_dev->base, 0x4);
    return(pc16550d_mcr_loop_extract(_regval));
}

static inline void pc16550d_mcr_dtr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_mcr_dtr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_mcr_t _regval = 0x1 & (((pc16550d_mcr_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1e & mackerel_read_io_8(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void pc16550d_mcr_rts_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_mcr_rts_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_mcr_t _regval = 0x2 & (((pc16550d_mcr_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1d & mackerel_read_io_8(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void pc16550d_mcr_out_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_mcr_out_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_mcr_t _regval = 0xc & (((pc16550d_mcr_t )(_fieldval)) << 2);
    _regval = (_regval | (0x13 & mackerel_read_io_8(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void pc16550d_mcr_loop_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_mcr_loop_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_mcr_t _regval = 0x10 & (((pc16550d_mcr_t )(_fieldval)) << 4);
    _regval = (_regval | (0xf & mackerel_read_io_8(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

/*
 * Register lsr: Line status
 * Type: pc16550d.lsr (Implicit type of Line status register)
 *   dr	(size 1, offset 0, init 0):	RW	Data ready
 *   oe	(size 1, offset 1, init 0):	RW	Overrun error
 *   pe	(size 1, offset 2, init 0):	RW	Parity error
 *   fe	(size 1, offset 3, init 0):	RW	Framing error
 *   bi	(size 1, offset 4, init 0):	RW	Break interrupt
 *   thre	(size 1, offset 5, init 0):	RW	Transmitter holding register
 *   temt	(size 1, offset 6, init 0):	RW	Transmitter empty
 *   erfifo	(size 1, offset 7, init 0):	RW	Error in RCVR FIFO
 */
static inline pc16550d_lsr_t pc16550d_lsr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_lsr_t pc16550d_lsr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x5));
}

static inline pc16550d_lsr_t pc16550d_lsr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_lsr_t pc16550d_lsr_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x5));
}

static inline void pc16550d_lsr_rawwr(__DN(t) *_dev, pc16550d_lsr_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_lsr_rawwr(__DN(t) *_dev, pc16550d_lsr_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x5, _regval);
}

static inline void pc16550d_lsr_wr(__DN(t) *_dev, pc16550d_lsr_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_lsr_wr(__DN(t) *_dev, pc16550d_lsr_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->base, 0x5, _regval);
}

static inline int pc16550d_lsr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pc16550d_lsr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pc16550d_lsr_t _regval = mackerel_read_io_8(_dev->base, 0x5);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lsr (Line status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dr =\t%" PRIx8 "\t(Data ready)\n", pc16550d_lsr_dr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oe =\t%" PRIx8 "\t(Overrun error)\n", pc16550d_lsr_oe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pe =\t%" PRIx8 "\t(Parity error)\n", pc16550d_lsr_pe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fe =\t%" PRIx8 "\t(Framing error)\n", pc16550d_lsr_fe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bi =\t%" PRIx8 "\t(Break interrupt)\n", pc16550d_lsr_bi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " thre =\t%" PRIx8 "\t(Transmitter holding register)\n", pc16550d_lsr_thre_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " temt =\t%" PRIx8 "\t(Transmitter empty)\n", pc16550d_lsr_temt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " erfifo =\t%" PRIx8 "\t(Error in RCVR FIFO)\n", pc16550d_lsr_erfifo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t pc16550d_lsr_dr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lsr_dr_rdf(__DN(t) *_dev)
{
    pc16550d_lsr_t _regval = mackerel_read_io_8(_dev->base, 0x5);
    return(pc16550d_lsr_dr_extract(_regval));
}

static inline uint8_t pc16550d_lsr_oe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lsr_oe_rdf(__DN(t) *_dev)
{
    pc16550d_lsr_t _regval = mackerel_read_io_8(_dev->base, 0x5);
    return(pc16550d_lsr_oe_extract(_regval));
}

static inline uint8_t pc16550d_lsr_pe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lsr_pe_rdf(__DN(t) *_dev)
{
    pc16550d_lsr_t _regval = mackerel_read_io_8(_dev->base, 0x5);
    return(pc16550d_lsr_pe_extract(_regval));
}

static inline uint8_t pc16550d_lsr_fe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lsr_fe_rdf(__DN(t) *_dev)
{
    pc16550d_lsr_t _regval = mackerel_read_io_8(_dev->base, 0x5);
    return(pc16550d_lsr_fe_extract(_regval));
}

static inline uint8_t pc16550d_lsr_bi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lsr_bi_rdf(__DN(t) *_dev)
{
    pc16550d_lsr_t _regval = mackerel_read_io_8(_dev->base, 0x5);
    return(pc16550d_lsr_bi_extract(_regval));
}

static inline uint8_t pc16550d_lsr_thre_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lsr_thre_rdf(__DN(t) *_dev)
{
    pc16550d_lsr_t _regval = mackerel_read_io_8(_dev->base, 0x5);
    return(pc16550d_lsr_thre_extract(_regval));
}

static inline uint8_t pc16550d_lsr_temt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lsr_temt_rdf(__DN(t) *_dev)
{
    pc16550d_lsr_t _regval = mackerel_read_io_8(_dev->base, 0x5);
    return(pc16550d_lsr_temt_extract(_regval));
}

static inline uint8_t pc16550d_lsr_erfifo_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_lsr_erfifo_rdf(__DN(t) *_dev)
{
    pc16550d_lsr_t _regval = mackerel_read_io_8(_dev->base, 0x5);
    return(pc16550d_lsr_erfifo_extract(_regval));
}

static inline void pc16550d_lsr_dr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_lsr_dr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_lsr_t _regval = 0x1 & (((pc16550d_lsr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfe & mackerel_read_io_8(_dev->base, 0x5)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x5, _regval);
    // No shadow register to write to
}

static inline void pc16550d_lsr_oe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_lsr_oe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_lsr_t _regval = 0x2 & (((pc16550d_lsr_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfd & mackerel_read_io_8(_dev->base, 0x5)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x5, _regval);
    // No shadow register to write to
}

static inline void pc16550d_lsr_pe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_lsr_pe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_lsr_t _regval = 0x4 & (((pc16550d_lsr_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfb & mackerel_read_io_8(_dev->base, 0x5)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x5, _regval);
    // No shadow register to write to
}

static inline void pc16550d_lsr_fe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_lsr_fe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_lsr_t _regval = 0x8 & (((pc16550d_lsr_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf7 & mackerel_read_io_8(_dev->base, 0x5)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x5, _regval);
    // No shadow register to write to
}

static inline void pc16550d_lsr_bi_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_lsr_bi_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_lsr_t _regval = 0x10 & (((pc16550d_lsr_t )(_fieldval)) << 4);
    _regval = (_regval | (0xef & mackerel_read_io_8(_dev->base, 0x5)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x5, _regval);
    // No shadow register to write to
}

static inline void pc16550d_lsr_thre_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_lsr_thre_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_lsr_t _regval = 0x20 & (((pc16550d_lsr_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdf & mackerel_read_io_8(_dev->base, 0x5)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x5, _regval);
    // No shadow register to write to
}

static inline void pc16550d_lsr_temt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_lsr_temt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_lsr_t _regval = 0x40 & (((pc16550d_lsr_t )(_fieldval)) << 6);
    _regval = (_regval | (0xbf & mackerel_read_io_8(_dev->base, 0x5)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x5, _regval);
    // No shadow register to write to
}

static inline void pc16550d_lsr_erfifo_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_lsr_erfifo_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_lsr_t _regval = 0x80 & (((pc16550d_lsr_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7f & mackerel_read_io_8(_dev->base, 0x5)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x5, _regval);
    // No shadow register to write to
}

/*
 * Register msr: Modem status
 * Type: pc16550d.msr (Implicit type of Modem status register)
 *   dcts	(size 1, offset 0, init 0):	RW	Delta clear to send
 *   ddsr	(size 1, offset 1, init 0):	RW	Delta data set ready
 *   teri	(size 1, offset 2, init 0):	RW	Trailing edge ring indicator
 *   ddcd	(size 1, offset 3, init 0):	RW	Delta data carrier detect
 *   cts	(size 1, offset 4, init 0):	RW	Clear to send
 *   dsr	(size 1, offset 5, init 0):	RW	Data set ready
 *   ri	(size 1, offset 6, init 0):	RW	Ring indicator
 *   dcd	(size 1, offset 7, init 0):	RW	Data carrier detect
 */
static inline pc16550d_msr_t pc16550d_msr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_msr_t pc16550d_msr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x6));
}

static inline pc16550d_msr_t pc16550d_msr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline pc16550d_msr_t pc16550d_msr_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x6));
}

static inline void pc16550d_msr_rawwr(__DN(t) *_dev, pc16550d_msr_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_msr_rawwr(__DN(t) *_dev, pc16550d_msr_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x6, _regval);
}

static inline void pc16550d_msr_wr(__DN(t) *_dev, pc16550d_msr_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_msr_wr(__DN(t) *_dev, pc16550d_msr_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->base, 0x6, _regval);
}

static inline int pc16550d_msr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pc16550d_msr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    pc16550d_msr_t _regval = mackerel_read_io_8(_dev->base, 0x6);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register msr (Modem status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcts =\t%" PRIx8 "\t(Delta clear to send)\n", pc16550d_msr_dcts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ddsr =\t%" PRIx8 "\t(Delta data set ready)\n", pc16550d_msr_ddsr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " teri =\t%" PRIx8 "\t(Trailing edge ring indicator)\n", pc16550d_msr_teri_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ddcd =\t%" PRIx8 "\t(Delta data carrier detect)\n", pc16550d_msr_ddcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cts =\t%" PRIx8 "\t(Clear to send)\n", pc16550d_msr_cts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsr =\t%" PRIx8 "\t(Data set ready)\n", pc16550d_msr_dsr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ri =\t%" PRIx8 "\t(Ring indicator)\n", pc16550d_msr_ri_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dcd =\t%" PRIx8 "\t(Data carrier detect)\n", pc16550d_msr_dcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t pc16550d_msr_dcts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_msr_dcts_rdf(__DN(t) *_dev)
{
    pc16550d_msr_t _regval = mackerel_read_io_8(_dev->base, 0x6);
    return(pc16550d_msr_dcts_extract(_regval));
}

static inline uint8_t pc16550d_msr_ddsr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_msr_ddsr_rdf(__DN(t) *_dev)
{
    pc16550d_msr_t _regval = mackerel_read_io_8(_dev->base, 0x6);
    return(pc16550d_msr_ddsr_extract(_regval));
}

static inline uint8_t pc16550d_msr_teri_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_msr_teri_rdf(__DN(t) *_dev)
{
    pc16550d_msr_t _regval = mackerel_read_io_8(_dev->base, 0x6);
    return(pc16550d_msr_teri_extract(_regval));
}

static inline uint8_t pc16550d_msr_ddcd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_msr_ddcd_rdf(__DN(t) *_dev)
{
    pc16550d_msr_t _regval = mackerel_read_io_8(_dev->base, 0x6);
    return(pc16550d_msr_ddcd_extract(_regval));
}

static inline uint8_t pc16550d_msr_cts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_msr_cts_rdf(__DN(t) *_dev)
{
    pc16550d_msr_t _regval = mackerel_read_io_8(_dev->base, 0x6);
    return(pc16550d_msr_cts_extract(_regval));
}

static inline uint8_t pc16550d_msr_dsr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_msr_dsr_rdf(__DN(t) *_dev)
{
    pc16550d_msr_t _regval = mackerel_read_io_8(_dev->base, 0x6);
    return(pc16550d_msr_dsr_extract(_regval));
}

static inline uint8_t pc16550d_msr_ri_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_msr_ri_rdf(__DN(t) *_dev)
{
    pc16550d_msr_t _regval = mackerel_read_io_8(_dev->base, 0x6);
    return(pc16550d_msr_ri_extract(_regval));
}

static inline uint8_t pc16550d_msr_dcd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_msr_dcd_rdf(__DN(t) *_dev)
{
    pc16550d_msr_t _regval = mackerel_read_io_8(_dev->base, 0x6);
    return(pc16550d_msr_dcd_extract(_regval));
}

static inline void pc16550d_msr_dcts_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_msr_dcts_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_msr_t _regval = 0x1 & (((pc16550d_msr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfe & mackerel_read_io_8(_dev->base, 0x6)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x6, _regval);
    // No shadow register to write to
}

static inline void pc16550d_msr_ddsr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_msr_ddsr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_msr_t _regval = 0x2 & (((pc16550d_msr_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfd & mackerel_read_io_8(_dev->base, 0x6)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x6, _regval);
    // No shadow register to write to
}

static inline void pc16550d_msr_teri_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_msr_teri_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_msr_t _regval = 0x4 & (((pc16550d_msr_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfb & mackerel_read_io_8(_dev->base, 0x6)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x6, _regval);
    // No shadow register to write to
}

static inline void pc16550d_msr_ddcd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_msr_ddcd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_msr_t _regval = 0x8 & (((pc16550d_msr_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf7 & mackerel_read_io_8(_dev->base, 0x6)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x6, _regval);
    // No shadow register to write to
}

static inline void pc16550d_msr_cts_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_msr_cts_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_msr_t _regval = 0x10 & (((pc16550d_msr_t )(_fieldval)) << 4);
    _regval = (_regval | (0xef & mackerel_read_io_8(_dev->base, 0x6)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x6, _regval);
    // No shadow register to write to
}

static inline void pc16550d_msr_dsr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_msr_dsr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_msr_t _regval = 0x20 & (((pc16550d_msr_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdf & mackerel_read_io_8(_dev->base, 0x6)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x6, _regval);
    // No shadow register to write to
}

static inline void pc16550d_msr_ri_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_msr_ri_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_msr_t _regval = 0x40 & (((pc16550d_msr_t )(_fieldval)) << 6);
    _regval = (_regval | (0xbf & mackerel_read_io_8(_dev->base, 0x6)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x6, _regval);
    // No shadow register to write to
}

static inline void pc16550d_msr_dcd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void pc16550d_msr_dcd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    pc16550d_msr_t _regval = 0x80 & (((pc16550d_msr_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7f & mackerel_read_io_8(_dev->base, 0x6)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x6, _regval);
    // No shadow register to write to
}

/*
 * Register scr: Scratch register
 * Type: pc16550d.uint8 (primitive type)
 */
static inline uint8_t pc16550d_scr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_scr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x7));
}

static inline uint8_t pc16550d_scr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t pc16550d_scr_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x7));
}

static inline void pc16550d_scr_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_scr_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x7, _regval);
}

// Register scr is not writeable
static inline int pc16550d_scr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pc16550d_scr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_io_8(_dev->base, 0x7);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register scr (Scratch register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register dl: Divisor latch
 * Type: pc16550d.uint16 (primitive type)
 */
static inline uint16_t pc16550d_dl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t pc16550d_dl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_16(_dev->base, 0x0));
}

static inline uint16_t pc16550d_dl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t pc16550d_dl_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_16(_dev->base, 0x0));
}

static inline void pc16550d_dl_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_dl_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_io_16(_dev->base, 0x0, _regval);
}

static inline void pc16550d_dl_wr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void pc16550d_dl_wr(__DN(t) *_dev, uint16_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_16(_dev->base, 0x0, _regval);
}

static inline int pc16550d_dl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pc16550d_dl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_io_16(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dl (Divisor latch): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int pc16550d_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int pc16550d_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device pc16550d (PC16550D UART):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_rbr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_thr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_ier_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_iir_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_fcr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_lcr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_mcr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_lsr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_msr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_scr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = pc16550d_dl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device pc16550d\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __pc16550d_DEV_H
