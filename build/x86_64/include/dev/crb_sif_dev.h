/*
 * DEVICE DEFINITION: RockCreek Copperridge System Interface
 * 
 * Copyright (c) 2007, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich.
 *  Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED: DO NOT EDIT!
 */

#ifndef __crb_sif_H
#define __crb_sif_H

#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR
#define __DN(x) crb_sif ## _ ## x
#ifdef crb_sif_PREFIX
#define __DP(x) __DP1(x,crb_sif_PREFIX)
#define __DP1(x1,x2) __DP2(x1,x2)
#define __DP2(x1,x2) x2 ## x1
#else
#define __DP(x) crb_sif##_ ##x
#endif
#define __STR(x) #x
#define __XTR(x) __STR(x)

/*
 * Register type: Implicit type of Device Control Status register
 */

/*
 * Dump of fields for register type: crb_sif_dcsr1_t
 *   _anon0 (size 8, offset 0):	 RSVD	  _
 *   buildversion (size 8, offset 8):	 RO	  Build version
 *   datapathwidth (size 8, offset 16):	 RO	  Data path width
 *   fpgafamily (size 8, offset 24):	 RO	  FPGA Family
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct crb_sif_dcsr1_t {
    uint8_t	_anon0	:8;
    uint8_t	buildversion	:8;
    uint8_t	datapathwidth	:8;
    uint8_t	fpgafamily	:8;
} __attribute__ ((packed))
 crb_sif_dcsr1_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(crb_sif_dcsr1_t, sizeof(uint32_t));

typedef union crb_sif_dcsr1_un {
    crb_sif_dcsr1_t	val;
    uint32_t	raw;
}
 crb_sif_dcsr1_un;
static inline int crb_sif_dcsr1_prtval( char * s, size_t sz, crb_sif_dcsr1_t v ) __attribute__ ((always_inline));
static inline int crb_sif_dcsr1_prtval( char * s, size_t sz, crb_sif_dcsr1_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " buildversion=0x%"PRIx8" (Build version)\n", (uint8_t)(v.buildversion));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " datapathwidth=0x%"PRIx8" (Data path width)\n", (uint8_t)(v.datapathwidth));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fpgafamily=0x%"PRIx8" (FPGA Family)\n", (uint8_t)(v.fpgafamily));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Device Link Width Status register
 */

/*
 * Dump of fields for register type: crb_sif_dlwstat_t
 *   capmaxwidth (size 6, offset 0):	 RO	  cap. max width
 *   _anon6 (size 2, offset 6):	 RSVD	  _
 *   negmaxwidth (size 6, offset 8):	 RO	  neg. max width
 *   _anon14 (size 18, offset 14):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct crb_sif_dlwstat_t {
    uint8_t	capmaxwidth	:6;
    uint8_t	_anon6	:2;
    uint8_t	negmaxwidth	:6;
    uint32_t	_anon14	:18;
} __attribute__ ((packed))
 crb_sif_dlwstat_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(crb_sif_dlwstat_t, sizeof(uint32_t));

typedef union crb_sif_dlwstat_un {
    crb_sif_dlwstat_t	val;
    uint32_t	raw;
}
 crb_sif_dlwstat_un;
static inline int crb_sif_dlwstat_prtval( char * s, size_t sz, crb_sif_dlwstat_t v ) __attribute__ ((always_inline));
static inline int crb_sif_dlwstat_prtval( char * s, size_t sz, crb_sif_dlwstat_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " capmaxwidth=0x%"PRIx8" (cap. max width)\n", (uint8_t)(v.capmaxwidth));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " negmaxwidth=0x%"PRIx8" (neg. max width)\n", (uint8_t)(v.negmaxwidth));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Device Link Transaction Size Status register
 */

/*
 * Dump of fields for register type: crb_sif_dltrsstat_t
 *   capmaxsize (size 3, offset 0):	 RO	  cap. max size
 *   _anon3 (size 5, offset 3):	 RSVD	  _
 *   progmaxsize (size 3, offset 8):	 RO	  prog. max size
 *   _anon11 (size 5, offset 11):	 RSVD	  _
 *   maxrdreqsize (size 3, offset 16):	 RO	  max. rd req size
 *   _anon19 (size 13, offset 19):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct crb_sif_dltrsstat_t {
    uint8_t	capmaxsize	:3;
    uint8_t	_anon3	:5;
    uint8_t	progmaxsize	:3;
    uint8_t	_anon11	:5;
    uint8_t	maxrdreqsize	:3;
    uint16_t	_anon19	:13;
} __attribute__ ((packed))
 crb_sif_dltrsstat_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(crb_sif_dltrsstat_t, sizeof(uint32_t));

typedef union crb_sif_dltrsstat_un {
    crb_sif_dltrsstat_t	val;
    uint32_t	raw;
}
 crb_sif_dltrsstat_un;
static inline int crb_sif_dltrsstat_prtval( char * s, size_t sz, crb_sif_dltrsstat_t v ) __attribute__ ((always_inline));
static inline int crb_sif_dltrsstat_prtval( char * s, size_t sz, crb_sif_dltrsstat_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " capmaxsize=0x%"PRIx8" (cap. max size)\n", (uint8_t)(v.capmaxsize));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " progmaxsize=0x%"PRIx8" (prog. max size)\n", (uint8_t)(v.progmaxsize));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " maxrdreqsize=0x%"PRIx8" (max. rd req size)\n", (uint8_t)(v.maxrdreqsize));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of MIP/MOP register
 */

/*
 * Dump of fields for register type: crb_sif_trnct4_t
 *   mopfifolvl (size 15, offset 0):	 RO	  MOP FIFO level
 *   moperror (size 1, offset 15):	 RO	  MOP Error
 *   mipfifolvl (size 15, offset 16):	 RO	  MIP FIFO level
 *   miperror (size 1, offset 31):	 RO	  MIP Error
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct crb_sif_trnct4_t {
    uint16_t	mopfifolvl	:15;
    uint8_t	moperror	:1;
    uint16_t	mipfifolvl	:15;
    uint8_t	miperror	:1;
} __attribute__ ((packed))
 crb_sif_trnct4_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(crb_sif_trnct4_t, sizeof(uint32_t));

typedef union crb_sif_trnct4_un {
    crb_sif_trnct4_t	val;
    uint32_t	raw;
}
 crb_sif_trnct4_un;
static inline int crb_sif_trnct4_prtval( char * s, size_t sz, crb_sif_trnct4_t v ) __attribute__ ((always_inline));
static inline int crb_sif_trnct4_prtval( char * s, size_t sz, crb_sif_trnct4_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mopfifolvl=0x%0"PRIx16" (MOP FIFO level)\n", (uint16_t)(v.mopfifolvl));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " moperror=0x%"PRIx8" (MOP Error)\n", (uint8_t)(v.moperror));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mipfifolvl=0x%0"PRIx16" (MIP FIFO level)\n", (uint16_t)(v.mipfifolvl));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " miperror=0x%"PRIx8" (MIP Error)\n", (uint8_t)(v.miperror));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Init register
 */

/*
 * Dump of fields for register type: crb_sif_trnct5_t
 *   init (size 1, offset 0):	 RO	  Init
 *   trncte (size 1, offset 1):	 RO	  TRNCTE
 *   _anon2 (size 30, offset 2):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct crb_sif_trnct5_t {
    uint8_t	init	:1;
    uint8_t	trncte	:1;
    uint32_t	_anon2	:30;
} __attribute__ ((packed))
 crb_sif_trnct5_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(crb_sif_trnct5_t, sizeof(uint32_t));

typedef union crb_sif_trnct5_un {
    crb_sif_trnct5_t	val;
    uint32_t	raw;
}
 crb_sif_trnct5_un;
static inline int crb_sif_trnct5_prtval( char * s, size_t sz, crb_sif_trnct5_t v ) __attribute__ ((always_inline));
static inline int crb_sif_trnct5_prtval( char * s, size_t sz, crb_sif_trnct5_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " init=0x%"PRIx8" (Init)\n", (uint8_t)(v.init));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " trncte=0x%"PRIx8" (TRNCTE)\n", (uint8_t)(v.trncte));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Config register
 */

/*
 * Dump of fields for register type: crb_sif_config_t
 *   softreset (size 1, offset 0):	 RO	  Soft reset
 *   gen_memcomp (size 1, offset 1):	 RO	  Gen Memcomp
 *   drop_memcomp (size 1, offset 2):	 RO	  Drop Memcomp
 *   rcinitdone (size 1, offset 3):	 RO	  RC init done
 *   _anon4 (size 28, offset 4):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct crb_sif_config_t {
    uint8_t	softreset	:1;
    uint8_t	gen_memcomp	:1;
    uint8_t	drop_memcomp	:1;
    uint8_t	rcinitdone	:1;
    uint32_t	_anon4	:28;
} __attribute__ ((packed))
 crb_sif_config_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(crb_sif_config_t, sizeof(uint32_t));

typedef union crb_sif_config_un {
    crb_sif_config_t	val;
    uint32_t	raw;
}
 crb_sif_config_un;
static inline int crb_sif_config_prtval( char * s, size_t sz, crb_sif_config_t v ) __attribute__ ((always_inline));
static inline int crb_sif_config_prtval( char * s, size_t sz, crb_sif_config_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " softreset=0x%"PRIx8" (Soft reset)\n", (uint8_t)(v.softreset));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " gen_memcomp=0x%"PRIx8" (Gen Memcomp)\n", (uint8_t)(v.gen_memcomp));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " drop_memcomp=0x%"PRIx8" (Drop Memcomp)\n", (uint8_t)(v.drop_memcomp));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rcinitdone=0x%"PRIx8" (RC init done)\n", (uint8_t)(v.rcinitdone));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Debug register
 */

/*
 * Dump of fields for register type: crb_sif_debug_t
 *   mipdisablerd (size 1, offset 0):	 RO	  MIP disable RD
 *   scemiloopback (size 1, offset 1):	 RO	  SCEMI loopback
 *   miprdtrig (size 1, offset 2):	 RO	  MIP rd trig
 *   _anon3 (size 29, offset 3):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct crb_sif_debug_t {
    uint8_t	mipdisablerd	:1;
    uint8_t	scemiloopback	:1;
    uint8_t	miprdtrig	:1;
    uint32_t	_anon3	:29;
} __attribute__ ((packed))
 crb_sif_debug_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(crb_sif_debug_t, sizeof(uint32_t));

typedef union crb_sif_debug_un {
    crb_sif_debug_t	val;
    uint32_t	raw;
}
 crb_sif_debug_un;
static inline int crb_sif_debug_prtval( char * s, size_t sz, crb_sif_debug_t v ) __attribute__ ((always_inline));
static inline int crb_sif_debug_prtval( char * s, size_t sz, crb_sif_debug_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mipdisablerd=0x%"PRIx8" (MIP disable RD)\n", (uint8_t)(v.mipdisablerd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " scemiloopback=0x%"PRIx8" (SCEMI loopback)\n", (uint8_t)(v.scemiloopback));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " miprdtrig=0x%"PRIx8" (MIP rd trig)\n", (uint8_t)(v.miprdtrig));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Device representation structure
 */
typedef struct __DN(t) {
    // Device arguments
    mackerel_addr_t	base;
    // Shadow registers
}
 __DN(t);

/*
 * Device Initialization function
 */
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_addr_t base ) __attribute__ ((always_inline));
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_addr_t base )
{
    /* Setting up device arguments*/
    _dev->base = base;
    /* Setting up shadow registers*/
}

// No user-defined spaces

/*
 * Register dcsr1 (Device Control Status); type crb_sif.dcsr1 (Implicit type of Device Control Status register)
 */

/*
 * Dump of fields for register: dcsr1
 *   _anon0 (size 8, offset 0):	 RSVD	  _
 *   buildversion (size 8, offset 8):	 RO	  Build version
 *   datapathwidth (size 8, offset 16):	 RO	  Data path width
 *   fpgafamily (size 8, offset 24):	 RO	  FPGA Family
 */

static inline uint32_t __DP(dcsr1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(dcsr1_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x0));
}

static inline crb_sif_dcsr1_t __DP(dcsr1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline crb_sif_dcsr1_t __DP(dcsr1_rd)( __DN(t) * _dev )
{
    crb_sif_dcsr1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    return u.val;
}

// Register dcsr1 is not writeable


static inline int __DP(dcsr1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(dcsr1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    crb_sif_dcsr1_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x0));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register dcsr1 (Device Control Status):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.buildversion;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " buildversion =\t0x%"PRIx8" (Build version", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.datapathwidth;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " datapathwidth =\t0x%"PRIx8" (Data path width", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fpgafamily;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fpgafamily =\t0x%"PRIx8" (FPGA Family", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register ddmacr (Device DMA Control Status); type crb_sif.uint32
 */

static inline uint32_t __DP(ddmacr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ddmacr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4));
}

static inline uint32_t __DP(ddmacr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ddmacr_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x4));
}

// Register ddmacr is not writeable


static inline int __DP(ddmacr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ddmacr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ddmacr (Device DMA Control Status):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x4)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register wdmatlpa (Write DMA TLP Address); type crb_sif.uint32
 */

static inline uint32_t __DP(wdmatlpa_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(wdmatlpa_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x8));
}

static inline uint32_t __DP(wdmatlpa_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(wdmatlpa_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x8));
}

// Register wdmatlpa is not writeable


static inline int __DP(wdmatlpa_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(wdmatlpa_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register wdmatlpa (Write DMA TLP Address):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x8)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register wdmatlps (Write DMA TLP Size); type crb_sif.uint32
 */

static inline uint32_t __DP(wdmatlps_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(wdmatlps_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0xc));
}

static inline uint32_t __DP(wdmatlps_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(wdmatlps_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0xc));
}

// Register wdmatlps is not writeable


static inline int __DP(wdmatlps_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(wdmatlps_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register wdmatlps (Write DMA TLP Size):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0xc)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register wdmatlpc (Write DMA TLP Count); type crb_sif.uint32
 */

static inline uint32_t __DP(wdmatlpc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(wdmatlpc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x10));
}

static inline uint32_t __DP(wdmatlpc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(wdmatlpc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x10));
}

// Register wdmatlpc is not writeable


static inline int __DP(wdmatlpc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(wdmatlpc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register wdmatlpc (Write DMA TLP Count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x10)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register wdmatlpp (Write DMA TLP Data Pattern); type crb_sif.uint32
 */

static inline uint32_t __DP(wdmatlpp_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(wdmatlpp_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x14));
}

static inline uint32_t __DP(wdmatlpp_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(wdmatlpp_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x14));
}

// Register wdmatlpp is not writeable


static inline int __DP(wdmatlpp_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(wdmatlpp_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register wdmatlpp (Write DMA TLP Data Pattern):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x14)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rdmatlpp (Read DMA TLP Expected Pattern); type crb_sif.uint32
 */

static inline uint32_t __DP(rdmatlpp_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdmatlpp_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x18));
}

static inline uint32_t __DP(rdmatlpp_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdmatlpp_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x18));
}

// Register rdmatlpp is not writeable


static inline int __DP(rdmatlpp_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rdmatlpp_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rdmatlpp (Read DMA TLP Expected Pattern):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x18)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rdmatlpa (Read DMA TLP Address); type crb_sif.uint32
 */

static inline uint32_t __DP(rdmatlpa_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdmatlpa_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x1c));
}

static inline uint32_t __DP(rdmatlpa_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdmatlpa_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x1c));
}

// Register rdmatlpa is not writeable


static inline int __DP(rdmatlpa_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rdmatlpa_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rdmatlpa (Read DMA TLP Address):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x1c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rdmatlps (Read DMA TLP Size); type crb_sif.uint32
 */

static inline uint32_t __DP(rdmatlps_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdmatlps_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x20));
}

static inline uint32_t __DP(rdmatlps_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdmatlps_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x20));
}

// Register rdmatlps is not writeable


static inline int __DP(rdmatlps_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rdmatlps_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rdmatlps (Read DMA TLP Size):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x20)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rdmatlpc (Read DMA TLP Count); type crb_sif.uint32
 */

static inline uint32_t __DP(rdmatlpc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdmatlpc_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x24));
}

static inline uint32_t __DP(rdmatlpc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdmatlpc_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x24));
}

// Register rdmatlpc is not writeable


static inline int __DP(rdmatlpc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rdmatlpc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rdmatlpc (Read DMA TLP Count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x24)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register wdmaperf (Write DMA Performance); type crb_sif.uint32
 */

static inline uint32_t __DP(wdmaperf_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(wdmaperf_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x28));
}

static inline uint32_t __DP(wdmaperf_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(wdmaperf_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x28));
}

// Register wdmaperf is not writeable


static inline int __DP(wdmaperf_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(wdmaperf_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register wdmaperf (Write DMA Performance):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x28)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rdmaperf (Read DMA Performance); type crb_sif.uint32
 */

static inline uint32_t __DP(rdmaperf_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdmaperf_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x2c));
}

static inline uint32_t __DP(rdmaperf_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdmaperf_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x2c));
}

// Register rdmaperf is not writeable


static inline int __DP(rdmaperf_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rdmaperf_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rdmaperf (Read DMA Performance):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x2c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rdmastat (Read DMA Status); type crb_sif.uint32
 */

static inline uint32_t __DP(rdmastat_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdmastat_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x30));
}

static inline uint32_t __DP(rdmastat_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rdmastat_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x30));
}

// Register rdmastat is not writeable


static inline int __DP(rdmastat_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rdmastat_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rdmastat (Read DMA Status):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x30)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register nrdcomp (Number of Rad Completion w/ data); type crb_sif.uint32
 */

static inline uint32_t __DP(nrdcomp_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(nrdcomp_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x34));
}

static inline uint32_t __DP(nrdcomp_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(nrdcomp_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x34));
}

// Register nrdcomp is not writeable


static inline int __DP(nrdcomp_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(nrdcomp_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register nrdcomp (Number of Rad Completion w/ data):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x34)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rcompdsizw (Read Completion Data Size); type crb_sif.uint32
 */

static inline uint32_t __DP(rcompdsizw_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rcompdsizw_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x38));
}

static inline uint32_t __DP(rcompdsizw_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rcompdsizw_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x38));
}

// Register rcompdsizw is not writeable


static inline int __DP(rcompdsizw_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rcompdsizw_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rcompdsizw (Read Completion Data Size):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x38)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register dlwstat (Device Link Width Status); type crb_sif.dlwstat (Implicit type of Device Link Width Status register)
 */

/*
 * Dump of fields for register: dlwstat
 *   capmaxwidth (size 6, offset 0):	 RO	  cap. max width
 *   _anon6 (size 2, offset 6):	 RSVD	  _
 *   negmaxwidth (size 6, offset 8):	 RO	  neg. max width
 *   _anon14 (size 18, offset 14):	 RSVD	  _
 */

static inline uint32_t __DP(dlwstat_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(dlwstat_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x3c));
}

static inline crb_sif_dlwstat_t __DP(dlwstat_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline crb_sif_dlwstat_t __DP(dlwstat_rd)( __DN(t) * _dev )
{
    crb_sif_dlwstat_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3c));
    return u.val;
}

// Register dlwstat is not writeable


static inline int __DP(dlwstat_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(dlwstat_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    crb_sif_dlwstat_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x3c));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register dlwstat (Device Link Width Status):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.capmaxwidth;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " capmaxwidth =\t0x%"PRIx8" (cap. max width", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.negmaxwidth;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " negmaxwidth =\t0x%"PRIx8" (neg. max width", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register dltrsstat (Device Link Transaction Size Status); type crb_sif.dltrsstat (Implicit type of Device Link Transaction Size Status register)
 */

/*
 * Dump of fields for register: dltrsstat
 *   capmaxsize (size 3, offset 0):	 RO	  cap. max size
 *   _anon3 (size 5, offset 3):	 RSVD	  _
 *   progmaxsize (size 3, offset 8):	 RO	  prog. max size
 *   _anon11 (size 5, offset 11):	 RSVD	  _
 *   maxrdreqsize (size 3, offset 16):	 RO	  max. rd req size
 *   _anon19 (size 13, offset 19):	 RSVD	  _
 */

static inline uint32_t __DP(dltrsstat_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(dltrsstat_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x40));
}

static inline crb_sif_dltrsstat_t __DP(dltrsstat_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline crb_sif_dltrsstat_t __DP(dltrsstat_rd)( __DN(t) * _dev )
{
    crb_sif_dltrsstat_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x40));
    return u.val;
}

// Register dltrsstat is not writeable


static inline int __DP(dltrsstat_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(dltrsstat_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    crb_sif_dltrsstat_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x40));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register dltrsstat (Device Link Transaction Size Status):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.capmaxsize;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " capmaxsize =\t0x%"PRIx8" (cap. max size", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.progmaxsize;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " progmaxsize =\t0x%"PRIx8" (prog. max size", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.maxrdreqsize;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " maxrdreqsize =\t0x%"PRIx8" (max. rd req size", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register dmisccont (Device Miscellaneous Control); type crb_sif.uint32
 */

static inline uint32_t __DP(dmisccont_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(dmisccont_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x44));
}

static inline uint32_t __DP(dmisccont_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(dmisccont_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x44));
}

// Register dmisccont is not writeable


static inline int __DP(dmisccont_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(dmisccont_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register dmisccont (Device Miscellaneous Control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x44)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register id0 (BitSID); type crb_sif.uint32
 */

static inline uint32_t __DP(id0_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(id0_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x300));
}

static inline uint32_t __DP(id0_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(id0_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x300));
}

// Register id0 is not writeable


static inline int __DP(id0_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(id0_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register id0 (BitSID):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x300)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register id1 (GRBTest); type crb_sif.uint32
 */

static inline uint32_t __DP(id1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(id1_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x304));
}

static inline uint32_t __DP(id1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(id1_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x304));
}

static inline void __DP(id1_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(id1_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x304),val);
}

static inline void __DP(id1_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(id1_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x304),val);
}


static inline int __DP(id1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(id1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register id1 (GRBTest):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x304)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register id2 (GRBTest); type crb_sif.uint32
 */

static inline uint32_t __DP(id2_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(id2_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x308));
}

static inline uint32_t __DP(id2_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(id2_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x308));
}

static inline void __DP(id2_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(id2_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x308),val);
}

static inline void __DP(id2_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(id2_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x308),val);
}


static inline int __DP(id2_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(id2_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register id2 (GRBTest):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x308)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register trnct0 (BAR Win 0); type crb_sif.uint32
 */

static inline uint32_t __DP(trnct0_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(trnct0_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x30c));
}

static inline uint32_t __DP(trnct0_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(trnct0_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x30c));
}

// Register trnct0 is not writeable


static inline int __DP(trnct0_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(trnct0_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register trnct0 (BAR Win 0):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x30c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register trnct1 (BAR Win 1); type crb_sif.uint32
 */

static inline uint32_t __DP(trnct1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(trnct1_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x310));
}

static inline uint32_t __DP(trnct1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(trnct1_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x310));
}

// Register trnct1 is not writeable


static inline int __DP(trnct1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(trnct1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register trnct1 (BAR Win 1):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x310)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register trnct2 (BAR Win 2); type crb_sif.uint32
 */

static inline uint32_t __DP(trnct2_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(trnct2_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x314));
}

static inline uint32_t __DP(trnct2_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(trnct2_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x314));
}

// Register trnct2 is not writeable


static inline int __DP(trnct2_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(trnct2_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register trnct2 (BAR Win 2):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x314)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register trnct3 (BAR Win 3); type crb_sif.uint32
 */

static inline uint32_t __DP(trnct3_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(trnct3_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x318));
}

static inline uint32_t __DP(trnct3_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(trnct3_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x318));
}

// Register trnct3 is not writeable


static inline int __DP(trnct3_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(trnct3_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register trnct3 (BAR Win 3):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x318)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register trnct4 (MIP/MOP); type crb_sif.trnct4 (Implicit type of MIP/MOP register)
 */

/*
 * Dump of fields for register: trnct4
 *   mopfifolvl (size 15, offset 0):	 RO	  MOP FIFO level
 *   moperror (size 1, offset 15):	 RO	  MOP Error
 *   mipfifolvl (size 15, offset 16):	 RO	  MIP FIFO level
 *   miperror (size 1, offset 31):	 RO	  MIP Error
 */

static inline uint32_t __DP(trnct4_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(trnct4_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x31c));
}

static inline crb_sif_trnct4_t __DP(trnct4_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline crb_sif_trnct4_t __DP(trnct4_rd)( __DN(t) * _dev )
{
    crb_sif_trnct4_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x31c));
    return u.val;
}

// Register trnct4 is not writeable


static inline int __DP(trnct4_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(trnct4_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    crb_sif_trnct4_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x31c));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register trnct4 (MIP/MOP):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.mopfifolvl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mopfifolvl =\t0x%0"PRIx16" (MOP FIFO level", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.moperror;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " moperror =\t0x%"PRIx8" (MOP Error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.mipfifolvl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mipfifolvl =\t0x%0"PRIx16" (MIP FIFO level", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.miperror;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " miperror =\t0x%"PRIx8" (MIP Error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register trnct5 (Init); type crb_sif.trnct5 (Implicit type of Init register)
 */

/*
 * Dump of fields for register: trnct5
 *   init (size 1, offset 0):	 RO	  Init
 *   trncte (size 1, offset 1):	 RO	  TRNCTE
 *   _anon2 (size 30, offset 2):	 RSVD	  _
 */

static inline uint32_t __DP(trnct5_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(trnct5_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x320));
}

static inline crb_sif_trnct5_t __DP(trnct5_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline crb_sif_trnct5_t __DP(trnct5_rd)( __DN(t) * _dev )
{
    crb_sif_trnct5_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x320));
    return u.val;
}

// Register trnct5 is not writeable


static inline int __DP(trnct5_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(trnct5_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    crb_sif_trnct5_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x320));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register trnct5 (Init):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.init;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " init =\t0x%"PRIx8" (Init", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.trncte;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " trncte =\t0x%"PRIx8" (TRNCTE", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register config (Config); type crb_sif.config (Implicit type of Config register)
 */

/*
 * Dump of fields for register: config
 *   softreset (size 1, offset 0):	 RO	  Soft reset
 *   gen_memcomp (size 1, offset 1):	 RO	  Gen Memcomp
 *   drop_memcomp (size 1, offset 2):	 RO	  Drop Memcomp
 *   rcinitdone (size 1, offset 3):	 RO	  RC init done
 *   _anon4 (size 28, offset 4):	 RSVD	  _
 */

static inline uint32_t __DP(config_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(config_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x324));
}

static inline crb_sif_config_t __DP(config_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline crb_sif_config_t __DP(config_rd)( __DN(t) * _dev )
{
    crb_sif_config_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x324));
    return u.val;
}

// Register config is not writeable


static inline int __DP(config_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(config_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    crb_sif_config_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x324));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register config (Config):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.softreset;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " softreset =\t0x%"PRIx8" (Soft reset", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.gen_memcomp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " gen_memcomp =\t0x%"PRIx8" (Gen Memcomp", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.drop_memcomp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " drop_memcomp =\t0x%"PRIx8" (Drop Memcomp", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rcinitdone;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rcinitdone =\t0x%"PRIx8" (RC init done", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register debug (Debug); type crb_sif.debug (Implicit type of Debug register)
 */

/*
 * Dump of fields for register: debug
 *   mipdisablerd (size 1, offset 0):	 RO	  MIP disable RD
 *   scemiloopback (size 1, offset 1):	 RO	  SCEMI loopback
 *   miprdtrig (size 1, offset 2):	 RO	  MIP rd trig
 *   _anon3 (size 29, offset 3):	 RSVD	  _
 */

static inline uint32_t __DP(debug_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(debug_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x328));
}

static inline crb_sif_debug_t __DP(debug_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline crb_sif_debug_t __DP(debug_rd)( __DN(t) * _dev )
{
    crb_sif_debug_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x328));
    return u.val;
}

// Register debug is not writeable


static inline int __DP(debug_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(debug_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    crb_sif_debug_un  u;
    u.raw = mackerel_read_addr_32(_dev->base,(0x328));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register debug (Debug):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.mipdisablerd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mipdisablerd =\t0x%"PRIx8" (MIP disable RD", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.scemiloopback;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " scemiloopback =\t0x%"PRIx8" (SCEMI loopback", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.miprdtrig;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " miprdtrig =\t0x%"PRIx8" (MIP rd trig", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register scemidata0 (scemidata0); type crb_sif.uint32
 */

static inline uint32_t __DP(scemidata0_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(scemidata0_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x32c));
}

static inline uint32_t __DP(scemidata0_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(scemidata0_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x32c));
}

// Register scemidata0 is not writeable


static inline int __DP(scemidata0_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(scemidata0_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register scemidata0 (scemidata0):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x32c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register scemidata1 (scemidata1); type crb_sif.uint32
 */

static inline uint32_t __DP(scemidata1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(scemidata1_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x330));
}

static inline uint32_t __DP(scemidata1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(scemidata1_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x330));
}

// Register scemidata1 is not writeable


static inline int __DP(scemidata1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(scemidata1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register scemidata1 (scemidata1):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x330)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Dump of device crb_sif (RockCreek Copperridge System Interface):\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(dcsr1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ddmacr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(wdmatlpa_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(wdmatlps_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(wdmatlpc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(wdmatlpp_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rdmatlpp_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rdmatlpa_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rdmatlps_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rdmatlpc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(wdmaperf_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rdmaperf_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rdmastat_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(nrdcomp_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rcompdsizw_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(dlwstat_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(dltrsstat_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(dmisccont_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(id0_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(id1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(id2_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(trnct0_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(trnct1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(trnct2_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(trnct3_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(trnct4_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(trnct5_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(config_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(debug_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(scemidata0_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(scemidata1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "End of dump of device crb_sif\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR


#endif // __crb_sif_H
