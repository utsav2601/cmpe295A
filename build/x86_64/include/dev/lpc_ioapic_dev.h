/*
 * DEVICE DEFINITION: LPC IHC I/O APIC function
 * 
 * Copyright (c) 2007, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich.
 *  Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED: DO NOT EDIT!
 */

#ifndef __lpc_ioapic_H
#define __lpc_ioapic_H

#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR
#define __DN(x) lpc_ioapic ## _ ## x
#ifdef lpc_ioapic_PREFIX
#define __DP(x) __DP1(x,lpc_ioapic_PREFIX)
#define __DP1(x1,x2) __DP2(x1,x2)
#define __DP2(x1,x2) x2 ## x1
#else
#define __DP(x) lpc_ioapic##_ ##x
#endif
#define __STR(x) #x
#define __XTR(x) __STR(x)

/*
 * Constant definition: lpc_ioapic.delivery_mode (Delivery Mode)
 */
typedef enum lpc_ioapic_delivery_mode_t {
    __DP(fixed) = (0x0),
    __DP(lowest) = (0x1),
    __DP(smi) = (0x2),
    __DP(nmi) = (0x4),
    __DP(init) = (0x5),
    __DP(extint) = (0x7),
} lpc_ioapic_delivery_mode_t;

static inline int lpc_ioapic_delivery_mode_prt( char * s, size_t sz, lpc_ioapic_delivery_mode_t e ) __attribute__ ((always_inline));
static inline int lpc_ioapic_delivery_mode_prt( char * s, size_t sz, lpc_ioapic_delivery_mode_t e )
{
    switch (e) {
        case __DP(fixed):
        return snprintf(s, sz, "%s", "Fixed");
        case __DP(lowest):
        return snprintf(s, sz, "%s", "Lowest Priority");
        case __DP(smi):
        return snprintf(s, sz, "%s", "SMI (System Management Interrupt)");
        case __DP(nmi):
        return snprintf(s, sz, "%s", "NMI (Non-maskable Interrupt)");
        case __DP(init):
        return snprintf(s, sz, "%s", "INIT");
        case __DP(extint):
        return snprintf(s, sz, "%s", "ExtINT");
        default:
        return snprintf(s, sz, "Unknown " __XTR(lpc_ioapic_delivery_mode_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int lpc_ioapic_delivery_mode_chk( lpc_ioapic_delivery_mode_t e ) __attribute__ ((always_inline));
static inline int lpc_ioapic_delivery_mode_chk( lpc_ioapic_delivery_mode_t e )
{
    switch (e) {
        case __DP(fixed):
        return 1;
        case __DP(lowest):
        return 1;
        case __DP(smi):
        return 1;
        case __DP(nmi):
        return 1;
        case __DP(init):
        return 1;
        case __DP(extint):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: lpc_ioapic.dest_mode (Destination Mode)
 */
typedef enum lpc_ioapic_dest_mode_t {
    __DP(physical) = (0x0),
    __DP(logical) = (0x1),
} lpc_ioapic_dest_mode_t;

static inline int lpc_ioapic_dest_mode_prt( char * s, size_t sz, lpc_ioapic_dest_mode_t e ) __attribute__ ((always_inline));
static inline int lpc_ioapic_dest_mode_prt( char * s, size_t sz, lpc_ioapic_dest_mode_t e )
{
    switch (e) {
        case __DP(physical):
        return snprintf(s, sz, "%s", "Physical");
        case __DP(logical):
        return snprintf(s, sz, "%s", "Logical");
        default:
        return snprintf(s, sz, "Unknown " __XTR(lpc_ioapic_dest_mode_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int lpc_ioapic_dest_mode_chk( lpc_ioapic_dest_mode_t e ) __attribute__ ((always_inline));
static inline int lpc_ioapic_dest_mode_chk( lpc_ioapic_dest_mode_t e )
{
    switch (e) {
        case __DP(physical):
        return 1;
        case __DP(logical):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: lpc_ioapic.delivery_status (Delivery Status)
 */
typedef enum lpc_ioapic_delivery_status_t {
    __DP(idle) = (0x0),
    __DP(pending) = (0x1),
} lpc_ioapic_delivery_status_t;

static inline int lpc_ioapic_delivery_status_prt( char * s, size_t sz, lpc_ioapic_delivery_status_t e ) __attribute__ ((always_inline));
static inline int lpc_ioapic_delivery_status_prt( char * s, size_t sz, lpc_ioapic_delivery_status_t e )
{
    switch (e) {
        case __DP(idle):
        return snprintf(s, sz, "%s", "Idle");
        case __DP(pending):
        return snprintf(s, sz, "%s", "Pending");
        default:
        return snprintf(s, sz, "Unknown " __XTR(lpc_ioapic_delivery_status_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int lpc_ioapic_delivery_status_chk( lpc_ioapic_delivery_status_t e ) __attribute__ ((always_inline));
static inline int lpc_ioapic_delivery_status_chk( lpc_ioapic_delivery_status_t e )
{
    switch (e) {
        case __DP(idle):
        return 1;
        case __DP(pending):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: lpc_ioapic.polarity (Interrupt Input Pin Polarity)
 */
typedef enum lpc_ioapic_polarity_t {
    __DP(active_high) = (0x0),
    __DP(active_low) = (0x1),
} lpc_ioapic_polarity_t;

static inline int lpc_ioapic_polarity_prt( char * s, size_t sz, lpc_ioapic_polarity_t e ) __attribute__ ((always_inline));
static inline int lpc_ioapic_polarity_prt( char * s, size_t sz, lpc_ioapic_polarity_t e )
{
    switch (e) {
        case __DP(active_high):
        return snprintf(s, sz, "%s", "Active high");
        case __DP(active_low):
        return snprintf(s, sz, "%s", "Active low");
        default:
        return snprintf(s, sz, "Unknown " __XTR(lpc_ioapic_polarity_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int lpc_ioapic_polarity_chk( lpc_ioapic_polarity_t e ) __attribute__ ((always_inline));
static inline int lpc_ioapic_polarity_chk( lpc_ioapic_polarity_t e )
{
    switch (e) {
        case __DP(active_high):
        return 1;
        case __DP(active_low):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: lpc_ioapic.trigger_mode (Trigger Mode)
 */
typedef enum lpc_ioapic_trigger_mode_t {
    __DP(edge) = (0x0),
    __DP(level) = (0x1),
} lpc_ioapic_trigger_mode_t;

static inline int lpc_ioapic_trigger_mode_prt( char * s, size_t sz, lpc_ioapic_trigger_mode_t e ) __attribute__ ((always_inline));
static inline int lpc_ioapic_trigger_mode_prt( char * s, size_t sz, lpc_ioapic_trigger_mode_t e )
{
    switch (e) {
        case __DP(edge):
        return snprintf(s, sz, "%s", "Edge Triggered");
        case __DP(level):
        return snprintf(s, sz, "%s", "Level Triggered");
        default:
        return snprintf(s, sz, "Unknown " __XTR(lpc_ioapic_trigger_mode_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int lpc_ioapic_trigger_mode_chk( lpc_ioapic_trigger_mode_t e ) __attribute__ ((always_inline));
static inline int lpc_ioapic_trigger_mode_chk( lpc_ioapic_trigger_mode_t e )
{
    switch (e) {
        case __DP(edge):
        return 1;
        case __DP(level):
        return 1;
        default:
        return 0;
    }
}


/*
 * Register type: Implicit type of EOI register
 */

/*
 * Dump of fields for register type: lpc_ioapic_eoir_t
 *   rec (size 8, offset 0):	 WO	  Redirection Entry Clear
 *   _anon8 (size 24, offset 8):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct lpc_ioapic_eoir_t {
    uint8_t	rec	:8;
    uint32_t	_anon8	:24;
} __attribute__ ((packed))
 lpc_ioapic_eoir_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(lpc_ioapic_eoir_t, sizeof(uint32_t));

typedef union lpc_ioapic_eoir_un {
    lpc_ioapic_eoir_t	val;
    uint32_t	raw;
}
 lpc_ioapic_eoir_un;
static inline int lpc_ioapic_eoir_prtval( char * s, size_t sz, lpc_ioapic_eoir_t v ) __attribute__ ((always_inline));
static inline int lpc_ioapic_eoir_prtval( char * s, size_t sz, lpc_ioapic_eoir_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rec=0x%"PRIx8" (Redirection Entry Clear)\n", (uint8_t)(v.rec));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Identification register
 */

/*
 * Dump of fields for register type: lpc_ioapic_id_t
 *   _anon0 (size 15, offset 0):	 RSVD	  _
 *   spb (size 1, offset 15):	 RW	  Scratchpad bit
 *   _anon16 (size 8, offset 16):	 RSVD	  _
 *   id (size 4, offset 24):	 RW	  APIC ID
 *   _anon28 (size 4, offset 28):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct lpc_ioapic_id_t {
    uint16_t	_anon0	:15;
    uint8_t	spb	:1;
    uint8_t	_anon16	:8;
    uint8_t	id	:4;
    uint8_t	_anon28	:4;
} __attribute__ ((packed))
 lpc_ioapic_id_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(lpc_ioapic_id_t, sizeof(uint32_t));

typedef union lpc_ioapic_id_un {
    lpc_ioapic_id_t	val;
    uint32_t	raw;
}
 lpc_ioapic_id_un;
static inline int lpc_ioapic_id_prtval( char * s, size_t sz, lpc_ioapic_id_t v ) __attribute__ ((always_inline));
static inline int lpc_ioapic_id_prtval( char * s, size_t sz, lpc_ioapic_id_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " spb=0x%"PRIx8" (Scratchpad bit)\n", (uint8_t)(v.spb));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " id=0x%"PRIx8" (APIC ID)\n", (uint8_t)(v.id));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Version register
 */

/*
 * Dump of fields for register type: lpc_ioapic_ver_t
 *   ver (size 8, offset 0):	 RO	  Version
 *   _anon8 (size 7, offset 8):	 RSVD	  _
 *   prq (size 1, offset 15):	 RO	  Pin assertion register non-support
 *   mre (size 8, offset 16):	 RO	  Maximum redirection entries
 *   _anon24 (size 8, offset 24):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct lpc_ioapic_ver_t {
    uint8_t	ver	:8;
    uint8_t	_anon8	:7;
    uint8_t	prq	:1;
    uint8_t	mre	:8;
    uint8_t	_anon24	:8;
} __attribute__ ((packed))
 lpc_ioapic_ver_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(lpc_ioapic_ver_t, sizeof(uint32_t));

typedef union lpc_ioapic_ver_un {
    lpc_ioapic_ver_t	val;
    uint32_t	raw;
}
 lpc_ioapic_ver_un;
static inline int lpc_ioapic_ver_prtval( char * s, size_t sz, lpc_ioapic_ver_t v ) __attribute__ ((always_inline));
static inline int lpc_ioapic_ver_prtval( char * s, size_t sz, lpc_ioapic_ver_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ver=0x%"PRIx8" (Version)\n", (uint8_t)(v.ver));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " prq=0x%"PRIx8" (Pin assertion register non-support)\n", (uint8_t)(v.prq));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mre=0x%"PRIx8" (Maximum redirection entries)\n", (uint8_t)(v.mre));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Arbitration register
 */

/*
 * Dump of fields for register type: lpc_ioapic_arb_t
 *   _anon0 (size 24, offset 0):	 RSVD	  _
 *   id (size 4, offset 24):	 RO	  IOAPIC Arbitration ID
 *   _anon28 (size 4, offset 28):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct lpc_ioapic_arb_t {
    uint32_t	_anon0	:24;
    uint8_t	id	:4;
    uint8_t	_anon28	:4;
} __attribute__ ((packed))
 lpc_ioapic_arb_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(lpc_ioapic_arb_t, sizeof(uint32_t));

typedef union lpc_ioapic_arb_un {
    lpc_ioapic_arb_t	val;
    uint32_t	raw;
}
 lpc_ioapic_arb_un;
static inline int lpc_ioapic_arb_prtval( char * s, size_t sz, lpc_ioapic_arb_t v ) __attribute__ ((always_inline));
static inline int lpc_ioapic_arb_prtval( char * s, size_t sz, lpc_ioapic_arb_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " id=0x%"PRIx8" (IOAPIC Arbitration ID)\n", (uint8_t)(v.id));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Redirection Table
 */

/*
 * Dump of fields for register type: lpc_ioapic_redir_tbl_t
 *   vector (size 8, offset 0):	 NOATTR	  Vector
 *   mode (size 3, offset 8):	 NOATTR	  Delivery mode
 *   destmode (size 1, offset 11):	 NOATTR	  Destination mode
 *   status (size 1, offset 12):	 RO	  Delivery status
 *   polarity (size 1, offset 13):	 NOATTR	  Interrupt input pin polarity
 *   rirr (size 1, offset 14):	 RO	  Remote IRR
 *   trigger (size 1, offset 15):	 NOATTR	  Trigger mode
 *   mask (size 1, offset 16):	 NOATTR	  Mask
 *   _anon17 (size 31, offset 17):	 RSVD	  _
 *   edid (size 8, offset 48):	 RO	  Extended destination ID
 *   dest (size 8, offset 56):	 NOATTR	  Destination
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct lpc_ioapic_redir_tbl_t {
    uint8_t	vector	:8;
    lpc_ioapic_delivery_mode_t	mode	:3;
    lpc_ioapic_dest_mode_t	destmode	:1;
    lpc_ioapic_delivery_status_t	status	:1;
    lpc_ioapic_polarity_t	polarity	:1;
    uint8_t	rirr	:1;
    lpc_ioapic_trigger_mode_t	trigger	:1;
    uint8_t	mask	:1;
    uint32_t	_anon17	:31;
    uint8_t	edid	:8;
    uint8_t	dest	:8;
} __attribute__ ((packed))
 lpc_ioapic_redir_tbl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(lpc_ioapic_redir_tbl_t, sizeof(uint64_t));

typedef union lpc_ioapic_redir_tbl_un {
    lpc_ioapic_redir_tbl_t	val;
    uint64_t	raw;
}
 lpc_ioapic_redir_tbl_un;
static inline int lpc_ioapic_redir_tbl_prtval( char * s, size_t sz, lpc_ioapic_redir_tbl_t v ) __attribute__ ((always_inline));
static inline int lpc_ioapic_redir_tbl_prtval( char * s, size_t sz, lpc_ioapic_redir_tbl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vector=0x%"PRIx8" (Vector)\n", (uint8_t)(v.vector));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " mode=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = lpc_ioapic_delivery_mode_prt(s+r, _avail, v.mode);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Delivery mode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " destmode=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = lpc_ioapic_dest_mode_prt(s+r, _avail, v.destmode);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Destination mode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " status=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = lpc_ioapic_delivery_status_prt(s+r, _avail, v.status);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Delivery status)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " polarity=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = lpc_ioapic_polarity_prt(s+r, _avail, v.polarity);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Interrupt input pin polarity)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rirr=0x%"PRIx8" (Remote IRR)\n", (uint8_t)(v.rirr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " trigger=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = lpc_ioapic_trigger_mode_prt(s+r, _avail, v.trigger);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Trigger mode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mask=0x%"PRIx8" (Mask)\n", (uint8_t)(v.mask));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " edid=0x%"PRIx8" (Extended destination ID)\n", (uint8_t)(v.edid));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dest=0x%"PRIx8" (Destination)\n", (uint8_t)(v.dest));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Device representation structure
 */
typedef struct __DN(t) {
    // Device arguments
    mackerel_addr_t	base;
    // Shadow registers
    lpc_ioapic_eoir_un	eoir_shadow;
}
 __DN(t);

/*
 * Device Initialization function
 */
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_addr_t base ) __attribute__ ((always_inline));
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_addr_t base )
{
    /* Setting up device arguments*/
    _dev->base = base;
    /* Setting up shadow registers*/
    _dev->eoir_shadow.raw = 0x0;
}

// Include access functions for user-defined spaces
#include "lpc_ioapic_spaces.h"

/*
 * Register ind (Index); type lpc_ioapic.uint32
 */

static inline uint32_t __DP(ind_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ind_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x0));
}

static inline uint32_t __DP(ind_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ind_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x0));
}

static inline void __DP(ind_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ind_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x0),val);
}

static inline void __DP(ind_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(ind_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x0),val);
}


static inline int __DP(ind_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ind_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ind (Index):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x0)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register wdw (Window); type lpc_ioapic.uint32
 */

static inline uint32_t __DP(wdw_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(wdw_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x10));
}

static inline uint32_t __DP(wdw_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(wdw_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_32(_dev->base,(0x10));
}

static inline void __DP(wdw_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(wdw_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x10),val);
}

static inline void __DP(wdw_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(wdw_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x10),val);
}


static inline int __DP(wdw_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(wdw_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register wdw (Window):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_addr_32(_dev->base,(0x10)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register eoir (EOI); type lpc_ioapic.eoir (Implicit type of EOI register)
 */

/*
 * Dump of fields for register: eoir
 *   rec (size 8, offset 0):	 WO	  Redirection Entry Clear
 *   _anon8 (size 24, offset 8):	 MBZ	  _
 */

// Register eoir is not readable
static inline lpc_ioapic_eoir_t __DP(eoir_rd_shadow)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline lpc_ioapic_eoir_t __DP(eoir_rd_shadow)( __DN(t) * _dev )
{
    return _dev->eoir_shadow.val;
}

static inline void __DP(eoir_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(eoir_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_addr_32(_dev->base,(0x40),val);
}

static inline void __DP(eoir_wr)( __DN(t) * _dev, lpc_ioapic_eoir_t val ) __attribute__ ((always_inline));
static inline void __DP(eoir_wr)( __DN(t) * _dev, lpc_ioapic_eoir_t val )
{
    lpc_ioapic_eoir_un  u;
    u.val = val;
    u.val._anon8 	= 0;
    mackerel_write_addr_32(_dev->base,(0x40),u.raw);
    _dev->eoir_shadow.val = u.val;
}

static inline void __DP(eoir_rec_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(eoir_rec_wrf)( __DN(t) * _dev, uint8_t val )
{
    lpc_ioapic_eoir_un  u;
    u.val._anon8 	= 0;
    u.val.rec = val;
    mackerel_write_addr_32(_dev->base,(0x40),u.raw);
    _dev->eoir_shadow.val = u.val;
}


static inline int __DP(eoir_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(eoir_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is not readable
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register eoir (EOI):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)_dev->eoir_shadow.val.rec;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rec =\t0x%"PRIx8" (SHADOW of Redirection Entry Clear", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register id (Identification); type lpc_ioapic.id (Implicit type of Identification register)
 */

/*
 * Dump of fields for register: id
 *   _anon0 (size 15, offset 0):	 RSVD	  _
 *   spb (size 1, offset 15):	 RW	  Scratchpad bit
 *   _anon16 (size 8, offset 16):	 RSVD	  _
 *   id (size 4, offset 24):	 RW	  APIC ID
 *   _anon28 (size 4, offset 28):	 RSVD	  _
 */

static inline uint32_t __DP(id_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(id_rd_raw)( __DN(t) * _dev )
{
    return __DP(ioapic_read_32)(_dev, (0x0));
}

static inline lpc_ioapic_id_t __DP(id_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline lpc_ioapic_id_t __DP(id_rd)( __DN(t) * _dev )
{
    lpc_ioapic_id_un  u;
    u.raw = __DP(ioapic_read_32)(_dev, (0x0));
    return u.val;
}

static inline void __DP(id_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(id_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    __DP(ioapic_write_32)(_dev, (0x0),val);
}

static inline void __DP(id_wr)( __DN(t) * _dev, lpc_ioapic_id_t val ) __attribute__ ((always_inline));
static inline void __DP(id_wr)( __DN(t) * _dev, lpc_ioapic_id_t val )
{
    lpc_ioapic_id_un  u;
    u.raw = __DP(ioapic_read_32)(_dev, (0x0));
    u.val.spb 	= val.spb;
    u.val.id 	= val.id;
    __DP(ioapic_write_32)(_dev, (0x0),u.raw);
}

static inline void __DP(id_spb_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(id_spb_wrf)( __DN(t) * _dev, uint8_t val )
{
    lpc_ioapic_id_un  u;
    u.raw = __DP(ioapic_read_32)(_dev, (0x0));
    u.val.spb = val;
    __DP(ioapic_write_32)(_dev, (0x0),u.raw);
}

static inline void __DP(id_id_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(id_id_wrf)( __DN(t) * _dev, uint8_t val )
{
    lpc_ioapic_id_un  u;
    u.raw = __DP(ioapic_read_32)(_dev, (0x0));
    u.val.id = val;
    __DP(ioapic_write_32)(_dev, (0x0),u.raw);
}


static inline int __DP(id_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(id_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    lpc_ioapic_id_un  u;
    u.raw = __DP(ioapic_read_32)(_dev, (0x0));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register id (Identification):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.spb;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " spb =\t0x%"PRIx8" (Scratchpad bit", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.id;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " id =\t0x%"PRIx8" (APIC ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register ver (Version); type lpc_ioapic.ver (Implicit type of Version register)
 */

/*
 * Dump of fields for register: ver
 *   ver (size 8, offset 0):	 RO	  Version
 *   _anon8 (size 7, offset 8):	 RSVD	  _
 *   prq (size 1, offset 15):	 RO	  Pin assertion register non-support
 *   mre (size 8, offset 16):	 RO	  Maximum redirection entries
 *   _anon24 (size 8, offset 24):	 RSVD	  _
 */

static inline uint32_t __DP(ver_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ver_rd_raw)( __DN(t) * _dev )
{
    return __DP(ioapic_read_32)(_dev, (0x1));
}

static inline lpc_ioapic_ver_t __DP(ver_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline lpc_ioapic_ver_t __DP(ver_rd)( __DN(t) * _dev )
{
    lpc_ioapic_ver_un  u;
    u.raw = __DP(ioapic_read_32)(_dev, (0x1));
    return u.val;
}

// Register ver is not writeable


static inline int __DP(ver_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ver_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    lpc_ioapic_ver_un  u;
    u.raw = __DP(ioapic_read_32)(_dev, (0x1));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ver (Version):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.ver;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ver =\t0x%"PRIx8" (Version", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.prq;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " prq =\t0x%"PRIx8" (Pin assertion register non-support", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mre;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mre =\t0x%"PRIx8" (Maximum redirection entries", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register arb (Arbitration); type lpc_ioapic.arb (Implicit type of Arbitration register)
 */

/*
 * Dump of fields for register: arb
 *   _anon0 (size 24, offset 0):	 RSVD	  _
 *   id (size 4, offset 24):	 RO	  IOAPIC Arbitration ID
 *   _anon28 (size 4, offset 28):	 RSVD	  _
 */

static inline uint32_t __DP(arb_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(arb_rd_raw)( __DN(t) * _dev )
{
    return __DP(ioapic_read_32)(_dev, (0x2));
}

static inline lpc_ioapic_arb_t __DP(arb_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline lpc_ioapic_arb_t __DP(arb_rd)( __DN(t) * _dev )
{
    lpc_ioapic_arb_un  u;
    u.raw = __DP(ioapic_read_32)(_dev, (0x2));
    return u.val;
}

// Register arb is not writeable


static inline int __DP(arb_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(arb_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    lpc_ioapic_arb_un  u;
    u.raw = __DP(ioapic_read_32)(_dev, (0x2));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register arb (Arbitration):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.id;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " id =\t0x%"PRIx8" (IOAPIC Arbitration ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register redirtbl (redirtbl); type lpc_ioapic.redir_tbl (Redirection Table)
 */

/*
 * Dump of fields for register: redirtbl
 *   vector (size 8, offset 0):	 RW	  Vector
 *   mode (size 3, offset 8):	 RW	  Delivery mode
 *   destmode (size 1, offset 11):	 RW	  Destination mode
 *   status (size 1, offset 12):	 RO	  Delivery status
 *   polarity (size 1, offset 13):	 RW	  Interrupt input pin polarity
 *   rirr (size 1, offset 14):	 RO	  Remote IRR
 *   trigger (size 1, offset 15):	 RW	  Trigger mode
 *   mask (size 1, offset 16):	 RW	  Mask
 *   _anon17 (size 31, offset 17):	 RSVD	  _
 *   edid (size 8, offset 48):	 RO	  Extended destination ID
 *   dest (size 8, offset 56):	 RW	  Destination
 */
static const int __DP(redirtbl_length) = 0x18;
static inline uint64_t __DP(redirtbl_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint64_t __DP(redirtbl_rd_raw)( __DN(t) * _dev, int _i )
{
    return __DP(ioapic_read_64)(_dev, (0x10) + (_i *(16/8)));
}

static inline lpc_ioapic_redir_tbl_t __DP(redirtbl_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline lpc_ioapic_redir_tbl_t __DP(redirtbl_rd)( __DN(t) * _dev, int _i )
{
    lpc_ioapic_redir_tbl_un  u;
    u.raw = __DP(ioapic_read_64)(_dev, (0x10) + (_i *(16/8)));
    return u.val;
}

static inline void __DP(redirtbl_wr_raw)( __DN(t) * _dev, int _i, uint64_t val ) __attribute__ ((always_inline));
static inline void __DP(redirtbl_wr_raw)( __DN(t) * _dev, int _i, uint64_t val )
{
    __DP(ioapic_write_64)(_dev, (0x10) + (_i *(16/8)),val);
}

static inline void __DP(redirtbl_wr)( __DN(t) * _dev, int _i, lpc_ioapic_redir_tbl_t val ) __attribute__ ((always_inline));
static inline void __DP(redirtbl_wr)( __DN(t) * _dev, int _i, lpc_ioapic_redir_tbl_t val )
{
    lpc_ioapic_redir_tbl_un  u;
    u.raw = __DP(ioapic_read_64)(_dev, (0x10) + (_i *(16/8)));
    u.val.vector 	= val.vector;
    u.val.mode 	= val.mode;
    u.val.destmode 	= val.destmode;
    u.val.status 	= val.status;
    u.val.polarity 	= val.polarity;
    u.val.rirr 	= val.rirr;
    u.val.trigger 	= val.trigger;
    u.val.mask 	= val.mask;
    u.val.edid 	= val.edid;
    u.val.dest 	= val.dest;
    __DP(ioapic_write_64)(_dev, (0x10) + (_i *(16/8)),u.raw);
}

static inline void __DP(redirtbl_vector_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(redirtbl_vector_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    lpc_ioapic_redir_tbl_un  u;
    u.raw = __DP(ioapic_read_64)(_dev, (0x10) + (_i *(16/8)));
    u.val.vector = val;
    __DP(ioapic_write_64)(_dev, (0x10) + (_i *(16/8)),u.raw);
}

static inline void __DP(redirtbl_mode_wrf)( __DN(t) * _dev, int _i, lpc_ioapic_delivery_mode_t val ) __attribute__ ((always_inline));
static inline void __DP(redirtbl_mode_wrf)( __DN(t) * _dev, int _i, lpc_ioapic_delivery_mode_t val )
{
    lpc_ioapic_redir_tbl_un  u;
    u.raw = __DP(ioapic_read_64)(_dev, (0x10) + (_i *(16/8)));
    u.val.mode = val;
    __DP(ioapic_write_64)(_dev, (0x10) + (_i *(16/8)),u.raw);
}

static inline void __DP(redirtbl_destmode_wrf)( __DN(t) * _dev, int _i, lpc_ioapic_dest_mode_t val ) __attribute__ ((always_inline));
static inline void __DP(redirtbl_destmode_wrf)( __DN(t) * _dev, int _i, lpc_ioapic_dest_mode_t val )
{
    lpc_ioapic_redir_tbl_un  u;
    u.raw = __DP(ioapic_read_64)(_dev, (0x10) + (_i *(16/8)));
    u.val.destmode = val;
    __DP(ioapic_write_64)(_dev, (0x10) + (_i *(16/8)),u.raw);
}

static inline void __DP(redirtbl_polarity_wrf)( __DN(t) * _dev, int _i, lpc_ioapic_polarity_t val ) __attribute__ ((always_inline));
static inline void __DP(redirtbl_polarity_wrf)( __DN(t) * _dev, int _i, lpc_ioapic_polarity_t val )
{
    lpc_ioapic_redir_tbl_un  u;
    u.raw = __DP(ioapic_read_64)(_dev, (0x10) + (_i *(16/8)));
    u.val.polarity = val;
    __DP(ioapic_write_64)(_dev, (0x10) + (_i *(16/8)),u.raw);
}

static inline void __DP(redirtbl_trigger_wrf)( __DN(t) * _dev, int _i, lpc_ioapic_trigger_mode_t val ) __attribute__ ((always_inline));
static inline void __DP(redirtbl_trigger_wrf)( __DN(t) * _dev, int _i, lpc_ioapic_trigger_mode_t val )
{
    lpc_ioapic_redir_tbl_un  u;
    u.raw = __DP(ioapic_read_64)(_dev, (0x10) + (_i *(16/8)));
    u.val.trigger = val;
    __DP(ioapic_write_64)(_dev, (0x10) + (_i *(16/8)),u.raw);
}

static inline void __DP(redirtbl_mask_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(redirtbl_mask_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    lpc_ioapic_redir_tbl_un  u;
    u.raw = __DP(ioapic_read_64)(_dev, (0x10) + (_i *(16/8)));
    u.val.mask = val;
    __DP(ioapic_write_64)(_dev, (0x10) + (_i *(16/8)),u.raw);
}

static inline void __DP(redirtbl_dest_wrf)( __DN(t) * _dev, int _i, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(redirtbl_dest_wrf)( __DN(t) * _dev, int _i, uint8_t val )
{
    lpc_ioapic_redir_tbl_un  u;
    u.raw = __DP(ioapic_read_64)(_dev, (0x10) + (_i *(16/8)));
    u.val.dest = val;
    __DP(ioapic_write_64)(_dev, (0x10) + (_i *(16/8)),u.raw);
}


static inline int __DP(redirtbl_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(redirtbl_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    lpc_ioapic_redir_tbl_un  u;
    u.raw = __DP(ioapic_read_64)(_dev, (0x10) + (_i *(16/8)));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register redirtbl[%d] (redirtbl):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.vector;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vector =\t0x%"PRIx8" (Vector", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mode =\t0x%"PRIx8" (Delivery mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = lpc_ioapic_delivery_mode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.destmode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " destmode =\t0x%"PRIx8" (Destination mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = lpc_ioapic_dest_mode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.status;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " status =\t0x%"PRIx8" (Delivery status", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = lpc_ioapic_delivery_status_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.polarity;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " polarity =\t0x%"PRIx8" (Interrupt input pin polarity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = lpc_ioapic_polarity_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rirr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rirr =\t0x%"PRIx8" (Remote IRR", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.trigger;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " trigger =\t0x%"PRIx8" (Trigger mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = lpc_ioapic_trigger_mode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mask;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mask =\t0x%"PRIx8" (Mask", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.edid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " edid =\t0x%"PRIx8" (Extended destination ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dest;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dest =\t0x%"PRIx8" (Destination", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}
static inline int __DP(redirtbl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(redirtbl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x18; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(redirtbl_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}

static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Dump of device lpc_ioapic (LPC IHC I/O APIC function):\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ind_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(wdw_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(eoir_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(id_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ver_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(arb_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(redirtbl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "End of dump of device lpc_ioapic\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR


#endif // __lpc_ioapic_H
