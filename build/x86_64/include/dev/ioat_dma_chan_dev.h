#ifndef __ioat_dma_chan_DEV_H
#define __ioat_dma_chan_DEV_H 1
/*
 * DEVICE DEFINITION: IOAT DMA (Crystal Beach) Channel registers
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) ioat_dma_chan ## _ ## x
/*
 * Constants defn: ioat_dma_chan.cmpl_status_shift (Completion Status Shift Value)
 *  - no width specified
 */
typedef uint8_t ioat_dma_chan_cmpl_status_shift_t;
#define ioat_dma_chan_compl_addr_shift ((ioat_dma_chan_cmpl_status_shift_t)0x6)

static inline char *ioat_dma_chan_cmpl_status_shift_describe(ioat_dma_chan_cmpl_status_shift_t _e) __attribute__ ((always_inline));
static inline char *ioat_dma_chan_cmpl_status_shift_describe(ioat_dma_chan_cmpl_status_shift_t _e)
{
    switch (_e) {
    case ioat_dma_chan_compl_addr_shift:
        return("compl_addr_shift: Completion addrss shift");
    default:
        return(NULL);
    }
}

static inline int ioat_dma_chan_cmpl_status_shift_prtval(char *_s, size_t _size, ioat_dma_chan_cmpl_status_shift_t _e) __attribute__ ((always_inline));
static inline int ioat_dma_chan_cmpl_status_shift_prtval(char *_s, size_t _size, ioat_dma_chan_cmpl_status_shift_t _e)
{
    char *d = ioat_dma_chan_cmpl_status_shift_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ioat_dma_chan_cmpl_status_shift_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ioat_dma_chan.cmpl_status_mask (Completion Status Mask Value)
 *  - width 64 bits
 */
typedef uint64_t ioat_dma_chan_cmpl_status_mask_t;
#define ioat_dma_chan_status_mask ((ioat_dma_chan_cmpl_status_mask_t)0x3f)

static inline char *ioat_dma_chan_cmpl_status_mask_describe(ioat_dma_chan_cmpl_status_mask_t _e) __attribute__ ((always_inline));
static inline char *ioat_dma_chan_cmpl_status_mask_describe(ioat_dma_chan_cmpl_status_mask_t _e)
{
    switch (_e) {
    case ioat_dma_chan_status_mask:
        return("status_mask: Mask for the status fields");
    default:
        return(NULL);
    }
}

static inline int ioat_dma_chan_cmpl_status_mask_prtval(char *_s, size_t _size, ioat_dma_chan_cmpl_status_mask_t _e) __attribute__ ((always_inline));
static inline int ioat_dma_chan_cmpl_status_mask_prtval(char *_s, size_t _size, ioat_dma_chan_cmpl_status_mask_t _e)
{
    char *d = ioat_dma_chan_cmpl_status_mask_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ioat_dma_chan_cmpl_status_mask_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ioat_dma_chan.chanctrl_snoop (Field values for Snoop Control)
 *  - no width specified
 */
typedef uint8_t ioat_dma_chan_chanctrl_snoop_t;
#define ioat_dma_chan_chanctrl_snoop_disabled ((ioat_dma_chan_chanctrl_snoop_t)0x1)
#define ioat_dma_chan_chanctrl_snoop_enabled ((ioat_dma_chan_chanctrl_snoop_t)0x0)

static inline char *ioat_dma_chan_chanctrl_snoop_describe(ioat_dma_chan_chanctrl_snoop_t _e) __attribute__ ((always_inline));
static inline char *ioat_dma_chan_chanctrl_snoop_describe(ioat_dma_chan_chanctrl_snoop_t _e)
{
    switch (_e) {
    case ioat_dma_chan_chanctrl_snoop_disabled:
        return("chanctrl_snoop_disabled: Disabled snooping");
    case ioat_dma_chan_chanctrl_snoop_enabled:
        return("chanctrl_snoop_enabled: Enable snooping");
    default:
        return(NULL);
    }
}

static inline int ioat_dma_chan_chanctrl_snoop_prtval(char *_s, size_t _size, ioat_dma_chan_chanctrl_snoop_t _e) __attribute__ ((always_inline));
static inline int ioat_dma_chan_chanctrl_snoop_prtval(char *_s, size_t _size, ioat_dma_chan_chanctrl_snoop_t _e)
{
    char *d = ioat_dma_chan_chanctrl_snoop_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ioat_dma_chan_chanctrl_snoop_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ioat_dma_chan.chanctrl_features (Field values for Channel Features)
 *  - no width specified
 */
typedef uint8_t ioat_dma_chan_chanctrl_features_t;
#define ioat_dma_chan_chanctrl_f_enable ((ioat_dma_chan_chanctrl_features_t)0x1)
#define ioat_dma_chan_chanctrl_f_disable ((ioat_dma_chan_chanctrl_features_t)0x0)

static inline char *ioat_dma_chan_chanctrl_features_describe(ioat_dma_chan_chanctrl_features_t _e) __attribute__ ((always_inline));
static inline char *ioat_dma_chan_chanctrl_features_describe(ioat_dma_chan_chanctrl_features_t _e)
{
    switch (_e) {
    case ioat_dma_chan_chanctrl_f_enable:
        return("chanctrl_f_enable: Feature field is enabled");
    case ioat_dma_chan_chanctrl_f_disable:
        return("chanctrl_f_disable: Feature field is disabled");
    default:
        return(NULL);
    }
}

static inline int ioat_dma_chan_chanctrl_features_prtval(char *_s, size_t _size, ioat_dma_chan_chanctrl_features_t _e) __attribute__ ((always_inline));
static inline int ioat_dma_chan_chanctrl_features_prtval(char *_s, size_t _size, ioat_dma_chan_chanctrl_features_t _e)
{
    char *d = ioat_dma_chan_chanctrl_features_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ioat_dma_chan_chanctrl_features_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ioat_dma_chan.trans_state (DMA Transfer States)
 *  - no width specified
 */
typedef uint8_t ioat_dma_chan_trans_state_t;
#define ioat_dma_chan_trans_state_active ((ioat_dma_chan_trans_state_t)0x0)
#define ioat_dma_chan_trans_state_idle ((ioat_dma_chan_trans_state_t)0x1)
#define ioat_dma_chan_trans_state_susp ((ioat_dma_chan_trans_state_t)0x2)
#define ioat_dma_chan_trans_state_halt ((ioat_dma_chan_trans_state_t)0x3)
#define ioat_dma_chan_trans_state_armed ((ioat_dma_chan_trans_state_t)0x4)

static inline char *ioat_dma_chan_trans_state_describe(ioat_dma_chan_trans_state_t _e) __attribute__ ((always_inline));
static inline char *ioat_dma_chan_trans_state_describe(ioat_dma_chan_trans_state_t _e)
{
    switch (_e) {
    case ioat_dma_chan_trans_state_active:
        return("trans_state_active: The transfer is active");
    case ioat_dma_chan_trans_state_idle:
        return("trans_state_idle: Idle, All DMA transfers done");
    case ioat_dma_chan_trans_state_susp:
        return("trans_state_susp: Suspended");
    case ioat_dma_chan_trans_state_halt:
        return("trans_state_halt: Halted, operation aborted (error)");
    case ioat_dma_chan_trans_state_armed:
        return("trans_state_armed: Armed State");
    default:
        return(NULL);
    }
}

static inline int ioat_dma_chan_trans_state_prtval(char *_s, size_t _size, ioat_dma_chan_trans_state_t _e) __attribute__ ((always_inline));
static inline int ioat_dma_chan_trans_state_prtval(char *_s, size_t _size, ioat_dma_chan_trans_state_t _e)
{
    char *d = ioat_dma_chan_trans_state_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ioat_dma_chan_trans_state_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ioat_dma_chan.dcactrl_targets (Target CPU Values)
 *  - no width specified
 */
typedef uint16_t ioat_dma_chan_dcactrl_targets_t;
#define ioat_dma_chan_dca_ctr_target_any ((ioat_dma_chan_dcactrl_targets_t)0xffff)

static inline char *ioat_dma_chan_dcactrl_targets_describe(ioat_dma_chan_dcactrl_targets_t _e) __attribute__ ((always_inline));
static inline char *ioat_dma_chan_dcactrl_targets_describe(ioat_dma_chan_dcactrl_targets_t _e)
{
    switch (_e) {
    case ioat_dma_chan_dca_ctr_target_any:
        return("dca_ctr_target_any: Any CPU as garget");
    default:
        return(NULL);
    }
}

static inline int ioat_dma_chan_dcactrl_targets_prtval(char *_s, size_t _size, ioat_dma_chan_dcactrl_targets_t _e) __attribute__ ((always_inline));
static inline int ioat_dma_chan_dcactrl_targets_prtval(char *_s, size_t _size, ioat_dma_chan_dcactrl_targets_t _e)
{
    char *d = ioat_dma_chan_dcactrl_targets_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ioat_dma_chan_dcactrl_targets_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: ioat_dma_chan_ctrl_t
 * Description: Implicit type of Channel Control Register register
 * Fields:
 *   intp_dis	(size 1, offset 0, init 0):	RWC	Interrupt disable
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   err_cmp_en	(size 1, offset 2, init 0):	RW	Error Completion Enabled
 *   err_abort	(size 1, offset 3, init 0):	RW	Any Error Abort Enbled
 *   err_int_en	(size 1, offset 4, init 0):	RW	Error Interrupt Enabled
 *   snoop_ctrl	(size 1, offset 5, init 0):	RW	Descriptor address snoop control
 *   _anon6	(size 2, offset 6, init 0):	RSVD	_
 *   in_use	(size 1, offset 8, init 0):	RW	Channel is in use
 *   dca_en	(size 1, offset 9, init 0):	RW	Direct Cache access enabled
 *   _anon10	(size 6, offset 10, init 0):	RSVD	_
 */
typedef uint16_t ioat_dma_chan_ctrl_t;
#define ioat_dma_chan_ctrl_default 0x0
static inline uint8_t ioat_dma_chan_ctrl_intp_dis_extract(ioat_dma_chan_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_ctrl_intp_dis_extract(ioat_dma_chan_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_intp_dis_insert(ioat_dma_chan_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_intp_dis_insert(ioat_dma_chan_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe) | (0x1 & (((ioat_dma_chan_ctrl_t )(_fieldval)) << 0)));
}

static inline uint8_t ioat_dma_chan_ctrl_err_cmp_en_extract(ioat_dma_chan_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_ctrl_err_cmp_en_extract(ioat_dma_chan_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_err_cmp_en_insert(ioat_dma_chan_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_err_cmp_en_insert(ioat_dma_chan_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffb) | (0x4 & (((ioat_dma_chan_ctrl_t )(_fieldval)) << 2)));
}

static inline uint8_t ioat_dma_chan_ctrl_err_abort_extract(ioat_dma_chan_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_ctrl_err_abort_extract(ioat_dma_chan_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_err_abort_insert(ioat_dma_chan_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_err_abort_insert(ioat_dma_chan_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7) | (0x8 & (((ioat_dma_chan_ctrl_t )(_fieldval)) << 3)));
}

static inline uint8_t ioat_dma_chan_ctrl_err_int_en_extract(ioat_dma_chan_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_ctrl_err_int_en_extract(ioat_dma_chan_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_err_int_en_insert(ioat_dma_chan_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_err_int_en_insert(ioat_dma_chan_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffef) | (0x10 & (((ioat_dma_chan_ctrl_t )(_fieldval)) << 4)));
}

static inline uint8_t ioat_dma_chan_ctrl_snoop_ctrl_extract(ioat_dma_chan_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_ctrl_snoop_ctrl_extract(ioat_dma_chan_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_snoop_ctrl_insert(ioat_dma_chan_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_snoop_ctrl_insert(ioat_dma_chan_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdf) | (0x20 & (((ioat_dma_chan_ctrl_t )(_fieldval)) << 5)));
}

static inline uint8_t ioat_dma_chan_ctrl_in_use_extract(ioat_dma_chan_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_ctrl_in_use_extract(ioat_dma_chan_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_in_use_insert(ioat_dma_chan_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_in_use_insert(ioat_dma_chan_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeff) | (0x100 & (((ioat_dma_chan_ctrl_t )(_fieldval)) << 8)));
}

static inline uint8_t ioat_dma_chan_ctrl_dca_en_extract(ioat_dma_chan_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_ctrl_dca_en_extract(ioat_dma_chan_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_dca_en_insert(ioat_dma_chan_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_dca_en_insert(ioat_dma_chan_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdff) | (0x200 & (((ioat_dma_chan_ctrl_t )(_fieldval)) << 9)));
}

static inline int ioat_dma_chan_ctrl_prtval(char *_s, size_t _size, ioat_dma_chan_ctrl_t _regval) __attribute__ ((always_inline));
static inline int ioat_dma_chan_ctrl_prtval(char *_s, size_t _size, ioat_dma_chan_ctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " intp_dis =\t%" PRIx8 "\t(Interrupt disable)\n", ioat_dma_chan_ctrl_intp_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err_cmp_en =\t%" PRIx8 "\t(Error Completion Enabled)\n", ioat_dma_chan_ctrl_err_cmp_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err_abort =\t%" PRIx8 "\t(Any Error Abort Enbled)\n", ioat_dma_chan_ctrl_err_abort_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err_int_en =\t%" PRIx8 "\t(Error Interrupt Enabled)\n", ioat_dma_chan_ctrl_err_int_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " snoop_ctrl =\t%" PRIx8 "\t(Descriptor address snoop control)\n", ioat_dma_chan_ctrl_snoop_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " in_use =\t%" PRIx8 "\t(Channel is in use)\n", ioat_dma_chan_ctrl_in_use_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dca_en =\t%" PRIx8 "\t(Direct Cache access enabled)\n", ioat_dma_chan_ctrl_dca_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ioat_dma_chan_dma_comp_t
 * Description: Implicit type of DMA Compatibility Register register
 * Fields:
 *   v1	(size 1, offset 0, init 0):	RO	NOT compatible with CB Version 1
 *   v2	(size 1, offset 1, init 0):	RO	Compatible with CB Version 2
 *   v3	(size 1, offset 2, init 0):	RO	Compatible with CB Version 3
 *   _anon3	(size 13, offset 3, init 0):	RSVD	_
 */
typedef uint16_t ioat_dma_chan_dma_comp_t;
#define ioat_dma_chan_dma_comp_default 0x0
static inline uint8_t ioat_dma_chan_dma_comp_v1_extract(ioat_dma_chan_dma_comp_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_dma_comp_v1_extract(ioat_dma_chan_dma_comp_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ioat_dma_chan_dma_comp_t ioat_dma_chan_dma_comp_v1_insert(ioat_dma_chan_dma_comp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_dma_comp_t ioat_dma_chan_dma_comp_v1_insert(ioat_dma_chan_dma_comp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe) | (0x1 & (((ioat_dma_chan_dma_comp_t )(_fieldval)) << 0)));
}

static inline uint8_t ioat_dma_chan_dma_comp_v2_extract(ioat_dma_chan_dma_comp_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_dma_comp_v2_extract(ioat_dma_chan_dma_comp_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ioat_dma_chan_dma_comp_t ioat_dma_chan_dma_comp_v2_insert(ioat_dma_chan_dma_comp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_dma_comp_t ioat_dma_chan_dma_comp_v2_insert(ioat_dma_chan_dma_comp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffd) | (0x2 & (((ioat_dma_chan_dma_comp_t )(_fieldval)) << 1)));
}

static inline uint8_t ioat_dma_chan_dma_comp_v3_extract(ioat_dma_chan_dma_comp_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_dma_comp_v3_extract(ioat_dma_chan_dma_comp_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ioat_dma_chan_dma_comp_t ioat_dma_chan_dma_comp_v3_insert(ioat_dma_chan_dma_comp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_dma_comp_t ioat_dma_chan_dma_comp_v3_insert(ioat_dma_chan_dma_comp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffb) | (0x4 & (((ioat_dma_chan_dma_comp_t )(_fieldval)) << 2)));
}

static inline int ioat_dma_chan_dma_comp_prtval(char *_s, size_t _size, ioat_dma_chan_dma_comp_t _regval) __attribute__ ((always_inline));
static inline int ioat_dma_chan_dma_comp_prtval(char *_s, size_t _size, ioat_dma_chan_dma_comp_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v1 =\t%" PRIx8 "\t(NOT compatible with CB Version 1)\n", ioat_dma_chan_dma_comp_v1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v2 =\t%" PRIx8 "\t(Compatible with CB Version 2)\n", ioat_dma_chan_dma_comp_v2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v3 =\t%" PRIx8 "\t(Compatible with CB Version 3)\n", ioat_dma_chan_dma_comp_v3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ioat_dma_chan_cmd_t
 * Description: Implicit type of DMA Channel Command Register. register
 * Fields:
 *   start	(size 1, offset 0, init 0):	RW	Start
 *   append	(size 1, offset 1, init 0):	RW	Append
 *   susp	(size 1, offset 2, init 0):	RW	Suspend the DMA channel
 *   abort	(size 1, offset 3, init 0):	RW	Abort
 *   resume	(size 1, offset 4, init 0):	RW	resume
 *   reset	(size 1, offset 5, init 0):	RW	Reset DMA channel
 *   _anon6	(size 2, offset 6, init 0):	RSVD	_
 */
typedef uint8_t ioat_dma_chan_cmd_t;
#define ioat_dma_chan_cmd_default 0x0
static inline uint8_t ioat_dma_chan_cmd_start_extract(ioat_dma_chan_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_cmd_start_extract(ioat_dma_chan_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ioat_dma_chan_cmd_t ioat_dma_chan_cmd_start_insert(ioat_dma_chan_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_cmd_t ioat_dma_chan_cmd_start_insert(ioat_dma_chan_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((ioat_dma_chan_cmd_t )(_fieldval)) << 0)));
}

static inline uint8_t ioat_dma_chan_cmd_append_extract(ioat_dma_chan_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_cmd_append_extract(ioat_dma_chan_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ioat_dma_chan_cmd_t ioat_dma_chan_cmd_append_insert(ioat_dma_chan_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_cmd_t ioat_dma_chan_cmd_append_insert(ioat_dma_chan_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((ioat_dma_chan_cmd_t )(_fieldval)) << 1)));
}

static inline uint8_t ioat_dma_chan_cmd_susp_extract(ioat_dma_chan_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_cmd_susp_extract(ioat_dma_chan_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ioat_dma_chan_cmd_t ioat_dma_chan_cmd_susp_insert(ioat_dma_chan_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_cmd_t ioat_dma_chan_cmd_susp_insert(ioat_dma_chan_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((ioat_dma_chan_cmd_t )(_fieldval)) << 2)));
}

static inline uint8_t ioat_dma_chan_cmd_abort_extract(ioat_dma_chan_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_cmd_abort_extract(ioat_dma_chan_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ioat_dma_chan_cmd_t ioat_dma_chan_cmd_abort_insert(ioat_dma_chan_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_cmd_t ioat_dma_chan_cmd_abort_insert(ioat_dma_chan_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((ioat_dma_chan_cmd_t )(_fieldval)) << 3)));
}

static inline uint8_t ioat_dma_chan_cmd_resume_extract(ioat_dma_chan_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_cmd_resume_extract(ioat_dma_chan_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ioat_dma_chan_cmd_t ioat_dma_chan_cmd_resume_insert(ioat_dma_chan_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_cmd_t ioat_dma_chan_cmd_resume_insert(ioat_dma_chan_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((ioat_dma_chan_cmd_t )(_fieldval)) << 4)));
}

static inline uint8_t ioat_dma_chan_cmd_reset_extract(ioat_dma_chan_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_cmd_reset_extract(ioat_dma_chan_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ioat_dma_chan_cmd_t ioat_dma_chan_cmd_reset_insert(ioat_dma_chan_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_cmd_t ioat_dma_chan_cmd_reset_insert(ioat_dma_chan_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdf) | (0x20 & (((ioat_dma_chan_cmd_t )(_fieldval)) << 5)));
}

static inline int ioat_dma_chan_cmd_prtval(char *_s, size_t _size, ioat_dma_chan_cmd_t _regval) __attribute__ ((always_inline));
static inline int ioat_dma_chan_cmd_prtval(char *_s, size_t _size, ioat_dma_chan_cmd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " start =\t%" PRIx8 "\t(Start)\n", ioat_dma_chan_cmd_start_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " append =\t%" PRIx8 "\t(Append)\n", ioat_dma_chan_cmd_append_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " susp =\t%" PRIx8 "\t(Suspend the DMA channel)\n", ioat_dma_chan_cmd_susp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " abort =\t%" PRIx8 "\t(Abort)\n", ioat_dma_chan_cmd_abort_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " resume =\t%" PRIx8 "\t(resume)\n", ioat_dma_chan_cmd_resume_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reset =\t%" PRIx8 "\t(Reset DMA channel)\n", ioat_dma_chan_cmd_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ioat_dma_chan_sts_lo_t
 * Description: Implicit type of Channel Status Lo Register. register
 * Fields:
 *   dma_trans_state	(size 3, offset 0, init 0):	RO	DMA transfer State
 *   _anon3	(size 3, offset 3, init 0):	RSVD	_
 *   cmpdscaddr	(size 26, offset 6, init 0):	RO	Uppder address of the last descriptor processed
 */
typedef uint32_t ioat_dma_chan_sts_lo_t;
#define ioat_dma_chan_sts_lo_default 0x0
static inline uint8_t ioat_dma_chan_sts_lo_dma_trans_state_extract(ioat_dma_chan_sts_lo_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_sts_lo_dma_trans_state_extract(ioat_dma_chan_sts_lo_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline ioat_dma_chan_sts_lo_t ioat_dma_chan_sts_lo_dma_trans_state_insert(ioat_dma_chan_sts_lo_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_sts_lo_t ioat_dma_chan_sts_lo_dma_trans_state_insert(ioat_dma_chan_sts_lo_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((ioat_dma_chan_sts_lo_t )(_fieldval)) << 0)));
}

static inline uint32_t ioat_dma_chan_sts_lo_cmpdscaddr_extract(ioat_dma_chan_sts_lo_t _regval) __attribute__ ((always_inline));
static inline uint32_t ioat_dma_chan_sts_lo_cmpdscaddr_extract(ioat_dma_chan_sts_lo_t _regval)
{
    return((uint32_t )((_regval & 0xffffffc0) >> 6));
}

static inline ioat_dma_chan_sts_lo_t ioat_dma_chan_sts_lo_cmpdscaddr_insert(ioat_dma_chan_sts_lo_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_sts_lo_t ioat_dma_chan_sts_lo_cmpdscaddr_insert(ioat_dma_chan_sts_lo_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x3f) | (0xffffffc0 & (((ioat_dma_chan_sts_lo_t )(_fieldval)) << 6)));
}

static inline int ioat_dma_chan_sts_lo_prtval(char *_s, size_t _size, ioat_dma_chan_sts_lo_t _regval) __attribute__ ((always_inline));
static inline int ioat_dma_chan_sts_lo_prtval(char *_s, size_t _size, ioat_dma_chan_sts_lo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma_trans_state =\t%" PRIx8 "\t(DMA transfer State)\n", ioat_dma_chan_sts_lo_dma_trans_state_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmpdscaddr =\t%" PRIx32 "\t(Uppder address of the last descriptor processed)\n", ioat_dma_chan_sts_lo_cmpdscaddr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ioat_dma_chan_chainaddr_lo_t
 * Description: Implicit type of Descriptor Chain Address Lo Register. register
 * Fields:
 *   _anon0	(size 6, offset 0, init 0):	MBZ	_
 *   descaddr_lo	(size 26, offset 6, init 0):	RW	Address of the first descriptor
 */
typedef uint32_t ioat_dma_chan_chainaddr_lo_t;
#define ioat_dma_chan_chainaddr_lo_default 0x0
static inline uint32_t ioat_dma_chan_chainaddr_lo_descaddr_lo_extract(ioat_dma_chan_chainaddr_lo_t _regval) __attribute__ ((always_inline));
static inline uint32_t ioat_dma_chan_chainaddr_lo_descaddr_lo_extract(ioat_dma_chan_chainaddr_lo_t _regval)
{
    return((uint32_t )((_regval & 0xffffffc0) >> 6));
}

static inline ioat_dma_chan_chainaddr_lo_t ioat_dma_chan_chainaddr_lo_descaddr_lo_insert(ioat_dma_chan_chainaddr_lo_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_chainaddr_lo_t ioat_dma_chan_chainaddr_lo_descaddr_lo_insert(ioat_dma_chan_chainaddr_lo_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x3f) | (0xffffffc0 & (((ioat_dma_chan_chainaddr_lo_t )(_fieldval)) << 6)));
}

static inline int ioat_dma_chan_chainaddr_lo_prtval(char *_s, size_t _size, ioat_dma_chan_chainaddr_lo_t _regval) __attribute__ ((always_inline));
static inline int ioat_dma_chan_chainaddr_lo_prtval(char *_s, size_t _size, ioat_dma_chan_chainaddr_lo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " descaddr_lo =\t%" PRIx32 "\t(Address of the first descriptor)\n", ioat_dma_chan_chainaddr_lo_descaddr_lo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ioat_dma_chan_err_t
 * Description: Implicit type of Channel Error Register register
 * Fields:
 *   dmatranserr	(size 1, offset 0, init 0):	RWCS	DMA Transfer Source address error
 *   dmaxfererr	(size 1, offset 1, init 0):	RWCS	DMA Transfer Destination address error
 *   nxtdescerr	(size 1, offset 2, init 0):	RWCS	Next Descriptor Address error
 *   descerr	(size 1, offset 3, init 0):	RWCS	Descriptor error
 *   chanaddr	(size 1, offset 4, init 0):	RWCS	Channel address value error
 *   chancmderr	(size 1, offset 5, init 0):	RWCS	Channel command error
 *   cdataerr	(size 1, offset 6, init 0):	RWCS	Data parity error
 *   dmadataerr	(size 1, offset 7, init 0):	RWCS	DMA Data Parity error
 *   rddataerr	(size 1, offset 8, init 0):	RWCS	Read Data error
 *   wrdataerr	(size 1, offset 9, init 0):	RWCS	Write data error
 *   descctrlerr	(size 1, offset 10, init 0):	RWCS	Description control  error
 *   desclenerr	(size 1, offset 11, init 0):	RWCS	Description length error
 *   cmpaddrerr	(size 1, offset 12, init 0):	RWCS	Completion Address error
 *   intcfgerr	(size 1, offset 13, init 0):	RWCS	Interrupt confiuguratio error
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   unaffilerr	(size 1, offset 15, init 0):	RO	Unaffiliated Error
 *   crc_err	(size 1, offset 16, init 0):	RWCS	CRC test failed
 *   xorqerr	(size 1, offset 17, init 0):	RWCS	Xor error
 *   desccnterr	(size 1, offset 18, init 0):	RWCS	Descriptor Count error
 *   _anon19	(size 13, offset 19, init 0):	RSVD	_
 */
typedef uint32_t ioat_dma_chan_err_t;
#define ioat_dma_chan_err_default 0x0
static inline uint8_t ioat_dma_chan_err_dmatranserr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_dmatranserr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_dmatranserr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_dmatranserr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ioat_dma_chan_err_t )(_fieldval)) << 0)));
}

static inline uint8_t ioat_dma_chan_err_dmaxfererr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_dmaxfererr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_dmaxfererr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_dmaxfererr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ioat_dma_chan_err_t )(_fieldval)) << 1)));
}

static inline uint8_t ioat_dma_chan_err_nxtdescerr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_nxtdescerr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_nxtdescerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_nxtdescerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ioat_dma_chan_err_t )(_fieldval)) << 2)));
}

static inline uint8_t ioat_dma_chan_err_descerr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_descerr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_descerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_descerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ioat_dma_chan_err_t )(_fieldval)) << 3)));
}

static inline uint8_t ioat_dma_chan_err_chanaddr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_chanaddr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_chanaddr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_chanaddr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ioat_dma_chan_err_t )(_fieldval)) << 4)));
}

static inline uint8_t ioat_dma_chan_err_chancmderr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_chancmderr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_chancmderr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_chancmderr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((ioat_dma_chan_err_t )(_fieldval)) << 5)));
}

static inline uint8_t ioat_dma_chan_err_cdataerr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_cdataerr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_cdataerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_cdataerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((ioat_dma_chan_err_t )(_fieldval)) << 6)));
}

static inline uint8_t ioat_dma_chan_err_dmadataerr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_dmadataerr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_dmadataerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_dmadataerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((ioat_dma_chan_err_t )(_fieldval)) << 7)));
}

static inline uint8_t ioat_dma_chan_err_rddataerr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_rddataerr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_rddataerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_rddataerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((ioat_dma_chan_err_t )(_fieldval)) << 8)));
}

static inline uint8_t ioat_dma_chan_err_wrdataerr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_wrdataerr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_wrdataerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_wrdataerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((ioat_dma_chan_err_t )(_fieldval)) << 9)));
}

static inline uint8_t ioat_dma_chan_err_descctrlerr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_descctrlerr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_descctrlerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_descctrlerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((ioat_dma_chan_err_t )(_fieldval)) << 10)));
}

static inline uint8_t ioat_dma_chan_err_desclenerr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_desclenerr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_desclenerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_desclenerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((ioat_dma_chan_err_t )(_fieldval)) << 11)));
}

static inline uint8_t ioat_dma_chan_err_cmpaddrerr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_cmpaddrerr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_cmpaddrerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_cmpaddrerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((ioat_dma_chan_err_t )(_fieldval)) << 12)));
}

static inline uint8_t ioat_dma_chan_err_intcfgerr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_intcfgerr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_intcfgerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_intcfgerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((ioat_dma_chan_err_t )(_fieldval)) << 13)));
}

static inline uint8_t ioat_dma_chan_err_unaffilerr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_unaffilerr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_unaffilerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_unaffilerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((ioat_dma_chan_err_t )(_fieldval)) << 15)));
}

static inline uint8_t ioat_dma_chan_err_crc_err_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_crc_err_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_crc_err_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_crc_err_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((ioat_dma_chan_err_t )(_fieldval)) << 16)));
}

static inline uint8_t ioat_dma_chan_err_xorqerr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_xorqerr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_xorqerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_xorqerr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((ioat_dma_chan_err_t )(_fieldval)) << 17)));
}

static inline uint8_t ioat_dma_chan_err_desccnterr_extract(ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_desccnterr_extract(ioat_dma_chan_err_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_desccnterr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_desccnterr_insert(ioat_dma_chan_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((ioat_dma_chan_err_t )(_fieldval)) << 18)));
}

static inline int ioat_dma_chan_err_prtval(char *_s, size_t _size, ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline int ioat_dma_chan_err_prtval(char *_s, size_t _size, ioat_dma_chan_err_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmatranserr =\t%" PRIx8 "\t(DMA Transfer Source address error)\n", ioat_dma_chan_err_dmatranserr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmaxfererr =\t%" PRIx8 "\t(DMA Transfer Destination address error)\n", ioat_dma_chan_err_dmaxfererr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nxtdescerr =\t%" PRIx8 "\t(Next Descriptor Address error)\n", ioat_dma_chan_err_nxtdescerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " descerr =\t%" PRIx8 "\t(Descriptor error)\n", ioat_dma_chan_err_descerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chanaddr =\t%" PRIx8 "\t(Channel address value error)\n", ioat_dma_chan_err_chanaddr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chancmderr =\t%" PRIx8 "\t(Channel command error)\n", ioat_dma_chan_err_chancmderr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cdataerr =\t%" PRIx8 "\t(Data parity error)\n", ioat_dma_chan_err_cdataerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmadataerr =\t%" PRIx8 "\t(DMA Data Parity error)\n", ioat_dma_chan_err_dmadataerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rddataerr =\t%" PRIx8 "\t(Read Data error)\n", ioat_dma_chan_err_rddataerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wrdataerr =\t%" PRIx8 "\t(Write data error)\n", ioat_dma_chan_err_wrdataerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " descctrlerr =\t%" PRIx8 "\t(Description control  error)\n", ioat_dma_chan_err_descctrlerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " desclenerr =\t%" PRIx8 "\t(Description length error)\n", ioat_dma_chan_err_desclenerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmpaddrerr =\t%" PRIx8 "\t(Completion Address error)\n", ioat_dma_chan_err_cmpaddrerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " intcfgerr =\t%" PRIx8 "\t(Interrupt confiuguratio error)\n", ioat_dma_chan_err_intcfgerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " unaffilerr =\t%" PRIx8 "\t(Unaffiliated Error)\n", ioat_dma_chan_err_unaffilerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crc_err =\t%" PRIx8 "\t(CRC test failed)\n", ioat_dma_chan_err_crc_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xorqerr =\t%" PRIx8 "\t(Xor error)\n", ioat_dma_chan_err_xorqerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " desccnterr =\t%" PRIx8 "\t(Descriptor Count error)\n", ioat_dma_chan_err_desccnterr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ioat_dma_chan_errmsk_t
 * Description: Implicit type of Channel Error Mask Register. register
 * Fields:
 *   dmatranserr	(size 1, offset 0, init 0):	RWCS	DMA Transfer Source address error
 *   dmaxfererr	(size 1, offset 1, init 0):	RWCS	DMA Transfer Destination address error
 *   nxtdescerr	(size 1, offset 2, init 0):	RWCS	Next Descriptor Address error
 *   descerr	(size 1, offset 3, init 0):	RWCS	Descriptor error
 *   chanaddr	(size 1, offset 4, init 0):	RWCS	Channel address value error
 *   chancmderr	(size 1, offset 5, init 0):	RWCS	Channel command error
 *   cdataerr	(size 1, offset 6, init 0):	RWCS	Data parity error
 *   dmadataerr	(size 1, offset 7, init 0):	RWCS	DMA Data Parity error
 *   rddataerr	(size 1, offset 8, init 0):	RWCS	Read Data error
 *   wrdataerr	(size 1, offset 9, init 0):	RWCS	Write data error
 *   descctrlerr	(size 1, offset 10, init 0):	RWCS	Description control  error
 *   desclenerr	(size 1, offset 11, init 0):	RWCS	Description length error
 *   cmpaddrerr	(size 1, offset 12, init 0):	RWCS	Completion Address error
 *   intcfgerr	(size 1, offset 13, init 0):	RWCS	Interrupt confiuguratio error
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   unaffilerr	(size 1, offset 15, init 0):	RO	Unaffiliated Error
 *   crc_err	(size 1, offset 16, init 0):	RWCS	CRC test failed
 *   xorqerr	(size 1, offset 17, init 0):	RWCS	Xor error
 *   desccnterr	(size 1, offset 18, init 0):	RWCS	Descriptor Count error
 *   _anon19	(size 13, offset 19, init 0):	RSVD	_
 */
typedef uint32_t ioat_dma_chan_errmsk_t;
#define ioat_dma_chan_errmsk_default 0x0
static inline uint8_t ioat_dma_chan_errmsk_dmatranserr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_dmatranserr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_dmatranserr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_dmatranserr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 0)));
}

static inline uint8_t ioat_dma_chan_errmsk_dmaxfererr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_dmaxfererr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_dmaxfererr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_dmaxfererr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 1)));
}

static inline uint8_t ioat_dma_chan_errmsk_nxtdescerr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_nxtdescerr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_nxtdescerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_nxtdescerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 2)));
}

static inline uint8_t ioat_dma_chan_errmsk_descerr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_descerr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_descerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_descerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 3)));
}

static inline uint8_t ioat_dma_chan_errmsk_chanaddr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_chanaddr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_chanaddr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_chanaddr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 4)));
}

static inline uint8_t ioat_dma_chan_errmsk_chancmderr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_chancmderr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_chancmderr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_chancmderr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 5)));
}

static inline uint8_t ioat_dma_chan_errmsk_cdataerr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_cdataerr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_cdataerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_cdataerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 6)));
}

static inline uint8_t ioat_dma_chan_errmsk_dmadataerr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_dmadataerr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_dmadataerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_dmadataerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 7)));
}

static inline uint8_t ioat_dma_chan_errmsk_rddataerr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_rddataerr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_rddataerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_rddataerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 8)));
}

static inline uint8_t ioat_dma_chan_errmsk_wrdataerr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_wrdataerr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_wrdataerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_wrdataerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 9)));
}

static inline uint8_t ioat_dma_chan_errmsk_descctrlerr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_descctrlerr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_descctrlerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_descctrlerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 10)));
}

static inline uint8_t ioat_dma_chan_errmsk_desclenerr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_desclenerr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_desclenerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_desclenerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 11)));
}

static inline uint8_t ioat_dma_chan_errmsk_cmpaddrerr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_cmpaddrerr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_cmpaddrerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_cmpaddrerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 12)));
}

static inline uint8_t ioat_dma_chan_errmsk_intcfgerr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_intcfgerr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_intcfgerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_intcfgerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 13)));
}

static inline uint8_t ioat_dma_chan_errmsk_unaffilerr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_unaffilerr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_unaffilerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_unaffilerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 15)));
}

static inline uint8_t ioat_dma_chan_errmsk_crc_err_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_crc_err_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_crc_err_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_crc_err_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 16)));
}

static inline uint8_t ioat_dma_chan_errmsk_xorqerr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_xorqerr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_xorqerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_xorqerr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 17)));
}

static inline uint8_t ioat_dma_chan_errmsk_desccnterr_extract(ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_desccnterr_extract(ioat_dma_chan_errmsk_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_desccnterr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_desccnterr_insert(ioat_dma_chan_errmsk_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 18)));
}

static inline int ioat_dma_chan_errmsk_prtval(char *_s, size_t _size, ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline int ioat_dma_chan_errmsk_prtval(char *_s, size_t _size, ioat_dma_chan_errmsk_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmatranserr =\t%" PRIx8 "\t(DMA Transfer Source address error)\n", ioat_dma_chan_errmsk_dmatranserr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmaxfererr =\t%" PRIx8 "\t(DMA Transfer Destination address error)\n", ioat_dma_chan_errmsk_dmaxfererr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nxtdescerr =\t%" PRIx8 "\t(Next Descriptor Address error)\n", ioat_dma_chan_errmsk_nxtdescerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " descerr =\t%" PRIx8 "\t(Descriptor error)\n", ioat_dma_chan_errmsk_descerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chanaddr =\t%" PRIx8 "\t(Channel address value error)\n", ioat_dma_chan_errmsk_chanaddr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chancmderr =\t%" PRIx8 "\t(Channel command error)\n", ioat_dma_chan_errmsk_chancmderr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cdataerr =\t%" PRIx8 "\t(Data parity error)\n", ioat_dma_chan_errmsk_cdataerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmadataerr =\t%" PRIx8 "\t(DMA Data Parity error)\n", ioat_dma_chan_errmsk_dmadataerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rddataerr =\t%" PRIx8 "\t(Read Data error)\n", ioat_dma_chan_errmsk_rddataerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wrdataerr =\t%" PRIx8 "\t(Write data error)\n", ioat_dma_chan_errmsk_wrdataerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " descctrlerr =\t%" PRIx8 "\t(Description control  error)\n", ioat_dma_chan_errmsk_descctrlerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " desclenerr =\t%" PRIx8 "\t(Description length error)\n", ioat_dma_chan_errmsk_desclenerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmpaddrerr =\t%" PRIx8 "\t(Completion Address error)\n", ioat_dma_chan_errmsk_cmpaddrerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " intcfgerr =\t%" PRIx8 "\t(Interrupt confiuguratio error)\n", ioat_dma_chan_errmsk_intcfgerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " unaffilerr =\t%" PRIx8 "\t(Unaffiliated Error)\n", ioat_dma_chan_errmsk_unaffilerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crc_err =\t%" PRIx8 "\t(CRC test failed)\n", ioat_dma_chan_errmsk_crc_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xorqerr =\t%" PRIx8 "\t(Xor error)\n", ioat_dma_chan_errmsk_xorqerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " desccnterr =\t%" PRIx8 "\t(Descriptor Count error)\n", ioat_dma_chan_errmsk_desccnterr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ioat_dma_chan_dcactrl_t
 * Description: Implicit type of DCA Control Register register
 * Fields:
 *   target_cpu	(size 16, offset 0, init 0):	RW	Specifies the APCI ID of the target CPU for compl writes
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t ioat_dma_chan_dcactrl_t;
#define ioat_dma_chan_dcactrl_default 0x0
static inline uint16_t ioat_dma_chan_dcactrl_target_cpu_extract(ioat_dma_chan_dcactrl_t _regval) __attribute__ ((always_inline));
static inline uint16_t ioat_dma_chan_dcactrl_target_cpu_extract(ioat_dma_chan_dcactrl_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline ioat_dma_chan_dcactrl_t ioat_dma_chan_dcactrl_target_cpu_insert(ioat_dma_chan_dcactrl_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ioat_dma_chan_dcactrl_t ioat_dma_chan_dcactrl_target_cpu_insert(ioat_dma_chan_dcactrl_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((ioat_dma_chan_dcactrl_t )(_fieldval)) << 0)));
}

static inline int ioat_dma_chan_dcactrl_prtval(char *_s, size_t _size, ioat_dma_chan_dcactrl_t _regval) __attribute__ ((always_inline));
static inline int ioat_dma_chan_dcactrl_prtval(char *_s, size_t _size, ioat_dma_chan_dcactrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " target_cpu =\t%" PRIx16 "\t(Specifies the APCI ID of the target CPU for compl writes)\n", ioat_dma_chan_dcactrl_target_cpu_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ioat_dma_chan_compl_status_t
 * Description: Completion writeback data area
 * Fields:
 *   status	(size 3, offset 0, init 0):	RW	Channel status field
 *   unaff_err	(size 1, offset 3, init 0):	RW	Unaffiliated error
 *   soft_err	(size 1, offset 4, init 0):	RW	Software Error
 *   _anon5	(size 1, offset 5, init 0):	RSVD	_
 *   compl_desc	(size 58, offset 6, init 0):	RW	Completed Descriptor Address
 */
typedef uint8_t *ioat_dma_chan_compl_status_t;
typedef uint8_t ioat_dma_chan_compl_status_array_t[8];
static const size_t ioat_dma_chan_compl_status_size = sizeof(ioat_dma_chan_compl_status_array_t );
static inline uint8_t ioat_dma_chan_compl_status_status_extract(ioat_dma_chan_compl_status_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_compl_status_status_extract(ioat_dma_chan_compl_status_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x7) >> 0);
}

static inline void ioat_dma_chan_compl_status_status_insert(ioat_dma_chan_compl_status_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_compl_status_status_insert(ioat_dma_chan_compl_status_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xf8) | (0x7 & (_fieldval << 0)));
}

static inline uint8_t ioat_dma_chan_compl_status_unaff_err_extract(ioat_dma_chan_compl_status_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_compl_status_unaff_err_extract(ioat_dma_chan_compl_status_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x8) >> 3);
}

static inline void ioat_dma_chan_compl_status_unaff_err_insert(ioat_dma_chan_compl_status_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_compl_status_unaff_err_insert(ioat_dma_chan_compl_status_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xf7) | (0x8 & (_fieldval << 3)));
}

static inline uint8_t ioat_dma_chan_compl_status_soft_err_extract(ioat_dma_chan_compl_status_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_compl_status_soft_err_extract(ioat_dma_chan_compl_status_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x10) >> 4);
}

static inline void ioat_dma_chan_compl_status_soft_err_insert(ioat_dma_chan_compl_status_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_compl_status_soft_err_insert(ioat_dma_chan_compl_status_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xef) | (0x10 & (_fieldval << 4)));
}

static inline uint64_t ioat_dma_chan_compl_status_compl_desc_extract(ioat_dma_chan_compl_status_t _dtptr) __attribute__ ((always_inline));
static inline uint64_t ioat_dma_chan_compl_status_compl_desc_extract(ioat_dma_chan_compl_status_t _dtptr)
{
    return(((*((uint64_t *)(0 + _dtptr))) & 0xffffffffffffffc0) >> 6);
}

static inline void ioat_dma_chan_compl_status_compl_desc_insert(ioat_dma_chan_compl_status_t _dtptr, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_compl_status_compl_desc_insert(ioat_dma_chan_compl_status_t _dtptr, uint64_t _fieldval)
{
    *((uint64_t *)(0 + _dtptr)) = (((*((uint64_t *)(0 + _dtptr))) & 0x3f) | (0xffffffffffffffc0 & (_fieldval << 6)));
}

static inline int ioat_dma_chan_compl_status_prtval(char *_s, size_t _size, ioat_dma_chan_compl_status_t _regval) __attribute__ ((always_inline));
static inline int ioat_dma_chan_compl_status_prtval(char *_s, size_t _size, ioat_dma_chan_compl_status_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t%" PRIx8 "\t(Channel status field)\n", ioat_dma_chan_compl_status_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " unaff_err =\t%" PRIx8 "\t(Unaffiliated error)\n", ioat_dma_chan_compl_status_unaff_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " soft_err =\t%" PRIx8 "\t(Software Error)\n", ioat_dma_chan_compl_status_soft_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " compl_desc =\t%" PRIx64 "\t(Completed Descriptor Address)\n", ioat_dma_chan_compl_status_compl_desc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t chan_base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum ioat_dma_chan_initials {
    ioat_dma_chan_ctrl_initial = 0x0,
    ioat_dma_chan_dma_comp_initial = 0x0,
    ioat_dma_chan_cmd_initial = 0x0,
    ioat_dma_chan_dmacount_initial = 0x0,
    ioat_dma_chan_sts_lo_initial = 0x0,
    ioat_dma_chan_sts_hi_initial = 0x0,
    ioat_dma_chan_chainaddr_lo_initial = 0x0,
    ioat_dma_chan_chainaddr_hi_initial = 0x0,
    ioat_dma_chan_cmpl_lo_initial = 0x0,
    ioat_dma_chan_cmpl_hi_initial = 0x0,
    ioat_dma_chan_err_initial = 0x0,
    ioat_dma_chan_errmsk_initial = 0x0,
    ioat_dma_chan_dcactrl_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void ioat_dma_chan_initialize(__DN(t) *_dev, mackerel_addr_t chan_base) __attribute__ ((always_inline));
static inline void ioat_dma_chan_initialize(__DN(t) *_dev, mackerel_addr_t chan_base)
{
    _dev->chan_base = chan_base;
}

/*
 * Register ctrl: Channel Control Register
 * Type: ioat_dma_chan.ctrl (Implicit type of Channel Control Register register)
 *   intp_dis	(size 1, offset 0, init 0):	RWC	Interrupt disable
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   err_cmp_en	(size 1, offset 2, init 0):	RW	Error Completion Enabled
 *   err_abort	(size 1, offset 3, init 0):	RW	Any Error Abort Enbled
 *   err_int_en	(size 1, offset 4, init 0):	RW	Error Interrupt Enabled
 *   snoop_ctrl	(size 1, offset 5, init 0):	RW	Descriptor address snoop control
 *   _anon6	(size 2, offset 6, init 0):	RSVD	_
 *   in_use	(size 1, offset 8, init 0):	RW	Channel is in use
 *   dca_en	(size 1, offset 9, init 0):	RW	Direct Cache access enabled
 *   _anon10	(size 6, offset 10, init 0):	RSVD	_
 */
static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->chan_base, 0x0));
}

static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ioat_dma_chan_ctrl_t ioat_dma_chan_ctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->chan_base, 0x0));
}

static inline void ioat_dma_chan_ctrl_rawwr(__DN(t) *_dev, ioat_dma_chan_ctrl_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_ctrl_rawwr(__DN(t) *_dev, ioat_dma_chan_ctrl_t _regval)
{
    mackerel_write_addr_16(_dev->chan_base, 0x0, _regval);
}

static inline void ioat_dma_chan_ctrl_wr(__DN(t) *_dev, ioat_dma_chan_ctrl_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_ctrl_wr(__DN(t) *_dev, ioat_dma_chan_ctrl_t _regval)
{
    _regval = (_regval & 0x33d);
    // No MB1 fields present
    _regval = (_regval | (0xfcc2 & mackerel_read_addr_16(_dev->chan_base, 0x0)));
    mackerel_write_addr_16(_dev->chan_base, 0x0, _regval);
}

static inline int ioat_dma_chan_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ioat_dma_chan_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ioat_dma_chan_ctrl_t _regval = mackerel_read_addr_16(_dev->chan_base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ctrl (Channel Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " intp_dis =\t%" PRIx8 "\t(Interrupt disable)\n", ioat_dma_chan_ctrl_intp_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err_cmp_en =\t%" PRIx8 "\t(Error Completion Enabled)\n", ioat_dma_chan_ctrl_err_cmp_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err_abort =\t%" PRIx8 "\t(Any Error Abort Enbled)\n", ioat_dma_chan_ctrl_err_abort_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err_int_en =\t%" PRIx8 "\t(Error Interrupt Enabled)\n", ioat_dma_chan_ctrl_err_int_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " snoop_ctrl =\t%" PRIx8 "\t(Descriptor address snoop control)\n", ioat_dma_chan_ctrl_snoop_ctrl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " in_use =\t%" PRIx8 "\t(Channel is in use)\n", ioat_dma_chan_ctrl_in_use_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dca_en =\t%" PRIx8 "\t(Direct Cache access enabled)\n", ioat_dma_chan_ctrl_dca_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    return(_r);
}

static inline uint8_t ioat_dma_chan_ctrl_intp_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_ctrl_intp_dis_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_ctrl_t _regval = mackerel_read_addr_16(_dev->chan_base, 0x0);
    return(ioat_dma_chan_ctrl_intp_dis_extract(_regval));
}

static inline uint8_t ioat_dma_chan_ctrl_err_cmp_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_ctrl_err_cmp_en_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_ctrl_t _regval = mackerel_read_addr_16(_dev->chan_base, 0x0);
    return(ioat_dma_chan_ctrl_err_cmp_en_extract(_regval));
}

static inline uint8_t ioat_dma_chan_ctrl_err_abort_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_ctrl_err_abort_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_ctrl_t _regval = mackerel_read_addr_16(_dev->chan_base, 0x0);
    return(ioat_dma_chan_ctrl_err_abort_extract(_regval));
}

static inline uint8_t ioat_dma_chan_ctrl_err_int_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_ctrl_err_int_en_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_ctrl_t _regval = mackerel_read_addr_16(_dev->chan_base, 0x0);
    return(ioat_dma_chan_ctrl_err_int_en_extract(_regval));
}

static inline uint8_t ioat_dma_chan_ctrl_snoop_ctrl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_ctrl_snoop_ctrl_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_ctrl_t _regval = mackerel_read_addr_16(_dev->chan_base, 0x0);
    return(ioat_dma_chan_ctrl_snoop_ctrl_extract(_regval));
}

static inline uint8_t ioat_dma_chan_ctrl_in_use_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_ctrl_in_use_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_ctrl_t _regval = mackerel_read_addr_16(_dev->chan_base, 0x0);
    return(ioat_dma_chan_ctrl_in_use_extract(_regval));
}

static inline uint8_t ioat_dma_chan_ctrl_dca_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_ctrl_dca_en_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_ctrl_t _regval = mackerel_read_addr_16(_dev->chan_base, 0x0);
    return(ioat_dma_chan_ctrl_dca_en_extract(_regval));
}

static inline void ioat_dma_chan_ctrl_intp_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_ctrl_intp_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_ctrl_t _regval = 0x1 & (((ioat_dma_chan_ctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffe & mackerel_read_addr_16(_dev->chan_base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->chan_base, 0x0, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_ctrl_err_cmp_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_ctrl_err_cmp_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_ctrl_t _regval = 0x4 & (((ioat_dma_chan_ctrl_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffa & mackerel_read_addr_16(_dev->chan_base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->chan_base, 0x0, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_ctrl_err_abort_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_ctrl_err_abort_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_ctrl_t _regval = 0x8 & (((ioat_dma_chan_ctrl_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfff6 & mackerel_read_addr_16(_dev->chan_base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->chan_base, 0x0, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_ctrl_err_int_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_ctrl_err_int_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_ctrl_t _regval = 0x10 & (((ioat_dma_chan_ctrl_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffee & mackerel_read_addr_16(_dev->chan_base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->chan_base, 0x0, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_ctrl_snoop_ctrl_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_ctrl_snoop_ctrl_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_ctrl_t _regval = 0x20 & (((ioat_dma_chan_ctrl_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffde & mackerel_read_addr_16(_dev->chan_base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->chan_base, 0x0, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_ctrl_in_use_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_ctrl_in_use_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_ctrl_t _regval = 0x100 & (((ioat_dma_chan_ctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfefe & mackerel_read_addr_16(_dev->chan_base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->chan_base, 0x0, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_ctrl_dca_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_ctrl_dca_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_ctrl_t _regval = 0x200 & (((ioat_dma_chan_ctrl_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfdfe & mackerel_read_addr_16(_dev->chan_base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->chan_base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register dma_comp: DMA Compatibility Register
 * Type: ioat_dma_chan.dma_comp (Implicit type of DMA Compatibility Register register)
 *   v1	(size 1, offset 0, init 0):	RO	NOT compatible with CB Version 1
 *   v2	(size 1, offset 1, init 0):	RO	Compatible with CB Version 2
 *   v3	(size 1, offset 2, init 0):	RO	Compatible with CB Version 3
 *   _anon3	(size 13, offset 3, init 0):	RSVD	_
 */
static inline ioat_dma_chan_dma_comp_t ioat_dma_chan_dma_comp_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ioat_dma_chan_dma_comp_t ioat_dma_chan_dma_comp_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->chan_base, 0x2));
}

static inline ioat_dma_chan_dma_comp_t ioat_dma_chan_dma_comp_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ioat_dma_chan_dma_comp_t ioat_dma_chan_dma_comp_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->chan_base, 0x2));
}

static inline void ioat_dma_chan_dma_comp_rawwr(__DN(t) *_dev, ioat_dma_chan_dma_comp_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_dma_comp_rawwr(__DN(t) *_dev, ioat_dma_chan_dma_comp_t _regval)
{
    mackerel_write_addr_16(_dev->chan_base, 0x2, _regval);
}

// Register dma_comp is not writeable
static inline int ioat_dma_chan_dma_comp_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ioat_dma_chan_dma_comp_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ioat_dma_chan_dma_comp_t _regval = mackerel_read_addr_16(_dev->chan_base, 0x2);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dma_comp (DMA Compatibility Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v1 =\t%" PRIx8 "\t(NOT compatible with CB Version 1)\n", ioat_dma_chan_dma_comp_v1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v2 =\t%" PRIx8 "\t(Compatible with CB Version 2)\n", ioat_dma_chan_dma_comp_v2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v3 =\t%" PRIx8 "\t(Compatible with CB Version 3)\n", ioat_dma_chan_dma_comp_v3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t ioat_dma_chan_dma_comp_v1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_dma_comp_v1_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_dma_comp_t _regval = mackerel_read_addr_16(_dev->chan_base, 0x2);
    return(ioat_dma_chan_dma_comp_v1_extract(_regval));
}

static inline uint8_t ioat_dma_chan_dma_comp_v2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_dma_comp_v2_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_dma_comp_t _regval = mackerel_read_addr_16(_dev->chan_base, 0x2);
    return(ioat_dma_chan_dma_comp_v2_extract(_regval));
}

static inline uint8_t ioat_dma_chan_dma_comp_v3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_dma_comp_v3_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_dma_comp_t _regval = mackerel_read_addr_16(_dev->chan_base, 0x2);
    return(ioat_dma_chan_dma_comp_v3_extract(_regval));
}

/*
 * Register cmd: DMA Channel Command Register.
 * Type: ioat_dma_chan.cmd (Implicit type of DMA Channel Command Register. register)
 *   start	(size 1, offset 0, init 0):	RW	Start
 *   append	(size 1, offset 1, init 0):	RW	Append
 *   susp	(size 1, offset 2, init 0):	RW	Suspend the DMA channel
 *   abort	(size 1, offset 3, init 0):	RW	Abort
 *   resume	(size 1, offset 4, init 0):	RW	resume
 *   reset	(size 1, offset 5, init 0):	RW	Reset DMA channel
 *   _anon6	(size 2, offset 6, init 0):	RSVD	_
 */
static inline ioat_dma_chan_cmd_t ioat_dma_chan_cmd_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ioat_dma_chan_cmd_t ioat_dma_chan_cmd_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->chan_base, 0x84));
}

static inline ioat_dma_chan_cmd_t ioat_dma_chan_cmd_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ioat_dma_chan_cmd_t ioat_dma_chan_cmd_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->chan_base, 0x84));
}

static inline void ioat_dma_chan_cmd_rawwr(__DN(t) *_dev, ioat_dma_chan_cmd_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_cmd_rawwr(__DN(t) *_dev, ioat_dma_chan_cmd_t _regval)
{
    mackerel_write_addr_8(_dev->chan_base, 0x84, _regval);
}

static inline void ioat_dma_chan_cmd_wr(__DN(t) *_dev, ioat_dma_chan_cmd_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_cmd_wr(__DN(t) *_dev, ioat_dma_chan_cmd_t _regval)
{
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    _regval = (_regval | (0xc0 & mackerel_read_addr_8(_dev->chan_base, 0x84)));
    mackerel_write_addr_8(_dev->chan_base, 0x84, _regval);
}

static inline int ioat_dma_chan_cmd_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ioat_dma_chan_cmd_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ioat_dma_chan_cmd_t _regval = mackerel_read_addr_8(_dev->chan_base, 0x84);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cmd (DMA Channel Command Register.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " start =\t%" PRIx8 "\t(Start)\n", ioat_dma_chan_cmd_start_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " append =\t%" PRIx8 "\t(Append)\n", ioat_dma_chan_cmd_append_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " susp =\t%" PRIx8 "\t(Suspend the DMA channel)\n", ioat_dma_chan_cmd_susp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " abort =\t%" PRIx8 "\t(Abort)\n", ioat_dma_chan_cmd_abort_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " resume =\t%" PRIx8 "\t(resume)\n", ioat_dma_chan_cmd_resume_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reset =\t%" PRIx8 "\t(Reset DMA channel)\n", ioat_dma_chan_cmd_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    return(_r);
}

static inline uint8_t ioat_dma_chan_cmd_start_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_cmd_start_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_cmd_t _regval = mackerel_read_addr_8(_dev->chan_base, 0x84);
    return(ioat_dma_chan_cmd_start_extract(_regval));
}

static inline uint8_t ioat_dma_chan_cmd_append_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_cmd_append_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_cmd_t _regval = mackerel_read_addr_8(_dev->chan_base, 0x84);
    return(ioat_dma_chan_cmd_append_extract(_regval));
}

static inline uint8_t ioat_dma_chan_cmd_susp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_cmd_susp_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_cmd_t _regval = mackerel_read_addr_8(_dev->chan_base, 0x84);
    return(ioat_dma_chan_cmd_susp_extract(_regval));
}

static inline uint8_t ioat_dma_chan_cmd_abort_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_cmd_abort_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_cmd_t _regval = mackerel_read_addr_8(_dev->chan_base, 0x84);
    return(ioat_dma_chan_cmd_abort_extract(_regval));
}

static inline uint8_t ioat_dma_chan_cmd_resume_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_cmd_resume_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_cmd_t _regval = mackerel_read_addr_8(_dev->chan_base, 0x84);
    return(ioat_dma_chan_cmd_resume_extract(_regval));
}

static inline uint8_t ioat_dma_chan_cmd_reset_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_cmd_reset_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_cmd_t _regval = mackerel_read_addr_8(_dev->chan_base, 0x84);
    return(ioat_dma_chan_cmd_reset_extract(_regval));
}

static inline void ioat_dma_chan_cmd_start_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_cmd_start_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_cmd_t _regval = 0x1 & (((ioat_dma_chan_cmd_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfe & mackerel_read_addr_8(_dev->chan_base, 0x84)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->chan_base, 0x84, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_cmd_append_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_cmd_append_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_cmd_t _regval = 0x2 & (((ioat_dma_chan_cmd_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfd & mackerel_read_addr_8(_dev->chan_base, 0x84)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->chan_base, 0x84, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_cmd_susp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_cmd_susp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_cmd_t _regval = 0x4 & (((ioat_dma_chan_cmd_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfb & mackerel_read_addr_8(_dev->chan_base, 0x84)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->chan_base, 0x84, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_cmd_abort_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_cmd_abort_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_cmd_t _regval = 0x8 & (((ioat_dma_chan_cmd_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf7 & mackerel_read_addr_8(_dev->chan_base, 0x84)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->chan_base, 0x84, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_cmd_resume_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_cmd_resume_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_cmd_t _regval = 0x10 & (((ioat_dma_chan_cmd_t )(_fieldval)) << 4);
    _regval = (_regval | (0xef & mackerel_read_addr_8(_dev->chan_base, 0x84)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->chan_base, 0x84, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_cmd_reset_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_cmd_reset_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_cmd_t _regval = 0x20 & (((ioat_dma_chan_cmd_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdf & mackerel_read_addr_8(_dev->chan_base, 0x84)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->chan_base, 0x84, _regval);
    // No shadow register to write to
}

/*
 * Register dmacount: DMA Descriptor Count Register
 * Type: ioat_dma_chan.uint16 (primitive type)
 */
static inline uint16_t ioat_dma_chan_dmacount_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ioat_dma_chan_dmacount_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->chan_base, 0x6));
}

static inline uint16_t ioat_dma_chan_dmacount_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ioat_dma_chan_dmacount_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->chan_base, 0x6));
}

static inline void ioat_dma_chan_dmacount_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_dmacount_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->chan_base, 0x6, _regval);
}

static inline void ioat_dma_chan_dmacount_wr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_dmacount_wr(__DN(t) *_dev, uint16_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->chan_base, 0x6, _regval);
}

static inline int ioat_dma_chan_dmacount_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ioat_dma_chan_dmacount_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->chan_base, 0x6);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dmacount (DMA Descriptor Count Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register sts_lo: Channel Status Lo Register.
 * Type: ioat_dma_chan.sts_lo (Implicit type of Channel Status Lo Register. register)
 *   dma_trans_state	(size 3, offset 0, init 0):	RO	DMA transfer State
 *   _anon3	(size 3, offset 3, init 0):	RSVD	_
 *   cmpdscaddr	(size 26, offset 6, init 0):	RO	Uppder address of the last descriptor processed
 */
static inline ioat_dma_chan_sts_lo_t ioat_dma_chan_sts_lo_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ioat_dma_chan_sts_lo_t ioat_dma_chan_sts_lo_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0x8));
}

static inline ioat_dma_chan_sts_lo_t ioat_dma_chan_sts_lo_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ioat_dma_chan_sts_lo_t ioat_dma_chan_sts_lo_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0x8));
}

static inline void ioat_dma_chan_sts_lo_rawwr(__DN(t) *_dev, ioat_dma_chan_sts_lo_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_sts_lo_rawwr(__DN(t) *_dev, ioat_dma_chan_sts_lo_t _regval)
{
    mackerel_write_addr_32(_dev->chan_base, 0x8, _regval);
}

// Register sts_lo is not writeable
static inline int ioat_dma_chan_sts_lo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ioat_dma_chan_sts_lo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ioat_dma_chan_sts_lo_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sts_lo (Channel Status Lo Register.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma_trans_state =\t%" PRIx8 "\t(DMA transfer State)\n", ioat_dma_chan_sts_lo_dma_trans_state_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmpdscaddr =\t%" PRIx32 "\t(Uppder address of the last descriptor processed)\n", ioat_dma_chan_sts_lo_cmpdscaddr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t ioat_dma_chan_sts_lo_dma_trans_state_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_sts_lo_dma_trans_state_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_sts_lo_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x8);
    return(ioat_dma_chan_sts_lo_dma_trans_state_extract(_regval));
}

static inline uint32_t ioat_dma_chan_sts_lo_cmpdscaddr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ioat_dma_chan_sts_lo_cmpdscaddr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_sts_lo_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x8);
    return(ioat_dma_chan_sts_lo_cmpdscaddr_extract(_regval));
}

/*
 * Register sts_hi: Channel Status Hi Register.
 * Type: ioat_dma_chan.uint32 (primitive type)
 */
static inline uint32_t ioat_dma_chan_sts_hi_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ioat_dma_chan_sts_hi_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0xc));
}

static inline uint32_t ioat_dma_chan_sts_hi_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ioat_dma_chan_sts_hi_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0xc));
}

static inline void ioat_dma_chan_sts_hi_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_sts_hi_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->chan_base, 0xc, _regval);
}

// Register sts_hi is not writeable
static inline int ioat_dma_chan_sts_hi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ioat_dma_chan_sts_hi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->chan_base, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sts_hi (Channel Status Hi Register.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register chainaddr_lo: Descriptor Chain Address Lo Register.
 * Type: ioat_dma_chan.chainaddr_lo (Implicit type of Descriptor Chain Address Lo Register. register)
 *   _anon0	(size 6, offset 0, init 0):	MBZ	_
 *   descaddr_lo	(size 26, offset 6, init 0):	RW	Address of the first descriptor
 */
static inline ioat_dma_chan_chainaddr_lo_t ioat_dma_chan_chainaddr_lo_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ioat_dma_chan_chainaddr_lo_t ioat_dma_chan_chainaddr_lo_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0x10));
}

static inline ioat_dma_chan_chainaddr_lo_t ioat_dma_chan_chainaddr_lo_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ioat_dma_chan_chainaddr_lo_t ioat_dma_chan_chainaddr_lo_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0x10));
}

static inline void ioat_dma_chan_chainaddr_lo_rawwr(__DN(t) *_dev, ioat_dma_chan_chainaddr_lo_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_chainaddr_lo_rawwr(__DN(t) *_dev, ioat_dma_chan_chainaddr_lo_t _regval)
{
    mackerel_write_addr_32(_dev->chan_base, 0x10, _regval);
}

static inline void ioat_dma_chan_chainaddr_lo_wr(__DN(t) *_dev, ioat_dma_chan_chainaddr_lo_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_chainaddr_lo_wr(__DN(t) *_dev, ioat_dma_chan_chainaddr_lo_t _regval)
{
    _regval = (_regval & 0xffffffc0);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->chan_base, 0x10, _regval);
}

static inline int ioat_dma_chan_chainaddr_lo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ioat_dma_chan_chainaddr_lo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ioat_dma_chan_chainaddr_lo_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register chainaddr_lo (Descriptor Chain Address Lo Register.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " descaddr_lo =\t%" PRIx32 "\t(Address of the first descriptor)\n", ioat_dma_chan_chainaddr_lo_descaddr_lo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t ioat_dma_chan_chainaddr_lo_descaddr_lo_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ioat_dma_chan_chainaddr_lo_descaddr_lo_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_chainaddr_lo_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x10);
    return(ioat_dma_chan_chainaddr_lo_descaddr_lo_extract(_regval));
}

static inline void ioat_dma_chan_chainaddr_lo_descaddr_lo_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_chainaddr_lo_descaddr_lo_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    ioat_dma_chan_chainaddr_lo_t _regval = 0xffffffc0 & (((ioat_dma_chan_chainaddr_lo_t )(_fieldval)) << 6);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffffffc0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register chainaddr_hi: Descriptor Chain Address Hi Register.
 * Type: ioat_dma_chan.uint32 (primitive type)
 */
static inline uint32_t ioat_dma_chan_chainaddr_hi_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ioat_dma_chan_chainaddr_hi_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0x14));
}

static inline uint32_t ioat_dma_chan_chainaddr_hi_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ioat_dma_chan_chainaddr_hi_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0x14));
}

static inline void ioat_dma_chan_chainaddr_hi_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_chainaddr_hi_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->chan_base, 0x14, _regval);
}

static inline void ioat_dma_chan_chainaddr_hi_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_chainaddr_hi_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->chan_base, 0x14, _regval);
}

static inline int ioat_dma_chan_chainaddr_hi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ioat_dma_chan_chainaddr_hi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register chainaddr_hi (Descriptor Chain Address Hi Register.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register cmpl_lo: Channel Completion Address Lo Register.
 * Type: ioat_dma_chan.uint32 (primitive type)
 */
static inline uint32_t ioat_dma_chan_cmpl_lo_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ioat_dma_chan_cmpl_lo_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0x18));
}

static inline uint32_t ioat_dma_chan_cmpl_lo_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ioat_dma_chan_cmpl_lo_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0x18));
}

static inline void ioat_dma_chan_cmpl_lo_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_cmpl_lo_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->chan_base, 0x18, _regval);
}

static inline void ioat_dma_chan_cmpl_lo_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_cmpl_lo_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->chan_base, 0x18, _regval);
}

static inline int ioat_dma_chan_cmpl_lo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ioat_dma_chan_cmpl_lo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cmpl_lo (Channel Completion Address Lo Register.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register cmpl_hi: Channel Completion Address Hi Register.
 * Type: ioat_dma_chan.uint32 (primitive type)
 */
static inline uint32_t ioat_dma_chan_cmpl_hi_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ioat_dma_chan_cmpl_hi_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0x1c));
}

static inline uint32_t ioat_dma_chan_cmpl_hi_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ioat_dma_chan_cmpl_hi_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0x1c));
}

static inline void ioat_dma_chan_cmpl_hi_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_cmpl_hi_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->chan_base, 0x1c, _regval);
}

static inline void ioat_dma_chan_cmpl_hi_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_cmpl_hi_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->chan_base, 0x1c, _regval);
}

static inline int ioat_dma_chan_cmpl_hi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ioat_dma_chan_cmpl_hi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cmpl_hi (Channel Completion Address Hi Register.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register err: Channel Error Register
 * Type: ioat_dma_chan.err (Implicit type of Channel Error Register register)
 *   dmatranserr	(size 1, offset 0, init 0):	RWCS	DMA Transfer Source address error
 *   dmaxfererr	(size 1, offset 1, init 0):	RWCS	DMA Transfer Destination address error
 *   nxtdescerr	(size 1, offset 2, init 0):	RWCS	Next Descriptor Address error
 *   descerr	(size 1, offset 3, init 0):	RWCS	Descriptor error
 *   chanaddr	(size 1, offset 4, init 0):	RWCS	Channel address value error
 *   chancmderr	(size 1, offset 5, init 0):	RWCS	Channel command error
 *   cdataerr	(size 1, offset 6, init 0):	RWCS	Data parity error
 *   dmadataerr	(size 1, offset 7, init 0):	RWCS	DMA Data Parity error
 *   rddataerr	(size 1, offset 8, init 0):	RWCS	Read Data error
 *   wrdataerr	(size 1, offset 9, init 0):	RWCS	Write data error
 *   descctrlerr	(size 1, offset 10, init 0):	RWCS	Description control  error
 *   desclenerr	(size 1, offset 11, init 0):	RWCS	Description length error
 *   cmpaddrerr	(size 1, offset 12, init 0):	RWCS	Completion Address error
 *   intcfgerr	(size 1, offset 13, init 0):	RWCS	Interrupt confiuguratio error
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   unaffilerr	(size 1, offset 15, init 0):	RO	Unaffiliated Error
 *   crc_err	(size 1, offset 16, init 0):	RWCS	CRC test failed
 *   xorqerr	(size 1, offset 17, init 0):	RWCS	Xor error
 *   desccnterr	(size 1, offset 18, init 0):	RWCS	Descriptor Count error
 *   _anon19	(size 13, offset 19, init 0):	RSVD	_
 */
static inline ioat_dma_chan_err_t ioat_dma_chan_err_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0x28));
}

static inline ioat_dma_chan_err_t ioat_dma_chan_err_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ioat_dma_chan_err_t ioat_dma_chan_err_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0x28));
}

static inline void ioat_dma_chan_err_rawwr(__DN(t) *_dev, ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_rawwr(__DN(t) *_dev, ioat_dma_chan_err_t _regval)
{
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
}

static inline void ioat_dma_chan_err_wr(__DN(t) *_dev, ioat_dma_chan_err_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_wr(__DN(t) *_dev, ioat_dma_chan_err_t _regval)
{
    _regval = (_regval & 0x7bfff);
    // No MB1 fields present
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
}

static inline int ioat_dma_chan_err_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ioat_dma_chan_err_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register err (Channel Error Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmatranserr =\t%" PRIx8 "\t(DMA Transfer Source address error)\n", ioat_dma_chan_err_dmatranserr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmaxfererr =\t%" PRIx8 "\t(DMA Transfer Destination address error)\n", ioat_dma_chan_err_dmaxfererr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nxtdescerr =\t%" PRIx8 "\t(Next Descriptor Address error)\n", ioat_dma_chan_err_nxtdescerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " descerr =\t%" PRIx8 "\t(Descriptor error)\n", ioat_dma_chan_err_descerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chanaddr =\t%" PRIx8 "\t(Channel address value error)\n", ioat_dma_chan_err_chanaddr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chancmderr =\t%" PRIx8 "\t(Channel command error)\n", ioat_dma_chan_err_chancmderr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cdataerr =\t%" PRIx8 "\t(Data parity error)\n", ioat_dma_chan_err_cdataerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmadataerr =\t%" PRIx8 "\t(DMA Data Parity error)\n", ioat_dma_chan_err_dmadataerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rddataerr =\t%" PRIx8 "\t(Read Data error)\n", ioat_dma_chan_err_rddataerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wrdataerr =\t%" PRIx8 "\t(Write data error)\n", ioat_dma_chan_err_wrdataerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " descctrlerr =\t%" PRIx8 "\t(Description control  error)\n", ioat_dma_chan_err_descctrlerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " desclenerr =\t%" PRIx8 "\t(Description length error)\n", ioat_dma_chan_err_desclenerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmpaddrerr =\t%" PRIx8 "\t(Completion Address error)\n", ioat_dma_chan_err_cmpaddrerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " intcfgerr =\t%" PRIx8 "\t(Interrupt confiuguratio error)\n", ioat_dma_chan_err_intcfgerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " unaffilerr =\t%" PRIx8 "\t(Unaffiliated Error)\n", ioat_dma_chan_err_unaffilerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crc_err =\t%" PRIx8 "\t(CRC test failed)\n", ioat_dma_chan_err_crc_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xorqerr =\t%" PRIx8 "\t(Xor error)\n", ioat_dma_chan_err_xorqerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " desccnterr =\t%" PRIx8 "\t(Descriptor Count error)\n", ioat_dma_chan_err_desccnterr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    return(_r);
}

static inline uint8_t ioat_dma_chan_err_dmatranserr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_dmatranserr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_dmatranserr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_dmaxfererr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_dmaxfererr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_dmaxfererr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_nxtdescerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_nxtdescerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_nxtdescerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_descerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_descerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_descerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_chanaddr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_chanaddr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_chanaddr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_chancmderr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_chancmderr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_chancmderr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_cdataerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_cdataerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_cdataerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_dmadataerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_dmadataerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_dmadataerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_rddataerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_rddataerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_rddataerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_wrdataerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_wrdataerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_wrdataerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_descctrlerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_descctrlerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_descctrlerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_desclenerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_desclenerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_desclenerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_cmpaddrerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_cmpaddrerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_cmpaddrerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_intcfgerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_intcfgerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_intcfgerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_unaffilerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_unaffilerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_unaffilerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_crc_err_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_crc_err_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_crc_err_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_xorqerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_xorqerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_xorqerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_err_desccnterr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_err_desccnterr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_err_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x28);
    return(ioat_dma_chan_err_desccnterr_extract(_regval));
}

static inline void ioat_dma_chan_err_dmatranserr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_dmatranserr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x1 & (((ioat_dma_chan_err_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_err_dmaxfererr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_dmaxfererr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x2 & (((ioat_dma_chan_err_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_err_nxtdescerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_nxtdescerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x4 & (((ioat_dma_chan_err_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_err_descerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_descerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x8 & (((ioat_dma_chan_err_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_err_chanaddr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_chanaddr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x10 & (((ioat_dma_chan_err_t )(_fieldval)) << 4);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_err_chancmderr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_chancmderr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x20 & (((ioat_dma_chan_err_t )(_fieldval)) << 5);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_err_cdataerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_cdataerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x40 & (((ioat_dma_chan_err_t )(_fieldval)) << 6);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_err_dmadataerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_dmadataerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x80 & (((ioat_dma_chan_err_t )(_fieldval)) << 7);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_err_rddataerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_rddataerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x100 & (((ioat_dma_chan_err_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_err_wrdataerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_wrdataerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x200 & (((ioat_dma_chan_err_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_err_descctrlerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_descctrlerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x400 & (((ioat_dma_chan_err_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_err_desclenerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_desclenerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x800 & (((ioat_dma_chan_err_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_err_cmpaddrerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_cmpaddrerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x1000 & (((ioat_dma_chan_err_t )(_fieldval)) << 12);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_err_intcfgerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_intcfgerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x2000 & (((ioat_dma_chan_err_t )(_fieldval)) << 13);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_err_crc_err_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_crc_err_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x10000 & (((ioat_dma_chan_err_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_err_xorqerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_xorqerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x20000 & (((ioat_dma_chan_err_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_err_desccnterr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_err_desccnterr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_err_t _regval = 0x40000 & (((ioat_dma_chan_err_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x28, _regval);
    // No shadow register to write to
}

/*
 * Register errmsk: Channel Error Mask Register.
 * Type: ioat_dma_chan.errmsk (Implicit type of Channel Error Mask Register. register)
 *   dmatranserr	(size 1, offset 0, init 0):	RWCS	DMA Transfer Source address error
 *   dmaxfererr	(size 1, offset 1, init 0):	RWCS	DMA Transfer Destination address error
 *   nxtdescerr	(size 1, offset 2, init 0):	RWCS	Next Descriptor Address error
 *   descerr	(size 1, offset 3, init 0):	RWCS	Descriptor error
 *   chanaddr	(size 1, offset 4, init 0):	RWCS	Channel address value error
 *   chancmderr	(size 1, offset 5, init 0):	RWCS	Channel command error
 *   cdataerr	(size 1, offset 6, init 0):	RWCS	Data parity error
 *   dmadataerr	(size 1, offset 7, init 0):	RWCS	DMA Data Parity error
 *   rddataerr	(size 1, offset 8, init 0):	RWCS	Read Data error
 *   wrdataerr	(size 1, offset 9, init 0):	RWCS	Write data error
 *   descctrlerr	(size 1, offset 10, init 0):	RWCS	Description control  error
 *   desclenerr	(size 1, offset 11, init 0):	RWCS	Description length error
 *   cmpaddrerr	(size 1, offset 12, init 0):	RWCS	Completion Address error
 *   intcfgerr	(size 1, offset 13, init 0):	RWCS	Interrupt confiuguratio error
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   unaffilerr	(size 1, offset 15, init 0):	RO	Unaffiliated Error
 *   crc_err	(size 1, offset 16, init 0):	RWCS	CRC test failed
 *   xorqerr	(size 1, offset 17, init 0):	RWCS	Xor error
 *   desccnterr	(size 1, offset 18, init 0):	RWCS	Descriptor Count error
 *   _anon19	(size 13, offset 19, init 0):	RSVD	_
 */
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0x2c));
}

static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ioat_dma_chan_errmsk_t ioat_dma_chan_errmsk_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0x2c));
}

static inline void ioat_dma_chan_errmsk_rawwr(__DN(t) *_dev, ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_rawwr(__DN(t) *_dev, ioat_dma_chan_errmsk_t _regval)
{
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
}

static inline void ioat_dma_chan_errmsk_wr(__DN(t) *_dev, ioat_dma_chan_errmsk_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_wr(__DN(t) *_dev, ioat_dma_chan_errmsk_t _regval)
{
    _regval = (_regval & 0x7bfff);
    // No MB1 fields present
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
}

static inline int ioat_dma_chan_errmsk_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ioat_dma_chan_errmsk_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register errmsk (Channel Error Mask Register.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmatranserr =\t%" PRIx8 "\t(DMA Transfer Source address error)\n", ioat_dma_chan_errmsk_dmatranserr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmaxfererr =\t%" PRIx8 "\t(DMA Transfer Destination address error)\n", ioat_dma_chan_errmsk_dmaxfererr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nxtdescerr =\t%" PRIx8 "\t(Next Descriptor Address error)\n", ioat_dma_chan_errmsk_nxtdescerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " descerr =\t%" PRIx8 "\t(Descriptor error)\n", ioat_dma_chan_errmsk_descerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chanaddr =\t%" PRIx8 "\t(Channel address value error)\n", ioat_dma_chan_errmsk_chanaddr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chancmderr =\t%" PRIx8 "\t(Channel command error)\n", ioat_dma_chan_errmsk_chancmderr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cdataerr =\t%" PRIx8 "\t(Data parity error)\n", ioat_dma_chan_errmsk_cdataerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmadataerr =\t%" PRIx8 "\t(DMA Data Parity error)\n", ioat_dma_chan_errmsk_dmadataerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rddataerr =\t%" PRIx8 "\t(Read Data error)\n", ioat_dma_chan_errmsk_rddataerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wrdataerr =\t%" PRIx8 "\t(Write data error)\n", ioat_dma_chan_errmsk_wrdataerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " descctrlerr =\t%" PRIx8 "\t(Description control  error)\n", ioat_dma_chan_errmsk_descctrlerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " desclenerr =\t%" PRIx8 "\t(Description length error)\n", ioat_dma_chan_errmsk_desclenerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmpaddrerr =\t%" PRIx8 "\t(Completion Address error)\n", ioat_dma_chan_errmsk_cmpaddrerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " intcfgerr =\t%" PRIx8 "\t(Interrupt confiuguratio error)\n", ioat_dma_chan_errmsk_intcfgerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " unaffilerr =\t%" PRIx8 "\t(Unaffiliated Error)\n", ioat_dma_chan_errmsk_unaffilerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crc_err =\t%" PRIx8 "\t(CRC test failed)\n", ioat_dma_chan_errmsk_crc_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xorqerr =\t%" PRIx8 "\t(Xor error)\n", ioat_dma_chan_errmsk_xorqerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " desccnterr =\t%" PRIx8 "\t(Descriptor Count error)\n", ioat_dma_chan_errmsk_desccnterr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    return(_r);
}

static inline uint8_t ioat_dma_chan_errmsk_dmatranserr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_dmatranserr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_dmatranserr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_dmaxfererr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_dmaxfererr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_dmaxfererr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_nxtdescerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_nxtdescerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_nxtdescerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_descerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_descerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_descerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_chanaddr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_chanaddr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_chanaddr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_chancmderr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_chancmderr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_chancmderr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_cdataerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_cdataerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_cdataerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_dmadataerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_dmadataerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_dmadataerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_rddataerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_rddataerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_rddataerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_wrdataerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_wrdataerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_wrdataerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_descctrlerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_descctrlerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_descctrlerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_desclenerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_desclenerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_desclenerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_cmpaddrerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_cmpaddrerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_cmpaddrerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_intcfgerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_intcfgerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_intcfgerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_unaffilerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_unaffilerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_unaffilerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_crc_err_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_crc_err_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_crc_err_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_xorqerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_xorqerr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_xorqerr_extract(_regval));
}

static inline uint8_t ioat_dma_chan_errmsk_desccnterr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ioat_dma_chan_errmsk_desccnterr_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_errmsk_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x2c);
    return(ioat_dma_chan_errmsk_desccnterr_extract(_regval));
}

static inline void ioat_dma_chan_errmsk_dmatranserr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_dmatranserr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x1 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_errmsk_dmaxfererr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_dmaxfererr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x2 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_errmsk_nxtdescerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_nxtdescerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x4 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_errmsk_descerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_descerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x8 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_errmsk_chanaddr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_chanaddr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x10 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 4);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_errmsk_chancmderr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_chancmderr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x20 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 5);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_errmsk_cdataerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_cdataerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x40 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 6);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_errmsk_dmadataerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_dmadataerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x80 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 7);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_errmsk_rddataerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_rddataerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x100 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_errmsk_wrdataerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_wrdataerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x200 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_errmsk_descctrlerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_descctrlerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x400 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_errmsk_desclenerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_desclenerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x800 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_errmsk_cmpaddrerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_cmpaddrerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x1000 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 12);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_errmsk_intcfgerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_intcfgerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x2000 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 13);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_errmsk_crc_err_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_crc_err_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x10000 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_errmsk_xorqerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_xorqerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x20000 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ioat_dma_chan_errmsk_desccnterr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_errmsk_desccnterr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ioat_dma_chan_errmsk_t _regval = 0x40000 & (((ioat_dma_chan_errmsk_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfff84000 & mackerel_read_addr_32(_dev->chan_base, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x2c, _regval);
    // No shadow register to write to
}

/*
 * Register dcactrl: DCA Control Register
 * Type: ioat_dma_chan.dcactrl (Implicit type of DCA Control Register register)
 *   target_cpu	(size 16, offset 0, init 0):	RW	Specifies the APCI ID of the target CPU for compl writes
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline ioat_dma_chan_dcactrl_t ioat_dma_chan_dcactrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ioat_dma_chan_dcactrl_t ioat_dma_chan_dcactrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0x30));
}

static inline ioat_dma_chan_dcactrl_t ioat_dma_chan_dcactrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ioat_dma_chan_dcactrl_t ioat_dma_chan_dcactrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->chan_base, 0x30));
}

static inline void ioat_dma_chan_dcactrl_rawwr(__DN(t) *_dev, ioat_dma_chan_dcactrl_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_dcactrl_rawwr(__DN(t) *_dev, ioat_dma_chan_dcactrl_t _regval)
{
    mackerel_write_addr_32(_dev->chan_base, 0x30, _regval);
}

static inline void ioat_dma_chan_dcactrl_wr(__DN(t) *_dev, ioat_dma_chan_dcactrl_t _regval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_dcactrl_wr(__DN(t) *_dev, ioat_dma_chan_dcactrl_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->chan_base, 0x30)));
    mackerel_write_addr_32(_dev->chan_base, 0x30, _regval);
}

static inline int ioat_dma_chan_dcactrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ioat_dma_chan_dcactrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ioat_dma_chan_dcactrl_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dcactrl (DCA Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " target_cpu =\t%" PRIx16 "\t(Specifies the APCI ID of the target CPU for compl writes)\n", ioat_dma_chan_dcactrl_target_cpu_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t ioat_dma_chan_dcactrl_target_cpu_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ioat_dma_chan_dcactrl_target_cpu_rdf(__DN(t) *_dev)
{
    ioat_dma_chan_dcactrl_t _regval = mackerel_read_addr_32(_dev->chan_base, 0x30);
    return(ioat_dma_chan_dcactrl_target_cpu_extract(_regval));
}

static inline void ioat_dma_chan_dcactrl_target_cpu_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ioat_dma_chan_dcactrl_target_cpu_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    ioat_dma_chan_dcactrl_t _regval = 0xffff & (((ioat_dma_chan_dcactrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->chan_base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->chan_base, 0x30, _regval);
    // No shadow register to write to
}

static inline int ioat_dma_chan_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ioat_dma_chan_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device ioat_dma_chan (IOAT DMA (Crystal Beach) Channel registers):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ioat_dma_chan_ctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ioat_dma_chan_dma_comp_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ioat_dma_chan_cmd_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ioat_dma_chan_dmacount_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ioat_dma_chan_sts_lo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ioat_dma_chan_sts_hi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ioat_dma_chan_chainaddr_lo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ioat_dma_chan_chainaddr_hi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ioat_dma_chan_cmpl_lo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ioat_dma_chan_cmpl_hi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ioat_dma_chan_err_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ioat_dma_chan_errmsk_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ioat_dma_chan_dcactrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device ioat_dma_chan\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __ioat_dma_chan_DEV_H
