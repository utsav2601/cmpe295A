#ifndef __lpc_kbd_DEV_H
#define __lpc_kbd_DEV_H 1
/*
 * DEVICE DEFINITION: LPC Keyboard
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) lpc_kbd ## _ ## x
/*
 * Constants defn: lpc_kbd.cmd (Command)
 *  - no width specified
 */
typedef uint8_t lpc_kbd_cmd_t;
#define lpc_kbd_rd_ccmd ((lpc_kbd_cmd_t)0x20)
#define lpc_kbd_wr_ccmd ((lpc_kbd_cmd_t)0x60)
#define lpc_kbd_aux_disable ((lpc_kbd_cmd_t)0xa7)
#define lpc_kbd_aux_enable ((lpc_kbd_cmd_t)0xa8)
#define lpc_kbd_kbd_disable ((lpc_kbd_cmd_t)0xad)
#define lpc_kbd_kbd_enable ((lpc_kbd_cmd_t)0xae)
#define lpc_kbd_read_input ((lpc_kbd_cmd_t)0xc0)
#define lpc_kbd_poll_input_low ((lpc_kbd_cmd_t)0xc1)
#define lpc_kbd_poll_input_high ((lpc_kbd_cmd_t)0xc2)
#define lpc_kbd_read_output ((lpc_kbd_cmd_t)0xd0)
#define lpc_kbd_write_output ((lpc_kbd_cmd_t)0xd1)
#define lpc_kbd_write_kbd_out ((lpc_kbd_cmd_t)0xd2)
#define lpc_kbd_write_aux_out ((lpc_kbd_cmd_t)0xd3)
#define lpc_kbd_write_aux ((lpc_kbd_cmd_t)0xd4)

static inline char *lpc_kbd_cmd_describe(lpc_kbd_cmd_t _e) __attribute__ ((always_inline));
static inline char *lpc_kbd_cmd_describe(lpc_kbd_cmd_t _e)
{
    switch (_e) {
    case lpc_kbd_rd_ccmd:
        return("rd_ccmd: Read controller command byte");
    case lpc_kbd_wr_ccmd:
        return("wr_ccmd: Write controller command byte");
    case lpc_kbd_aux_disable:
        return("aux_disable: Disable auxiliary device interface");
    case lpc_kbd_aux_enable:
        return("aux_enable: Enable auxiliary device interface");
    case lpc_kbd_kbd_disable:
        return("kbd_disable: Disable keyboard interface");
    case lpc_kbd_kbd_enable:
        return("kbd_enable: Enable keyboard interface");
    case lpc_kbd_read_input:
        return("read_input: Read input port");
    case lpc_kbd_poll_input_low:
        return("poll_input_low: Poll input port low");
    case lpc_kbd_poll_input_high:
        return("poll_input_high: Poll input port high");
    case lpc_kbd_read_output:
        return("read_output: Read output port");
    case lpc_kbd_write_output:
        return("write_output: Write output port");
    case lpc_kbd_write_kbd_out:
        return("write_kbd_out: Write keyboard output buffer");
    case lpc_kbd_write_aux_out:
        return("write_aux_out: Write auxiliary device output buffer");
    case lpc_kbd_write_aux:
        return("write_aux: Write to auxiliary device");
    default:
        return(NULL);
    }
}

static inline int lpc_kbd_cmd_prtval(char *_s, size_t _size, lpc_kbd_cmd_t _e) __attribute__ ((always_inline));
static inline int lpc_kbd_cmd_prtval(char *_s, size_t _size, lpc_kbd_cmd_t _e)
{
    char *d = lpc_kbd_cmd_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "lpc_kbd_cmd_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: lpc_kbd_status_t
 * Description: Implicit type of Status register
 * Fields:
 *   obf	(size 1, offset 0, init 0):	RO	Output buffer full
 *   ibf	(size 1, offset 1, init 0):	RO	Input buffer full
 *   sf	(size 1, offset 2, init 0):	RO	System flag
 *   cd	(size 1, offset 3, init 0):	RO	Command/data
 *   is	(size 1, offset 4, init 0):	RO	Inhibit switch
 *   aobf	(size 1, offset 5, init 0):	RO	Auxiliary device output buffer full
 *   timeout	(size 1, offset 6, init 0):	RO	General timeout
 *   perr	(size 1, offset 7, init 0):	RO	Parity error
 */
typedef uint8_t lpc_kbd_status_t;
#define lpc_kbd_status_default 0x0
static inline uint8_t lpc_kbd_status_obf_extract(lpc_kbd_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_status_obf_extract(lpc_kbd_status_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline lpc_kbd_status_t lpc_kbd_status_obf_insert(lpc_kbd_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_kbd_status_t lpc_kbd_status_obf_insert(lpc_kbd_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((lpc_kbd_status_t )(_fieldval)) << 0)));
}

static inline uint8_t lpc_kbd_status_ibf_extract(lpc_kbd_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_status_ibf_extract(lpc_kbd_status_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline lpc_kbd_status_t lpc_kbd_status_ibf_insert(lpc_kbd_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_kbd_status_t lpc_kbd_status_ibf_insert(lpc_kbd_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((lpc_kbd_status_t )(_fieldval)) << 1)));
}

static inline uint8_t lpc_kbd_status_sf_extract(lpc_kbd_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_status_sf_extract(lpc_kbd_status_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline lpc_kbd_status_t lpc_kbd_status_sf_insert(lpc_kbd_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_kbd_status_t lpc_kbd_status_sf_insert(lpc_kbd_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((lpc_kbd_status_t )(_fieldval)) << 2)));
}

static inline uint8_t lpc_kbd_status_cd_extract(lpc_kbd_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_status_cd_extract(lpc_kbd_status_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline lpc_kbd_status_t lpc_kbd_status_cd_insert(lpc_kbd_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_kbd_status_t lpc_kbd_status_cd_insert(lpc_kbd_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((lpc_kbd_status_t )(_fieldval)) << 3)));
}

static inline uint8_t lpc_kbd_status_is_extract(lpc_kbd_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_status_is_extract(lpc_kbd_status_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline lpc_kbd_status_t lpc_kbd_status_is_insert(lpc_kbd_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_kbd_status_t lpc_kbd_status_is_insert(lpc_kbd_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((lpc_kbd_status_t )(_fieldval)) << 4)));
}

static inline uint8_t lpc_kbd_status_aobf_extract(lpc_kbd_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_status_aobf_extract(lpc_kbd_status_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline lpc_kbd_status_t lpc_kbd_status_aobf_insert(lpc_kbd_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_kbd_status_t lpc_kbd_status_aobf_insert(lpc_kbd_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdf) | (0x20 & (((lpc_kbd_status_t )(_fieldval)) << 5)));
}

static inline uint8_t lpc_kbd_status_timeout_extract(lpc_kbd_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_status_timeout_extract(lpc_kbd_status_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline lpc_kbd_status_t lpc_kbd_status_timeout_insert(lpc_kbd_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_kbd_status_t lpc_kbd_status_timeout_insert(lpc_kbd_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbf) | (0x40 & (((lpc_kbd_status_t )(_fieldval)) << 6)));
}

static inline uint8_t lpc_kbd_status_perr_extract(lpc_kbd_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_status_perr_extract(lpc_kbd_status_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline lpc_kbd_status_t lpc_kbd_status_perr_insert(lpc_kbd_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_kbd_status_t lpc_kbd_status_perr_insert(lpc_kbd_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7f) | (0x80 & (((lpc_kbd_status_t )(_fieldval)) << 7)));
}

static inline int lpc_kbd_status_prtval(char *_s, size_t _size, lpc_kbd_status_t _regval) __attribute__ ((always_inline));
static inline int lpc_kbd_status_prtval(char *_s, size_t _size, lpc_kbd_status_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " obf =\t%" PRIx8 "\t(Output buffer full)\n", lpc_kbd_status_obf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ibf =\t%" PRIx8 "\t(Input buffer full)\n", lpc_kbd_status_ibf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sf =\t%" PRIx8 "\t(System flag)\n", lpc_kbd_status_sf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cd =\t%" PRIx8 "\t(Command/data)\n", lpc_kbd_status_cd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " is =\t%" PRIx8 "\t(Inhibit switch)\n", lpc_kbd_status_is_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aobf =\t%" PRIx8 "\t(Auxiliary device output buffer full)\n", lpc_kbd_status_aobf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " timeout =\t%" PRIx8 "\t(General timeout)\n", lpc_kbd_status_timeout_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " perr =\t%" PRIx8 "\t(Parity error)\n", lpc_kbd_status_perr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: lpc_kbd_command_t
 * Description: Implicit type of Command register
 * Fields:
 *   cmd	(size 8, offset 0, init 0):	WO	Command
 */
typedef uint8_t lpc_kbd_command_t;
#define lpc_kbd_command_default 0x0
static inline lpc_kbd_cmd_t lpc_kbd_command_cmd_extract(lpc_kbd_command_t _regval) __attribute__ ((always_inline));
static inline lpc_kbd_cmd_t lpc_kbd_command_cmd_extract(lpc_kbd_command_t _regval)
{
    return((lpc_kbd_cmd_t )((_regval & 0xff) >> 0));
}

static inline lpc_kbd_command_t lpc_kbd_command_cmd_insert(lpc_kbd_command_t _regval, lpc_kbd_cmd_t _fieldval) __attribute__ ((always_inline));
static inline lpc_kbd_command_t lpc_kbd_command_cmd_insert(lpc_kbd_command_t _regval, lpc_kbd_cmd_t _fieldval)
{
    return((_regval & 0x0) | (0xff & (((lpc_kbd_command_t )(_fieldval)) << 0)));
}

static inline int lpc_kbd_command_prtval(char *_s, size_t _size, lpc_kbd_command_t _regval) __attribute__ ((always_inline));
static inline int lpc_kbd_command_prtval(char *_s, size_t _size, lpc_kbd_command_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmd =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_kbd_cmd_prtval(_s + _r, _avail, lpc_kbd_command_cmd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Command)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: lpc_kbd_ccmd_t
 * Description: Controller command byte
 * Fields:
 *   kbd_int	(size 1, offset 0, init 0):	NOATTR	Enable keyboard interrupt
 *   aux_int	(size 1, offset 1, init 0):	NOATTR	Enable auxiliary interrupt
 *   sysflg	(size 1, offset 2, init 0):	NOATTR	System flag
 *   _anon3	(size 1, offset 3, init 0):	RSVD	_
 *   kbd_dis	(size 1, offset 4, init 0):	NOATTR	Disable keyboard
 *   aux_dis	(size 1, offset 5, init 0):	NOATTR	Disable auxiliary device
 *   kbd_xl	(size 1, offset 6, init 0):	NOATTR	Keyboard translate
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 */
typedef uint8_t lpc_kbd_ccmd_t;
#define lpc_kbd_ccmd_default 0x0
static inline uint8_t lpc_kbd_ccmd_kbd_int_extract(lpc_kbd_ccmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_ccmd_kbd_int_extract(lpc_kbd_ccmd_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline lpc_kbd_ccmd_t lpc_kbd_ccmd_kbd_int_insert(lpc_kbd_ccmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_kbd_ccmd_t lpc_kbd_ccmd_kbd_int_insert(lpc_kbd_ccmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((lpc_kbd_ccmd_t )(_fieldval)) << 0)));
}

static inline uint8_t lpc_kbd_ccmd_aux_int_extract(lpc_kbd_ccmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_ccmd_aux_int_extract(lpc_kbd_ccmd_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline lpc_kbd_ccmd_t lpc_kbd_ccmd_aux_int_insert(lpc_kbd_ccmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_kbd_ccmd_t lpc_kbd_ccmd_aux_int_insert(lpc_kbd_ccmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((lpc_kbd_ccmd_t )(_fieldval)) << 1)));
}

static inline uint8_t lpc_kbd_ccmd_sysflg_extract(lpc_kbd_ccmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_ccmd_sysflg_extract(lpc_kbd_ccmd_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline lpc_kbd_ccmd_t lpc_kbd_ccmd_sysflg_insert(lpc_kbd_ccmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_kbd_ccmd_t lpc_kbd_ccmd_sysflg_insert(lpc_kbd_ccmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((lpc_kbd_ccmd_t )(_fieldval)) << 2)));
}

static inline uint8_t lpc_kbd_ccmd_kbd_dis_extract(lpc_kbd_ccmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_ccmd_kbd_dis_extract(lpc_kbd_ccmd_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline lpc_kbd_ccmd_t lpc_kbd_ccmd_kbd_dis_insert(lpc_kbd_ccmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_kbd_ccmd_t lpc_kbd_ccmd_kbd_dis_insert(lpc_kbd_ccmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((lpc_kbd_ccmd_t )(_fieldval)) << 4)));
}

static inline uint8_t lpc_kbd_ccmd_aux_dis_extract(lpc_kbd_ccmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_ccmd_aux_dis_extract(lpc_kbd_ccmd_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline lpc_kbd_ccmd_t lpc_kbd_ccmd_aux_dis_insert(lpc_kbd_ccmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_kbd_ccmd_t lpc_kbd_ccmd_aux_dis_insert(lpc_kbd_ccmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdf) | (0x20 & (((lpc_kbd_ccmd_t )(_fieldval)) << 5)));
}

static inline uint8_t lpc_kbd_ccmd_kbd_xl_extract(lpc_kbd_ccmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_ccmd_kbd_xl_extract(lpc_kbd_ccmd_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline lpc_kbd_ccmd_t lpc_kbd_ccmd_kbd_xl_insert(lpc_kbd_ccmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline lpc_kbd_ccmd_t lpc_kbd_ccmd_kbd_xl_insert(lpc_kbd_ccmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbf) | (0x40 & (((lpc_kbd_ccmd_t )(_fieldval)) << 6)));
}

static inline int lpc_kbd_ccmd_prtval(char *_s, size_t _size, lpc_kbd_ccmd_t _regval) __attribute__ ((always_inline));
static inline int lpc_kbd_ccmd_prtval(char *_s, size_t _size, lpc_kbd_ccmd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kbd_int =\t%" PRIx8 "\t(Enable keyboard interrupt)\n", lpc_kbd_ccmd_kbd_int_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aux_int =\t%" PRIx8 "\t(Enable auxiliary interrupt)\n", lpc_kbd_ccmd_aux_int_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sysflg =\t%" PRIx8 "\t(System flag)\n", lpc_kbd_ccmd_sysflg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kbd_dis =\t%" PRIx8 "\t(Disable keyboard)\n", lpc_kbd_ccmd_kbd_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aux_dis =\t%" PRIx8 "\t(Disable auxiliary device)\n", lpc_kbd_ccmd_aux_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kbd_xl =\t%" PRIx8 "\t(Keyboard translate)\n", lpc_kbd_ccmd_kbd_xl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_io_t base;
    uint8_t output_shadow;
    lpc_kbd_command_t command_shadow;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum lpc_kbd_initials {
    lpc_kbd_input_initial = 0x0,
    lpc_kbd_status_initial = 0x0,
    lpc_kbd_output_initial = 0x0,
    lpc_kbd_command_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void lpc_kbd_initialize(__DN(t) *_dev, mackerel_io_t base) __attribute__ ((always_inline));
static inline void lpc_kbd_initialize(__DN(t) *_dev, mackerel_io_t base)
{
    _dev->base = base;
}

/*
 * Register input: Input
 * Type: lpc_kbd.uint8 (primitive type)
 */
static inline uint8_t lpc_kbd_input_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_input_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x0));
}

static inline uint8_t lpc_kbd_input_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_input_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x0));
}

static inline void lpc_kbd_input_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void lpc_kbd_input_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x0, _regval);
}

// Register input is not writeable
static inline int lpc_kbd_input_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int lpc_kbd_input_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_io_8(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register input (Input): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register status: Status
 * Type: lpc_kbd.status (Implicit type of Status register)
 *   obf	(size 1, offset 0, init 0):	RO	Output buffer full
 *   ibf	(size 1, offset 1, init 0):	RO	Input buffer full
 *   sf	(size 1, offset 2, init 0):	RO	System flag
 *   cd	(size 1, offset 3, init 0):	RO	Command/data
 *   is	(size 1, offset 4, init 0):	RO	Inhibit switch
 *   aobf	(size 1, offset 5, init 0):	RO	Auxiliary device output buffer full
 *   timeout	(size 1, offset 6, init 0):	RO	General timeout
 *   perr	(size 1, offset 7, init 0):	RO	Parity error
 */
static inline lpc_kbd_status_t lpc_kbd_status_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline lpc_kbd_status_t lpc_kbd_status_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x4));
}

static inline lpc_kbd_status_t lpc_kbd_status_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline lpc_kbd_status_t lpc_kbd_status_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x4));
}

static inline void lpc_kbd_status_rawwr(__DN(t) *_dev, lpc_kbd_status_t _regval) __attribute__ ((always_inline));
static inline void lpc_kbd_status_rawwr(__DN(t) *_dev, lpc_kbd_status_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x4, _regval);
}

// Register status is not writeable
static inline int lpc_kbd_status_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int lpc_kbd_status_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    lpc_kbd_status_t _regval = mackerel_read_io_8(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register status (Status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " obf =\t%" PRIx8 "\t(Output buffer full)\n", lpc_kbd_status_obf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ibf =\t%" PRIx8 "\t(Input buffer full)\n", lpc_kbd_status_ibf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sf =\t%" PRIx8 "\t(System flag)\n", lpc_kbd_status_sf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cd =\t%" PRIx8 "\t(Command/data)\n", lpc_kbd_status_cd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " is =\t%" PRIx8 "\t(Inhibit switch)\n", lpc_kbd_status_is_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aobf =\t%" PRIx8 "\t(Auxiliary device output buffer full)\n", lpc_kbd_status_aobf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " timeout =\t%" PRIx8 "\t(General timeout)\n", lpc_kbd_status_timeout_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " perr =\t%" PRIx8 "\t(Parity error)\n", lpc_kbd_status_perr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t lpc_kbd_status_obf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_status_obf_rdf(__DN(t) *_dev)
{
    lpc_kbd_status_t _regval = mackerel_read_io_8(_dev->base, 0x4);
    return(lpc_kbd_status_obf_extract(_regval));
}

static inline uint8_t lpc_kbd_status_ibf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_status_ibf_rdf(__DN(t) *_dev)
{
    lpc_kbd_status_t _regval = mackerel_read_io_8(_dev->base, 0x4);
    return(lpc_kbd_status_ibf_extract(_regval));
}

static inline uint8_t lpc_kbd_status_sf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_status_sf_rdf(__DN(t) *_dev)
{
    lpc_kbd_status_t _regval = mackerel_read_io_8(_dev->base, 0x4);
    return(lpc_kbd_status_sf_extract(_regval));
}

static inline uint8_t lpc_kbd_status_cd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_status_cd_rdf(__DN(t) *_dev)
{
    lpc_kbd_status_t _regval = mackerel_read_io_8(_dev->base, 0x4);
    return(lpc_kbd_status_cd_extract(_regval));
}

static inline uint8_t lpc_kbd_status_is_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_status_is_rdf(__DN(t) *_dev)
{
    lpc_kbd_status_t _regval = mackerel_read_io_8(_dev->base, 0x4);
    return(lpc_kbd_status_is_extract(_regval));
}

static inline uint8_t lpc_kbd_status_aobf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_status_aobf_rdf(__DN(t) *_dev)
{
    lpc_kbd_status_t _regval = mackerel_read_io_8(_dev->base, 0x4);
    return(lpc_kbd_status_aobf_extract(_regval));
}

static inline uint8_t lpc_kbd_status_timeout_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_status_timeout_rdf(__DN(t) *_dev)
{
    lpc_kbd_status_t _regval = mackerel_read_io_8(_dev->base, 0x4);
    return(lpc_kbd_status_timeout_extract(_regval));
}

static inline uint8_t lpc_kbd_status_perr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_status_perr_rdf(__DN(t) *_dev)
{
    lpc_kbd_status_t _regval = mackerel_read_io_8(_dev->base, 0x4);
    return(lpc_kbd_status_perr_extract(_regval));
}

/*
 * Register output: Output
 * Type: lpc_kbd.uint8 (primitive type)
 */
static inline uint8_t lpc_kbd_output_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_output_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x0));
}

static inline uint8_t lpc_kbd_output_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t lpc_kbd_output_rd(__DN(t) *_dev)
{
    return(_dev->output_shadow);
}

static inline void lpc_kbd_output_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void lpc_kbd_output_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x0, _regval);
}

static inline void lpc_kbd_output_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void lpc_kbd_output_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->base, 0x0, _regval);
}

static inline int lpc_kbd_output_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int lpc_kbd_output_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = _dev->output_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register output (Output): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 " (SHADOW copy)\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register command: Command
 * Type: lpc_kbd.command (Implicit type of Command register)
 *   cmd	(size 8, offset 0, init 0):	WO	Command
 */
static inline lpc_kbd_command_t lpc_kbd_command_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline lpc_kbd_command_t lpc_kbd_command_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x4));
}

static inline lpc_kbd_command_t lpc_kbd_command_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline lpc_kbd_command_t lpc_kbd_command_rd(__DN(t) *_dev)
{
    return(_dev->command_shadow);
}

static inline void lpc_kbd_command_rawwr(__DN(t) *_dev, lpc_kbd_command_t _regval) __attribute__ ((always_inline));
static inline void lpc_kbd_command_rawwr(__DN(t) *_dev, lpc_kbd_command_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x4, _regval);
}

static inline void lpc_kbd_command_wr(__DN(t) *_dev, lpc_kbd_command_t _regval) __attribute__ ((always_inline));
static inline void lpc_kbd_command_wr(__DN(t) *_dev, lpc_kbd_command_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->base, 0x4, _regval);
}

static inline int lpc_kbd_command_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int lpc_kbd_command_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    lpc_kbd_command_t _regval = _dev->command_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register command (Command): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmd =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_kbd_cmd_prtval(_s + _r, _avail, lpc_kbd_command_cmd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Command)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline lpc_kbd_cmd_t lpc_kbd_command_cmd_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline lpc_kbd_cmd_t lpc_kbd_command_cmd_rd_shadow(__DN(t) *_dev)
{
    return(lpc_kbd_command_cmd_extract(_dev->command_shadow));
}

static inline void lpc_kbd_command_cmd_wrf(__DN(t) *_dev, lpc_kbd_cmd_t _fieldval) __attribute__ ((always_inline));
static inline void lpc_kbd_command_cmd_wrf(__DN(t) *_dev, lpc_kbd_cmd_t _fieldval)
{
    lpc_kbd_command_t _regval = 0xff & (((lpc_kbd_command_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x4, _regval);
    _dev->command_shadow = _regval;
}

static inline int lpc_kbd_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int lpc_kbd_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device lpc_kbd (LPC Keyboard):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_kbd_input_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_kbd_status_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_kbd_output_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = lpc_kbd_command_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device lpc_kbd\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __lpc_kbd_DEV_H
