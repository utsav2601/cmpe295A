#ifndef __fat_direntry_DEV_H
#define __fat_direntry_DEV_H 1
/*
 * DEVICE DEFINITION: FAT 16 Directory Entry
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) fat_direntry ## _ ## x
/*
 * Register type: fat_direntry_attr_t
 * Description: Implicit type of File Attributes register
 * Fields:
 *   ro	(size 1, offset 0, init 0):	RW	Read only
 *   hid	(size 1, offset 1, init 0):	RW	Hidden
 *   sys	(size 1, offset 2, init 0):	RW	System file
 *   vlb	(size 1, offset 3, init 0):	RW	Volume label
 *   dir	(size 1, offset 4, init 0):	RW	Directory
 *   ar	(size 1, offset 5, init 0):	RW	Archive
 *   _anon6	(size 2, offset 6, init 0):	RSVD	_
 */
typedef uint8_t fat_direntry_attr_t;
#define fat_direntry_attr_default 0x0
static inline uint8_t fat_direntry_attr_ro_extract(fat_direntry_attr_t _regval) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_attr_ro_extract(fat_direntry_attr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline fat_direntry_attr_t fat_direntry_attr_ro_insert(fat_direntry_attr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline fat_direntry_attr_t fat_direntry_attr_ro_insert(fat_direntry_attr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((fat_direntry_attr_t )(_fieldval)) << 0)));
}

static inline uint8_t fat_direntry_attr_hid_extract(fat_direntry_attr_t _regval) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_attr_hid_extract(fat_direntry_attr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline fat_direntry_attr_t fat_direntry_attr_hid_insert(fat_direntry_attr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline fat_direntry_attr_t fat_direntry_attr_hid_insert(fat_direntry_attr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((fat_direntry_attr_t )(_fieldval)) << 1)));
}

static inline uint8_t fat_direntry_attr_sys_extract(fat_direntry_attr_t _regval) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_attr_sys_extract(fat_direntry_attr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline fat_direntry_attr_t fat_direntry_attr_sys_insert(fat_direntry_attr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline fat_direntry_attr_t fat_direntry_attr_sys_insert(fat_direntry_attr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((fat_direntry_attr_t )(_fieldval)) << 2)));
}

static inline uint8_t fat_direntry_attr_vlb_extract(fat_direntry_attr_t _regval) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_attr_vlb_extract(fat_direntry_attr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline fat_direntry_attr_t fat_direntry_attr_vlb_insert(fat_direntry_attr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline fat_direntry_attr_t fat_direntry_attr_vlb_insert(fat_direntry_attr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((fat_direntry_attr_t )(_fieldval)) << 3)));
}

static inline uint8_t fat_direntry_attr_dir_extract(fat_direntry_attr_t _regval) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_attr_dir_extract(fat_direntry_attr_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline fat_direntry_attr_t fat_direntry_attr_dir_insert(fat_direntry_attr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline fat_direntry_attr_t fat_direntry_attr_dir_insert(fat_direntry_attr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((fat_direntry_attr_t )(_fieldval)) << 4)));
}

static inline uint8_t fat_direntry_attr_ar_extract(fat_direntry_attr_t _regval) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_attr_ar_extract(fat_direntry_attr_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline fat_direntry_attr_t fat_direntry_attr_ar_insert(fat_direntry_attr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline fat_direntry_attr_t fat_direntry_attr_ar_insert(fat_direntry_attr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdf) | (0x20 & (((fat_direntry_attr_t )(_fieldval)) << 5)));
}

static inline int fat_direntry_attr_prtval(char *_s, size_t _size, fat_direntry_attr_t _regval) __attribute__ ((always_inline));
static inline int fat_direntry_attr_prtval(char *_s, size_t _size, fat_direntry_attr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ro =\t%" PRIx8 "\t(Read only)\n", fat_direntry_attr_ro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hid =\t%" PRIx8 "\t(Hidden)\n", fat_direntry_attr_hid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys =\t%" PRIx8 "\t(System file)\n", fat_direntry_attr_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlb =\t%" PRIx8 "\t(Volume label)\n", fat_direntry_attr_vlb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dir =\t%" PRIx8 "\t(Directory)\n", fat_direntry_attr_dir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ar =\t%" PRIx8 "\t(Archive)\n", fat_direntry_attr_ar_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: fat_direntry_lwr_t
 * Description: Implicit type of Base and extension case register
 * Fields:
 *   _anon0	(size 3, offset 0, init 0):	RSVD	_
 *   bl	(size 1, offset 3, init 0):	RW	Base is lowercase
 *   el	(size 1, offset 4, init 0):	RW	Extension is lowercase
 *   _anon5	(size 3, offset 5, init 0):	RSVD	_
 */
typedef uint8_t fat_direntry_lwr_t;
#define fat_direntry_lwr_default 0x0
static inline uint8_t fat_direntry_lwr_bl_extract(fat_direntry_lwr_t _regval) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_lwr_bl_extract(fat_direntry_lwr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline fat_direntry_lwr_t fat_direntry_lwr_bl_insert(fat_direntry_lwr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline fat_direntry_lwr_t fat_direntry_lwr_bl_insert(fat_direntry_lwr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((fat_direntry_lwr_t )(_fieldval)) << 3)));
}

static inline uint8_t fat_direntry_lwr_el_extract(fat_direntry_lwr_t _regval) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_lwr_el_extract(fat_direntry_lwr_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline fat_direntry_lwr_t fat_direntry_lwr_el_insert(fat_direntry_lwr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline fat_direntry_lwr_t fat_direntry_lwr_el_insert(fat_direntry_lwr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((fat_direntry_lwr_t )(_fieldval)) << 4)));
}

static inline int fat_direntry_lwr_prtval(char *_s, size_t _size, fat_direntry_lwr_t _regval) __attribute__ ((always_inline));
static inline int fat_direntry_lwr_prtval(char *_s, size_t _size, fat_direntry_lwr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bl =\t%" PRIx8 "\t(Base is lowercase)\n", fat_direntry_lwr_bl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " el =\t%" PRIx8 "\t(Extension is lowercase)\n", fat_direntry_lwr_el_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: fat_direntry_time_t
 * Description: Time
 * Fields:
 *   dsec	(size 5, offset 0, init 0):	NOATTR	Double seconds (0-29)
 *   min	(size 6, offset 5, init 0):	NOATTR	Minutes
 *   hour	(size 5, offset 11, init 0):	NOATTR	Hour
 */
typedef uint16_t fat_direntry_time_t;
#define fat_direntry_time_default 0x0
static inline uint8_t fat_direntry_time_dsec_extract(fat_direntry_time_t _regval) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_time_dsec_extract(fat_direntry_time_t _regval)
{
    return((uint8_t )((_regval & 0x1f) >> 0));
}

static inline fat_direntry_time_t fat_direntry_time_dsec_insert(fat_direntry_time_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline fat_direntry_time_t fat_direntry_time_dsec_insert(fat_direntry_time_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffe0) | (0x1f & (((fat_direntry_time_t )(_fieldval)) << 0)));
}

static inline uint8_t fat_direntry_time_min_extract(fat_direntry_time_t _regval) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_time_min_extract(fat_direntry_time_t _regval)
{
    return((uint8_t )((_regval & 0x7e0) >> 5));
}

static inline fat_direntry_time_t fat_direntry_time_min_insert(fat_direntry_time_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline fat_direntry_time_t fat_direntry_time_min_insert(fat_direntry_time_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf81f) | (0x7e0 & (((fat_direntry_time_t )(_fieldval)) << 5)));
}

static inline uint8_t fat_direntry_time_hour_extract(fat_direntry_time_t _regval) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_time_hour_extract(fat_direntry_time_t _regval)
{
    return((uint8_t )((_regval & 0xf800) >> 11));
}

static inline fat_direntry_time_t fat_direntry_time_hour_insert(fat_direntry_time_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline fat_direntry_time_t fat_direntry_time_hour_insert(fat_direntry_time_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7ff) | (0xf800 & (((fat_direntry_time_t )(_fieldval)) << 11)));
}

static inline int fat_direntry_time_prtval(char *_s, size_t _size, fat_direntry_time_t _regval) __attribute__ ((always_inline));
static inline int fat_direntry_time_prtval(char *_s, size_t _size, fat_direntry_time_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsec =\t%" PRIx8 "\t(Double seconds (0-29))\n", fat_direntry_time_dsec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " min =\t%" PRIx8 "\t(Minutes)\n", fat_direntry_time_min_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hour =\t%" PRIx8 "\t(Hour)\n", fat_direntry_time_hour_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: fat_direntry_date_t
 * Description: Date
 * Fields:
 *   day	(size 5, offset 0, init 0):	NOATTR	Day of month
 *   mnth	(size 4, offset 5, init 0):	NOATTR	Month of year
 *   yr	(size 7, offset 9, init 0):	NOATTR	Years from 1980
 */
typedef uint16_t fat_direntry_date_t;
#define fat_direntry_date_default 0x0
static inline uint8_t fat_direntry_date_day_extract(fat_direntry_date_t _regval) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_date_day_extract(fat_direntry_date_t _regval)
{
    return((uint8_t )((_regval & 0x1f) >> 0));
}

static inline fat_direntry_date_t fat_direntry_date_day_insert(fat_direntry_date_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline fat_direntry_date_t fat_direntry_date_day_insert(fat_direntry_date_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffe0) | (0x1f & (((fat_direntry_date_t )(_fieldval)) << 0)));
}

static inline uint8_t fat_direntry_date_mnth_extract(fat_direntry_date_t _regval) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_date_mnth_extract(fat_direntry_date_t _regval)
{
    return((uint8_t )((_regval & 0x1e0) >> 5));
}

static inline fat_direntry_date_t fat_direntry_date_mnth_insert(fat_direntry_date_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline fat_direntry_date_t fat_direntry_date_mnth_insert(fat_direntry_date_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe1f) | (0x1e0 & (((fat_direntry_date_t )(_fieldval)) << 5)));
}

static inline uint8_t fat_direntry_date_yr_extract(fat_direntry_date_t _regval) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_date_yr_extract(fat_direntry_date_t _regval)
{
    return((uint8_t )((_regval & 0xfe00) >> 9));
}

static inline fat_direntry_date_t fat_direntry_date_yr_insert(fat_direntry_date_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline fat_direntry_date_t fat_direntry_date_yr_insert(fat_direntry_date_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x1ff) | (0xfe00 & (((fat_direntry_date_t )(_fieldval)) << 9)));
}

static inline int fat_direntry_date_prtval(char *_s, size_t _size, fat_direntry_date_t _regval) __attribute__ ((always_inline));
static inline int fat_direntry_date_prtval(char *_s, size_t _size, fat_direntry_date_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " day =\t%" PRIx8 "\t(Day of month)\n", fat_direntry_date_day_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mnth =\t%" PRIx8 "\t(Month of year)\n", fat_direntry_date_mnth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " yr =\t%" PRIx8 "\t(Years from 1980)\n", fat_direntry_date_yr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t b;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum fat_direntry_initials {
    fat_direntry_fn_initial = 0x0,
    fat_direntry_ext_initial = 0x0,
    fat_direntry_attr_initial = 0x0,
    fat_direntry_lwr_initial = 0x0,
    fat_direntry_ctms_initial = 0x0,
    fat_direntry_ctime_initial = 0x0,
    fat_direntry_cdate_initial = 0x0,
    fat_direntry_adate_initial = 0x0,
    fat_direntry_starth_initial = 0x0,
    fat_direntry_wtime_initial = 0x0,
    fat_direntry_wdate_initial = 0x0,
    fat_direntry_start_initial = 0x0,
    fat_direntry_size_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void fat_direntry_initialize(__DN(t) *_dev, mackerel_addr_t b) __attribute__ ((always_inline));
static inline void fat_direntry_initialize(__DN(t) *_dev, mackerel_addr_t b)
{
    _dev->b = b;
}

/*
 * Register array fn: Filename
 * Type: fat_direntry.uint8 (primitive type)
 */
static const size_t fat_direntry_fn_length = 8;
static inline uint8_t fat_direntry_fn_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_fn_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->b, 0x0 + (_i * (8 / 8))));
}

static inline uint8_t fat_direntry_fn_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_fn_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->b, 0x0 + (_i * (8 / 8))));
}

static inline void fat_direntry_fn_rawwr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_fn_rawwr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->b, 0x0 + (_i * (8 / 8)), _regval);
}

static inline void fat_direntry_fn_wr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_fn_wr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->b, 0x0 + (_i * (8 / 8)), _regval);
}

static inline int fat_direntry_fn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int fat_direntry_fn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->b, 0x0 + (_i * (8 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "fn", _i, "Filename");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int fat_direntry_fn_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_direntry_fn_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = fat_direntry_fn_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array ext: Filename extension
 * Type: fat_direntry.uint8 (primitive type)
 */
static const size_t fat_direntry_ext_length = 3;
static inline uint8_t fat_direntry_ext_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_ext_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->b, 0x8 + (_i * (8 / 8))));
}

static inline uint8_t fat_direntry_ext_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_ext_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->b, 0x8 + (_i * (8 / 8))));
}

static inline void fat_direntry_ext_rawwr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_ext_rawwr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->b, 0x8 + (_i * (8 / 8)), _regval);
}

static inline void fat_direntry_ext_wr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_ext_wr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->b, 0x8 + (_i * (8 / 8)), _regval);
}

static inline int fat_direntry_ext_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int fat_direntry_ext_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->b, 0x8 + (_i * (8 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ext", _i, "Filename extension");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int fat_direntry_ext_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_direntry_ext_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 3; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = fat_direntry_ext_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register attr: File Attributes
 * Type: fat_direntry.attr (Implicit type of File Attributes register)
 *   ro	(size 1, offset 0, init 0):	RW	Read only
 *   hid	(size 1, offset 1, init 0):	RW	Hidden
 *   sys	(size 1, offset 2, init 0):	RW	System file
 *   vlb	(size 1, offset 3, init 0):	RW	Volume label
 *   dir	(size 1, offset 4, init 0):	RW	Directory
 *   ar	(size 1, offset 5, init 0):	RW	Archive
 *   _anon6	(size 2, offset 6, init 0):	RSVD	_
 */
static inline fat_direntry_attr_t fat_direntry_attr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline fat_direntry_attr_t fat_direntry_attr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0xb));
}

static inline fat_direntry_attr_t fat_direntry_attr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline fat_direntry_attr_t fat_direntry_attr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0xb));
}

static inline void fat_direntry_attr_rawwr(__DN(t) *_dev, fat_direntry_attr_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_attr_rawwr(__DN(t) *_dev, fat_direntry_attr_t _regval)
{
    mackerel_write_addr_8(_dev->b, 0xb, _regval);
}

static inline void fat_direntry_attr_wr(__DN(t) *_dev, fat_direntry_attr_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_attr_wr(__DN(t) *_dev, fat_direntry_attr_t _regval)
{
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    _regval = (_regval | (0xc0 & mackerel_read_addr_8(_dev->b, 0xb)));
    mackerel_write_addr_8(_dev->b, 0xb, _regval);
}

static inline int fat_direntry_attr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_direntry_attr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    fat_direntry_attr_t _regval = mackerel_read_addr_8(_dev->b, 0xb);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register attr (File Attributes): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ro =\t%" PRIx8 "\t(Read only)\n", fat_direntry_attr_ro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hid =\t%" PRIx8 "\t(Hidden)\n", fat_direntry_attr_hid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sys =\t%" PRIx8 "\t(System file)\n", fat_direntry_attr_sys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlb =\t%" PRIx8 "\t(Volume label)\n", fat_direntry_attr_vlb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dir =\t%" PRIx8 "\t(Directory)\n", fat_direntry_attr_dir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ar =\t%" PRIx8 "\t(Archive)\n", fat_direntry_attr_ar_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    return(_r);
}

static inline uint8_t fat_direntry_attr_ro_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_attr_ro_rdf(__DN(t) *_dev)
{
    fat_direntry_attr_t _regval = mackerel_read_addr_8(_dev->b, 0xb);
    return(fat_direntry_attr_ro_extract(_regval));
}

static inline uint8_t fat_direntry_attr_hid_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_attr_hid_rdf(__DN(t) *_dev)
{
    fat_direntry_attr_t _regval = mackerel_read_addr_8(_dev->b, 0xb);
    return(fat_direntry_attr_hid_extract(_regval));
}

static inline uint8_t fat_direntry_attr_sys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_attr_sys_rdf(__DN(t) *_dev)
{
    fat_direntry_attr_t _regval = mackerel_read_addr_8(_dev->b, 0xb);
    return(fat_direntry_attr_sys_extract(_regval));
}

static inline uint8_t fat_direntry_attr_vlb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_attr_vlb_rdf(__DN(t) *_dev)
{
    fat_direntry_attr_t _regval = mackerel_read_addr_8(_dev->b, 0xb);
    return(fat_direntry_attr_vlb_extract(_regval));
}

static inline uint8_t fat_direntry_attr_dir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_attr_dir_rdf(__DN(t) *_dev)
{
    fat_direntry_attr_t _regval = mackerel_read_addr_8(_dev->b, 0xb);
    return(fat_direntry_attr_dir_extract(_regval));
}

static inline uint8_t fat_direntry_attr_ar_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_attr_ar_rdf(__DN(t) *_dev)
{
    fat_direntry_attr_t _regval = mackerel_read_addr_8(_dev->b, 0xb);
    return(fat_direntry_attr_ar_extract(_regval));
}

static inline void fat_direntry_attr_ro_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_attr_ro_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_attr_t _regval = 0x1 & (((fat_direntry_attr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfe & mackerel_read_addr_8(_dev->b, 0xb)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->b, 0xb, _regval);
    // No shadow register to write to
}

static inline void fat_direntry_attr_hid_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_attr_hid_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_attr_t _regval = 0x2 & (((fat_direntry_attr_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfd & mackerel_read_addr_8(_dev->b, 0xb)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->b, 0xb, _regval);
    // No shadow register to write to
}

static inline void fat_direntry_attr_sys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_attr_sys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_attr_t _regval = 0x4 & (((fat_direntry_attr_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfb & mackerel_read_addr_8(_dev->b, 0xb)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->b, 0xb, _regval);
    // No shadow register to write to
}

static inline void fat_direntry_attr_vlb_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_attr_vlb_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_attr_t _regval = 0x8 & (((fat_direntry_attr_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf7 & mackerel_read_addr_8(_dev->b, 0xb)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->b, 0xb, _regval);
    // No shadow register to write to
}

static inline void fat_direntry_attr_dir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_attr_dir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_attr_t _regval = 0x10 & (((fat_direntry_attr_t )(_fieldval)) << 4);
    _regval = (_regval | (0xef & mackerel_read_addr_8(_dev->b, 0xb)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->b, 0xb, _regval);
    // No shadow register to write to
}

static inline void fat_direntry_attr_ar_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_attr_ar_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_attr_t _regval = 0x20 & (((fat_direntry_attr_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdf & mackerel_read_addr_8(_dev->b, 0xb)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->b, 0xb, _regval);
    // No shadow register to write to
}

/*
 * Register lwr: Base and extension case
 * Type: fat_direntry.lwr (Implicit type of Base and extension case register)
 *   _anon0	(size 3, offset 0, init 0):	RSVD	_
 *   bl	(size 1, offset 3, init 0):	RW	Base is lowercase
 *   el	(size 1, offset 4, init 0):	RW	Extension is lowercase
 *   _anon5	(size 3, offset 5, init 0):	RSVD	_
 */
static inline fat_direntry_lwr_t fat_direntry_lwr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline fat_direntry_lwr_t fat_direntry_lwr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0xc));
}

static inline fat_direntry_lwr_t fat_direntry_lwr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline fat_direntry_lwr_t fat_direntry_lwr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0xc));
}

static inline void fat_direntry_lwr_rawwr(__DN(t) *_dev, fat_direntry_lwr_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_lwr_rawwr(__DN(t) *_dev, fat_direntry_lwr_t _regval)
{
    mackerel_write_addr_8(_dev->b, 0xc, _regval);
}

static inline void fat_direntry_lwr_wr(__DN(t) *_dev, fat_direntry_lwr_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_lwr_wr(__DN(t) *_dev, fat_direntry_lwr_t _regval)
{
    _regval = (_regval & 0x18);
    // No MB1 fields present
    _regval = (_regval | (0xe7 & mackerel_read_addr_8(_dev->b, 0xc)));
    mackerel_write_addr_8(_dev->b, 0xc, _regval);
}

static inline int fat_direntry_lwr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_direntry_lwr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    fat_direntry_lwr_t _regval = mackerel_read_addr_8(_dev->b, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lwr (Base and extension case): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bl =\t%" PRIx8 "\t(Base is lowercase)\n", fat_direntry_lwr_bl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " el =\t%" PRIx8 "\t(Extension is lowercase)\n", fat_direntry_lwr_el_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline uint8_t fat_direntry_lwr_bl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_lwr_bl_rdf(__DN(t) *_dev)
{
    fat_direntry_lwr_t _regval = mackerel_read_addr_8(_dev->b, 0xc);
    return(fat_direntry_lwr_bl_extract(_regval));
}

static inline uint8_t fat_direntry_lwr_el_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_lwr_el_rdf(__DN(t) *_dev)
{
    fat_direntry_lwr_t _regval = mackerel_read_addr_8(_dev->b, 0xc);
    return(fat_direntry_lwr_el_extract(_regval));
}

static inline void fat_direntry_lwr_bl_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_lwr_bl_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_lwr_t _regval = 0x8 & (((fat_direntry_lwr_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf7 & mackerel_read_addr_8(_dev->b, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->b, 0xc, _regval);
    // No shadow register to write to
}

static inline void fat_direntry_lwr_el_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_lwr_el_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_lwr_t _regval = 0x10 & (((fat_direntry_lwr_t )(_fieldval)) << 4);
    _regval = (_regval | (0xef & mackerel_read_addr_8(_dev->b, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->b, 0xc, _regval);
    // No shadow register to write to
}

/*
 * Register ctms: Creation deca-milliseconds (0-199)
 * Type: fat_direntry.uint8 (primitive type)
 */
static inline uint8_t fat_direntry_ctms_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_ctms_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0xd));
}

static inline uint8_t fat_direntry_ctms_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_ctms_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0xd));
}

static inline void fat_direntry_ctms_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_ctms_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->b, 0xd, _regval);
}

static inline void fat_direntry_ctms_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_ctms_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->b, 0xd, _regval);
}

static inline int fat_direntry_ctms_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_direntry_ctms_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->b, 0xd);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ctms (Creation deca-milliseconds (0-199)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ctime: Creation time
 * Type: fat_direntry.time (Time)
 *   dsec	(size 5, offset 0, init 0):	RW	Double seconds (0-29)
 *   min	(size 6, offset 5, init 0):	RW	Minutes
 *   hour	(size 5, offset 11, init 0):	RW	Hour
 */
static inline fat_direntry_time_t fat_direntry_ctime_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline fat_direntry_time_t fat_direntry_ctime_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xe));
}

static inline fat_direntry_time_t fat_direntry_ctime_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline fat_direntry_time_t fat_direntry_ctime_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xe));
}

static inline void fat_direntry_ctime_rawwr(__DN(t) *_dev, fat_direntry_time_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_ctime_rawwr(__DN(t) *_dev, fat_direntry_time_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0xe, _regval);
}

static inline void fat_direntry_ctime_wr(__DN(t) *_dev, fat_direntry_time_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_ctime_wr(__DN(t) *_dev, fat_direntry_time_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->b, 0xe, _regval);
}

static inline int fat_direntry_ctime_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_direntry_ctime_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    fat_direntry_time_t _regval = mackerel_read_addr_16(_dev->b, 0xe);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ctime (Creation time): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsec =\t%" PRIx8 "\t(Double seconds (0-29))\n", fat_direntry_time_dsec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " min =\t%" PRIx8 "\t(Minutes)\n", fat_direntry_time_min_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hour =\t%" PRIx8 "\t(Hour)\n", fat_direntry_time_hour_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t fat_direntry_ctime_dsec_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_ctime_dsec_rdf(__DN(t) *_dev)
{
    fat_direntry_time_t _regval = mackerel_read_addr_16(_dev->b, 0xe);
    return(fat_direntry_time_dsec_extract(_regval));
}

static inline uint8_t fat_direntry_ctime_min_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_ctime_min_rdf(__DN(t) *_dev)
{
    fat_direntry_time_t _regval = mackerel_read_addr_16(_dev->b, 0xe);
    return(fat_direntry_time_min_extract(_regval));
}

static inline uint8_t fat_direntry_ctime_hour_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_ctime_hour_rdf(__DN(t) *_dev)
{
    fat_direntry_time_t _regval = mackerel_read_addr_16(_dev->b, 0xe);
    return(fat_direntry_time_hour_extract(_regval));
}

static inline void fat_direntry_ctime_dsec_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_ctime_dsec_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_time_t _regval = 0x1f & (((fat_direntry_time_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffe0 & mackerel_read_addr_16(_dev->b, 0xe)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->b, 0xe, _regval);
    // No shadow register to write to
}

static inline void fat_direntry_ctime_min_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_ctime_min_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_time_t _regval = 0x7e0 & (((fat_direntry_time_t )(_fieldval)) << 5);
    _regval = (_regval | (0xf81f & mackerel_read_addr_16(_dev->b, 0xe)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->b, 0xe, _regval);
    // No shadow register to write to
}

static inline void fat_direntry_ctime_hour_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_ctime_hour_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_time_t _regval = 0xf800 & (((fat_direntry_time_t )(_fieldval)) << 11);
    _regval = (_regval | (0x7ff & mackerel_read_addr_16(_dev->b, 0xe)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->b, 0xe, _regval);
    // No shadow register to write to
}

/*
 * Register cdate: Create date
 * Type: fat_direntry.date (Date)
 *   day	(size 5, offset 0, init 0):	RW	Day of month
 *   mnth	(size 4, offset 5, init 0):	RW	Month of year
 *   yr	(size 7, offset 9, init 0):	RW	Years from 1980
 */
static inline fat_direntry_date_t fat_direntry_cdate_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline fat_direntry_date_t fat_direntry_cdate_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x10));
}

static inline fat_direntry_date_t fat_direntry_cdate_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline fat_direntry_date_t fat_direntry_cdate_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x10));
}

static inline void fat_direntry_cdate_rawwr(__DN(t) *_dev, fat_direntry_date_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_cdate_rawwr(__DN(t) *_dev, fat_direntry_date_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x10, _regval);
}

static inline void fat_direntry_cdate_wr(__DN(t) *_dev, fat_direntry_date_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_cdate_wr(__DN(t) *_dev, fat_direntry_date_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->b, 0x10, _regval);
}

static inline int fat_direntry_cdate_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_direntry_cdate_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    fat_direntry_date_t _regval = mackerel_read_addr_16(_dev->b, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cdate (Create date): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " day =\t%" PRIx8 "\t(Day of month)\n", fat_direntry_date_day_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mnth =\t%" PRIx8 "\t(Month of year)\n", fat_direntry_date_mnth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " yr =\t%" PRIx8 "\t(Years from 1980)\n", fat_direntry_date_yr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t fat_direntry_cdate_day_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_cdate_day_rdf(__DN(t) *_dev)
{
    fat_direntry_date_t _regval = mackerel_read_addr_16(_dev->b, 0x10);
    return(fat_direntry_date_day_extract(_regval));
}

static inline uint8_t fat_direntry_cdate_mnth_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_cdate_mnth_rdf(__DN(t) *_dev)
{
    fat_direntry_date_t _regval = mackerel_read_addr_16(_dev->b, 0x10);
    return(fat_direntry_date_mnth_extract(_regval));
}

static inline uint8_t fat_direntry_cdate_yr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_cdate_yr_rdf(__DN(t) *_dev)
{
    fat_direntry_date_t _regval = mackerel_read_addr_16(_dev->b, 0x10);
    return(fat_direntry_date_yr_extract(_regval));
}

static inline void fat_direntry_cdate_day_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_cdate_day_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_date_t _regval = 0x1f & (((fat_direntry_date_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffe0 & mackerel_read_addr_16(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

static inline void fat_direntry_cdate_mnth_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_cdate_mnth_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_date_t _regval = 0x1e0 & (((fat_direntry_date_t )(_fieldval)) << 5);
    _regval = (_regval | (0xfe1f & mackerel_read_addr_16(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

static inline void fat_direntry_cdate_yr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_cdate_yr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_date_t _regval = 0xfe00 & (((fat_direntry_date_t )(_fieldval)) << 9);
    _regval = (_regval | (0x1ff & mackerel_read_addr_16(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register adate: Last access date
 * Type: fat_direntry.date (Date)
 *   day	(size 5, offset 0, init 0):	RW	Day of month
 *   mnth	(size 4, offset 5, init 0):	RW	Month of year
 *   yr	(size 7, offset 9, init 0):	RW	Years from 1980
 */
static inline fat_direntry_date_t fat_direntry_adate_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline fat_direntry_date_t fat_direntry_adate_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x12));
}

static inline fat_direntry_date_t fat_direntry_adate_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline fat_direntry_date_t fat_direntry_adate_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x12));
}

static inline void fat_direntry_adate_rawwr(__DN(t) *_dev, fat_direntry_date_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_adate_rawwr(__DN(t) *_dev, fat_direntry_date_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x12, _regval);
}

static inline void fat_direntry_adate_wr(__DN(t) *_dev, fat_direntry_date_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_adate_wr(__DN(t) *_dev, fat_direntry_date_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->b, 0x12, _regval);
}

static inline int fat_direntry_adate_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_direntry_adate_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    fat_direntry_date_t _regval = mackerel_read_addr_16(_dev->b, 0x12);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register adate (Last access date): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " day =\t%" PRIx8 "\t(Day of month)\n", fat_direntry_date_day_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mnth =\t%" PRIx8 "\t(Month of year)\n", fat_direntry_date_mnth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " yr =\t%" PRIx8 "\t(Years from 1980)\n", fat_direntry_date_yr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t fat_direntry_adate_day_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_adate_day_rdf(__DN(t) *_dev)
{
    fat_direntry_date_t _regval = mackerel_read_addr_16(_dev->b, 0x12);
    return(fat_direntry_date_day_extract(_regval));
}

static inline uint8_t fat_direntry_adate_mnth_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_adate_mnth_rdf(__DN(t) *_dev)
{
    fat_direntry_date_t _regval = mackerel_read_addr_16(_dev->b, 0x12);
    return(fat_direntry_date_mnth_extract(_regval));
}

static inline uint8_t fat_direntry_adate_yr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_adate_yr_rdf(__DN(t) *_dev)
{
    fat_direntry_date_t _regval = mackerel_read_addr_16(_dev->b, 0x12);
    return(fat_direntry_date_yr_extract(_regval));
}

static inline void fat_direntry_adate_day_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_adate_day_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_date_t _regval = 0x1f & (((fat_direntry_date_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffe0 & mackerel_read_addr_16(_dev->b, 0x12)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->b, 0x12, _regval);
    // No shadow register to write to
}

static inline void fat_direntry_adate_mnth_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_adate_mnth_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_date_t _regval = 0x1e0 & (((fat_direntry_date_t )(_fieldval)) << 5);
    _regval = (_regval | (0xfe1f & mackerel_read_addr_16(_dev->b, 0x12)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->b, 0x12, _regval);
    // No shadow register to write to
}

static inline void fat_direntry_adate_yr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_adate_yr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_date_t _regval = 0xfe00 & (((fat_direntry_date_t )(_fieldval)) << 9);
    _regval = (_regval | (0x1ff & mackerel_read_addr_16(_dev->b, 0x12)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->b, 0x12, _regval);
    // No shadow register to write to
}

/*
 * Register starth: Start cluster high bits (FAT32)
 * Type: fat_direntry.uint16 (primitive type)
 */
static inline uint16_t fat_direntry_starth_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_direntry_starth_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x14));
}

static inline uint16_t fat_direntry_starth_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_direntry_starth_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x14));
}

static inline void fat_direntry_starth_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_starth_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x14, _regval);
}

static inline void fat_direntry_starth_wr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_starth_wr(__DN(t) *_dev, uint16_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->b, 0x14, _regval);
}

static inline int fat_direntry_starth_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_direntry_starth_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->b, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register starth (Start cluster high bits (FAT32)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register wtime: Last write time
 * Type: fat_direntry.time (Time)
 *   dsec	(size 5, offset 0, init 0):	RW	Double seconds (0-29)
 *   min	(size 6, offset 5, init 0):	RW	Minutes
 *   hour	(size 5, offset 11, init 0):	RW	Hour
 */
static inline fat_direntry_time_t fat_direntry_wtime_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline fat_direntry_time_t fat_direntry_wtime_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x16));
}

static inline fat_direntry_time_t fat_direntry_wtime_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline fat_direntry_time_t fat_direntry_wtime_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x16));
}

static inline void fat_direntry_wtime_rawwr(__DN(t) *_dev, fat_direntry_time_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_wtime_rawwr(__DN(t) *_dev, fat_direntry_time_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x16, _regval);
}

static inline void fat_direntry_wtime_wr(__DN(t) *_dev, fat_direntry_time_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_wtime_wr(__DN(t) *_dev, fat_direntry_time_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->b, 0x16, _regval);
}

static inline int fat_direntry_wtime_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_direntry_wtime_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    fat_direntry_time_t _regval = mackerel_read_addr_16(_dev->b, 0x16);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register wtime (Last write time): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsec =\t%" PRIx8 "\t(Double seconds (0-29))\n", fat_direntry_time_dsec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " min =\t%" PRIx8 "\t(Minutes)\n", fat_direntry_time_min_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hour =\t%" PRIx8 "\t(Hour)\n", fat_direntry_time_hour_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t fat_direntry_wtime_dsec_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_wtime_dsec_rdf(__DN(t) *_dev)
{
    fat_direntry_time_t _regval = mackerel_read_addr_16(_dev->b, 0x16);
    return(fat_direntry_time_dsec_extract(_regval));
}

static inline uint8_t fat_direntry_wtime_min_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_wtime_min_rdf(__DN(t) *_dev)
{
    fat_direntry_time_t _regval = mackerel_read_addr_16(_dev->b, 0x16);
    return(fat_direntry_time_min_extract(_regval));
}

static inline uint8_t fat_direntry_wtime_hour_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_wtime_hour_rdf(__DN(t) *_dev)
{
    fat_direntry_time_t _regval = mackerel_read_addr_16(_dev->b, 0x16);
    return(fat_direntry_time_hour_extract(_regval));
}

static inline void fat_direntry_wtime_dsec_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_wtime_dsec_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_time_t _regval = 0x1f & (((fat_direntry_time_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffe0 & mackerel_read_addr_16(_dev->b, 0x16)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->b, 0x16, _regval);
    // No shadow register to write to
}

static inline void fat_direntry_wtime_min_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_wtime_min_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_time_t _regval = 0x7e0 & (((fat_direntry_time_t )(_fieldval)) << 5);
    _regval = (_regval | (0xf81f & mackerel_read_addr_16(_dev->b, 0x16)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->b, 0x16, _regval);
    // No shadow register to write to
}

static inline void fat_direntry_wtime_hour_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_wtime_hour_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_time_t _regval = 0xf800 & (((fat_direntry_time_t )(_fieldval)) << 11);
    _regval = (_regval | (0x7ff & mackerel_read_addr_16(_dev->b, 0x16)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->b, 0x16, _regval);
    // No shadow register to write to
}

/*
 * Register wdate: Last write date
 * Type: fat_direntry.date (Date)
 *   day	(size 5, offset 0, init 0):	RW	Day of month
 *   mnth	(size 4, offset 5, init 0):	RW	Month of year
 *   yr	(size 7, offset 9, init 0):	RW	Years from 1980
 */
static inline fat_direntry_date_t fat_direntry_wdate_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline fat_direntry_date_t fat_direntry_wdate_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x18));
}

static inline fat_direntry_date_t fat_direntry_wdate_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline fat_direntry_date_t fat_direntry_wdate_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x18));
}

static inline void fat_direntry_wdate_rawwr(__DN(t) *_dev, fat_direntry_date_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_wdate_rawwr(__DN(t) *_dev, fat_direntry_date_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x18, _regval);
}

static inline void fat_direntry_wdate_wr(__DN(t) *_dev, fat_direntry_date_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_wdate_wr(__DN(t) *_dev, fat_direntry_date_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->b, 0x18, _regval);
}

static inline int fat_direntry_wdate_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_direntry_wdate_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    fat_direntry_date_t _regval = mackerel_read_addr_16(_dev->b, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register wdate (Last write date): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " day =\t%" PRIx8 "\t(Day of month)\n", fat_direntry_date_day_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mnth =\t%" PRIx8 "\t(Month of year)\n", fat_direntry_date_mnth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " yr =\t%" PRIx8 "\t(Years from 1980)\n", fat_direntry_date_yr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t fat_direntry_wdate_day_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_wdate_day_rdf(__DN(t) *_dev)
{
    fat_direntry_date_t _regval = mackerel_read_addr_16(_dev->b, 0x18);
    return(fat_direntry_date_day_extract(_regval));
}

static inline uint8_t fat_direntry_wdate_mnth_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_wdate_mnth_rdf(__DN(t) *_dev)
{
    fat_direntry_date_t _regval = mackerel_read_addr_16(_dev->b, 0x18);
    return(fat_direntry_date_mnth_extract(_regval));
}

static inline uint8_t fat_direntry_wdate_yr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_direntry_wdate_yr_rdf(__DN(t) *_dev)
{
    fat_direntry_date_t _regval = mackerel_read_addr_16(_dev->b, 0x18);
    return(fat_direntry_date_yr_extract(_regval));
}

static inline void fat_direntry_wdate_day_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_wdate_day_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_date_t _regval = 0x1f & (((fat_direntry_date_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffe0 & mackerel_read_addr_16(_dev->b, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->b, 0x18, _regval);
    // No shadow register to write to
}

static inline void fat_direntry_wdate_mnth_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_wdate_mnth_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_date_t _regval = 0x1e0 & (((fat_direntry_date_t )(_fieldval)) << 5);
    _regval = (_regval | (0xfe1f & mackerel_read_addr_16(_dev->b, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->b, 0x18, _regval);
    // No shadow register to write to
}

static inline void fat_direntry_wdate_yr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void fat_direntry_wdate_yr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    fat_direntry_date_t _regval = 0xfe00 & (((fat_direntry_date_t )(_fieldval)) << 9);
    _regval = (_regval | (0x1ff & mackerel_read_addr_16(_dev->b, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->b, 0x18, _regval);
    // No shadow register to write to
}

/*
 * Register start: Starting cluster
 * Type: fat_direntry.uint16 (primitive type)
 */
static inline uint16_t fat_direntry_start_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_direntry_start_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x1a));
}

static inline uint16_t fat_direntry_start_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_direntry_start_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x1a));
}

static inline void fat_direntry_start_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_start_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x1a, _regval);
}

static inline void fat_direntry_start_wr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_start_wr(__DN(t) *_dev, uint16_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->b, 0x1a, _regval);
}

static inline int fat_direntry_start_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_direntry_start_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->b, 0x1a);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register start (Starting cluster): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register size: File size
 * Type: fat_direntry.uint32 (primitive type)
 */
static inline uint32_t fat_direntry_size_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t fat_direntry_size_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x1c));
}

static inline uint32_t fat_direntry_size_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t fat_direntry_size_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x1c));
}

static inline void fat_direntry_size_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_size_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x1c, _regval);
}

static inline void fat_direntry_size_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void fat_direntry_size_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->b, 0x1c, _regval);
}

static inline int fat_direntry_size_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_direntry_size_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->b, 0x1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register size (File size): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int fat_direntry_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_direntry_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device fat_direntry (FAT 16 Directory Entry):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_direntry_fn_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_direntry_ext_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_direntry_attr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_direntry_lwr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_direntry_ctms_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_direntry_ctime_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_direntry_cdate_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_direntry_adate_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_direntry_starth_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_direntry_wtime_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_direntry_wdate_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_direntry_start_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_direntry_size_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device fat_direntry\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __fat_direntry_DEV_H
