/*
 * DEVICE DEFINITION: PC16550D UART Memory Represenation
 * 
 * Copyright (c) 2007, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich.
 *  Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED: DO NOT EDIT!
 */

#ifndef __pc16550d_mem_H
#define __pc16550d_mem_H

#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR
#define __DN(x) pc16550d_mem ## _ ## x
#ifdef pc16550d_mem_PREFIX
#define __DP(x) __DP1(x,pc16550d_mem_PREFIX)
#define __DP1(x1,x2) __DP2(x1,x2)
#define __DP2(x1,x2) x2 ## x1
#else
#define __DP(x) pc16550d_mem##_ ##x
#endif
#define __STR(x) #x
#define __XTR(x) __STR(x)

/*
 * Constant definition: pc16550d_mem.trigger_lvl (RCVR FIFO trigger level)
 */
typedef enum pc16550d_mem_trigger_lvl_t {
    __DP(bytes1) = (0x0),
    __DP(bytes4) = (0x1),
    __DP(bytes8) = (0x2),
    __DP(bytes14) = (0x3),
} pc16550d_mem_trigger_lvl_t;

static inline int pc16550d_mem_trigger_lvl_prt( char * s, size_t sz, pc16550d_mem_trigger_lvl_t e ) __attribute__ ((always_inline));
static inline int pc16550d_mem_trigger_lvl_prt( char * s, size_t sz, pc16550d_mem_trigger_lvl_t e )
{
    switch (e) {
        case __DP(bytes1):
        return snprintf(s, sz, "%s", "Every byte");
        case __DP(bytes4):
        return snprintf(s, sz, "%s", "Every 4th byte");
        case __DP(bytes8):
        return snprintf(s, sz, "%s", "Every 8th byte");
        case __DP(bytes14):
        return snprintf(s, sz, "%s", "Every 14th byte");
        default:
        return snprintf(s, sz, "Unknown " __XTR(pc16550d_mem_trigger_lvl_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int pc16550d_mem_trigger_lvl_chk( pc16550d_mem_trigger_lvl_t e ) __attribute__ ((always_inline));
static inline int pc16550d_mem_trigger_lvl_chk( pc16550d_mem_trigger_lvl_t e )
{
    switch (e) {
        case __DP(bytes1):
        return 1;
        case __DP(bytes4):
        return 1;
        case __DP(bytes8):
        return 1;
        case __DP(bytes14):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: pc16550d_mem.char_len (Character Length)
 */
typedef enum pc16550d_mem_char_len_t {
    __DP(bits5) = (0x0),
    __DP(bits6) = (0x1),
    __DP(bits7) = (0x2),
    __DP(bits8) = (0x3),
} pc16550d_mem_char_len_t;

static inline int pc16550d_mem_char_len_prt( char * s, size_t sz, pc16550d_mem_char_len_t e ) __attribute__ ((always_inline));
static inline int pc16550d_mem_char_len_prt( char * s, size_t sz, pc16550d_mem_char_len_t e )
{
    switch (e) {
        case __DP(bits5):
        return snprintf(s, sz, "%s", "5 Bits");
        case __DP(bits6):
        return snprintf(s, sz, "%s", "6 Bits");
        case __DP(bits7):
        return snprintf(s, sz, "%s", "7 Bits");
        case __DP(bits8):
        return snprintf(s, sz, "%s", "8 Bits");
        default:
        return snprintf(s, sz, "Unknown " __XTR(pc16550d_mem_char_len_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int pc16550d_mem_char_len_chk( pc16550d_mem_char_len_t e ) __attribute__ ((always_inline));
static inline int pc16550d_mem_char_len_chk( pc16550d_mem_char_len_t e )
{
    switch (e) {
        case __DP(bits5):
        return 1;
        case __DP(bits6):
        return 1;
        case __DP(bits7):
        return 1;
        case __DP(bits8):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: pc16550d_mem.irq_id (Interrupt ID)
 */
typedef enum pc16550d_mem_irq_id_t {
    __DP(irq_none) = (0x1),
    __DP(irq_rls) = (0x6),
    __DP(irq_rda) = (0x4),
    __DP(irq_cti) = (0xc),
    __DP(irq_thre) = (0x2),
    __DP(irq_ms) = (0x0),
} pc16550d_mem_irq_id_t;

static inline int pc16550d_mem_irq_id_prt( char * s, size_t sz, pc16550d_mem_irq_id_t e ) __attribute__ ((always_inline));
static inline int pc16550d_mem_irq_id_prt( char * s, size_t sz, pc16550d_mem_irq_id_t e )
{
    switch (e) {
        case __DP(irq_none):
        return snprintf(s, sz, "%s", "No interrupt pending");
        case __DP(irq_rls):
        return snprintf(s, sz, "%s", "Receiver line status");
        case __DP(irq_rda):
        return snprintf(s, sz, "%s", "Receiver data available");
        case __DP(irq_cti):
        return snprintf(s, sz, "%s", "Character timeout");
        case __DP(irq_thre):
        return snprintf(s, sz, "%s", "Transmitter holding register empty");
        case __DP(irq_ms):
        return snprintf(s, sz, "%s", "Modem status");
        default:
        return snprintf(s, sz, "Unknown " __XTR(pc16550d_mem_irq_id_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int pc16550d_mem_irq_id_chk( pc16550d_mem_irq_id_t e ) __attribute__ ((always_inline));
static inline int pc16550d_mem_irq_id_chk( pc16550d_mem_irq_id_t e )
{
    switch (e) {
        case __DP(irq_none):
        return 1;
        case __DP(irq_rls):
        return 1;
        case __DP(irq_rda):
        return 1;
        case __DP(irq_cti):
        return 1;
        case __DP(irq_thre):
        return 1;
        case __DP(irq_ms):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: pc16550d_mem.divisor (Baud Rate Divisor)
 */
typedef enum pc16550d_mem_divisor_t {
    __DP(baud50) = (0x900),
    __DP(baud75) = (0x600),
    __DP(baud110) = (0x417),
    __DP(baud134_5) = (0x359),
    __DP(baud150) = (0x300),
    __DP(baud300) = (0x180),
    __DP(baud600) = (0xc0),
    __DP(baud1200) = (0x60),
    __DP(baud1800) = (0x40),
    __DP(baud2000) = (0x3a),
    __DP(baud2400) = (0x30),
    __DP(baud4800) = (0x18),
    __DP(baud7200) = (0x10),
    __DP(baud9600) = (0xc),
    __DP(baud19200) = (0x6),
    __DP(baud38400) = (0x3),
    __DP(baud57600) = (0x2),
    __DP(baud115200) = (0x1),
} pc16550d_mem_divisor_t;

static inline int pc16550d_mem_divisor_prt( char * s, size_t sz, pc16550d_mem_divisor_t e ) __attribute__ ((always_inline));
static inline int pc16550d_mem_divisor_prt( char * s, size_t sz, pc16550d_mem_divisor_t e )
{
    switch (e) {
        case __DP(baud50):
        return snprintf(s, sz, "%s", "50 bps");
        case __DP(baud75):
        return snprintf(s, sz, "%s", "75 bps");
        case __DP(baud110):
        return snprintf(s, sz, "%s", "110 bps");
        case __DP(baud134_5):
        return snprintf(s, sz, "%s", "134.5 bps");
        case __DP(baud150):
        return snprintf(s, sz, "%s", "150 bps");
        case __DP(baud300):
        return snprintf(s, sz, "%s", "300 bps");
        case __DP(baud600):
        return snprintf(s, sz, "%s", "600 bps");
        case __DP(baud1200):
        return snprintf(s, sz, "%s", "1200 bps");
        case __DP(baud1800):
        return snprintf(s, sz, "%s", "1800 bps");
        case __DP(baud2000):
        return snprintf(s, sz, "%s", "2000 bps");
        case __DP(baud2400):
        return snprintf(s, sz, "%s", "2400 bps");
        case __DP(baud4800):
        return snprintf(s, sz, "%s", "4800 bps");
        case __DP(baud7200):
        return snprintf(s, sz, "%s", "7200 bps");
        case __DP(baud9600):
        return snprintf(s, sz, "%s", "9600 bps");
        case __DP(baud19200):
        return snprintf(s, sz, "%s", "19200 bps");
        case __DP(baud38400):
        return snprintf(s, sz, "%s", "38400 bps");
        case __DP(baud57600):
        return snprintf(s, sz, "%s", "57600 bps");
        case __DP(baud115200):
        return snprintf(s, sz, "%s", "115200 bps");
        default:
        return snprintf(s, sz, "Unknown " __XTR(pc16550d_mem_divisor_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int pc16550d_mem_divisor_chk( pc16550d_mem_divisor_t e ) __attribute__ ((always_inline));
static inline int pc16550d_mem_divisor_chk( pc16550d_mem_divisor_t e )
{
    switch (e) {
        case __DP(baud50):
        return 1;
        case __DP(baud75):
        return 1;
        case __DP(baud110):
        return 1;
        case __DP(baud134_5):
        return 1;
        case __DP(baud150):
        return 1;
        case __DP(baud300):
        return 1;
        case __DP(baud600):
        return 1;
        case __DP(baud1200):
        return 1;
        case __DP(baud1800):
        return 1;
        case __DP(baud2000):
        return 1;
        case __DP(baud2400):
        return 1;
        case __DP(baud4800):
        return 1;
        case __DP(baud7200):
        return 1;
        case __DP(baud9600):
        return 1;
        case __DP(baud19200):
        return 1;
        case __DP(baud38400):
        return 1;
        case __DP(baud57600):
        return 1;
        case __DP(baud115200):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: pc16550d_mem.fifo_type (FIFO Type)
 */
typedef enum pc16550d_mem_fifo_type_t {
    __DP(no_fifo) = (0x0),
    __DP(unusable_fifo) = (0x2),
    __DP(fifo_enabled) = (0x3),
} pc16550d_mem_fifo_type_t;

static inline int pc16550d_mem_fifo_type_prt( char * s, size_t sz, pc16550d_mem_fifo_type_t e ) __attribute__ ((always_inline));
static inline int pc16550d_mem_fifo_type_prt( char * s, size_t sz, pc16550d_mem_fifo_type_t e )
{
    switch (e) {
        case __DP(no_fifo):
        return snprintf(s, sz, "%s", "No FIFO");
        case __DP(unusable_fifo):
        return snprintf(s, sz, "%s", "Unusable FIFO (16550 only)");
        case __DP(fifo_enabled):
        return snprintf(s, sz, "%s", "FIFO enabled");
        default:
        return snprintf(s, sz, "Unknown " __XTR(pc16550d_mem_fifo_type_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int pc16550d_mem_fifo_type_chk( pc16550d_mem_fifo_type_t e ) __attribute__ ((always_inline));
static inline int pc16550d_mem_fifo_type_chk( pc16550d_mem_fifo_type_t e )
{
    switch (e) {
        case __DP(no_fifo):
        return 1;
        case __DP(unusable_fifo):
        return 1;
        case __DP(fifo_enabled):
        return 1;
        default:
        return 0;
    }
}


/*
 * Register type: Implicit type of Interrupt enable register
 */

/*
 * Dump of fields for register type: pc16550d_mem_ier_t
 *   erbfi (size 1, offset 0):	 RW	  Enable received data available interrupt
 *   etbei (size 1, offset 1):	 RW	  Enable transmitter holding register empty interrupt
 *   elsi (size 1, offset 2):	 RW	  Enable receiver line status interrupt
 *   edssi (size 1, offset 3):	 RW	  Enable modem status interrupt
 *   _anon4 (size 4, offset 4):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pc16550d_mem_ier_t {
    uint8_t	erbfi	:1;
    uint8_t	etbei	:1;
    uint8_t	elsi	:1;
    uint8_t	edssi	:1;
    uint8_t	_anon4	:4;
} __attribute__ ((packed))
 pc16550d_mem_ier_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pc16550d_mem_ier_t, sizeof(uint8_t));

typedef union pc16550d_mem_ier_un {
    pc16550d_mem_ier_t	val;
    uint8_t	raw;
}
 pc16550d_mem_ier_un;
static inline int pc16550d_mem_ier_prtval( char * s, size_t sz, pc16550d_mem_ier_t v ) __attribute__ ((always_inline));
static inline int pc16550d_mem_ier_prtval( char * s, size_t sz, pc16550d_mem_ier_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " erbfi=0x%"PRIx8" (Enable received data available interrupt)\n", (uint8_t)(v.erbfi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " etbei=0x%"PRIx8" (Enable transmitter holding register empty interrupt)\n", (uint8_t)(v.etbei));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " elsi=0x%"PRIx8" (Enable receiver line status interrupt)\n", (uint8_t)(v.elsi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " edssi=0x%"PRIx8" (Enable modem status interrupt)\n", (uint8_t)(v.edssi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Interrupt identification register
 */

/*
 * Dump of fields for register type: pc16550d_mem_iir_t
 *   iid (size 4, offset 0):	 RW	  Interrupt ID
 *   _anon4 (size 2, offset 4):	 MBZ	  _
 *   fifoe (size 2, offset 6):	 RW	  FIFOs enabled
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pc16550d_mem_iir_t {
    pc16550d_mem_irq_id_t	iid	:4;
    uint8_t	_anon4	:2;
    pc16550d_mem_fifo_type_t	fifoe	:2;
} __attribute__ ((packed))
 pc16550d_mem_iir_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pc16550d_mem_iir_t, sizeof(uint8_t));

typedef union pc16550d_mem_iir_un {
    pc16550d_mem_iir_t	val;
    uint8_t	raw;
}
 pc16550d_mem_iir_un;
static inline int pc16550d_mem_iir_prtval( char * s, size_t sz, pc16550d_mem_iir_t v ) __attribute__ ((always_inline));
static inline int pc16550d_mem_iir_prtval( char * s, size_t sz, pc16550d_mem_iir_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " iid=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = pc16550d_mem_irq_id_prt(s+r, _avail, v.iid);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Interrupt ID)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " fifoe=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = pc16550d_mem_fifo_type_prt(s+r, _avail, v.fifoe);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (FIFOs enabled)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of FIFO control register
 */

/*
 * Dump of fields for register type: pc16550d_mem_fcr_t
 *   fifoe (size 1, offset 0):	 RW	  FIFO enable
 *   rfifo_reset (size 1, offset 1):	 RW	  RCVR FIFO reset
 *   xfifo_reset (size 1, offset 2):	 RW	  XMIT FIFO reset
 *   dma_mode (size 1, offset 3):	 RW	  DMA mode select
 *   _anon4 (size 2, offset 4):	 RSVD	  _
 *   rtrigger (size 2, offset 6):	 RW	  RCVR trigger
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pc16550d_mem_fcr_t {
    uint8_t	fifoe	:1;
    uint8_t	rfifo_reset	:1;
    uint8_t	xfifo_reset	:1;
    uint8_t	dma_mode	:1;
    uint8_t	_anon4	:2;
    pc16550d_mem_trigger_lvl_t	rtrigger	:2;
} __attribute__ ((packed))
 pc16550d_mem_fcr_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pc16550d_mem_fcr_t, sizeof(uint8_t));

typedef union pc16550d_mem_fcr_un {
    pc16550d_mem_fcr_t	val;
    uint8_t	raw;
}
 pc16550d_mem_fcr_un;
static inline int pc16550d_mem_fcr_prtval( char * s, size_t sz, pc16550d_mem_fcr_t v ) __attribute__ ((always_inline));
static inline int pc16550d_mem_fcr_prtval( char * s, size_t sz, pc16550d_mem_fcr_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fifoe=0x%"PRIx8" (FIFO enable)\n", (uint8_t)(v.fifoe));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rfifo_reset=0x%"PRIx8" (RCVR FIFO reset)\n", (uint8_t)(v.rfifo_reset));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " xfifo_reset=0x%"PRIx8" (XMIT FIFO reset)\n", (uint8_t)(v.xfifo_reset));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dma_mode=0x%"PRIx8" (DMA mode select)\n", (uint8_t)(v.dma_mode));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " rtrigger=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = pc16550d_mem_trigger_lvl_prt(s+r, _avail, v.rtrigger);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (RCVR trigger)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Line control register
 */

/*
 * Dump of fields for register type: pc16550d_mem_lcr_t
 *   wls (size 2, offset 0):	 RW	  Word length select
 *   stb (size 1, offset 2):	 RW	  Number of stop bits
 *   pen (size 1, offset 3):	 RW	  Parity enable
 *   eps (size 1, offset 4):	 RW	  Even parity select
 *   sp (size 1, offset 5):	 RW	  Stick parity
 *   sb (size 1, offset 6):	 RW	  Set break
 *   dlab (size 1, offset 7):	 RW	  Divisor latch access
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pc16550d_mem_lcr_t {
    pc16550d_mem_char_len_t	wls	:2;
    uint8_t	stb	:1;
    uint8_t	pen	:1;
    uint8_t	eps	:1;
    uint8_t	sp	:1;
    uint8_t	sb	:1;
    uint8_t	dlab	:1;
} __attribute__ ((packed))
 pc16550d_mem_lcr_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pc16550d_mem_lcr_t, sizeof(uint8_t));

typedef union pc16550d_mem_lcr_un {
    pc16550d_mem_lcr_t	val;
    uint8_t	raw;
}
 pc16550d_mem_lcr_un;
static inline int pc16550d_mem_lcr_prtval( char * s, size_t sz, pc16550d_mem_lcr_t v ) __attribute__ ((always_inline));
static inline int pc16550d_mem_lcr_prtval( char * s, size_t sz, pc16550d_mem_lcr_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " wls=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = pc16550d_mem_char_len_prt(s+r, _avail, v.wls);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Word length select)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " stb=0x%"PRIx8" (Number of stop bits)\n", (uint8_t)(v.stb));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pen=0x%"PRIx8" (Parity enable)\n", (uint8_t)(v.pen));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " eps=0x%"PRIx8" (Even parity select)\n", (uint8_t)(v.eps));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sp=0x%"PRIx8" (Stick parity)\n", (uint8_t)(v.sp));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sb=0x%"PRIx8" (Set break)\n", (uint8_t)(v.sb));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dlab=0x%"PRIx8" (Divisor latch access)\n", (uint8_t)(v.dlab));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Modem control register
 */

/*
 * Dump of fields for register type: pc16550d_mem_mcr_t
 *   dtr (size 1, offset 0):	 RW	  Data terminal ready
 *   rts (size 1, offset 1):	 RW	  Request to send
 *   out (size 2, offset 2):	 RW	  Out
 *   loop (size 1, offset 4):	 RW	  Loop
 *   _anon5 (size 3, offset 5):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pc16550d_mem_mcr_t {
    uint8_t	dtr	:1;
    uint8_t	rts	:1;
    uint8_t	out	:2;
    uint8_t	loop	:1;
    uint8_t	_anon5	:3;
} __attribute__ ((packed))
 pc16550d_mem_mcr_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pc16550d_mem_mcr_t, sizeof(uint8_t));

typedef union pc16550d_mem_mcr_un {
    pc16550d_mem_mcr_t	val;
    uint8_t	raw;
}
 pc16550d_mem_mcr_un;
static inline int pc16550d_mem_mcr_prtval( char * s, size_t sz, pc16550d_mem_mcr_t v ) __attribute__ ((always_inline));
static inline int pc16550d_mem_mcr_prtval( char * s, size_t sz, pc16550d_mem_mcr_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dtr=0x%"PRIx8" (Data terminal ready)\n", (uint8_t)(v.dtr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rts=0x%"PRIx8" (Request to send)\n", (uint8_t)(v.rts));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " out=0x%"PRIx8" (Out)\n", (uint8_t)(v.out));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " loop=0x%"PRIx8" (Loop)\n", (uint8_t)(v.loop));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Line status register
 */

/*
 * Dump of fields for register type: pc16550d_mem_lsr_t
 *   dr (size 1, offset 0):	 RW	  Data ready
 *   oe (size 1, offset 1):	 RW	  Overrun error
 *   pe (size 1, offset 2):	 RW	  Parity error
 *   fe (size 1, offset 3):	 RW	  Framing error
 *   bi (size 1, offset 4):	 RW	  Break interrupt
 *   thre (size 1, offset 5):	 RW	  Transmitter holding register
 *   temt (size 1, offset 6):	 RW	  Transmitter empty
 *   erfifo (size 1, offset 7):	 RW	  Error in RCVR FIFO
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pc16550d_mem_lsr_t {
    uint8_t	dr	:1;
    uint8_t	oe	:1;
    uint8_t	pe	:1;
    uint8_t	fe	:1;
    uint8_t	bi	:1;
    uint8_t	thre	:1;
    uint8_t	temt	:1;
    uint8_t	erfifo	:1;
} __attribute__ ((packed))
 pc16550d_mem_lsr_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pc16550d_mem_lsr_t, sizeof(uint8_t));

typedef union pc16550d_mem_lsr_un {
    pc16550d_mem_lsr_t	val;
    uint8_t	raw;
}
 pc16550d_mem_lsr_un;
static inline int pc16550d_mem_lsr_prtval( char * s, size_t sz, pc16550d_mem_lsr_t v ) __attribute__ ((always_inline));
static inline int pc16550d_mem_lsr_prtval( char * s, size_t sz, pc16550d_mem_lsr_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dr=0x%"PRIx8" (Data ready)\n", (uint8_t)(v.dr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " oe=0x%"PRIx8" (Overrun error)\n", (uint8_t)(v.oe));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pe=0x%"PRIx8" (Parity error)\n", (uint8_t)(v.pe));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fe=0x%"PRIx8" (Framing error)\n", (uint8_t)(v.fe));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " bi=0x%"PRIx8" (Break interrupt)\n", (uint8_t)(v.bi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " thre=0x%"PRIx8" (Transmitter holding register)\n", (uint8_t)(v.thre));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " temt=0x%"PRIx8" (Transmitter empty)\n", (uint8_t)(v.temt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " erfifo=0x%"PRIx8" (Error in RCVR FIFO)\n", (uint8_t)(v.erfifo));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Modem status register
 */

/*
 * Dump of fields for register type: pc16550d_mem_msr_t
 *   dcts (size 1, offset 0):	 RW	  Delta clear to send
 *   ddsr (size 1, offset 1):	 RW	  Delta data set ready
 *   teri (size 1, offset 2):	 RW	  Trailing edge ring indicator
 *   ddcd (size 1, offset 3):	 RW	  Delta data carrier detect
 *   cts (size 1, offset 4):	 RW	  Clear to send
 *   dsr (size 1, offset 5):	 RW	  Data set ready
 *   ri (size 1, offset 6):	 RW	  Ring indicator
 *   dcd (size 1, offset 7):	 RW	  Data carrier detect
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pc16550d_mem_msr_t {
    uint8_t	dcts	:1;
    uint8_t	ddsr	:1;
    uint8_t	teri	:1;
    uint8_t	ddcd	:1;
    uint8_t	cts	:1;
    uint8_t	dsr	:1;
    uint8_t	ri	:1;
    uint8_t	dcd	:1;
} __attribute__ ((packed))
 pc16550d_mem_msr_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pc16550d_mem_msr_t, sizeof(uint8_t));

typedef union pc16550d_mem_msr_un {
    pc16550d_mem_msr_t	val;
    uint8_t	raw;
}
 pc16550d_mem_msr_un;
static inline int pc16550d_mem_msr_prtval( char * s, size_t sz, pc16550d_mem_msr_t v ) __attribute__ ((always_inline));
static inline int pc16550d_mem_msr_prtval( char * s, size_t sz, pc16550d_mem_msr_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dcts=0x%"PRIx8" (Delta clear to send)\n", (uint8_t)(v.dcts));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ddsr=0x%"PRIx8" (Delta data set ready)\n", (uint8_t)(v.ddsr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " teri=0x%"PRIx8" (Trailing edge ring indicator)\n", (uint8_t)(v.teri));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ddcd=0x%"PRIx8" (Delta data carrier detect)\n", (uint8_t)(v.ddcd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cts=0x%"PRIx8" (Clear to send)\n", (uint8_t)(v.cts));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dsr=0x%"PRIx8" (Data set ready)\n", (uint8_t)(v.dsr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ri=0x%"PRIx8" (Ring indicator)\n", (uint8_t)(v.ri));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dcd=0x%"PRIx8" (Data carrier detect)\n", (uint8_t)(v.dcd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Device representation structure
 */
typedef struct __DN(t) {
    // Device arguments
    mackerel_addr_t	base;
    // Shadow registers
}
 __DN(t);

/*
 * Device Initialization function
 */
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_addr_t base ) __attribute__ ((always_inline));
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_addr_t base )
{
    /* Setting up device arguments*/
    _dev->base = base;
    /* Setting up shadow registers*/
}

// No user-defined spaces

/*
 * Register rbr (Receiver buffer); type pc16550d_mem.uint8
 */

static inline uint8_t __DP(rbr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(rbr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0x0));
}

static inline uint8_t __DP(rbr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(rbr_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0x0));
}

static inline void __DP(rbr_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rbr_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x0),val);
}

static inline void __DP(rbr_wr)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rbr_wr)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x0),val);
}


static inline int __DP(rbr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rbr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rbr (Receiver buffer):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_addr_8(_dev->base,(0x0)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register thr (Transmitter holding); type pc16550d_mem.uint8
 */

static inline uint8_t __DP(thr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(thr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0x1));
}

static inline uint8_t __DP(thr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(thr_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0x1));
}

static inline void __DP(thr_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(thr_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x1),val);
}

static inline void __DP(thr_wr)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(thr_wr)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x1),val);
}


static inline int __DP(thr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(thr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register thr (Transmitter holding):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_addr_8(_dev->base,(0x1)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ier (Interrupt enable); type pc16550d_mem.ier (Implicit type of Interrupt enable register)
 */

/*
 * Dump of fields for register: ier
 *   erbfi (size 1, offset 0):	 RW	  Enable received data available interrupt
 *   etbei (size 1, offset 1):	 RW	  Enable transmitter holding register empty interrupt
 *   elsi (size 1, offset 2):	 RW	  Enable receiver line status interrupt
 *   edssi (size 1, offset 3):	 RW	  Enable modem status interrupt
 *   _anon4 (size 4, offset 4):	 MBZ	  _
 */

static inline uint8_t __DP(ier_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(ier_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0x2));
}

static inline pc16550d_mem_ier_t __DP(ier_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pc16550d_mem_ier_t __DP(ier_rd)( __DN(t) * _dev )
{
    pc16550d_mem_ier_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x2));
    return u.val;
}

static inline void __DP(ier_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ier_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x2),val);
}

static inline void __DP(ier_wr)( __DN(t) * _dev, pc16550d_mem_ier_t val ) __attribute__ ((always_inline));
static inline void __DP(ier_wr)( __DN(t) * _dev, pc16550d_mem_ier_t val )
{
    pc16550d_mem_ier_un  u;
    u.val = val;
    u.val._anon4 	= 0;
    mackerel_write_addr_8(_dev->base,(0x2),u.raw);
}

static inline void __DP(ier_erbfi_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ier_erbfi_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_ier_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x2));
    u.val._anon4 	= 0;
    u.val.erbfi = val;
    mackerel_write_addr_8(_dev->base,(0x2),u.raw);
}

static inline void __DP(ier_etbei_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ier_etbei_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_ier_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x2));
    u.val._anon4 	= 0;
    u.val.etbei = val;
    mackerel_write_addr_8(_dev->base,(0x2),u.raw);
}

static inline void __DP(ier_elsi_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ier_elsi_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_ier_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x2));
    u.val._anon4 	= 0;
    u.val.elsi = val;
    mackerel_write_addr_8(_dev->base,(0x2),u.raw);
}

static inline void __DP(ier_edssi_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ier_edssi_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_ier_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x2));
    u.val._anon4 	= 0;
    u.val.edssi = val;
    mackerel_write_addr_8(_dev->base,(0x2),u.raw);
}


static inline int __DP(ier_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ier_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pc16550d_mem_ier_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x2));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ier (Interrupt enable):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.erbfi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " erbfi =\t0x%"PRIx8" (Enable received data available interrupt", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.etbei;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " etbei =\t0x%"PRIx8" (Enable transmitter holding register empty interrupt", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.elsi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " elsi =\t0x%"PRIx8" (Enable receiver line status interrupt", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.edssi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " edssi =\t0x%"PRIx8" (Enable modem status interrupt", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register iir (Interrupt identification); type pc16550d_mem.iir (Implicit type of Interrupt identification register)
 */

/*
 * Dump of fields for register: iir
 *   iid (size 4, offset 0):	 RW	  Interrupt ID
 *   _anon4 (size 2, offset 4):	 MBZ	  _
 *   fifoe (size 2, offset 6):	 RW	  FIFOs enabled
 */

static inline uint8_t __DP(iir_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(iir_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0x3));
}

static inline pc16550d_mem_iir_t __DP(iir_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pc16550d_mem_iir_t __DP(iir_rd)( __DN(t) * _dev )
{
    pc16550d_mem_iir_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x3));
    return u.val;
}

static inline void __DP(iir_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(iir_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x3),val);
}

static inline void __DP(iir_wr)( __DN(t) * _dev, pc16550d_mem_iir_t val ) __attribute__ ((always_inline));
static inline void __DP(iir_wr)( __DN(t) * _dev, pc16550d_mem_iir_t val )
{
    pc16550d_mem_iir_un  u;
    u.val = val;
    u.val._anon4 	= 0;
    mackerel_write_addr_8(_dev->base,(0x3),u.raw);
}

static inline void __DP(iir_iid_wrf)( __DN(t) * _dev, pc16550d_mem_irq_id_t val ) __attribute__ ((always_inline));
static inline void __DP(iir_iid_wrf)( __DN(t) * _dev, pc16550d_mem_irq_id_t val )
{
    pc16550d_mem_iir_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x3));
    u.val._anon4 	= 0;
    u.val.iid = val;
    mackerel_write_addr_8(_dev->base,(0x3),u.raw);
}

static inline void __DP(iir_fifoe_wrf)( __DN(t) * _dev, pc16550d_mem_fifo_type_t val ) __attribute__ ((always_inline));
static inline void __DP(iir_fifoe_wrf)( __DN(t) * _dev, pc16550d_mem_fifo_type_t val )
{
    pc16550d_mem_iir_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x3));
    u.val._anon4 	= 0;
    u.val.fifoe = val;
    mackerel_write_addr_8(_dev->base,(0x3),u.raw);
}


static inline int __DP(iir_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(iir_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pc16550d_mem_iir_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x3));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register iir (Interrupt identification):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.iid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " iid =\t0x%"PRIx8" (Interrupt ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = pc16550d_mem_irq_id_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.fifoe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fifoe =\t0x%"PRIx8" (FIFOs enabled", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = pc16550d_mem_fifo_type_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register fcr (FIFO control); type pc16550d_mem.fcr (Implicit type of FIFO control register)
 */

/*
 * Dump of fields for register: fcr
 *   fifoe (size 1, offset 0):	 RW	  FIFO enable
 *   rfifo_reset (size 1, offset 1):	 RW	  RCVR FIFO reset
 *   xfifo_reset (size 1, offset 2):	 RW	  XMIT FIFO reset
 *   dma_mode (size 1, offset 3):	 RW	  DMA mode select
 *   _anon4 (size 2, offset 4):	 RSVD	  _
 *   rtrigger (size 2, offset 6):	 RW	  RCVR trigger
 */

static inline uint8_t __DP(fcr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(fcr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0x4));
}

static inline pc16550d_mem_fcr_t __DP(fcr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pc16550d_mem_fcr_t __DP(fcr_rd)( __DN(t) * _dev )
{
    pc16550d_mem_fcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x4));
    return u.val;
}

static inline void __DP(fcr_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fcr_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x4),val);
}

static inline void __DP(fcr_wr)( __DN(t) * _dev, pc16550d_mem_fcr_t val ) __attribute__ ((always_inline));
static inline void __DP(fcr_wr)( __DN(t) * _dev, pc16550d_mem_fcr_t val )
{
    pc16550d_mem_fcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x4));
    u.val.fifoe 	= val.fifoe;
    u.val.rfifo_reset 	= val.rfifo_reset;
    u.val.xfifo_reset 	= val.xfifo_reset;
    u.val.dma_mode 	= val.dma_mode;
    u.val.rtrigger 	= val.rtrigger;
    mackerel_write_addr_8(_dev->base,(0x4),u.raw);
}

static inline void __DP(fcr_fifoe_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fcr_fifoe_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_fcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x4));
    u.val.fifoe = val;
    mackerel_write_addr_8(_dev->base,(0x4),u.raw);
}

static inline void __DP(fcr_rfifo_reset_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fcr_rfifo_reset_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_fcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x4));
    u.val.rfifo_reset = val;
    mackerel_write_addr_8(_dev->base,(0x4),u.raw);
}

static inline void __DP(fcr_xfifo_reset_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fcr_xfifo_reset_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_fcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x4));
    u.val.xfifo_reset = val;
    mackerel_write_addr_8(_dev->base,(0x4),u.raw);
}

static inline void __DP(fcr_dma_mode_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(fcr_dma_mode_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_fcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x4));
    u.val.dma_mode = val;
    mackerel_write_addr_8(_dev->base,(0x4),u.raw);
}

static inline void __DP(fcr_rtrigger_wrf)( __DN(t) * _dev, pc16550d_mem_trigger_lvl_t val ) __attribute__ ((always_inline));
static inline void __DP(fcr_rtrigger_wrf)( __DN(t) * _dev, pc16550d_mem_trigger_lvl_t val )
{
    pc16550d_mem_fcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x4));
    u.val.rtrigger = val;
    mackerel_write_addr_8(_dev->base,(0x4),u.raw);
}


static inline int __DP(fcr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(fcr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pc16550d_mem_fcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x4));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register fcr (FIFO control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.fifoe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fifoe =\t0x%"PRIx8" (FIFO enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rfifo_reset;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rfifo_reset =\t0x%"PRIx8" (RCVR FIFO reset", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.xfifo_reset;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " xfifo_reset =\t0x%"PRIx8" (XMIT FIFO reset", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dma_mode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dma_mode =\t0x%"PRIx8" (DMA mode select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.rtrigger;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rtrigger =\t0x%"PRIx8" (RCVR trigger", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = pc16550d_mem_trigger_lvl_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register lcr (Line control); type pc16550d_mem.lcr (Implicit type of Line control register)
 */

/*
 * Dump of fields for register: lcr
 *   wls (size 2, offset 0):	 RW	  Word length select
 *   stb (size 1, offset 2):	 RW	  Number of stop bits
 *   pen (size 1, offset 3):	 RW	  Parity enable
 *   eps (size 1, offset 4):	 RW	  Even parity select
 *   sp (size 1, offset 5):	 RW	  Stick parity
 *   sb (size 1, offset 6):	 RW	  Set break
 *   dlab (size 1, offset 7):	 RW	  Divisor latch access
 */

static inline uint8_t __DP(lcr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(lcr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0x5));
}

static inline pc16550d_mem_lcr_t __DP(lcr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pc16550d_mem_lcr_t __DP(lcr_rd)( __DN(t) * _dev )
{
    pc16550d_mem_lcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x5));
    return u.val;
}

static inline void __DP(lcr_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lcr_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x5),val);
}

static inline void __DP(lcr_wr)( __DN(t) * _dev, pc16550d_mem_lcr_t val ) __attribute__ ((always_inline));
static inline void __DP(lcr_wr)( __DN(t) * _dev, pc16550d_mem_lcr_t val )
{
    pc16550d_mem_lcr_un  u;
    u.val = val;
    mackerel_write_addr_8(_dev->base,(0x5),u.raw);
}

static inline void __DP(lcr_wls_wrf)( __DN(t) * _dev, pc16550d_mem_char_len_t val ) __attribute__ ((always_inline));
static inline void __DP(lcr_wls_wrf)( __DN(t) * _dev, pc16550d_mem_char_len_t val )
{
    pc16550d_mem_lcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x5));
    u.val.wls = val;
    mackerel_write_addr_8(_dev->base,(0x5),u.raw);
}

static inline void __DP(lcr_stb_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lcr_stb_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_lcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x5));
    u.val.stb = val;
    mackerel_write_addr_8(_dev->base,(0x5),u.raw);
}

static inline void __DP(lcr_pen_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lcr_pen_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_lcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x5));
    u.val.pen = val;
    mackerel_write_addr_8(_dev->base,(0x5),u.raw);
}

static inline void __DP(lcr_eps_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lcr_eps_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_lcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x5));
    u.val.eps = val;
    mackerel_write_addr_8(_dev->base,(0x5),u.raw);
}

static inline void __DP(lcr_sp_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lcr_sp_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_lcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x5));
    u.val.sp = val;
    mackerel_write_addr_8(_dev->base,(0x5),u.raw);
}

static inline void __DP(lcr_sb_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lcr_sb_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_lcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x5));
    u.val.sb = val;
    mackerel_write_addr_8(_dev->base,(0x5),u.raw);
}

static inline void __DP(lcr_dlab_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lcr_dlab_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_lcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x5));
    u.val.dlab = val;
    mackerel_write_addr_8(_dev->base,(0x5),u.raw);
}


static inline int __DP(lcr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(lcr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pc16550d_mem_lcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x5));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register lcr (Line control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.wls;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wls =\t0x%"PRIx8" (Word length select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = pc16550d_mem_char_len_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.stb;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " stb =\t0x%"PRIx8" (Number of stop bits", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pen;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pen =\t0x%"PRIx8" (Parity enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.eps;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " eps =\t0x%"PRIx8" (Even parity select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sp =\t0x%"PRIx8" (Stick parity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sb;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sb =\t0x%"PRIx8" (Set break", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dlab;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dlab =\t0x%"PRIx8" (Divisor latch access", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register mcr (Modem control); type pc16550d_mem.mcr (Implicit type of Modem control register)
 */

/*
 * Dump of fields for register: mcr
 *   dtr (size 1, offset 0):	 RW	  Data terminal ready
 *   rts (size 1, offset 1):	 RW	  Request to send
 *   out (size 2, offset 2):	 RW	  Out
 *   loop (size 1, offset 4):	 RW	  Loop
 *   _anon5 (size 3, offset 5):	 MBZ	  _
 */

static inline uint8_t __DP(mcr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(mcr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0x6));
}

static inline pc16550d_mem_mcr_t __DP(mcr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pc16550d_mem_mcr_t __DP(mcr_rd)( __DN(t) * _dev )
{
    pc16550d_mem_mcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x6));
    return u.val;
}

static inline void __DP(mcr_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mcr_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x6),val);
}

static inline void __DP(mcr_wr)( __DN(t) * _dev, pc16550d_mem_mcr_t val ) __attribute__ ((always_inline));
static inline void __DP(mcr_wr)( __DN(t) * _dev, pc16550d_mem_mcr_t val )
{
    pc16550d_mem_mcr_un  u;
    u.val = val;
    u.val._anon5 	= 0;
    mackerel_write_addr_8(_dev->base,(0x6),u.raw);
}

static inline void __DP(mcr_dtr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mcr_dtr_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_mcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x6));
    u.val._anon5 	= 0;
    u.val.dtr = val;
    mackerel_write_addr_8(_dev->base,(0x6),u.raw);
}

static inline void __DP(mcr_rts_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mcr_rts_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_mcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x6));
    u.val._anon5 	= 0;
    u.val.rts = val;
    mackerel_write_addr_8(_dev->base,(0x6),u.raw);
}

static inline void __DP(mcr_out_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mcr_out_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_mcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x6));
    u.val._anon5 	= 0;
    u.val.out = val;
    mackerel_write_addr_8(_dev->base,(0x6),u.raw);
}

static inline void __DP(mcr_loop_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(mcr_loop_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_mcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x6));
    u.val._anon5 	= 0;
    u.val.loop = val;
    mackerel_write_addr_8(_dev->base,(0x6),u.raw);
}


static inline int __DP(mcr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(mcr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pc16550d_mem_mcr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x6));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register mcr (Modem control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.dtr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dtr =\t0x%"PRIx8" (Data terminal ready", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rts;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rts =\t0x%"PRIx8" (Request to send", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.out;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " out =\t0x%"PRIx8" (Out", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.loop;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " loop =\t0x%"PRIx8" (Loop", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register lsr (Line status); type pc16550d_mem.lsr (Implicit type of Line status register)
 */

/*
 * Dump of fields for register: lsr
 *   dr (size 1, offset 0):	 RW	  Data ready
 *   oe (size 1, offset 1):	 RW	  Overrun error
 *   pe (size 1, offset 2):	 RW	  Parity error
 *   fe (size 1, offset 3):	 RW	  Framing error
 *   bi (size 1, offset 4):	 RW	  Break interrupt
 *   thre (size 1, offset 5):	 RW	  Transmitter holding register
 *   temt (size 1, offset 6):	 RW	  Transmitter empty
 *   erfifo (size 1, offset 7):	 RW	  Error in RCVR FIFO
 */

static inline uint8_t __DP(lsr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(lsr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0x7));
}

static inline pc16550d_mem_lsr_t __DP(lsr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pc16550d_mem_lsr_t __DP(lsr_rd)( __DN(t) * _dev )
{
    pc16550d_mem_lsr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x7));
    return u.val;
}

static inline void __DP(lsr_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lsr_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x7),val);
}

static inline void __DP(lsr_wr)( __DN(t) * _dev, pc16550d_mem_lsr_t val ) __attribute__ ((always_inline));
static inline void __DP(lsr_wr)( __DN(t) * _dev, pc16550d_mem_lsr_t val )
{
    pc16550d_mem_lsr_un  u;
    u.val = val;
    mackerel_write_addr_8(_dev->base,(0x7),u.raw);
}

static inline void __DP(lsr_dr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lsr_dr_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_lsr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x7));
    u.val.dr = val;
    mackerel_write_addr_8(_dev->base,(0x7),u.raw);
}

static inline void __DP(lsr_oe_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lsr_oe_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_lsr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x7));
    u.val.oe = val;
    mackerel_write_addr_8(_dev->base,(0x7),u.raw);
}

static inline void __DP(lsr_pe_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lsr_pe_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_lsr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x7));
    u.val.pe = val;
    mackerel_write_addr_8(_dev->base,(0x7),u.raw);
}

static inline void __DP(lsr_fe_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lsr_fe_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_lsr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x7));
    u.val.fe = val;
    mackerel_write_addr_8(_dev->base,(0x7),u.raw);
}

static inline void __DP(lsr_bi_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lsr_bi_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_lsr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x7));
    u.val.bi = val;
    mackerel_write_addr_8(_dev->base,(0x7),u.raw);
}

static inline void __DP(lsr_thre_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lsr_thre_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_lsr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x7));
    u.val.thre = val;
    mackerel_write_addr_8(_dev->base,(0x7),u.raw);
}

static inline void __DP(lsr_temt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lsr_temt_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_lsr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x7));
    u.val.temt = val;
    mackerel_write_addr_8(_dev->base,(0x7),u.raw);
}

static inline void __DP(lsr_erfifo_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(lsr_erfifo_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_lsr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x7));
    u.val.erfifo = val;
    mackerel_write_addr_8(_dev->base,(0x7),u.raw);
}


static inline int __DP(lsr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(lsr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pc16550d_mem_lsr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x7));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register lsr (Line status):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.dr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dr =\t0x%"PRIx8" (Data ready", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.oe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " oe =\t0x%"PRIx8" (Overrun error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pe =\t0x%"PRIx8" (Parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fe =\t0x%"PRIx8" (Framing error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.bi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bi =\t0x%"PRIx8" (Break interrupt", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.thre;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " thre =\t0x%"PRIx8" (Transmitter holding register", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.temt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " temt =\t0x%"PRIx8" (Transmitter empty", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.erfifo;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " erfifo =\t0x%"PRIx8" (Error in RCVR FIFO", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register msr (Modem status); type pc16550d_mem.msr (Implicit type of Modem status register)
 */

/*
 * Dump of fields for register: msr
 *   dcts (size 1, offset 0):	 RW	  Delta clear to send
 *   ddsr (size 1, offset 1):	 RW	  Delta data set ready
 *   teri (size 1, offset 2):	 RW	  Trailing edge ring indicator
 *   ddcd (size 1, offset 3):	 RW	  Delta data carrier detect
 *   cts (size 1, offset 4):	 RW	  Clear to send
 *   dsr (size 1, offset 5):	 RW	  Data set ready
 *   ri (size 1, offset 6):	 RW	  Ring indicator
 *   dcd (size 1, offset 7):	 RW	  Data carrier detect
 */

static inline uint8_t __DP(msr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(msr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0x8));
}

static inline pc16550d_mem_msr_t __DP(msr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pc16550d_mem_msr_t __DP(msr_rd)( __DN(t) * _dev )
{
    pc16550d_mem_msr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x8));
    return u.val;
}

static inline void __DP(msr_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(msr_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x8),val);
}

static inline void __DP(msr_wr)( __DN(t) * _dev, pc16550d_mem_msr_t val ) __attribute__ ((always_inline));
static inline void __DP(msr_wr)( __DN(t) * _dev, pc16550d_mem_msr_t val )
{
    pc16550d_mem_msr_un  u;
    u.val = val;
    mackerel_write_addr_8(_dev->base,(0x8),u.raw);
}

static inline void __DP(msr_dcts_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(msr_dcts_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_msr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x8));
    u.val.dcts = val;
    mackerel_write_addr_8(_dev->base,(0x8),u.raw);
}

static inline void __DP(msr_ddsr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(msr_ddsr_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_msr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x8));
    u.val.ddsr = val;
    mackerel_write_addr_8(_dev->base,(0x8),u.raw);
}

static inline void __DP(msr_teri_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(msr_teri_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_msr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x8));
    u.val.teri = val;
    mackerel_write_addr_8(_dev->base,(0x8),u.raw);
}

static inline void __DP(msr_ddcd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(msr_ddcd_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_msr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x8));
    u.val.ddcd = val;
    mackerel_write_addr_8(_dev->base,(0x8),u.raw);
}

static inline void __DP(msr_cts_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(msr_cts_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_msr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x8));
    u.val.cts = val;
    mackerel_write_addr_8(_dev->base,(0x8),u.raw);
}

static inline void __DP(msr_dsr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(msr_dsr_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_msr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x8));
    u.val.dsr = val;
    mackerel_write_addr_8(_dev->base,(0x8),u.raw);
}

static inline void __DP(msr_ri_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(msr_ri_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_msr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x8));
    u.val.ri = val;
    mackerel_write_addr_8(_dev->base,(0x8),u.raw);
}

static inline void __DP(msr_dcd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(msr_dcd_wrf)( __DN(t) * _dev, uint8_t val )
{
    pc16550d_mem_msr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x8));
    u.val.dcd = val;
    mackerel_write_addr_8(_dev->base,(0x8),u.raw);
}


static inline int __DP(msr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(msr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pc16550d_mem_msr_un  u;
    u.raw = mackerel_read_addr_8(_dev->base,(0x8));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register msr (Modem status):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.dcts;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dcts =\t0x%"PRIx8" (Delta clear to send", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ddsr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ddsr =\t0x%"PRIx8" (Delta data set ready", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.teri;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " teri =\t0x%"PRIx8" (Trailing edge ring indicator", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ddcd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ddcd =\t0x%"PRIx8" (Delta data carrier detect", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cts;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cts =\t0x%"PRIx8" (Clear to send", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dsr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dsr =\t0x%"PRIx8" (Data set ready", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ri;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ri =\t0x%"PRIx8" (Ring indicator", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dcd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dcd =\t0x%"PRIx8" (Data carrier detect", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register scr (Scratch register); type pc16550d_mem.uint8
 */

static inline uint8_t __DP(scr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(scr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0x9));
}

static inline uint8_t __DP(scr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(scr_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0x9));
}

static inline void __DP(scr_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(scr_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x9),val);
}

static inline void __DP(scr_wr)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(scr_wr)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0x9),val);
}


static inline int __DP(scr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(scr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register scr (Scratch register):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_addr_8(_dev->base,(0x9)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register dl (Divisor latch); type pc16550d_mem.uint16
 */

static inline uint16_t __DP(dl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(dl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0xa));
}

static inline uint16_t __DP(dl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(dl_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_16(_dev->base,(0xa));
}

static inline void __DP(dl_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(dl_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0xa),val);
}

static inline void __DP(dl_wr)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(dl_wr)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_addr_16(_dev->base,(0xa),val);
}


static inline int __DP(dl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(dl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register dl (Divisor latch):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_addr_16(_dev->base,(0xa)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register dll (Divisor latch LSB); type pc16550d_mem.uint8
 */

static inline uint8_t __DP(dll_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(dll_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0xa));
}

static inline uint8_t __DP(dll_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(dll_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0xa));
}

static inline void __DP(dll_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dll_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0xa),val);
}

static inline void __DP(dll_wr)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dll_wr)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0xa),val);
}


static inline int __DP(dll_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(dll_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register dll (Divisor latch LSB):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_addr_8(_dev->base,(0xa)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register dlm (Divisor latch MSB); type pc16550d_mem.uint8
 */

static inline uint8_t __DP(dlm_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(dlm_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0xb));
}

static inline uint8_t __DP(dlm_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(dlm_rd)( __DN(t) * _dev )
{
    return mackerel_read_addr_8(_dev->base,(0xb));
}

static inline void __DP(dlm_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dlm_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0xb),val);
}

static inline void __DP(dlm_wr)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(dlm_wr)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_addr_8(_dev->base,(0xb),val);
}


static inline int __DP(dlm_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(dlm_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register dlm (Divisor latch MSB):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_addr_8(_dev->base,(0xb)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Dump of device pc16550d_mem (PC16550D UART Memory Represenation):\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rbr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(thr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ier_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(iir_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(fcr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(lcr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(mcr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(lsr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(msr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(scr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(dl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(dll_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(dlm_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "End of dump of device pc16550d_mem\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR


#endif // __pc16550d_mem_H
