#ifndef __ehci_DEV_H
#define __ehci_DEV_H 1
/*
 * DEVICE DEFINITION: EHCI USB Controller
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) ehci ## _ ## x
/*
 * Constants defn: ehci.itc_val (Interrupt threshold control)
 *  - no width specified
 */
typedef uint8_t ehci_itc_val_t;
#define ehci_itc_val_rsvd ((ehci_itc_val_t)0x0)
#define ehci_uframe_1 ((ehci_itc_val_t)0x1)
#define ehci_uframes_2 ((ehci_itc_val_t)0x2)
#define ehci_uframes_4 ((ehci_itc_val_t)0x4)
#define ehci_uframes_8 ((ehci_itc_val_t)0x8)
#define ehci_uframes_16 ((ehci_itc_val_t)0x10)
#define ehci_uframes_32 ((ehci_itc_val_t)0x20)
#define ehci_uframes_64 ((ehci_itc_val_t)0x40)

static inline char *ehci_itc_val_describe(ehci_itc_val_t _e) __attribute__ ((always_inline));
static inline char *ehci_itc_val_describe(ehci_itc_val_t _e)
{
    switch (_e) {
    case ehci_itc_val_rsvd:
        return("itc_val_rsvd: Reserved");
    case ehci_uframe_1:
        return("uframe_1: 1 Micro frame");
    case ehci_uframes_2:
        return("uframes_2: 2 Micro frames");
    case ehci_uframes_4:
        return("uframes_4: 4 Micro frames");
    case ehci_uframes_8:
        return("uframes_8: 8 Micro frames (default, equates to 1 ms)");
    case ehci_uframes_16:
        return("uframes_16: 16 Micro frames (2 ms)");
    case ehci_uframes_32:
        return("uframes_32: 32 Micro frames (4 ms)");
    case ehci_uframes_64:
        return("uframes_64: 64 Micro frames (8 ms)");
    default:
        return(NULL);
    }
}

static inline int ehci_itc_val_prtval(char *_s, size_t _size, ehci_itc_val_t _e) __attribute__ ((always_inline));
static inline int ehci_itc_val_prtval(char *_s, size_t _size, ehci_itc_val_t _e)
{
    char *d = ehci_itc_val_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ehci_itc_val_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ehci.frame_val (Frame list size)
 *  - no width specified
 */
typedef uint8_t ehci_frame_val_t;
#define ehci_elem_1024 ((ehci_frame_val_t)0x0)
#define ehci_elem_512 ((ehci_frame_val_t)0x1)
#define ehci_elem_256 ((ehci_frame_val_t)0x2)
#define ehci_frame_rsvd ((ehci_frame_val_t)0x3)

static inline char *ehci_frame_val_describe(ehci_frame_val_t _e) __attribute__ ((always_inline));
static inline char *ehci_frame_val_describe(ehci_frame_val_t _e)
{
    switch (_e) {
    case ehci_elem_1024:
        return("elem_1024: 1024 Elements (4096 bytes, default)");
    case ehci_elem_512:
        return("elem_512: 512 Elements (2048 bytes)");
    case ehci_elem_256:
        return("elem_256: 256 Elements (1024 bytes)");
    case ehci_frame_rsvd:
        return("frame_rsvd: Reserved");
    default:
        return(NULL);
    }
}

static inline int ehci_frame_val_prtval(char *_s, size_t _size, ehci_frame_val_t _e) __attribute__ ((always_inline));
static inline int ehci_frame_val_prtval(char *_s, size_t _size, ehci_frame_val_t _e)
{
    char *d = ehci_frame_val_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ehci_frame_val_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ehci.test_mode_val (Test modes)
 *  - no width specified
 */
typedef uint8_t ehci_test_mode_val_t;
#define ehci_disabled ((ehci_test_mode_val_t)0x0)
#define ehci_test_j_st ((ehci_test_mode_val_t)0x1)
#define ehci_test_k_st ((ehci_test_mode_val_t)0x2)
#define ehci_se0_nak ((ehci_test_mode_val_t)0x3)
#define ehci_test_pack ((ehci_test_mode_val_t)0x4)
#define ehci_force_ena ((ehci_test_mode_val_t)0x5)

static inline char *ehci_test_mode_val_describe(ehci_test_mode_val_t _e) __attribute__ ((always_inline));
static inline char *ehci_test_mode_val_describe(ehci_test_mode_val_t _e)
{
    switch (_e) {
    case ehci_disabled:
        return("disabled: Test mode not enabled");
    case ehci_test_j_st:
        return("test_j_st: Test J_STATE");
    case ehci_test_k_st:
        return("test_k_st: Test K_STATE");
    case ehci_se0_nak:
        return("se0_nak: Test SE0_NAK");
    case ehci_test_pack:
        return("test_pack: Test packet");
    case ehci_force_ena:
        return("force_ena: Force enable");
    default:
        return(NULL);
    }
}

static inline int ehci_test_mode_val_prtval(char *_s, size_t _size, ehci_test_mode_val_t _e) __attribute__ ((always_inline));
static inline int ehci_test_mode_val_prtval(char *_s, size_t _size, ehci_test_mode_val_t _e)
{
    char *d = ehci_test_mode_val_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ehci_test_mode_val_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ehci.indi_val (Port indicator values)
 *  - no width specified
 */
typedef uint8_t ehci_indi_val_t;
#define ehci_off ((ehci_indi_val_t)0x0)
#define ehci_amber ((ehci_indi_val_t)0x1)
#define ehci_green ((ehci_indi_val_t)0x2)
#define ehci_indi_val_undef ((ehci_indi_val_t)0x3)

static inline char *ehci_indi_val_describe(ehci_indi_val_t _e) __attribute__ ((always_inline));
static inline char *ehci_indi_val_describe(ehci_indi_val_t _e)
{
    switch (_e) {
    case ehci_off:
        return("off: Port indicators are off");
    case ehci_amber:
        return("amber: Amber");
    case ehci_green:
        return("green: Green");
    case ehci_indi_val_undef:
        return("indi_val_undef: Undefined");
    default:
        return(NULL);
    }
}

static inline int ehci_indi_val_prtval(char *_s, size_t _size, ehci_indi_val_t _e) __attribute__ ((always_inline));
static inline int ehci_indi_val_prtval(char *_s, size_t _size, ehci_indi_val_t _e)
{
    char *d = ehci_indi_val_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ehci_indi_val_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ehci.lstatus_val (USB line status)
 *  - no width specified
 */
typedef uint8_t ehci_lstatus_val_t;
#define ehci_se0 ((ehci_lstatus_val_t)0x0)
#define ehci_j_state ((ehci_lstatus_val_t)0x2)
#define ehci_k_state ((ehci_lstatus_val_t)0x1)
#define ehci_lstatus_undef ((ehci_lstatus_val_t)0x3)

static inline char *ehci_lstatus_val_describe(ehci_lstatus_val_t _e) __attribute__ ((always_inline));
static inline char *ehci_lstatus_val_describe(ehci_lstatus_val_t _e)
{
    switch (_e) {
    case ehci_se0:
        return("se0: Not low speed device, perform EHCI reset");
    case ehci_j_state:
        return("j_state: Not low speed device, perform EHCI reset");
    case ehci_k_state:
        return("k_state: Low speed device, release ownership of port");
    case ehci_lstatus_undef:
        return("lstatus_undef: Not low speed device, perform EHCI reset");
    default:
        return(NULL);
    }
}

static inline int ehci_lstatus_val_prtval(char *_s, size_t _size, ehci_lstatus_val_t _e) __attribute__ ((always_inline));
static inline int ehci_lstatus_val_prtval(char *_s, size_t _size, ehci_lstatus_val_t _e)
{
    char *d = ehci_lstatus_val_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ehci_lstatus_val_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: ehci_hcsparams_t
 * Description: Implicit type of Structural parameters register
 * Fields:
 *   n_ports	(size 4, offset 0, init 0):	RO	Num. physical downstream ports on this controller
 *   ppc	(size 1, offset 4, init 0):	RO	Port power control
 *   _anon5	(size 2, offset 5, init 0):	RSVD	_
 *   prr	(size 1, offset 7, init 0):	RO	Port routing rules
 *   n_pcc	(size 4, offset 8, init 0):	RO	Number of ports per companion controller
 *   n_cc	(size 4, offset 12, init 0):	RO	Number of campanion controller
 *   p_indicator	(size 1, offset 16, init 0):	RO	Port indicator
 *   _anon17	(size 3, offset 17, init 0):	RSVD	_
 *   dpn	(size 4, offset 20, init 0):	RO	Debug port number
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
typedef uint32_t ehci_hcsparams_t;
#define ehci_hcsparams_default 0x0
static inline uint8_t ehci_hcsparams_n_ports_extract(ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hcsparams_n_ports_extract(ehci_hcsparams_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline ehci_hcsparams_t ehci_hcsparams_n_ports_insert(ehci_hcsparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hcsparams_t ehci_hcsparams_n_ports_insert(ehci_hcsparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((ehci_hcsparams_t )(_fieldval)) << 0)));
}

static inline uint8_t ehci_hcsparams_ppc_extract(ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hcsparams_ppc_extract(ehci_hcsparams_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ehci_hcsparams_t ehci_hcsparams_ppc_insert(ehci_hcsparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hcsparams_t ehci_hcsparams_ppc_insert(ehci_hcsparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ehci_hcsparams_t )(_fieldval)) << 4)));
}

static inline uint8_t ehci_hcsparams_prr_extract(ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hcsparams_prr_extract(ehci_hcsparams_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline ehci_hcsparams_t ehci_hcsparams_prr_insert(ehci_hcsparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hcsparams_t ehci_hcsparams_prr_insert(ehci_hcsparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((ehci_hcsparams_t )(_fieldval)) << 7)));
}

static inline uint8_t ehci_hcsparams_n_pcc_extract(ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hcsparams_n_pcc_extract(ehci_hcsparams_t _regval)
{
    return((uint8_t )((_regval & 0xf00) >> 8));
}

static inline ehci_hcsparams_t ehci_hcsparams_n_pcc_insert(ehci_hcsparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hcsparams_t ehci_hcsparams_n_pcc_insert(ehci_hcsparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff0ff) | (0xf00 & (((ehci_hcsparams_t )(_fieldval)) << 8)));
}

static inline uint8_t ehci_hcsparams_n_cc_extract(ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hcsparams_n_cc_extract(ehci_hcsparams_t _regval)
{
    return((uint8_t )((_regval & 0xf000) >> 12));
}

static inline ehci_hcsparams_t ehci_hcsparams_n_cc_insert(ehci_hcsparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hcsparams_t ehci_hcsparams_n_cc_insert(ehci_hcsparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff0fff) | (0xf000 & (((ehci_hcsparams_t )(_fieldval)) << 12)));
}

static inline uint8_t ehci_hcsparams_p_indicator_extract(ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hcsparams_p_indicator_extract(ehci_hcsparams_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline ehci_hcsparams_t ehci_hcsparams_p_indicator_insert(ehci_hcsparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hcsparams_t ehci_hcsparams_p_indicator_insert(ehci_hcsparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((ehci_hcsparams_t )(_fieldval)) << 16)));
}

static inline uint8_t ehci_hcsparams_dpn_extract(ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hcsparams_dpn_extract(ehci_hcsparams_t _regval)
{
    return((uint8_t )((_regval & 0xf00000) >> 20));
}

static inline ehci_hcsparams_t ehci_hcsparams_dpn_insert(ehci_hcsparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hcsparams_t ehci_hcsparams_dpn_insert(ehci_hcsparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff0fffff) | (0xf00000 & (((ehci_hcsparams_t )(_fieldval)) << 20)));
}

static inline int ehci_hcsparams_prtval(char *_s, size_t _size, ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline int ehci_hcsparams_prtval(char *_s, size_t _size, ehci_hcsparams_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_ports =\t%" PRIx8 "\t(Num. physical downstream ports on this controller)\n", ehci_hcsparams_n_ports_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ppc =\t%" PRIx8 "\t(Port power control)\n", ehci_hcsparams_ppc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prr =\t%" PRIx8 "\t(Port routing rules)\n", ehci_hcsparams_prr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_pcc =\t%" PRIx8 "\t(Number of ports per companion controller)\n", ehci_hcsparams_n_pcc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_cc =\t%" PRIx8 "\t(Number of campanion controller)\n", ehci_hcsparams_n_cc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_indicator =\t%" PRIx8 "\t(Port indicator)\n", ehci_hcsparams_p_indicator_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpn =\t%" PRIx8 "\t(Debug port number)\n", ehci_hcsparams_dpn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_hccparams_t
 * Description: Implicit type of Capability parameters register
 * Fields:
 *   bit64ac	(size 1, offset 0, init 0):	RO	Extended 64 bit addressing capability
 *   pflf	(size 1, offset 1, init 0):	RO	Programmable frame list flag
 *   aspc	(size 1, offset 2, init 0):	RO	Asynchronous sechedule park capability
 *   _anon3	(size 1, offset 3, init 0):	RSVD	_
 *   ist	(size 4, offset 4, init 0):	RO	Isochronous scheduling threshold
 *   eecp	(size 8, offset 8, init 0):	RO	EHCI extended capabilities pointer
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t ehci_hccparams_t;
#define ehci_hccparams_default 0x0
static inline uint8_t ehci_hccparams_bit64ac_extract(ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_bit64ac_extract(ehci_hccparams_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ehci_hccparams_t ehci_hccparams_bit64ac_insert(ehci_hccparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hccparams_t ehci_hccparams_bit64ac_insert(ehci_hccparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ehci_hccparams_t )(_fieldval)) << 0)));
}

static inline uint8_t ehci_hccparams_pflf_extract(ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_pflf_extract(ehci_hccparams_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ehci_hccparams_t ehci_hccparams_pflf_insert(ehci_hccparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hccparams_t ehci_hccparams_pflf_insert(ehci_hccparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ehci_hccparams_t )(_fieldval)) << 1)));
}

static inline uint8_t ehci_hccparams_aspc_extract(ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_aspc_extract(ehci_hccparams_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ehci_hccparams_t ehci_hccparams_aspc_insert(ehci_hccparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hccparams_t ehci_hccparams_aspc_insert(ehci_hccparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ehci_hccparams_t )(_fieldval)) << 2)));
}

static inline uint8_t ehci_hccparams_ist_extract(ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_ist_extract(ehci_hccparams_t _regval)
{
    return((uint8_t )((_regval & 0xf0) >> 4));
}

static inline ehci_hccparams_t ehci_hccparams_ist_insert(ehci_hccparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hccparams_t ehci_hccparams_ist_insert(ehci_hccparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((ehci_hccparams_t )(_fieldval)) << 4)));
}

static inline uint8_t ehci_hccparams_eecp_extract(ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_eecp_extract(ehci_hccparams_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline ehci_hccparams_t ehci_hccparams_eecp_insert(ehci_hccparams_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hccparams_t ehci_hccparams_eecp_insert(ehci_hccparams_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((ehci_hccparams_t )(_fieldval)) << 8)));
}

static inline int ehci_hccparams_prtval(char *_s, size_t _size, ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline int ehci_hccparams_prtval(char *_s, size_t _size, ehci_hccparams_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bit64ac =\t%" PRIx8 "\t(Extended 64 bit addressing capability)\n", ehci_hccparams_bit64ac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pflf =\t%" PRIx8 "\t(Programmable frame list flag)\n", ehci_hccparams_pflf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspc =\t%" PRIx8 "\t(Asynchronous sechedule park capability)\n", ehci_hccparams_aspc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ist =\t%" PRIx8 "\t(Isochronous scheduling threshold)\n", ehci_hccparams_ist_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eecp =\t%" PRIx8 "\t(EHCI extended capabilities pointer)\n", ehci_hccparams_eecp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_hcspportroute_t
 * Description: Implicit type of Companion port route descr. register
 * Fields:
 *   _anon0	(size 4, offset 0, init 0):	RSVD	_
 *   attr	(size 60, offset 4, init 0):	RO	Port array
 */
typedef uint64_t ehci_hcspportroute_t;
#define ehci_hcspportroute_default 0x0
static inline uint64_t ehci_hcspportroute_attr_extract(ehci_hcspportroute_t _regval) __attribute__ ((always_inline));
static inline uint64_t ehci_hcspportroute_attr_extract(ehci_hcspportroute_t _regval)
{
    return((uint64_t )((_regval & 0xfffffffffffffff0) >> 4));
}

static inline ehci_hcspportroute_t ehci_hcspportroute_attr_insert(ehci_hcspportroute_t _regval, uint64_t _fieldval) __attribute__ ((always_inline));
static inline ehci_hcspportroute_t ehci_hcspportroute_attr_insert(ehci_hcspportroute_t _regval, uint64_t _fieldval)
{
    return((_regval & 0xf) | (0xfffffffffffffff0 & (((ehci_hcspportroute_t )(_fieldval)) << 4)));
}

static inline int ehci_hcspportroute_prtval(char *_s, size_t _size, ehci_hcspportroute_t _regval) __attribute__ ((always_inline));
static inline int ehci_hcspportroute_prtval(char *_s, size_t _size, ehci_hcspportroute_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " attr =\t%" PRIx64 "\t(Port array)\n", ehci_hcspportroute_attr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_usbcmd_t
 * Description: Implicit type of USB command register
 * Fields:
 *   rs	(size 1, offset 0, init 0):	RW	Run stop for scheduling
 *   hcr	(size 1, offset 1, init 0):	RW	Host controller reset
 *   fls	(size 2, offset 2, init 0):	RW	Frame list size
 *   pse	(size 1, offset 4, init 0):	RW	Periodic schedule enable
 *   ase	(size 1, offset 5, init 0):	RW	Asynchronous schedule enable
 *   iaad	(size 1, offset 6, init 0):	RW	Interrupt on async advance doorbell
 *   lhcr	(size 1, offset 7, init 0):	RW	Light host controller reset
 *   aspmc	(size 2, offset 8, init 0):	RW	Asynchronous schedule park mode count
 *   _anon10	(size 1, offset 10, init 0):	MBZ	_
 *   aspme	(size 1, offset 11, init 0):	RW	Asynchronous schedule park mode enable
 *   _anon12	(size 4, offset 12, init 0):	MBZ	_
 *   itc	(size 8, offset 16, init 0):	RW	Interrupt threshold control
 *   _anon24	(size 8, offset 24, init 0):	MBZ	_
 */
typedef uint32_t ehci_usbcmd_t;
#define ehci_usbcmd_default 0x0
static inline uint8_t ehci_usbcmd_rs_extract(ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbcmd_rs_extract(ehci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ehci_usbcmd_t ehci_usbcmd_rs_insert(ehci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbcmd_t ehci_usbcmd_rs_insert(ehci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ehci_usbcmd_t )(_fieldval)) << 0)));
}

static inline uint8_t ehci_usbcmd_hcr_extract(ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbcmd_hcr_extract(ehci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ehci_usbcmd_t ehci_usbcmd_hcr_insert(ehci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbcmd_t ehci_usbcmd_hcr_insert(ehci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ehci_usbcmd_t )(_fieldval)) << 1)));
}

static inline ehci_frame_val_t ehci_usbcmd_fls_extract(ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline ehci_frame_val_t ehci_usbcmd_fls_extract(ehci_usbcmd_t _regval)
{
    return((ehci_frame_val_t )((_regval & 0xc) >> 2));
}

static inline ehci_usbcmd_t ehci_usbcmd_fls_insert(ehci_usbcmd_t _regval, ehci_frame_val_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbcmd_t ehci_usbcmd_fls_insert(ehci_usbcmd_t _regval, ehci_frame_val_t _fieldval)
{
    return((_regval & 0xfffffff3) | (0xc & (((ehci_usbcmd_t )(_fieldval)) << 2)));
}

static inline uint8_t ehci_usbcmd_pse_extract(ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbcmd_pse_extract(ehci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ehci_usbcmd_t ehci_usbcmd_pse_insert(ehci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbcmd_t ehci_usbcmd_pse_insert(ehci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ehci_usbcmd_t )(_fieldval)) << 4)));
}

static inline uint8_t ehci_usbcmd_ase_extract(ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbcmd_ase_extract(ehci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ehci_usbcmd_t ehci_usbcmd_ase_insert(ehci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbcmd_t ehci_usbcmd_ase_insert(ehci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((ehci_usbcmd_t )(_fieldval)) << 5)));
}

static inline uint8_t ehci_usbcmd_iaad_extract(ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbcmd_iaad_extract(ehci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline ehci_usbcmd_t ehci_usbcmd_iaad_insert(ehci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbcmd_t ehci_usbcmd_iaad_insert(ehci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((ehci_usbcmd_t )(_fieldval)) << 6)));
}

static inline uint8_t ehci_usbcmd_lhcr_extract(ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbcmd_lhcr_extract(ehci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline ehci_usbcmd_t ehci_usbcmd_lhcr_insert(ehci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbcmd_t ehci_usbcmd_lhcr_insert(ehci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((ehci_usbcmd_t )(_fieldval)) << 7)));
}

static inline uint8_t ehci_usbcmd_aspmc_extract(ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbcmd_aspmc_extract(ehci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x300) >> 8));
}

static inline ehci_usbcmd_t ehci_usbcmd_aspmc_insert(ehci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbcmd_t ehci_usbcmd_aspmc_insert(ehci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffcff) | (0x300 & (((ehci_usbcmd_t )(_fieldval)) << 8)));
}

static inline uint8_t ehci_usbcmd_aspme_extract(ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbcmd_aspme_extract(ehci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline ehci_usbcmd_t ehci_usbcmd_aspme_insert(ehci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbcmd_t ehci_usbcmd_aspme_insert(ehci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((ehci_usbcmd_t )(_fieldval)) << 11)));
}

static inline ehci_itc_val_t ehci_usbcmd_itc_extract(ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline ehci_itc_val_t ehci_usbcmd_itc_extract(ehci_usbcmd_t _regval)
{
    return((ehci_itc_val_t )((_regval & 0xff0000) >> 16));
}

static inline ehci_usbcmd_t ehci_usbcmd_itc_insert(ehci_usbcmd_t _regval, ehci_itc_val_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbcmd_t ehci_usbcmd_itc_insert(ehci_usbcmd_t _regval, ehci_itc_val_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((ehci_usbcmd_t )(_fieldval)) << 16)));
}

static inline int ehci_usbcmd_prtval(char *_s, size_t _size, ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline int ehci_usbcmd_prtval(char *_s, size_t _size, ehci_usbcmd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rs =\t%" PRIx8 "\t(Run stop for scheduling)\n", ehci_usbcmd_rs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcr =\t%" PRIx8 "\t(Host controller reset)\n", ehci_usbcmd_hcr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fls =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_frame_val_prtval(_s + _r, _avail, ehci_usbcmd_fls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Frame list size)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pse =\t%" PRIx8 "\t(Periodic schedule enable)\n", ehci_usbcmd_pse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ase =\t%" PRIx8 "\t(Asynchronous schedule enable)\n", ehci_usbcmd_ase_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iaad =\t%" PRIx8 "\t(Interrupt on async advance doorbell)\n", ehci_usbcmd_iaad_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lhcr =\t%" PRIx8 "\t(Light host controller reset)\n", ehci_usbcmd_lhcr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspmc =\t%" PRIx8 "\t(Asynchronous schedule park mode count)\n", ehci_usbcmd_aspmc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspme =\t%" PRIx8 "\t(Asynchronous schedule park mode enable)\n", ehci_usbcmd_aspme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " itc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itc_val_prtval(_s + _r, _avail, ehci_usbcmd_itc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interrupt threshold control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_usbsts_t
 * Description: Implicit type of USB status register
 * Fields:
 *   usbi	(size 1, offset 0, init 0):	RWC	USB interrupt
 *   usbei	(size 1, offset 1, init 0):	RWC	USB error interrupt
 *   pcd	(size 1, offset 2, init 0):	RWC	Port change detect
 *   flr	(size 1, offset 3, init 0):	RWC	Frame list rollover
 *   hse	(size 1, offset 4, init 0):	RWC	Host system error
 *   iaa	(size 1, offset 5, init 0):	RWC	Interrupt on Async advance
 *   _anon6	(size 6, offset 6, init 0):	MBZ	_
 *   hch	(size 1, offset 12, init 0):	RO	Host controller halted see Run/Stop
 *   rec	(size 1, offset 13, init 0):	RO	Reclamation
 *   pss	(size 1, offset 14, init 0):	RO	Periodic schedule status
 *   ass	(size 1, offset 15, init 0):	RO	Asynchronous schedule status
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint32_t ehci_usbsts_t;
#define ehci_usbsts_default 0x0
static inline uint8_t ehci_usbsts_usbi_extract(ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_usbi_extract(ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ehci_usbsts_t ehci_usbsts_usbi_insert(ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbsts_t ehci_usbsts_usbi_insert(ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ehci_usbsts_t )(_fieldval)) << 0)));
}

static inline uint8_t ehci_usbsts_usbei_extract(ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_usbei_extract(ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ehci_usbsts_t ehci_usbsts_usbei_insert(ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbsts_t ehci_usbsts_usbei_insert(ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ehci_usbsts_t )(_fieldval)) << 1)));
}

static inline uint8_t ehci_usbsts_pcd_extract(ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_pcd_extract(ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ehci_usbsts_t ehci_usbsts_pcd_insert(ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbsts_t ehci_usbsts_pcd_insert(ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ehci_usbsts_t )(_fieldval)) << 2)));
}

static inline uint8_t ehci_usbsts_flr_extract(ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_flr_extract(ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ehci_usbsts_t ehci_usbsts_flr_insert(ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbsts_t ehci_usbsts_flr_insert(ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ehci_usbsts_t )(_fieldval)) << 3)));
}

static inline uint8_t ehci_usbsts_hse_extract(ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_hse_extract(ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ehci_usbsts_t ehci_usbsts_hse_insert(ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbsts_t ehci_usbsts_hse_insert(ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ehci_usbsts_t )(_fieldval)) << 4)));
}

static inline uint8_t ehci_usbsts_iaa_extract(ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_iaa_extract(ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ehci_usbsts_t ehci_usbsts_iaa_insert(ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbsts_t ehci_usbsts_iaa_insert(ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((ehci_usbsts_t )(_fieldval)) << 5)));
}

static inline uint8_t ehci_usbsts_hch_extract(ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_hch_extract(ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline ehci_usbsts_t ehci_usbsts_hch_insert(ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbsts_t ehci_usbsts_hch_insert(ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((ehci_usbsts_t )(_fieldval)) << 12)));
}

static inline uint8_t ehci_usbsts_rec_extract(ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_rec_extract(ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline ehci_usbsts_t ehci_usbsts_rec_insert(ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbsts_t ehci_usbsts_rec_insert(ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((ehci_usbsts_t )(_fieldval)) << 13)));
}

static inline uint8_t ehci_usbsts_pss_extract(ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_pss_extract(ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline ehci_usbsts_t ehci_usbsts_pss_insert(ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbsts_t ehci_usbsts_pss_insert(ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((ehci_usbsts_t )(_fieldval)) << 14)));
}

static inline uint8_t ehci_usbsts_ass_extract(ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_ass_extract(ehci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline ehci_usbsts_t ehci_usbsts_ass_insert(ehci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbsts_t ehci_usbsts_ass_insert(ehci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((ehci_usbsts_t )(_fieldval)) << 15)));
}

static inline int ehci_usbsts_prtval(char *_s, size_t _size, ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline int ehci_usbsts_prtval(char *_s, size_t _size, ehci_usbsts_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbi =\t%" PRIx8 "\t(USB interrupt)\n", ehci_usbsts_usbi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbei =\t%" PRIx8 "\t(USB error interrupt)\n", ehci_usbsts_usbei_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcd =\t%" PRIx8 "\t(Port change detect)\n", ehci_usbsts_pcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flr =\t%" PRIx8 "\t(Frame list rollover)\n", ehci_usbsts_flr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hse =\t%" PRIx8 "\t(Host system error)\n", ehci_usbsts_hse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iaa =\t%" PRIx8 "\t(Interrupt on Async advance)\n", ehci_usbsts_iaa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hch =\t%" PRIx8 "\t(Host controller halted see Run/Stop)\n", ehci_usbsts_hch_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rec =\t%" PRIx8 "\t(Reclamation)\n", ehci_usbsts_rec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pss =\t%" PRIx8 "\t(Periodic schedule status)\n", ehci_usbsts_pss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ass =\t%" PRIx8 "\t(Asynchronous schedule status)\n", ehci_usbsts_ass_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_usbintr_t
 * Description: Implicit type of USB interrupt enable register
 * Fields:
 *   usbie	(size 1, offset 0, init 0):	RW	USB interrupt enable
 *   usbeie	(size 1, offset 1, init 0):	RW	USB error interrupt enable
 *   pcie	(size 1, offset 2, init 0):	RW	Port change interrupt enable
 *   flre	(size 1, offset 3, init 0):	RW	Frame list rollover enable
 *   hsee	(size 1, offset 4, init 0):	RW	Host system error enable
 *   iaae	(size 1, offset 5, init 0):	RW	Interrupt on async advance enable
 *   _anon6	(size 26, offset 6, init 0):	MBZ	_
 */
typedef uint32_t ehci_usbintr_t;
#define ehci_usbintr_default 0x0
static inline uint8_t ehci_usbintr_usbie_extract(ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbintr_usbie_extract(ehci_usbintr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ehci_usbintr_t ehci_usbintr_usbie_insert(ehci_usbintr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbintr_t ehci_usbintr_usbie_insert(ehci_usbintr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ehci_usbintr_t )(_fieldval)) << 0)));
}

static inline uint8_t ehci_usbintr_usbeie_extract(ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbintr_usbeie_extract(ehci_usbintr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ehci_usbintr_t ehci_usbintr_usbeie_insert(ehci_usbintr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbintr_t ehci_usbintr_usbeie_insert(ehci_usbintr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ehci_usbintr_t )(_fieldval)) << 1)));
}

static inline uint8_t ehci_usbintr_pcie_extract(ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbintr_pcie_extract(ehci_usbintr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ehci_usbintr_t ehci_usbintr_pcie_insert(ehci_usbintr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbintr_t ehci_usbintr_pcie_insert(ehci_usbintr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ehci_usbintr_t )(_fieldval)) << 2)));
}

static inline uint8_t ehci_usbintr_flre_extract(ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbintr_flre_extract(ehci_usbintr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ehci_usbintr_t ehci_usbintr_flre_insert(ehci_usbintr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbintr_t ehci_usbintr_flre_insert(ehci_usbintr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ehci_usbintr_t )(_fieldval)) << 3)));
}

static inline uint8_t ehci_usbintr_hsee_extract(ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbintr_hsee_extract(ehci_usbintr_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ehci_usbintr_t ehci_usbintr_hsee_insert(ehci_usbintr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbintr_t ehci_usbintr_hsee_insert(ehci_usbintr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ehci_usbintr_t )(_fieldval)) << 4)));
}

static inline uint8_t ehci_usbintr_iaae_extract(ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_usbintr_iaae_extract(ehci_usbintr_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ehci_usbintr_t ehci_usbintr_iaae_insert(ehci_usbintr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_usbintr_t ehci_usbintr_iaae_insert(ehci_usbintr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((ehci_usbintr_t )(_fieldval)) << 5)));
}

static inline int ehci_usbintr_prtval(char *_s, size_t _size, ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline int ehci_usbintr_prtval(char *_s, size_t _size, ehci_usbintr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbie =\t%" PRIx8 "\t(USB interrupt enable)\n", ehci_usbintr_usbie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbeie =\t%" PRIx8 "\t(USB error interrupt enable)\n", ehci_usbintr_usbeie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie =\t%" PRIx8 "\t(Port change interrupt enable)\n", ehci_usbintr_pcie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flre =\t%" PRIx8 "\t(Frame list rollover enable)\n", ehci_usbintr_flre_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsee =\t%" PRIx8 "\t(Host system error enable)\n", ehci_usbintr_hsee_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iaae =\t%" PRIx8 "\t(Interrupt on async advance enable)\n", ehci_usbintr_iaae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_frindex_t
 * Description: Implicit type of Frame index register
 * Fields:
 *   fi	(size 14, offset 0, init 0):	RW	Frame index
 *   _anon14	(size 18, offset 14, init 0):	MBZ	_
 */
typedef uint32_t ehci_frindex_t;
#define ehci_frindex_default 0x0
static inline uint16_t ehci_frindex_fi_extract(ehci_frindex_t _regval) __attribute__ ((always_inline));
static inline uint16_t ehci_frindex_fi_extract(ehci_frindex_t _regval)
{
    return((uint16_t )((_regval & 0x3fff) >> 0));
}

static inline ehci_frindex_t ehci_frindex_fi_insert(ehci_frindex_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ehci_frindex_t ehci_frindex_fi_insert(ehci_frindex_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffffc000) | (0x3fff & (((ehci_frindex_t )(_fieldval)) << 0)));
}

static inline int ehci_frindex_prtval(char *_s, size_t _size, ehci_frindex_t _regval) __attribute__ ((always_inline));
static inline int ehci_frindex_prtval(char *_s, size_t _size, ehci_frindex_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fi =\t%" PRIx16 "\t(Frame index)\n", ehci_frindex_fi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_ctrldssegment_t
 * Description: Implicit type of Control data structure segment register
 * Fields:
 *   data	(size 32, offset 0, init 0):	RW	MSB [63:32] bits of EHCI data strctures
 */
typedef uint32_t ehci_ctrldssegment_t;
#define ehci_ctrldssegment_default 0x0
static inline uint32_t ehci_ctrldssegment_data_extract(ehci_ctrldssegment_t _regval) __attribute__ ((always_inline));
static inline uint32_t ehci_ctrldssegment_data_extract(ehci_ctrldssegment_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline ehci_ctrldssegment_t ehci_ctrldssegment_data_insert(ehci_ctrldssegment_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline ehci_ctrldssegment_t ehci_ctrldssegment_data_insert(ehci_ctrldssegment_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((ehci_ctrldssegment_t )(_fieldval)) << 0)));
}

static inline int ehci_ctrldssegment_prtval(char *_s, size_t _size, ehci_ctrldssegment_t _regval) __attribute__ ((always_inline));
static inline int ehci_ctrldssegment_prtval(char *_s, size_t _size, ehci_ctrldssegment_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx32 "\t(MSB [63:32] bits of EHCI data strctures)\n", ehci_ctrldssegment_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_periodiclistbase_t
 * Description: Implicit type of Periodic frame list base addr register
 * Fields:
 *   _anon0	(size 12, offset 0, init 0):	MBZ	_
 *   addr	(size 20, offset 12, init 0):	RW	Base address (must be 4k aligned)
 */
typedef uint32_t ehci_periodiclistbase_t;
#define ehci_periodiclistbase_default 0x0
static inline uint32_t ehci_periodiclistbase_addr_extract(ehci_periodiclistbase_t _regval) __attribute__ ((always_inline));
static inline uint32_t ehci_periodiclistbase_addr_extract(ehci_periodiclistbase_t _regval)
{
    return((uint32_t )((_regval & 0xfffff000) >> 12));
}

static inline ehci_periodiclistbase_t ehci_periodiclistbase_addr_insert(ehci_periodiclistbase_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline ehci_periodiclistbase_t ehci_periodiclistbase_addr_insert(ehci_periodiclistbase_t _regval, uint32_t _fieldval)
{
    return((_regval & 0xfff) | (0xfffff000 & (((ehci_periodiclistbase_t )(_fieldval)) << 12)));
}

static inline int ehci_periodiclistbase_prtval(char *_s, size_t _size, ehci_periodiclistbase_t _regval) __attribute__ ((always_inline));
static inline int ehci_periodiclistbase_prtval(char *_s, size_t _size, ehci_periodiclistbase_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Base address (must be 4k aligned))\n", ehci_periodiclistbase_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_asynclistaddr_t
 * Description: Implicit type of Current async. list addr. register
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	MBZ	_
 *   lpl	(size 27, offset 5, init 0):	RW	Link pointer low
 */
typedef uint32_t ehci_asynclistaddr_t;
#define ehci_asynclistaddr_default 0x0
static inline uint32_t ehci_asynclistaddr_lpl_extract(ehci_asynclistaddr_t _regval) __attribute__ ((always_inline));
static inline uint32_t ehci_asynclistaddr_lpl_extract(ehci_asynclistaddr_t _regval)
{
    return((uint32_t )((_regval & 0xffffffe0) >> 5));
}

static inline ehci_asynclistaddr_t ehci_asynclistaddr_lpl_insert(ehci_asynclistaddr_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline ehci_asynclistaddr_t ehci_asynclistaddr_lpl_insert(ehci_asynclistaddr_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x1f) | (0xffffffe0 & (((ehci_asynclistaddr_t )(_fieldval)) << 5)));
}

static inline int ehci_asynclistaddr_prtval(char *_s, size_t _size, ehci_asynclistaddr_t _regval) __attribute__ ((always_inline));
static inline int ehci_asynclistaddr_prtval(char *_s, size_t _size, ehci_asynclistaddr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpl =\t%" PRIx32 "\t(Link pointer low)\n", ehci_asynclistaddr_lpl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_configflag_t
 * Description: Implicit type of Configure flag register
 * Fields:
 *   cf	(size 1, offset 0, init 0):	RW	Configure flag
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
typedef uint32_t ehci_configflag_t;
#define ehci_configflag_default 0x0
static inline uint8_t ehci_configflag_cf_extract(ehci_configflag_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_configflag_cf_extract(ehci_configflag_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ehci_configflag_t ehci_configflag_cf_insert(ehci_configflag_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_configflag_t ehci_configflag_cf_insert(ehci_configflag_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ehci_configflag_t )(_fieldval)) << 0)));
}

static inline int ehci_configflag_prtval(char *_s, size_t _size, ehci_configflag_t _regval) __attribute__ ((always_inline));
static inline int ehci_configflag_prtval(char *_s, size_t _size, ehci_configflag_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cf =\t%" PRIx8 "\t(Configure flag)\n", ehci_configflag_cf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ehci_portsc_t
 * Description: Implicit type of Port status and control register array
 * Fields:
 *   ccs	(size 1, offset 0, init 0):	RO	Current connect status
 *   csc	(size 1, offset 1, init 0):	RWC	Connect status change
 *   ped	(size 1, offset 2, init 0):	NOATTR	Port enabled/disabled
 *   pec	(size 1, offset 3, init 0):	RWC	Port enable/disbale change
 *   oca	(size 1, offset 4, init 0):	RO	Over current active
 *   occ	(size 1, offset 5, init 0):	RWC	Over current change
 *   fpr	(size 1, offset 6, init 0):	NOATTR	Force port resume
 *   sus	(size 1, offset 7, init 0):	NOATTR	Port suspend
 *   pr	(size 1, offset 8, init 0):	NOATTR	Port reset
 *   _anon9	(size 1, offset 9, init 0):	MBZ	_
 *   ls	(size 2, offset 10, init 0):	NOATTR	Line status value
 *   pp	(size 1, offset 12, init 0):	NOATTR	Port power
 *   po	(size 1, offset 13, init 0):	NOATTR	Port owner
 *   pic	(size 2, offset 14, init 0):	NOATTR	Port indicator control
 *   ptc	(size 4, offset 16, init 0):	NOATTR	Port test control
 *   wkcnnt_e	(size 1, offset 20, init 0):	NOATTR	Wake on connect enable
 *   wkdscnnt_e	(size 1, offset 21, init 0):	NOATTR	Wake on disconnect enable
 *   wkoc_e	(size 1, offset 22, init 0):	NOATTR	Wake on over-current enable
 *   _anon23	(size 9, offset 23, init 0):	MBZ	_
 */
typedef uint32_t ehci_portsc_t;
#define ehci_portsc_default 0x0
static inline uint8_t ehci_portsc_ccs_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_ccs_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ehci_portsc_t ehci_portsc_ccs_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_ccs_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ehci_portsc_t )(_fieldval)) << 0)));
}

static inline uint8_t ehci_portsc_csc_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_csc_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ehci_portsc_t ehci_portsc_csc_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_csc_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ehci_portsc_t )(_fieldval)) << 1)));
}

static inline uint8_t ehci_portsc_ped_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_ped_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ehci_portsc_t ehci_portsc_ped_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_ped_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ehci_portsc_t )(_fieldval)) << 2)));
}

static inline uint8_t ehci_portsc_pec_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_pec_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ehci_portsc_t ehci_portsc_pec_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_pec_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ehci_portsc_t )(_fieldval)) << 3)));
}

static inline uint8_t ehci_portsc_oca_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_oca_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ehci_portsc_t ehci_portsc_oca_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_oca_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ehci_portsc_t )(_fieldval)) << 4)));
}

static inline uint8_t ehci_portsc_occ_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_occ_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ehci_portsc_t ehci_portsc_occ_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_occ_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((ehci_portsc_t )(_fieldval)) << 5)));
}

static inline uint8_t ehci_portsc_fpr_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_fpr_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline ehci_portsc_t ehci_portsc_fpr_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_fpr_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((ehci_portsc_t )(_fieldval)) << 6)));
}

static inline uint8_t ehci_portsc_sus_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_sus_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline ehci_portsc_t ehci_portsc_sus_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_sus_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((ehci_portsc_t )(_fieldval)) << 7)));
}

static inline uint8_t ehci_portsc_pr_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_pr_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ehci_portsc_t ehci_portsc_pr_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_pr_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((ehci_portsc_t )(_fieldval)) << 8)));
}

static inline ehci_lstatus_val_t ehci_portsc_ls_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline ehci_lstatus_val_t ehci_portsc_ls_extract(ehci_portsc_t _regval)
{
    return((ehci_lstatus_val_t )((_regval & 0xc00) >> 10));
}

static inline ehci_portsc_t ehci_portsc_ls_insert(ehci_portsc_t _regval, ehci_lstatus_val_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_ls_insert(ehci_portsc_t _regval, ehci_lstatus_val_t _fieldval)
{
    return((_regval & 0xfffff3ff) | (0xc00 & (((ehci_portsc_t )(_fieldval)) << 10)));
}

static inline uint8_t ehci_portsc_pp_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_pp_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline ehci_portsc_t ehci_portsc_pp_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_pp_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((ehci_portsc_t )(_fieldval)) << 12)));
}

static inline uint8_t ehci_portsc_po_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_po_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline ehci_portsc_t ehci_portsc_po_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_po_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((ehci_portsc_t )(_fieldval)) << 13)));
}

static inline ehci_indi_val_t ehci_portsc_pic_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline ehci_indi_val_t ehci_portsc_pic_extract(ehci_portsc_t _regval)
{
    return((ehci_indi_val_t )((_regval & 0xc000) >> 14));
}

static inline ehci_portsc_t ehci_portsc_pic_insert(ehci_portsc_t _regval, ehci_indi_val_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_pic_insert(ehci_portsc_t _regval, ehci_indi_val_t _fieldval)
{
    return((_regval & 0xffff3fff) | (0xc000 & (((ehci_portsc_t )(_fieldval)) << 14)));
}

static inline ehci_test_mode_val_t ehci_portsc_ptc_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline ehci_test_mode_val_t ehci_portsc_ptc_extract(ehci_portsc_t _regval)
{
    return((ehci_test_mode_val_t )((_regval & 0xf0000) >> 16));
}

static inline ehci_portsc_t ehci_portsc_ptc_insert(ehci_portsc_t _regval, ehci_test_mode_val_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_ptc_insert(ehci_portsc_t _regval, ehci_test_mode_val_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((ehci_portsc_t )(_fieldval)) << 16)));
}

static inline uint8_t ehci_portsc_wkcnnt_e_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_wkcnnt_e_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline ehci_portsc_t ehci_portsc_wkcnnt_e_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_wkcnnt_e_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((ehci_portsc_t )(_fieldval)) << 20)));
}

static inline uint8_t ehci_portsc_wkdscnnt_e_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_wkdscnnt_e_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline ehci_portsc_t ehci_portsc_wkdscnnt_e_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_wkdscnnt_e_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((ehci_portsc_t )(_fieldval)) << 21)));
}

static inline uint8_t ehci_portsc_wkoc_e_extract(ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_wkoc_e_extract(ehci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline ehci_portsc_t ehci_portsc_wkoc_e_insert(ehci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_wkoc_e_insert(ehci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((ehci_portsc_t )(_fieldval)) << 22)));
}

static inline int ehci_portsc_prtval(char *_s, size_t _size, ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline int ehci_portsc_prtval(char *_s, size_t _size, ehci_portsc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ccs =\t%" PRIx8 "\t(Current connect status)\n", ehci_portsc_ccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " csc =\t%" PRIx8 "\t(Connect status change)\n", ehci_portsc_csc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ped =\t%" PRIx8 "\t(Port enabled/disabled)\n", ehci_portsc_ped_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pec =\t%" PRIx8 "\t(Port enable/disbale change)\n", ehci_portsc_pec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oca =\t%" PRIx8 "\t(Over current active)\n", ehci_portsc_oca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " occ =\t%" PRIx8 "\t(Over current change)\n", ehci_portsc_occ_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fpr =\t%" PRIx8 "\t(Force port resume)\n", ehci_portsc_fpr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sus =\t%" PRIx8 "\t(Port suspend)\n", ehci_portsc_sus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pr =\t%" PRIx8 "\t(Port reset)\n", ehci_portsc_pr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ls =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_lstatus_val_prtval(_s + _r, _avail, ehci_portsc_ls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Line status value)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pp =\t%" PRIx8 "\t(Port power)\n", ehci_portsc_pp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " po =\t%" PRIx8 "\t(Port owner)\n", ehci_portsc_po_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pic =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_indi_val_prtval(_s + _r, _avail, ehci_portsc_pic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port indicator control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ptc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_test_mode_val_prtval(_s + _r, _avail, ehci_portsc_ptc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port test control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkcnnt_e =\t%" PRIx8 "\t(Wake on connect enable)\n", ehci_portsc_wkcnnt_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkdscnnt_e =\t%" PRIx8 "\t(Wake on disconnect enable)\n", ehci_portsc_wkdscnnt_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkoc_e =\t%" PRIx8 "\t(Wake on over-current enable)\n", ehci_portsc_wkoc_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t cap;
    mackerel_addr_t op;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum ehci_initials {
    ehci_caplength_initial = 0x0,
    ehci_hciversion_initial = 0x0,
    ehci_hcsparams_initial = 0x0,
    ehci_hccparams_initial = 0x0,
    ehci_hcspportroute_initial = 0x0,
    ehci_usbcmd_initial = 0x0,
    ehci_usbsts_initial = 0x0,
    ehci_usbintr_initial = 0x0,
    ehci_frindex_initial = 0x0,
    ehci_ctrldssegment_initial = 0x0,
    ehci_periodiclistbase_initial = 0x0,
    ehci_asynclistaddr_initial = 0x0,
    ehci_configflag_initial = 0x0,
    ehci_portsc_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void ehci_initialize(__DN(t) *_dev, mackerel_addr_t cap, mackerel_addr_t op) __attribute__ ((always_inline));
static inline void ehci_initialize(__DN(t) *_dev, mackerel_addr_t cap, mackerel_addr_t op)
{
    _dev->cap = cap;
    _dev->op = op;
}

/*
 * Register caplength: Capability Registers Length
 * Type: ehci.uint8 (primitive type)
 */
static inline uint8_t ehci_caplength_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_caplength_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->cap, 0x0));
}

static inline uint8_t ehci_caplength_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_caplength_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->cap, 0x0));
}

static inline void ehci_caplength_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void ehci_caplength_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->cap, 0x0, _regval);
}

// Register caplength is not writeable
static inline int ehci_caplength_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_caplength_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->cap, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register caplength (Capability Registers Length): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register hciversion: Host Controller Interface Version Number
 * Type: ehci.uint16 (primitive type)
 */
static inline uint16_t ehci_hciversion_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ehci_hciversion_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->cap, 0x2));
}

static inline uint16_t ehci_hciversion_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ehci_hciversion_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->cap, 0x2));
}

static inline void ehci_hciversion_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void ehci_hciversion_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->cap, 0x2, _regval);
}

// Register hciversion is not writeable
static inline int ehci_hciversion_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_hciversion_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->cap, 0x2);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hciversion (Host Controller Interface Version Number): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register hcsparams: Structural parameters
 * Type: ehci.hcsparams (Implicit type of Structural parameters register)
 *   n_ports	(size 4, offset 0, init 0):	RO	Num. physical downstream ports on this controller
 *   ppc	(size 1, offset 4, init 0):	RO	Port power control
 *   _anon5	(size 2, offset 5, init 0):	RSVD	_
 *   prr	(size 1, offset 7, init 0):	RO	Port routing rules
 *   n_pcc	(size 4, offset 8, init 0):	RO	Number of ports per companion controller
 *   n_cc	(size 4, offset 12, init 0):	RO	Number of campanion controller
 *   p_indicator	(size 1, offset 16, init 0):	RO	Port indicator
 *   _anon17	(size 3, offset 17, init 0):	RSVD	_
 *   dpn	(size 4, offset 20, init 0):	RO	Debug port number
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
static inline ehci_hcsparams_t ehci_hcsparams_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_hcsparams_t ehci_hcsparams_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cap, 0x4));
}

static inline ehci_hcsparams_t ehci_hcsparams_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_hcsparams_t ehci_hcsparams_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cap, 0x4));
}

static inline void ehci_hcsparams_rawwr(__DN(t) *_dev, ehci_hcsparams_t _regval) __attribute__ ((always_inline));
static inline void ehci_hcsparams_rawwr(__DN(t) *_dev, ehci_hcsparams_t _regval)
{
    mackerel_write_addr_32(_dev->cap, 0x4, _regval);
}

// Register hcsparams is not writeable
static inline int ehci_hcsparams_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_hcsparams_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_hcsparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hcsparams (Structural parameters): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_ports =\t%" PRIx8 "\t(Num. physical downstream ports on this controller)\n", ehci_hcsparams_n_ports_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ppc =\t%" PRIx8 "\t(Port power control)\n", ehci_hcsparams_ppc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prr =\t%" PRIx8 "\t(Port routing rules)\n", ehci_hcsparams_prr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_pcc =\t%" PRIx8 "\t(Number of ports per companion controller)\n", ehci_hcsparams_n_pcc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " n_cc =\t%" PRIx8 "\t(Number of campanion controller)\n", ehci_hcsparams_n_cc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p_indicator =\t%" PRIx8 "\t(Port indicator)\n", ehci_hcsparams_p_indicator_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon17 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpn =\t%" PRIx8 "\t(Debug port number)\n", ehci_hcsparams_dpn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    return(_r);
}

static inline uint8_t ehci_hcsparams_n_ports_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hcsparams_n_ports_rdf(__DN(t) *_dev)
{
    ehci_hcsparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x4);
    return(ehci_hcsparams_n_ports_extract(_regval));
}

static inline uint8_t ehci_hcsparams_ppc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hcsparams_ppc_rdf(__DN(t) *_dev)
{
    ehci_hcsparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x4);
    return(ehci_hcsparams_ppc_extract(_regval));
}

static inline uint8_t ehci_hcsparams_prr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hcsparams_prr_rdf(__DN(t) *_dev)
{
    ehci_hcsparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x4);
    return(ehci_hcsparams_prr_extract(_regval));
}

static inline uint8_t ehci_hcsparams_n_pcc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hcsparams_n_pcc_rdf(__DN(t) *_dev)
{
    ehci_hcsparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x4);
    return(ehci_hcsparams_n_pcc_extract(_regval));
}

static inline uint8_t ehci_hcsparams_n_cc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hcsparams_n_cc_rdf(__DN(t) *_dev)
{
    ehci_hcsparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x4);
    return(ehci_hcsparams_n_cc_extract(_regval));
}

static inline uint8_t ehci_hcsparams_p_indicator_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hcsparams_p_indicator_rdf(__DN(t) *_dev)
{
    ehci_hcsparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x4);
    return(ehci_hcsparams_p_indicator_extract(_regval));
}

static inline uint8_t ehci_hcsparams_dpn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hcsparams_dpn_rdf(__DN(t) *_dev)
{
    ehci_hcsparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x4);
    return(ehci_hcsparams_dpn_extract(_regval));
}

/*
 * Register hccparams: Capability parameters
 * Type: ehci.hccparams (Implicit type of Capability parameters register)
 *   bit64ac	(size 1, offset 0, init 0):	RO	Extended 64 bit addressing capability
 *   pflf	(size 1, offset 1, init 0):	RO	Programmable frame list flag
 *   aspc	(size 1, offset 2, init 0):	RO	Asynchronous sechedule park capability
 *   _anon3	(size 1, offset 3, init 0):	RSVD	_
 *   ist	(size 4, offset 4, init 0):	RO	Isochronous scheduling threshold
 *   eecp	(size 8, offset 8, init 0):	RO	EHCI extended capabilities pointer
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline ehci_hccparams_t ehci_hccparams_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_hccparams_t ehci_hccparams_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cap, 0x8));
}

static inline ehci_hccparams_t ehci_hccparams_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_hccparams_t ehci_hccparams_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->cap, 0x8));
}

static inline void ehci_hccparams_rawwr(__DN(t) *_dev, ehci_hccparams_t _regval) __attribute__ ((always_inline));
static inline void ehci_hccparams_rawwr(__DN(t) *_dev, ehci_hccparams_t _regval)
{
    mackerel_write_addr_32(_dev->cap, 0x8, _regval);
}

// Register hccparams is not writeable
static inline int ehci_hccparams_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_hccparams_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hccparams (Capability parameters): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bit64ac =\t%" PRIx8 "\t(Extended 64 bit addressing capability)\n", ehci_hccparams_bit64ac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pflf =\t%" PRIx8 "\t(Programmable frame list flag)\n", ehci_hccparams_pflf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspc =\t%" PRIx8 "\t(Asynchronous sechedule park capability)\n", ehci_hccparams_aspc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ist =\t%" PRIx8 "\t(Isochronous scheduling threshold)\n", ehci_hccparams_ist_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eecp =\t%" PRIx8 "\t(EHCI extended capabilities pointer)\n", ehci_hccparams_eecp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t ehci_hccparams_bit64ac_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_bit64ac_rdf(__DN(t) *_dev)
{
    ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x8);
    return(ehci_hccparams_bit64ac_extract(_regval));
}

static inline uint8_t ehci_hccparams_pflf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_pflf_rdf(__DN(t) *_dev)
{
    ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x8);
    return(ehci_hccparams_pflf_extract(_regval));
}

static inline uint8_t ehci_hccparams_aspc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_aspc_rdf(__DN(t) *_dev)
{
    ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x8);
    return(ehci_hccparams_aspc_extract(_regval));
}

static inline uint8_t ehci_hccparams_ist_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_ist_rdf(__DN(t) *_dev)
{
    ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x8);
    return(ehci_hccparams_ist_extract(_regval));
}

static inline uint8_t ehci_hccparams_eecp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_hccparams_eecp_rdf(__DN(t) *_dev)
{
    ehci_hccparams_t _regval = mackerel_read_addr_32(_dev->cap, 0x8);
    return(ehci_hccparams_eecp_extract(_regval));
}

/*
 * Register hcspportroute: Companion port route descr.
 * Type: ehci.hcspportroute (Implicit type of Companion port route descr. register)
 *   _anon0	(size 4, offset 0, init 0):	RSVD	_
 *   attr	(size 60, offset 4, init 0):	RO	Port array
 */
static inline ehci_hcspportroute_t ehci_hcspportroute_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_hcspportroute_t ehci_hcspportroute_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->cap, 0xc));
}

static inline ehci_hcspportroute_t ehci_hcspportroute_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_hcspportroute_t ehci_hcspportroute_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->cap, 0xc));
}

static inline void ehci_hcspportroute_rawwr(__DN(t) *_dev, ehci_hcspportroute_t _regval) __attribute__ ((always_inline));
static inline void ehci_hcspportroute_rawwr(__DN(t) *_dev, ehci_hcspportroute_t _regval)
{
    mackerel_write_addr_64(_dev->cap, 0xc, _regval);
}

// Register hcspportroute is not writeable
static inline int ehci_hcspportroute_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_hcspportroute_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_hcspportroute_t _regval = mackerel_read_addr_64(_dev->cap, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hcspportroute (Companion port route descr.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " attr =\t%" PRIx64 "\t(Port array)\n", ehci_hcspportroute_attr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint64_t ehci_hcspportroute_attr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint64_t ehci_hcspportroute_attr_rdf(__DN(t) *_dev)
{
    ehci_hcspportroute_t _regval = mackerel_read_addr_64(_dev->cap, 0xc);
    return(ehci_hcspportroute_attr_extract(_regval));
}

/*
 * Register usbcmd: USB command
 * Type: ehci.usbcmd (Implicit type of USB command register)
 *   rs	(size 1, offset 0, init 0):	RW	Run stop for scheduling
 *   hcr	(size 1, offset 1, init 0):	RW	Host controller reset
 *   fls	(size 2, offset 2, init 0):	RW	Frame list size
 *   pse	(size 1, offset 4, init 0):	RW	Periodic schedule enable
 *   ase	(size 1, offset 5, init 0):	RW	Asynchronous schedule enable
 *   iaad	(size 1, offset 6, init 0):	RW	Interrupt on async advance doorbell
 *   lhcr	(size 1, offset 7, init 0):	RW	Light host controller reset
 *   aspmc	(size 2, offset 8, init 0):	RW	Asynchronous schedule park mode count
 *   _anon10	(size 1, offset 10, init 0):	MBZ	_
 *   aspme	(size 1, offset 11, init 0):	RW	Asynchronous schedule park mode enable
 *   _anon12	(size 4, offset 12, init 0):	MBZ	_
 *   itc	(size 8, offset 16, init 0):	RW	Interrupt threshold control
 *   _anon24	(size 8, offset 24, init 0):	MBZ	_
 */
static inline ehci_usbcmd_t ehci_usbcmd_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_usbcmd_t ehci_usbcmd_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x0));
}

static inline ehci_usbcmd_t ehci_usbcmd_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_usbcmd_t ehci_usbcmd_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x0));
}

static inline void ehci_usbcmd_rawwr(__DN(t) *_dev, ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline void ehci_usbcmd_rawwr(__DN(t) *_dev, ehci_usbcmd_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
}

static inline void ehci_usbcmd_wr(__DN(t) *_dev, ehci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline void ehci_usbcmd_wr(__DN(t) *_dev, ehci_usbcmd_t _regval)
{
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
}

static inline int ehci_usbcmd_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_usbcmd_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbcmd (USB command): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rs =\t%" PRIx8 "\t(Run stop for scheduling)\n", ehci_usbcmd_rs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcr =\t%" PRIx8 "\t(Host controller reset)\n", ehci_usbcmd_hcr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fls =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_frame_val_prtval(_s + _r, _avail, ehci_usbcmd_fls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Frame list size)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pse =\t%" PRIx8 "\t(Periodic schedule enable)\n", ehci_usbcmd_pse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ase =\t%" PRIx8 "\t(Asynchronous schedule enable)\n", ehci_usbcmd_ase_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iaad =\t%" PRIx8 "\t(Interrupt on async advance doorbell)\n", ehci_usbcmd_iaad_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lhcr =\t%" PRIx8 "\t(Light host controller reset)\n", ehci_usbcmd_lhcr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspmc =\t%" PRIx8 "\t(Asynchronous schedule park mode count)\n", ehci_usbcmd_aspmc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " aspme =\t%" PRIx8 "\t(Asynchronous schedule park mode enable)\n", ehci_usbcmd_aspme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " itc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_itc_val_prtval(_s + _r, _avail, ehci_usbcmd_itc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interrupt threshold control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    return(_r);
}

static inline uint8_t ehci_usbcmd_rs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbcmd_rs_rdf(__DN(t) *_dev)
{
    ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usbcmd_rs_extract(_regval));
}

static inline uint8_t ehci_usbcmd_hcr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbcmd_hcr_rdf(__DN(t) *_dev)
{
    ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usbcmd_hcr_extract(_regval));
}

static inline ehci_frame_val_t ehci_usbcmd_fls_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_frame_val_t ehci_usbcmd_fls_rdf(__DN(t) *_dev)
{
    ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usbcmd_fls_extract(_regval));
}

static inline uint8_t ehci_usbcmd_pse_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbcmd_pse_rdf(__DN(t) *_dev)
{
    ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usbcmd_pse_extract(_regval));
}

static inline uint8_t ehci_usbcmd_ase_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbcmd_ase_rdf(__DN(t) *_dev)
{
    ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usbcmd_ase_extract(_regval));
}

static inline uint8_t ehci_usbcmd_iaad_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbcmd_iaad_rdf(__DN(t) *_dev)
{
    ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usbcmd_iaad_extract(_regval));
}

static inline uint8_t ehci_usbcmd_lhcr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbcmd_lhcr_rdf(__DN(t) *_dev)
{
    ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usbcmd_lhcr_extract(_regval));
}

static inline uint8_t ehci_usbcmd_aspmc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbcmd_aspmc_rdf(__DN(t) *_dev)
{
    ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usbcmd_aspmc_extract(_regval));
}

static inline uint8_t ehci_usbcmd_aspme_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbcmd_aspme_rdf(__DN(t) *_dev)
{
    ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usbcmd_aspme_extract(_regval));
}

static inline ehci_itc_val_t ehci_usbcmd_itc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_itc_val_t ehci_usbcmd_itc_rdf(__DN(t) *_dev)
{
    ehci_usbcmd_t _regval = mackerel_read_addr_32(_dev->op, 0x0);
    return(ehci_usbcmd_itc_extract(_regval));
}

static inline void ehci_usbcmd_rs_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbcmd_rs_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbcmd_t _regval = 0x1 & (((ehci_usbcmd_t )(_fieldval)) << 0);
    _regval = (_regval | (0xff0bfe & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usbcmd_hcr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbcmd_hcr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbcmd_t _regval = 0x2 & (((ehci_usbcmd_t )(_fieldval)) << 1);
    _regval = (_regval | (0xff0bfd & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usbcmd_fls_wrf(__DN(t) *_dev, ehci_frame_val_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbcmd_fls_wrf(__DN(t) *_dev, ehci_frame_val_t _fieldval)
{
    ehci_usbcmd_t _regval = 0xc & (((ehci_usbcmd_t )(_fieldval)) << 2);
    _regval = (_regval | (0xff0bf3 & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usbcmd_pse_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbcmd_pse_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbcmd_t _regval = 0x10 & (((ehci_usbcmd_t )(_fieldval)) << 4);
    _regval = (_regval | (0xff0bef & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usbcmd_ase_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbcmd_ase_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbcmd_t _regval = 0x20 & (((ehci_usbcmd_t )(_fieldval)) << 5);
    _regval = (_regval | (0xff0bdf & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usbcmd_iaad_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbcmd_iaad_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbcmd_t _regval = 0x40 & (((ehci_usbcmd_t )(_fieldval)) << 6);
    _regval = (_regval | (0xff0bbf & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usbcmd_lhcr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbcmd_lhcr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbcmd_t _regval = 0x80 & (((ehci_usbcmd_t )(_fieldval)) << 7);
    _regval = (_regval | (0xff0b7f & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usbcmd_aspmc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbcmd_aspmc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbcmd_t _regval = 0x300 & (((ehci_usbcmd_t )(_fieldval)) << 8);
    _regval = (_regval | (0xff08ff & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usbcmd_aspme_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbcmd_aspme_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbcmd_t _regval = 0x800 & (((ehci_usbcmd_t )(_fieldval)) << 11);
    _regval = (_regval | (0xff03ff & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

static inline void ehci_usbcmd_itc_wrf(__DN(t) *_dev, ehci_itc_val_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbcmd_itc_wrf(__DN(t) *_dev, ehci_itc_val_t _fieldval)
{
    ehci_usbcmd_t _regval = 0xff0000 & (((ehci_usbcmd_t )(_fieldval)) << 16);
    _regval = (_regval | (0xbff & mackerel_read_addr_32(_dev->op, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xff0bff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register usbsts: USB status
 * Type: ehci.usbsts (Implicit type of USB status register)
 *   usbi	(size 1, offset 0, init 0):	RWC	USB interrupt
 *   usbei	(size 1, offset 1, init 0):	RWC	USB error interrupt
 *   pcd	(size 1, offset 2, init 0):	RWC	Port change detect
 *   flr	(size 1, offset 3, init 0):	RWC	Frame list rollover
 *   hse	(size 1, offset 4, init 0):	RWC	Host system error
 *   iaa	(size 1, offset 5, init 0):	RWC	Interrupt on Async advance
 *   _anon6	(size 6, offset 6, init 0):	MBZ	_
 *   hch	(size 1, offset 12, init 0):	RO	Host controller halted see Run/Stop
 *   rec	(size 1, offset 13, init 0):	RO	Reclamation
 *   pss	(size 1, offset 14, init 0):	RO	Periodic schedule status
 *   ass	(size 1, offset 15, init 0):	RO	Asynchronous schedule status
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static inline ehci_usbsts_t ehci_usbsts_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_usbsts_t ehci_usbsts_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x4));
}

static inline ehci_usbsts_t ehci_usbsts_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_usbsts_t ehci_usbsts_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x4));
}

static inline void ehci_usbsts_rawwr(__DN(t) *_dev, ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline void ehci_usbsts_rawwr(__DN(t) *_dev, ehci_usbsts_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0x4, _regval);
}

static inline void ehci_usbsts_wr(__DN(t) *_dev, ehci_usbsts_t _regval) __attribute__ ((always_inline));
static inline void ehci_usbsts_wr(__DN(t) *_dev, ehci_usbsts_t _regval)
{
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0x4, _regval);
}

static inline int ehci_usbsts_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_usbsts_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbsts (USB status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbi =\t%" PRIx8 "\t(USB interrupt)\n", ehci_usbsts_usbi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbei =\t%" PRIx8 "\t(USB error interrupt)\n", ehci_usbsts_usbei_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcd =\t%" PRIx8 "\t(Port change detect)\n", ehci_usbsts_pcd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flr =\t%" PRIx8 "\t(Frame list rollover)\n", ehci_usbsts_flr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hse =\t%" PRIx8 "\t(Host system error)\n", ehci_usbsts_hse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iaa =\t%" PRIx8 "\t(Interrupt on Async advance)\n", ehci_usbsts_iaa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hch =\t%" PRIx8 "\t(Host controller halted see Run/Stop)\n", ehci_usbsts_hch_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rec =\t%" PRIx8 "\t(Reclamation)\n", ehci_usbsts_rec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pss =\t%" PRIx8 "\t(Periodic schedule status)\n", ehci_usbsts_pss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ass =\t%" PRIx8 "\t(Asynchronous schedule status)\n", ehci_usbsts_ass_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t ehci_usbsts_usbi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_usbi_rdf(__DN(t) *_dev)
{
    ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usbsts_usbi_extract(_regval));
}

static inline uint8_t ehci_usbsts_usbei_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_usbei_rdf(__DN(t) *_dev)
{
    ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usbsts_usbei_extract(_regval));
}

static inline uint8_t ehci_usbsts_pcd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_pcd_rdf(__DN(t) *_dev)
{
    ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usbsts_pcd_extract(_regval));
}

static inline uint8_t ehci_usbsts_flr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_flr_rdf(__DN(t) *_dev)
{
    ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usbsts_flr_extract(_regval));
}

static inline uint8_t ehci_usbsts_hse_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_hse_rdf(__DN(t) *_dev)
{
    ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usbsts_hse_extract(_regval));
}

static inline uint8_t ehci_usbsts_iaa_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_iaa_rdf(__DN(t) *_dev)
{
    ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usbsts_iaa_extract(_regval));
}

static inline uint8_t ehci_usbsts_hch_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_hch_rdf(__DN(t) *_dev)
{
    ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usbsts_hch_extract(_regval));
}

static inline uint8_t ehci_usbsts_rec_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_rec_rdf(__DN(t) *_dev)
{
    ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usbsts_rec_extract(_regval));
}

static inline uint8_t ehci_usbsts_pss_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_pss_rdf(__DN(t) *_dev)
{
    ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usbsts_pss_extract(_regval));
}

static inline uint8_t ehci_usbsts_ass_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbsts_ass_rdf(__DN(t) *_dev)
{
    ehci_usbsts_t _regval = mackerel_read_addr_32(_dev->op, 0x4);
    return(ehci_usbsts_ass_extract(_regval));
}

static inline void ehci_usbsts_usbi_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbsts_usbi_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbsts_t _regval = 0x1 & (((ehci_usbsts_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x4, _regval);
    // No shadow register to write to
}

static inline void ehci_usbsts_usbei_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbsts_usbei_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbsts_t _regval = 0x2 & (((ehci_usbsts_t )(_fieldval)) << 1);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x4, _regval);
    // No shadow register to write to
}

static inline void ehci_usbsts_pcd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbsts_pcd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbsts_t _regval = 0x4 & (((ehci_usbsts_t )(_fieldval)) << 2);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x4, _regval);
    // No shadow register to write to
}

static inline void ehci_usbsts_flr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbsts_flr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbsts_t _regval = 0x8 & (((ehci_usbsts_t )(_fieldval)) << 3);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x4, _regval);
    // No shadow register to write to
}

static inline void ehci_usbsts_hse_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbsts_hse_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbsts_t _regval = 0x10 & (((ehci_usbsts_t )(_fieldval)) << 4);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x4, _regval);
    // No shadow register to write to
}

static inline void ehci_usbsts_iaa_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbsts_iaa_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbsts_t _regval = 0x20 & (((ehci_usbsts_t )(_fieldval)) << 5);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xf03f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x4, _regval);
    // No shadow register to write to
}

/*
 * Register usbintr: USB interrupt enable
 * Type: ehci.usbintr (Implicit type of USB interrupt enable register)
 *   usbie	(size 1, offset 0, init 0):	RW	USB interrupt enable
 *   usbeie	(size 1, offset 1, init 0):	RW	USB error interrupt enable
 *   pcie	(size 1, offset 2, init 0):	RW	Port change interrupt enable
 *   flre	(size 1, offset 3, init 0):	RW	Frame list rollover enable
 *   hsee	(size 1, offset 4, init 0):	RW	Host system error enable
 *   iaae	(size 1, offset 5, init 0):	RW	Interrupt on async advance enable
 *   _anon6	(size 26, offset 6, init 0):	MBZ	_
 */
static inline ehci_usbintr_t ehci_usbintr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_usbintr_t ehci_usbintr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x8));
}

static inline ehci_usbintr_t ehci_usbintr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_usbintr_t ehci_usbintr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x8));
}

static inline void ehci_usbintr_rawwr(__DN(t) *_dev, ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline void ehci_usbintr_rawwr(__DN(t) *_dev, ehci_usbintr_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0x8, _regval);
}

static inline void ehci_usbintr_wr(__DN(t) *_dev, ehci_usbintr_t _regval) __attribute__ ((always_inline));
static inline void ehci_usbintr_wr(__DN(t) *_dev, ehci_usbintr_t _regval)
{
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0x8, _regval);
}

static inline int ehci_usbintr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_usbintr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_usbintr_t _regval = mackerel_read_addr_32(_dev->op, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbintr (USB interrupt enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbie =\t%" PRIx8 "\t(USB interrupt enable)\n", ehci_usbintr_usbie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbeie =\t%" PRIx8 "\t(USB error interrupt enable)\n", ehci_usbintr_usbeie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie =\t%" PRIx8 "\t(Port change interrupt enable)\n", ehci_usbintr_pcie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flre =\t%" PRIx8 "\t(Frame list rollover enable)\n", ehci_usbintr_flre_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hsee =\t%" PRIx8 "\t(Host system error enable)\n", ehci_usbintr_hsee_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iaae =\t%" PRIx8 "\t(Interrupt on async advance enable)\n", ehci_usbintr_iaae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    return(_r);
}

static inline uint8_t ehci_usbintr_usbie_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbintr_usbie_rdf(__DN(t) *_dev)
{
    ehci_usbintr_t _regval = mackerel_read_addr_32(_dev->op, 0x8);
    return(ehci_usbintr_usbie_extract(_regval));
}

static inline uint8_t ehci_usbintr_usbeie_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbintr_usbeie_rdf(__DN(t) *_dev)
{
    ehci_usbintr_t _regval = mackerel_read_addr_32(_dev->op, 0x8);
    return(ehci_usbintr_usbeie_extract(_regval));
}

static inline uint8_t ehci_usbintr_pcie_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbintr_pcie_rdf(__DN(t) *_dev)
{
    ehci_usbintr_t _regval = mackerel_read_addr_32(_dev->op, 0x8);
    return(ehci_usbintr_pcie_extract(_regval));
}

static inline uint8_t ehci_usbintr_flre_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbintr_flre_rdf(__DN(t) *_dev)
{
    ehci_usbintr_t _regval = mackerel_read_addr_32(_dev->op, 0x8);
    return(ehci_usbintr_flre_extract(_regval));
}

static inline uint8_t ehci_usbintr_hsee_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbintr_hsee_rdf(__DN(t) *_dev)
{
    ehci_usbintr_t _regval = mackerel_read_addr_32(_dev->op, 0x8);
    return(ehci_usbintr_hsee_extract(_regval));
}

static inline uint8_t ehci_usbintr_iaae_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_usbintr_iaae_rdf(__DN(t) *_dev)
{
    ehci_usbintr_t _regval = mackerel_read_addr_32(_dev->op, 0x8);
    return(ehci_usbintr_iaae_extract(_regval));
}

static inline void ehci_usbintr_usbie_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbintr_usbie_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbintr_t _regval = 0x1 & (((ehci_usbintr_t )(_fieldval)) << 0);
    _regval = (_regval | (0x3e & mackerel_read_addr_32(_dev->op, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x8, _regval);
    // No shadow register to write to
}

static inline void ehci_usbintr_usbeie_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbintr_usbeie_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbintr_t _regval = 0x2 & (((ehci_usbintr_t )(_fieldval)) << 1);
    _regval = (_regval | (0x3d & mackerel_read_addr_32(_dev->op, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x8, _regval);
    // No shadow register to write to
}

static inline void ehci_usbintr_pcie_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbintr_pcie_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbintr_t _regval = 0x4 & (((ehci_usbintr_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3b & mackerel_read_addr_32(_dev->op, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x8, _regval);
    // No shadow register to write to
}

static inline void ehci_usbintr_flre_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbintr_flre_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbintr_t _regval = 0x8 & (((ehci_usbintr_t )(_fieldval)) << 3);
    _regval = (_regval | (0x37 & mackerel_read_addr_32(_dev->op, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x8, _regval);
    // No shadow register to write to
}

static inline void ehci_usbintr_hsee_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbintr_hsee_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbintr_t _regval = 0x10 & (((ehci_usbintr_t )(_fieldval)) << 4);
    _regval = (_regval | (0x2f & mackerel_read_addr_32(_dev->op, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x8, _regval);
    // No shadow register to write to
}

static inline void ehci_usbintr_iaae_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_usbintr_iaae_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_usbintr_t _regval = 0x20 & (((ehci_usbintr_t )(_fieldval)) << 5);
    _regval = (_regval | (0x1f & mackerel_read_addr_32(_dev->op, 0x8)));
    // No read of register shadow required
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x8, _regval);
    // No shadow register to write to
}

/*
 * Register frindex: Frame index
 * Type: ehci.frindex (Implicit type of Frame index register)
 *   fi	(size 14, offset 0, init 0):	RW	Frame index
 *   _anon14	(size 18, offset 14, init 0):	MBZ	_
 */
static inline ehci_frindex_t ehci_frindex_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_frindex_t ehci_frindex_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0xc));
}

static inline ehci_frindex_t ehci_frindex_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_frindex_t ehci_frindex_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0xc));
}

static inline void ehci_frindex_rawwr(__DN(t) *_dev, ehci_frindex_t _regval) __attribute__ ((always_inline));
static inline void ehci_frindex_rawwr(__DN(t) *_dev, ehci_frindex_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0xc, _regval);
}

static inline void ehci_frindex_wr(__DN(t) *_dev, ehci_frindex_t _regval) __attribute__ ((always_inline));
static inline void ehci_frindex_wr(__DN(t) *_dev, ehci_frindex_t _regval)
{
    _regval = (_regval & 0x3fff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0xc, _regval);
}

static inline int ehci_frindex_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_frindex_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_frindex_t _regval = mackerel_read_addr_32(_dev->op, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register frindex (Frame index): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fi =\t%" PRIx16 "\t(Frame index)\n", ehci_frindex_fi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    return(_r);
}

static inline uint16_t ehci_frindex_fi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ehci_frindex_fi_rdf(__DN(t) *_dev)
{
    ehci_frindex_t _regval = mackerel_read_addr_32(_dev->op, 0xc);
    return(ehci_frindex_fi_extract(_regval));
}

static inline void ehci_frindex_fi_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_frindex_fi_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    ehci_frindex_t _regval = 0x3fff & (((ehci_frindex_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x3fff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0xc, _regval);
    // No shadow register to write to
}

/*
 * Register ctrldssegment: Control data structure segment
 * Type: ehci.ctrldssegment (Implicit type of Control data structure segment register)
 *   data	(size 32, offset 0, init 0):	RW	MSB [63:32] bits of EHCI data strctures
 */
static inline ehci_ctrldssegment_t ehci_ctrldssegment_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_ctrldssegment_t ehci_ctrldssegment_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x10));
}

static inline ehci_ctrldssegment_t ehci_ctrldssegment_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_ctrldssegment_t ehci_ctrldssegment_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x10));
}

static inline void ehci_ctrldssegment_rawwr(__DN(t) *_dev, ehci_ctrldssegment_t _regval) __attribute__ ((always_inline));
static inline void ehci_ctrldssegment_rawwr(__DN(t) *_dev, ehci_ctrldssegment_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0x10, _regval);
}

static inline void ehci_ctrldssegment_wr(__DN(t) *_dev, ehci_ctrldssegment_t _regval) __attribute__ ((always_inline));
static inline void ehci_ctrldssegment_wr(__DN(t) *_dev, ehci_ctrldssegment_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0x10, _regval);
}

static inline int ehci_ctrldssegment_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_ctrldssegment_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_ctrldssegment_t _regval = mackerel_read_addr_32(_dev->op, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ctrldssegment (Control data structure segment): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx32 "\t(MSB [63:32] bits of EHCI data strctures)\n", ehci_ctrldssegment_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t ehci_ctrldssegment_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ehci_ctrldssegment_data_rdf(__DN(t) *_dev)
{
    ehci_ctrldssegment_t _regval = mackerel_read_addr_32(_dev->op, 0x10);
    return(ehci_ctrldssegment_data_extract(_regval));
}

static inline void ehci_ctrldssegment_data_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_ctrldssegment_data_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    ehci_ctrldssegment_t _regval = 0xffffffff & (((ehci_ctrldssegment_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register periodiclistbase: Periodic frame list base addr
 * Type: ehci.periodiclistbase (Implicit type of Periodic frame list base addr register)
 *   _anon0	(size 12, offset 0, init 0):	MBZ	_
 *   addr	(size 20, offset 12, init 0):	RW	Base address (must be 4k aligned)
 */
static inline ehci_periodiclistbase_t ehci_periodiclistbase_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_periodiclistbase_t ehci_periodiclistbase_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x14));
}

static inline ehci_periodiclistbase_t ehci_periodiclistbase_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_periodiclistbase_t ehci_periodiclistbase_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x14));
}

static inline void ehci_periodiclistbase_rawwr(__DN(t) *_dev, ehci_periodiclistbase_t _regval) __attribute__ ((always_inline));
static inline void ehci_periodiclistbase_rawwr(__DN(t) *_dev, ehci_periodiclistbase_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0x14, _regval);
}

static inline void ehci_periodiclistbase_wr(__DN(t) *_dev, ehci_periodiclistbase_t _regval) __attribute__ ((always_inline));
static inline void ehci_periodiclistbase_wr(__DN(t) *_dev, ehci_periodiclistbase_t _regval)
{
    _regval = (_regval & 0xfffff000);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0x14, _regval);
}

static inline int ehci_periodiclistbase_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_periodiclistbase_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_periodiclistbase_t _regval = mackerel_read_addr_32(_dev->op, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register periodiclistbase (Periodic frame list base addr): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Base address (must be 4k aligned))\n", ehci_periodiclistbase_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t ehci_periodiclistbase_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ehci_periodiclistbase_addr_rdf(__DN(t) *_dev)
{
    ehci_periodiclistbase_t _regval = mackerel_read_addr_32(_dev->op, 0x14);
    return(ehci_periodiclistbase_addr_extract(_regval));
}

static inline void ehci_periodiclistbase_addr_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_periodiclistbase_addr_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    ehci_periodiclistbase_t _regval = 0xfffff000 & (((ehci_periodiclistbase_t )(_fieldval)) << 12);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xfffff000);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x14, _regval);
    // No shadow register to write to
}

/*
 * Register asynclistaddr: Current async. list addr.
 * Type: ehci.asynclistaddr (Implicit type of Current async. list addr. register)
 *   _anon0	(size 5, offset 0, init 0):	MBZ	_
 *   lpl	(size 27, offset 5, init 0):	RW	Link pointer low
 */
static inline ehci_asynclistaddr_t ehci_asynclistaddr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_asynclistaddr_t ehci_asynclistaddr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x18));
}

static inline ehci_asynclistaddr_t ehci_asynclistaddr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_asynclistaddr_t ehci_asynclistaddr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x18));
}

static inline void ehci_asynclistaddr_rawwr(__DN(t) *_dev, ehci_asynclistaddr_t _regval) __attribute__ ((always_inline));
static inline void ehci_asynclistaddr_rawwr(__DN(t) *_dev, ehci_asynclistaddr_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0x18, _regval);
}

static inline void ehci_asynclistaddr_wr(__DN(t) *_dev, ehci_asynclistaddr_t _regval) __attribute__ ((always_inline));
static inline void ehci_asynclistaddr_wr(__DN(t) *_dev, ehci_asynclistaddr_t _regval)
{
    _regval = (_regval & 0xffffffe0);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0x18, _regval);
}

static inline int ehci_asynclistaddr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_asynclistaddr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_asynclistaddr_t _regval = mackerel_read_addr_32(_dev->op, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register asynclistaddr (Current async. list addr.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpl =\t%" PRIx32 "\t(Link pointer low)\n", ehci_asynclistaddr_lpl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t ehci_asynclistaddr_lpl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ehci_asynclistaddr_lpl_rdf(__DN(t) *_dev)
{
    ehci_asynclistaddr_t _regval = mackerel_read_addr_32(_dev->op, 0x18);
    return(ehci_asynclistaddr_lpl_extract(_regval));
}

static inline void ehci_asynclistaddr_lpl_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_asynclistaddr_lpl_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    ehci_asynclistaddr_t _regval = 0xffffffe0 & (((ehci_asynclistaddr_t )(_fieldval)) << 5);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffffffe0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x18, _regval);
    // No shadow register to write to
}

/*
 * Register configflag: Configure flag
 * Type: ehci.configflag (Implicit type of Configure flag register)
 *   cf	(size 1, offset 0, init 0):	RW	Configure flag
 *   _anon1	(size 31, offset 1, init 0):	MBZ	_
 */
static inline ehci_configflag_t ehci_configflag_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_configflag_t ehci_configflag_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x40));
}

static inline ehci_configflag_t ehci_configflag_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ehci_configflag_t ehci_configflag_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->op, 0x40));
}

static inline void ehci_configflag_rawwr(__DN(t) *_dev, ehci_configflag_t _regval) __attribute__ ((always_inline));
static inline void ehci_configflag_rawwr(__DN(t) *_dev, ehci_configflag_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0x40, _regval);
}

static inline void ehci_configflag_wr(__DN(t) *_dev, ehci_configflag_t _regval) __attribute__ ((always_inline));
static inline void ehci_configflag_wr(__DN(t) *_dev, ehci_configflag_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0x40, _regval);
}

static inline int ehci_configflag_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_configflag_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_configflag_t _regval = mackerel_read_addr_32(_dev->op, 0x40);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register configflag (Configure flag): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cf =\t%" PRIx8 "\t(Configure flag)\n", ehci_configflag_cf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline uint8_t ehci_configflag_cf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ehci_configflag_cf_rdf(__DN(t) *_dev)
{
    ehci_configflag_t _regval = mackerel_read_addr_32(_dev->op, 0x40);
    return(ehci_configflag_cf_extract(_regval));
}

static inline void ehci_configflag_cf_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_configflag_cf_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ehci_configflag_t _regval = 0x1 & (((ehci_configflag_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x1);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x40, _regval);
    // No shadow register to write to
}

/*
 * Register array portsc: Port status and control
 * Type: ehci.portsc (Implicit type of Port status and control register array)
 *   ccs	(size 1, offset 0, init 0):	RO	Current connect status
 *   csc	(size 1, offset 1, init 0):	RWC	Connect status change
 *   ped	(size 1, offset 2, init 0):	RW	Port enabled/disabled
 *   pec	(size 1, offset 3, init 0):	RWC	Port enable/disbale change
 *   oca	(size 1, offset 4, init 0):	RO	Over current active
 *   occ	(size 1, offset 5, init 0):	RWC	Over current change
 *   fpr	(size 1, offset 6, init 0):	RW	Force port resume
 *   sus	(size 1, offset 7, init 0):	RW	Port suspend
 *   pr	(size 1, offset 8, init 0):	RW	Port reset
 *   _anon9	(size 1, offset 9, init 0):	MBZ	_
 *   ls	(size 2, offset 10, init 0):	RW	Line status value
 *   pp	(size 1, offset 12, init 0):	RW	Port power
 *   po	(size 1, offset 13, init 0):	RW	Port owner
 *   pic	(size 2, offset 14, init 0):	RW	Port indicator control
 *   ptc	(size 4, offset 16, init 0):	RW	Port test control
 *   wkcnnt_e	(size 1, offset 20, init 0):	RW	Wake on connect enable
 *   wkdscnnt_e	(size 1, offset 21, init 0):	RW	Wake on disconnect enable
 *   wkoc_e	(size 1, offset 22, init 0):	RW	Wake on over-current enable
 *   _anon23	(size 9, offset 23, init 0):	MBZ	_
 */
static const size_t ehci_portsc_length = 16;
static inline ehci_portsc_t ehci_portsc_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8))));
}

static inline ehci_portsc_t ehci_portsc_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline ehci_portsc_t ehci_portsc_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8))));
}

static inline void ehci_portsc_rawwr(__DN(t) *_dev, int _i, ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline void ehci_portsc_rawwr(__DN(t) *_dev, int _i, ehci_portsc_t _regval)
{
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
}

static inline void ehci_portsc_wr(__DN(t) *_dev, int _i, ehci_portsc_t _regval) __attribute__ ((always_inline));
static inline void ehci_portsc_wr(__DN(t) *_dev, int _i, ehci_portsc_t _regval)
{
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
}

static inline int ehci_portsc_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int ehci_portsc_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "portsc", _i, "Port status and control");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ccs =\t%" PRIx8 "\t(Current connect status)\n", ehci_portsc_ccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " csc =\t%" PRIx8 "\t(Connect status change)\n", ehci_portsc_csc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ped =\t%" PRIx8 "\t(Port enabled/disabled)\n", ehci_portsc_ped_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pec =\t%" PRIx8 "\t(Port enable/disbale change)\n", ehci_portsc_pec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oca =\t%" PRIx8 "\t(Over current active)\n", ehci_portsc_oca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " occ =\t%" PRIx8 "\t(Over current change)\n", ehci_portsc_occ_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fpr =\t%" PRIx8 "\t(Force port resume)\n", ehci_portsc_fpr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sus =\t%" PRIx8 "\t(Port suspend)\n", ehci_portsc_sus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pr =\t%" PRIx8 "\t(Port reset)\n", ehci_portsc_pr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ls =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_lstatus_val_prtval(_s + _r, _avail, ehci_portsc_ls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Line status value)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pp =\t%" PRIx8 "\t(Port power)\n", ehci_portsc_pp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " po =\t%" PRIx8 "\t(Port owner)\n", ehci_portsc_po_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pic =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_indi_val_prtval(_s + _r, _avail, ehci_portsc_pic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port indicator control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ptc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_test_mode_val_prtval(_s + _r, _avail, ehci_portsc_ptc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Port test control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkcnnt_e =\t%" PRIx8 "\t(Wake on connect enable)\n", ehci_portsc_wkcnnt_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkdscnnt_e =\t%" PRIx8 "\t(Wake on disconnect enable)\n", ehci_portsc_wkdscnnt_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wkoc_e =\t%" PRIx8 "\t(Wake on over-current enable)\n", ehci_portsc_wkoc_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon23 is anonymous
    return(_r);
}

static inline int ehci_portsc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_portsc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 16; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = ehci_portsc_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t ehci_portsc_ccs_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_ccs_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_ccs_extract(_regval));
}

static inline uint8_t ehci_portsc_csc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_csc_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_csc_extract(_regval));
}

static inline uint8_t ehci_portsc_ped_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_ped_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_ped_extract(_regval));
}

static inline uint8_t ehci_portsc_pec_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_pec_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_pec_extract(_regval));
}

static inline uint8_t ehci_portsc_oca_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_oca_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_oca_extract(_regval));
}

static inline uint8_t ehci_portsc_occ_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_occ_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_occ_extract(_regval));
}

static inline uint8_t ehci_portsc_fpr_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_fpr_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_fpr_extract(_regval));
}

static inline uint8_t ehci_portsc_sus_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_sus_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_sus_extract(_regval));
}

static inline uint8_t ehci_portsc_pr_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_pr_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_pr_extract(_regval));
}

static inline ehci_lstatus_val_t ehci_portsc_ls_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline ehci_lstatus_val_t ehci_portsc_ls_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_ls_extract(_regval));
}

static inline uint8_t ehci_portsc_pp_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_pp_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_pp_extract(_regval));
}

static inline uint8_t ehci_portsc_po_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_po_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_po_extract(_regval));
}

static inline ehci_indi_val_t ehci_portsc_pic_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline ehci_indi_val_t ehci_portsc_pic_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_pic_extract(_regval));
}

static inline ehci_test_mode_val_t ehci_portsc_ptc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline ehci_test_mode_val_t ehci_portsc_ptc_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_ptc_extract(_regval));
}

static inline uint8_t ehci_portsc_wkcnnt_e_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_wkcnnt_e_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_wkcnnt_e_extract(_regval));
}

static inline uint8_t ehci_portsc_wkdscnnt_e_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_wkdscnnt_e_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_wkdscnnt_e_extract(_regval));
}

static inline uint8_t ehci_portsc_wkoc_e_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ehci_portsc_wkoc_e_rdf(__DN(t) *_dev, int _i)
{
    ehci_portsc_t _regval = mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)));
    return(ehci_portsc_wkoc_e_extract(_regval));
}

static inline void ehci_portsc_csc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_csc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x2 & (((ehci_portsc_t )(_fieldval)) << 1);
    _regval = (_regval | (0x7ffdc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_ped_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_ped_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x4 & (((ehci_portsc_t )(_fieldval)) << 2);
    _regval = (_regval | (0x7ffdc0 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_pec_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_pec_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x8 & (((ehci_portsc_t )(_fieldval)) << 3);
    _regval = (_regval | (0x7ffdc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_occ_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_occ_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x20 & (((ehci_portsc_t )(_fieldval)) << 5);
    _regval = (_regval | (0x7ffdc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_fpr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_fpr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x40 & (((ehci_portsc_t )(_fieldval)) << 6);
    _regval = (_regval | (0x7ffd84 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_sus_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_sus_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x80 & (((ehci_portsc_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7ffd44 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_pr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_pr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x100 & (((ehci_portsc_t )(_fieldval)) << 8);
    _regval = (_regval | (0x7ffcc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_ls_wrf(__DN(t) *_dev, int _i, ehci_lstatus_val_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_ls_wrf(__DN(t) *_dev, int _i, ehci_lstatus_val_t _fieldval)
{
    ehci_portsc_t _regval = 0xc00 & (((ehci_portsc_t )(_fieldval)) << 10);
    _regval = (_regval | (0x7ff1c4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_pp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_pp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x1000 & (((ehci_portsc_t )(_fieldval)) << 12);
    _regval = (_regval | (0x7fedc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_po_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_po_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x2000 & (((ehci_portsc_t )(_fieldval)) << 13);
    _regval = (_regval | (0x7fddc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_pic_wrf(__DN(t) *_dev, int _i, ehci_indi_val_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_pic_wrf(__DN(t) *_dev, int _i, ehci_indi_val_t _fieldval)
{
    ehci_portsc_t _regval = 0xc000 & (((ehci_portsc_t )(_fieldval)) << 14);
    _regval = (_regval | (0x7f3dc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_ptc_wrf(__DN(t) *_dev, int _i, ehci_test_mode_val_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_ptc_wrf(__DN(t) *_dev, int _i, ehci_test_mode_val_t _fieldval)
{
    ehci_portsc_t _regval = 0xf0000 & (((ehci_portsc_t )(_fieldval)) << 16);
    _regval = (_regval | (0x70fdc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_wkcnnt_e_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_wkcnnt_e_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x100000 & (((ehci_portsc_t )(_fieldval)) << 20);
    _regval = (_regval | (0x6ffdc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_wkdscnnt_e_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_wkdscnnt_e_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x200000 & (((ehci_portsc_t )(_fieldval)) << 21);
    _regval = (_regval | (0x5ffdc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void ehci_portsc_wkoc_e_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ehci_portsc_wkoc_e_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ehci_portsc_t _regval = 0x400000 & (((ehci_portsc_t )(_fieldval)) << 22);
    _regval = (_regval | (0x3ffdc4 & mackerel_read_addr_32(_dev->op, 0x44 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0x7ffdff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->op, 0x44 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline int ehci_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ehci_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device ehci (EHCI USB Controller):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_caplength_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_hciversion_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_hcsparams_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_hccparams_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_hcspportroute_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_usbcmd_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_usbsts_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_usbintr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_frindex_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_ctrldssegment_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_periodiclistbase_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_asynclistaddr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_configflag_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ehci_portsc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device ehci\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __ehci_DEV_H
