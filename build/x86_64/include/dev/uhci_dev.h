#ifndef __uhci_DEV_H
#define __uhci_DEV_H 1
/*
 * DEVICE DEFINITION: UHCI USB controller
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) uhci ## _ ## x
/*
 * Register type: uhci_usbcmd_t
 * Description: Implicit type of USB command register
 * Fields:
 *   rs	(size 1, offset 0, init 0):	RW	Run/stop
 *   hcreset	(size 1, offset 1, init 0):	RW	Host controller reset
 *   greset	(size 1, offset 2, init 0):	RW	Global reset
 *   egsm	(size 1, offset 3, init 0):	RW	Enter global suspend mode
 *   fgr	(size 1, offset 4, init 0):	RW	Force global resume
 *   swdbg	(size 1, offset 5, init 0):	RW	Software debug
 *   cf	(size 1, offset 6, init 0):	RW	Configure flag
 *   maxp	(size 1, offset 7, init 0):	RW	Max packet (1=64 bytes, 0=32 bytes)
 *   _anon8	(size 8, offset 8, init 0):	RSVD	_
 */
typedef uint16_t uhci_usbcmd_t;
#define uhci_usbcmd_default 0x0
static inline uint8_t uhci_usbcmd_rs_extract(uhci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbcmd_rs_extract(uhci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline uhci_usbcmd_t uhci_usbcmd_rs_insert(uhci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbcmd_t uhci_usbcmd_rs_insert(uhci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe) | (0x1 & (((uhci_usbcmd_t )(_fieldval)) << 0)));
}

static inline uint8_t uhci_usbcmd_hcreset_extract(uhci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbcmd_hcreset_extract(uhci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline uhci_usbcmd_t uhci_usbcmd_hcreset_insert(uhci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbcmd_t uhci_usbcmd_hcreset_insert(uhci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffd) | (0x2 & (((uhci_usbcmd_t )(_fieldval)) << 1)));
}

static inline uint8_t uhci_usbcmd_greset_extract(uhci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbcmd_greset_extract(uhci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline uhci_usbcmd_t uhci_usbcmd_greset_insert(uhci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbcmd_t uhci_usbcmd_greset_insert(uhci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffb) | (0x4 & (((uhci_usbcmd_t )(_fieldval)) << 2)));
}

static inline uint8_t uhci_usbcmd_egsm_extract(uhci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbcmd_egsm_extract(uhci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline uhci_usbcmd_t uhci_usbcmd_egsm_insert(uhci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbcmd_t uhci_usbcmd_egsm_insert(uhci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7) | (0x8 & (((uhci_usbcmd_t )(_fieldval)) << 3)));
}

static inline uint8_t uhci_usbcmd_fgr_extract(uhci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbcmd_fgr_extract(uhci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline uhci_usbcmd_t uhci_usbcmd_fgr_insert(uhci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbcmd_t uhci_usbcmd_fgr_insert(uhci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffef) | (0x10 & (((uhci_usbcmd_t )(_fieldval)) << 4)));
}

static inline uint8_t uhci_usbcmd_swdbg_extract(uhci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbcmd_swdbg_extract(uhci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline uhci_usbcmd_t uhci_usbcmd_swdbg_insert(uhci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbcmd_t uhci_usbcmd_swdbg_insert(uhci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdf) | (0x20 & (((uhci_usbcmd_t )(_fieldval)) << 5)));
}

static inline uint8_t uhci_usbcmd_cf_extract(uhci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbcmd_cf_extract(uhci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline uhci_usbcmd_t uhci_usbcmd_cf_insert(uhci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbcmd_t uhci_usbcmd_cf_insert(uhci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbf) | (0x40 & (((uhci_usbcmd_t )(_fieldval)) << 6)));
}

static inline uint8_t uhci_usbcmd_maxp_extract(uhci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbcmd_maxp_extract(uhci_usbcmd_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline uhci_usbcmd_t uhci_usbcmd_maxp_insert(uhci_usbcmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbcmd_t uhci_usbcmd_maxp_insert(uhci_usbcmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7f) | (0x80 & (((uhci_usbcmd_t )(_fieldval)) << 7)));
}

static inline int uhci_usbcmd_prtval(char *_s, size_t _size, uhci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline int uhci_usbcmd_prtval(char *_s, size_t _size, uhci_usbcmd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rs =\t%" PRIx8 "\t(Run/stop)\n", uhci_usbcmd_rs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcreset =\t%" PRIx8 "\t(Host controller reset)\n", uhci_usbcmd_hcreset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " greset =\t%" PRIx8 "\t(Global reset)\n", uhci_usbcmd_greset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " egsm =\t%" PRIx8 "\t(Enter global suspend mode)\n", uhci_usbcmd_egsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fgr =\t%" PRIx8 "\t(Force global resume)\n", uhci_usbcmd_fgr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " swdbg =\t%" PRIx8 "\t(Software debug)\n", uhci_usbcmd_swdbg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cf =\t%" PRIx8 "\t(Configure flag)\n", uhci_usbcmd_cf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " maxp =\t%" PRIx8 "\t(Max packet (1=64 bytes, 0=32 bytes))\n", uhci_usbcmd_maxp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: uhci_usbsts_t
 * Description: Implicit type of USB status register
 * Fields:
 *   usbint	(size 1, offset 0, init 0):	RWC	USB interrupt
 *   uei	(size 1, offset 1, init 0):	RWC	USB error interrupt
 *   rd	(size 1, offset 2, init 0):	RWC	Resume detect
 *   hse	(size 1, offset 3, init 0):	RWC	Host system error
 *   hcpe	(size 1, offset 4, init 0):	RWC	Host controller process error
 *   hch	(size 1, offset 5, init 0):	RWC	Host controller halted
 *   _anon6	(size 10, offset 6, init 0):	RSVD	_
 */
typedef uint16_t uhci_usbsts_t;
#define uhci_usbsts_default 0x0
static inline uint8_t uhci_usbsts_usbint_extract(uhci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbsts_usbint_extract(uhci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline uhci_usbsts_t uhci_usbsts_usbint_insert(uhci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbsts_t uhci_usbsts_usbint_insert(uhci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe) | (0x1 & (((uhci_usbsts_t )(_fieldval)) << 0)));
}

static inline uint8_t uhci_usbsts_uei_extract(uhci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbsts_uei_extract(uhci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline uhci_usbsts_t uhci_usbsts_uei_insert(uhci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbsts_t uhci_usbsts_uei_insert(uhci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffd) | (0x2 & (((uhci_usbsts_t )(_fieldval)) << 1)));
}

static inline uint8_t uhci_usbsts_rd_extract(uhci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbsts_rd_extract(uhci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline uhci_usbsts_t uhci_usbsts_rd_insert(uhci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbsts_t uhci_usbsts_rd_insert(uhci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffb) | (0x4 & (((uhci_usbsts_t )(_fieldval)) << 2)));
}

static inline uint8_t uhci_usbsts_hse_extract(uhci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbsts_hse_extract(uhci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline uhci_usbsts_t uhci_usbsts_hse_insert(uhci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbsts_t uhci_usbsts_hse_insert(uhci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7) | (0x8 & (((uhci_usbsts_t )(_fieldval)) << 3)));
}

static inline uint8_t uhci_usbsts_hcpe_extract(uhci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbsts_hcpe_extract(uhci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline uhci_usbsts_t uhci_usbsts_hcpe_insert(uhci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbsts_t uhci_usbsts_hcpe_insert(uhci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffef) | (0x10 & (((uhci_usbsts_t )(_fieldval)) << 4)));
}

static inline uint8_t uhci_usbsts_hch_extract(uhci_usbsts_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbsts_hch_extract(uhci_usbsts_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline uhci_usbsts_t uhci_usbsts_hch_insert(uhci_usbsts_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbsts_t uhci_usbsts_hch_insert(uhci_usbsts_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdf) | (0x20 & (((uhci_usbsts_t )(_fieldval)) << 5)));
}

static inline int uhci_usbsts_prtval(char *_s, size_t _size, uhci_usbsts_t _regval) __attribute__ ((always_inline));
static inline int uhci_usbsts_prtval(char *_s, size_t _size, uhci_usbsts_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbint =\t%" PRIx8 "\t(USB interrupt)\n", uhci_usbsts_usbint_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " uei =\t%" PRIx8 "\t(USB error interrupt)\n", uhci_usbsts_uei_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rd =\t%" PRIx8 "\t(Resume detect)\n", uhci_usbsts_rd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hse =\t%" PRIx8 "\t(Host system error)\n", uhci_usbsts_hse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcpe =\t%" PRIx8 "\t(Host controller process error)\n", uhci_usbsts_hcpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hch =\t%" PRIx8 "\t(Host controller halted)\n", uhci_usbsts_hch_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: uhci_usbintr_t
 * Description: Implicit type of USB interrupt enable register
 * Fields:
 *   tc	(size 1, offset 0, init 0):	RW	Timeout/CRC interrupt enable
 *   ri	(size 1, offset 1, init 0):	RW	Resume interrupt enable
 *   ioc	(size 1, offset 2, init 0):	RW	Interrupt on complete enable
 *   sp	(size 1, offset 3, init 0):	RW	Short packet interrupt enable
 *   _anon4	(size 12, offset 4, init 0):	RSVD	_
 */
typedef uint16_t uhci_usbintr_t;
#define uhci_usbintr_default 0x0
static inline uint8_t uhci_usbintr_tc_extract(uhci_usbintr_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbintr_tc_extract(uhci_usbintr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline uhci_usbintr_t uhci_usbintr_tc_insert(uhci_usbintr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbintr_t uhci_usbintr_tc_insert(uhci_usbintr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe) | (0x1 & (((uhci_usbintr_t )(_fieldval)) << 0)));
}

static inline uint8_t uhci_usbintr_ri_extract(uhci_usbintr_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbintr_ri_extract(uhci_usbintr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline uhci_usbintr_t uhci_usbintr_ri_insert(uhci_usbintr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbintr_t uhci_usbintr_ri_insert(uhci_usbintr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffd) | (0x2 & (((uhci_usbintr_t )(_fieldval)) << 1)));
}

static inline uint8_t uhci_usbintr_ioc_extract(uhci_usbintr_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbintr_ioc_extract(uhci_usbintr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline uhci_usbintr_t uhci_usbintr_ioc_insert(uhci_usbintr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbintr_t uhci_usbintr_ioc_insert(uhci_usbintr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffb) | (0x4 & (((uhci_usbintr_t )(_fieldval)) << 2)));
}

static inline uint8_t uhci_usbintr_sp_extract(uhci_usbintr_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_usbintr_sp_extract(uhci_usbintr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline uhci_usbintr_t uhci_usbintr_sp_insert(uhci_usbintr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_usbintr_t uhci_usbintr_sp_insert(uhci_usbintr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7) | (0x8 & (((uhci_usbintr_t )(_fieldval)) << 3)));
}

static inline int uhci_usbintr_prtval(char *_s, size_t _size, uhci_usbintr_t _regval) __attribute__ ((always_inline));
static inline int uhci_usbintr_prtval(char *_s, size_t _size, uhci_usbintr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc =\t%" PRIx8 "\t(Timeout/CRC interrupt enable)\n", uhci_usbintr_tc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ri =\t%" PRIx8 "\t(Resume interrupt enable)\n", uhci_usbintr_ri_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ioc =\t%" PRIx8 "\t(Interrupt on complete enable)\n", uhci_usbintr_ioc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sp =\t%" PRIx8 "\t(Short packet interrupt enable)\n", uhci_usbintr_sp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: uhci_frnum_t
 * Description: Implicit type of Frame number register
 * Fields:
 *   flcifn	(size 11, offset 0, init 0):	RW	Frame list current index / frame number
 *   _anon11	(size 5, offset 11, init 0):	RSVD	_
 */
typedef uint16_t uhci_frnum_t;
#define uhci_frnum_default 0x0
static inline uint16_t uhci_frnum_flcifn_extract(uhci_frnum_t _regval) __attribute__ ((always_inline));
static inline uint16_t uhci_frnum_flcifn_extract(uhci_frnum_t _regval)
{
    return((uint16_t )((_regval & 0x7ff) >> 0));
}

static inline uhci_frnum_t uhci_frnum_flcifn_insert(uhci_frnum_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline uhci_frnum_t uhci_frnum_flcifn_insert(uhci_frnum_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xf800) | (0x7ff & (((uhci_frnum_t )(_fieldval)) << 0)));
}

static inline int uhci_frnum_prtval(char *_s, size_t _size, uhci_frnum_t _regval) __attribute__ ((always_inline));
static inline int uhci_frnum_prtval(char *_s, size_t _size, uhci_frnum_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flcifn =\t%" PRIx16 "\t(Frame list current index / frame number)\n", uhci_frnum_flcifn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: uhci_sof_t
 * Description: Implicit type of Start of frame modify register
 * Fields:
 *   softv	(size 7, offset 0, init 0):	RW	SOF timing value
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 */
typedef uint8_t uhci_sof_t;
#define uhci_sof_default 0x0
static inline uint8_t uhci_sof_softv_extract(uhci_sof_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_sof_softv_extract(uhci_sof_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline uhci_sof_t uhci_sof_softv_insert(uhci_sof_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_sof_t uhci_sof_softv_insert(uhci_sof_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x80) | (0x7f & (((uhci_sof_t )(_fieldval)) << 0)));
}

static inline int uhci_sof_prtval(char *_s, size_t _size, uhci_sof_t _regval) __attribute__ ((always_inline));
static inline int uhci_sof_prtval(char *_s, size_t _size, uhci_sof_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " softv =\t%" PRIx8 "\t(SOF timing value)\n", uhci_sof_softv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: uhci_portsc_t
 * Description: Implicit type of Port status and control register array
 * Fields:
 *   ccs	(size 1, offset 0, init 0):	RO	current connect status
 *   csc	(size 1, offset 1, init 0):	RWC	connect status change
 *   ped	(size 1, offset 2, init 0):	RW	port enabled/disabled
 *   pedc	(size 1, offset 3, init 0):	RWC	port enable/disable change
 *   ls	(size 2, offset 4, init 0):	RO	line status
 *   rd	(size 1, offset 6, init 0):	RW	resume detect
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 *   lsda	(size 1, offset 8, init 0):	RO	low-speed device attached
 *   pr	(size 1, offset 9, init 0):	RW	port reset
 *   _anon10	(size 2, offset 10, init 0):	RSVD	_
 *   susp	(size 1, offset 12, init 0):	RW	suspend
 *   _anon13	(size 3, offset 13, init 0):	RSVD	_
 */
typedef uint16_t uhci_portsc_t;
#define uhci_portsc_default 0x0
static inline uint8_t uhci_portsc_ccs_extract(uhci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_ccs_extract(uhci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline uhci_portsc_t uhci_portsc_ccs_insert(uhci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_portsc_t uhci_portsc_ccs_insert(uhci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe) | (0x1 & (((uhci_portsc_t )(_fieldval)) << 0)));
}

static inline uint8_t uhci_portsc_csc_extract(uhci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_csc_extract(uhci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline uhci_portsc_t uhci_portsc_csc_insert(uhci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_portsc_t uhci_portsc_csc_insert(uhci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffd) | (0x2 & (((uhci_portsc_t )(_fieldval)) << 1)));
}

static inline uint8_t uhci_portsc_ped_extract(uhci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_ped_extract(uhci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline uhci_portsc_t uhci_portsc_ped_insert(uhci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_portsc_t uhci_portsc_ped_insert(uhci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffb) | (0x4 & (((uhci_portsc_t )(_fieldval)) << 2)));
}

static inline uint8_t uhci_portsc_pedc_extract(uhci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_pedc_extract(uhci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline uhci_portsc_t uhci_portsc_pedc_insert(uhci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_portsc_t uhci_portsc_pedc_insert(uhci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7) | (0x8 & (((uhci_portsc_t )(_fieldval)) << 3)));
}

static inline uint8_t uhci_portsc_ls_extract(uhci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_ls_extract(uhci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x30) >> 4));
}

static inline uhci_portsc_t uhci_portsc_ls_insert(uhci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_portsc_t uhci_portsc_ls_insert(uhci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffcf) | (0x30 & (((uhci_portsc_t )(_fieldval)) << 4)));
}

static inline uint8_t uhci_portsc_rd_extract(uhci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_rd_extract(uhci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline uhci_portsc_t uhci_portsc_rd_insert(uhci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_portsc_t uhci_portsc_rd_insert(uhci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbf) | (0x40 & (((uhci_portsc_t )(_fieldval)) << 6)));
}

static inline uint8_t uhci_portsc_lsda_extract(uhci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_lsda_extract(uhci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline uhci_portsc_t uhci_portsc_lsda_insert(uhci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_portsc_t uhci_portsc_lsda_insert(uhci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeff) | (0x100 & (((uhci_portsc_t )(_fieldval)) << 8)));
}

static inline uint8_t uhci_portsc_pr_extract(uhci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_pr_extract(uhci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline uhci_portsc_t uhci_portsc_pr_insert(uhci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_portsc_t uhci_portsc_pr_insert(uhci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdff) | (0x200 & (((uhci_portsc_t )(_fieldval)) << 9)));
}

static inline uint8_t uhci_portsc_susp_extract(uhci_portsc_t _regval) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_susp_extract(uhci_portsc_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline uhci_portsc_t uhci_portsc_susp_insert(uhci_portsc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline uhci_portsc_t uhci_portsc_susp_insert(uhci_portsc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefff) | (0x1000 & (((uhci_portsc_t )(_fieldval)) << 12)));
}

static inline int uhci_portsc_prtval(char *_s, size_t _size, uhci_portsc_t _regval) __attribute__ ((always_inline));
static inline int uhci_portsc_prtval(char *_s, size_t _size, uhci_portsc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ccs =\t%" PRIx8 "\t(current connect status)\n", uhci_portsc_ccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " csc =\t%" PRIx8 "\t(connect status change)\n", uhci_portsc_csc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ped =\t%" PRIx8 "\t(port enabled/disabled)\n", uhci_portsc_ped_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pedc =\t%" PRIx8 "\t(port enable/disable change)\n", uhci_portsc_pedc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ls =\t%" PRIx8 "\t(line status)\n", uhci_portsc_ls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rd =\t%" PRIx8 "\t(resume detect)\n", uhci_portsc_rd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsda =\t%" PRIx8 "\t(low-speed device attached)\n", uhci_portsc_lsda_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pr =\t%" PRIx8 "\t(port reset)\n", uhci_portsc_pr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " susp =\t%" PRIx8 "\t(suspend)\n", uhci_portsc_susp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: uhci_flp_t
 * Description: Frame list pointer
 * Fields:
 *   t	(size 1, offset 0, init 0):	RW	terminate (frame list pointer not valid)
 *   q	(size 1, offset 1, init 0):	RW	QH/TD select
 *   _anon2	(size 2, offset 2, init 0):	MBZ	_
 *   flp	(size 28, offset 4, init 0):	RW	bits 31:4 of frame list pointer
 */
typedef uint8_t *uhci_flp_t;
typedef uint8_t uhci_flp_array_t[4];
static const size_t uhci_flp_size = sizeof(uhci_flp_array_t );
static inline uint8_t uhci_flp_t_extract(uhci_flp_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_flp_t_extract(uhci_flp_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x1) >> 0);
}

static inline void uhci_flp_t_insert(uhci_flp_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_flp_t_insert(uhci_flp_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t uhci_flp_q_extract(uhci_flp_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_flp_q_extract(uhci_flp_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x2) >> 1);
}

static inline void uhci_flp_q_insert(uhci_flp_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_flp_q_insert(uhci_flp_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint32_t uhci_flp_flp_extract(uhci_flp_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t uhci_flp_flp_extract(uhci_flp_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xfffffff0) >> 4);
}

static inline void uhci_flp_flp_insert(uhci_flp_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_flp_flp_insert(uhci_flp_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0xf) | (0xfffffff0 & (_fieldval << 4)));
}

static inline int uhci_flp_prtval(char *_s, size_t _size, uhci_flp_t _regval) __attribute__ ((always_inline));
static inline int uhci_flp_prtval(char *_s, size_t _size, uhci_flp_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " t =\t%" PRIx8 "\t(terminate (frame list pointer not valid))\n", uhci_flp_t_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " q =\t%" PRIx8 "\t(QH/TD select)\n", uhci_flp_q_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flp =\t%" PRIx32 "\t(bits 31:4 of frame list pointer)\n", uhci_flp_flp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: uhci_td_t
 * Description: Transfer descriptor
 * Fields:
 *   t	(size 1, offset 0, init 0):	RW	terminate (link pointer is not valid)
 *   q	(size 1, offset 1, init 0):	RW	QH/TD select
 *   vf	(size 1, offset 2, init 0):	RW	Depth/breadth select
 *   _anon3	(size 1, offset 3, init 0):	MBZ	_
 *   lp	(size 28, offset 4, init 0):	RW	bits 31:4 of link pointer
 *   actlen	(size 11, offset 32, init 0):	RW	actual length
 *   _anon43	(size 5, offset 43, init 0):	RSVD	_
 *   _anon48	(size 1, offset 48, init 0):	RSVD	_
 *   bse	(size 1, offset 49, init 0):	RW	bitstuff error
 *   cte	(size 1, offset 50, init 0):	RW	CRC/Timeout error
 *   nakr	(size 1, offset 51, init 0):	RW	NAK received
 *   babble	(size 1, offset 52, init 0):	RW	babble detected
 *   dbe	(size 1, offset 53, init 0):	RW	data buffer error
 *   stalled	(size 1, offset 54, init 0):	RW	stalled
 *   active	(size 1, offset 55, init 0):	RW	active
 *   ioc	(size 1, offset 56, init 0):	RW	interrupt on complete
 *   ios	(size 1, offset 57, init 0):	RW	isochronous select
 *   ls	(size 1, offset 58, init 0):	RW	low speed device
 *   ec	(size 2, offset 59, init 0):	RW	error count
 *   spd	(size 1, offset 61, init 0):	RW	short packet detect
 *   _anon62	(size 2, offset 62, init 0):	RSVD	_
 *   pid	(size 8, offset 64, init 0):	RW	packet indentification
 *   devaddr	(size 7, offset 72, init 0):	RW	device address
 *   endpt	(size 4, offset 79, init 0):	RW	endpoint
 *   d	(size 1, offset 83, init 0):	RW	data toggle
 *   _anon84	(size 1, offset 84, init 0):	RSVD	_
 *   maxlen	(size 11, offset 85, init 0):	RW	maximum length
 *   buffer	(size 32, offset 96, init 0):	RW	buffer pointer
 */
typedef uint8_t *uhci_td_t;
typedef uint8_t uhci_td_array_t[16];
static const size_t uhci_td_size = sizeof(uhci_td_array_t );
static inline uint8_t uhci_td_t_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_t_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x1) >> 0);
}

static inline void uhci_td_t_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_t_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t uhci_td_q_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_q_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x2) >> 1);
}

static inline void uhci_td_q_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_q_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t uhci_td_vf_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_vf_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x4) >> 2);
}

static inline void uhci_td_vf_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_vf_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint32_t uhci_td_lp_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t uhci_td_lp_extract(uhci_td_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xfffffff0) >> 4);
}

static inline void uhci_td_lp_insert(uhci_td_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_lp_insert(uhci_td_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0xf) | (0xfffffff0 & (_fieldval << 4)));
}

static inline uint16_t uhci_td_actlen_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t uhci_td_actlen_extract(uhci_td_t _dtptr)
{
    return(((*((uint16_t *)(4 + _dtptr))) & 0x7ff) >> 0);
}

static inline void uhci_td_actlen_insert(uhci_td_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_actlen_insert(uhci_td_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(4 + _dtptr)) = (((*((uint16_t *)(4 + _dtptr))) & 0xf800) | (0x7ff & (_fieldval << 0)));
}

static inline uint8_t uhci_td_bse_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_bse_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(6 + _dtptr))) & 0x2) >> 1);
}

static inline void uhci_td_bse_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_bse_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(6 + _dtptr)) = (((*((uint8_t *)(6 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t uhci_td_cte_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_cte_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(6 + _dtptr))) & 0x4) >> 2);
}

static inline void uhci_td_cte_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_cte_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(6 + _dtptr)) = (((*((uint8_t *)(6 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t uhci_td_nakr_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_nakr_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(6 + _dtptr))) & 0x8) >> 3);
}

static inline void uhci_td_nakr_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_nakr_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(6 + _dtptr)) = (((*((uint8_t *)(6 + _dtptr))) & 0xf7) | (0x8 & (_fieldval << 3)));
}

static inline uint8_t uhci_td_babble_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_babble_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(6 + _dtptr))) & 0x10) >> 4);
}

static inline void uhci_td_babble_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_babble_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(6 + _dtptr)) = (((*((uint8_t *)(6 + _dtptr))) & 0xef) | (0x10 & (_fieldval << 4)));
}

static inline uint8_t uhci_td_dbe_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_dbe_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(6 + _dtptr))) & 0x20) >> 5);
}

static inline void uhci_td_dbe_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_dbe_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(6 + _dtptr)) = (((*((uint8_t *)(6 + _dtptr))) & 0xdf) | (0x20 & (_fieldval << 5)));
}

static inline uint8_t uhci_td_stalled_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_stalled_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(6 + _dtptr))) & 0x40) >> 6);
}

static inline void uhci_td_stalled_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_stalled_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(6 + _dtptr)) = (((*((uint8_t *)(6 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t uhci_td_active_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_active_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(6 + _dtptr))) & 0x80) >> 7);
}

static inline void uhci_td_active_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_active_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(6 + _dtptr)) = (((*((uint8_t *)(6 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint8_t uhci_td_ioc_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_ioc_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(7 + _dtptr))) & 0x1) >> 0);
}

static inline void uhci_td_ioc_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_ioc_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(7 + _dtptr)) = (((*((uint8_t *)(7 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t uhci_td_ios_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_ios_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(7 + _dtptr))) & 0x2) >> 1);
}

static inline void uhci_td_ios_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_ios_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(7 + _dtptr)) = (((*((uint8_t *)(7 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t uhci_td_ls_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_ls_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(7 + _dtptr))) & 0x4) >> 2);
}

static inline void uhci_td_ls_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_ls_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(7 + _dtptr)) = (((*((uint8_t *)(7 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t uhci_td_ec_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_ec_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(7 + _dtptr))) & 0x18) >> 3);
}

static inline void uhci_td_ec_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_ec_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(7 + _dtptr)) = (((*((uint8_t *)(7 + _dtptr))) & 0xe7) | (0x18 & (_fieldval << 3)));
}

static inline uint8_t uhci_td_spd_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_spd_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(7 + _dtptr))) & 0x20) >> 5);
}

static inline void uhci_td_spd_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_spd_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(7 + _dtptr)) = (((*((uint8_t *)(7 + _dtptr))) & 0xdf) | (0x20 & (_fieldval << 5)));
}

static inline uint8_t uhci_td_pid_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_pid_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(8 + _dtptr))) & 0xff) >> 0);
}

static inline void uhci_td_pid_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_pid_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(8 + _dtptr)) = (((*((uint8_t *)(8 + _dtptr))) & 0x0) | (0xff & (_fieldval << 0)));
}

static inline uint8_t uhci_td_devaddr_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_devaddr_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(9 + _dtptr))) & 0x7f) >> 0);
}

static inline void uhci_td_devaddr_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_devaddr_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(9 + _dtptr)) = (((*((uint8_t *)(9 + _dtptr))) & 0x80) | (0x7f & (_fieldval << 0)));
}

static inline uint8_t uhci_td_endpt_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_endpt_extract(uhci_td_t _dtptr)
{
    return(((*((uint32_t *)(8 + _dtptr))) & 0x78000) >> 15);
}

static inline void uhci_td_endpt_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_endpt_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint32_t *)(8 + _dtptr)) = (((*((uint32_t *)(8 + _dtptr))) & 0xfff87fff) | (0x78000 & (_fieldval << 15)));
}

static inline uint8_t uhci_td_d_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_td_d_extract(uhci_td_t _dtptr)
{
    return(((*((uint8_t *)(10 + _dtptr))) & 0x8) >> 3);
}

static inline void uhci_td_d_insert(uhci_td_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_d_insert(uhci_td_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(10 + _dtptr)) = (((*((uint8_t *)(10 + _dtptr))) & 0xf7) | (0x8 & (_fieldval << 3)));
}

static inline uint16_t uhci_td_maxlen_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t uhci_td_maxlen_extract(uhci_td_t _dtptr)
{
    return(((*((uint16_t *)(10 + _dtptr))) & 0xffe0) >> 5);
}

static inline void uhci_td_maxlen_insert(uhci_td_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_maxlen_insert(uhci_td_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(10 + _dtptr)) = (((*((uint16_t *)(10 + _dtptr))) & 0x1f) | (0xffe0 & (_fieldval << 5)));
}

static inline uint32_t uhci_td_buffer_extract(uhci_td_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t uhci_td_buffer_extract(uhci_td_t _dtptr)
{
    return(((*((uint32_t *)(12 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void uhci_td_buffer_insert(uhci_td_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_td_buffer_insert(uhci_td_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(12 + _dtptr)) = (((*((uint32_t *)(12 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline int uhci_td_prtval(char *_s, size_t _size, uhci_td_t _regval) __attribute__ ((always_inline));
static inline int uhci_td_prtval(char *_s, size_t _size, uhci_td_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " t =\t%" PRIx8 "\t(terminate (link pointer is not valid))\n", uhci_td_t_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " q =\t%" PRIx8 "\t(QH/TD select)\n", uhci_td_q_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vf =\t%" PRIx8 "\t(Depth/breadth select)\n", uhci_td_vf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lp =\t%" PRIx32 "\t(bits 31:4 of link pointer)\n", uhci_td_lp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " actlen =\t%" PRIx16 "\t(actual length)\n", uhci_td_actlen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bse =\t%" PRIx8 "\t(bitstuff error)\n", uhci_td_bse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cte =\t%" PRIx8 "\t(CRC/Timeout error)\n", uhci_td_cte_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nakr =\t%" PRIx8 "\t(NAK received)\n", uhci_td_nakr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " babble =\t%" PRIx8 "\t(babble detected)\n", uhci_td_babble_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dbe =\t%" PRIx8 "\t(data buffer error)\n", uhci_td_dbe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stalled =\t%" PRIx8 "\t(stalled)\n", uhci_td_stalled_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " active =\t%" PRIx8 "\t(active)\n", uhci_td_active_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ioc =\t%" PRIx8 "\t(interrupt on complete)\n", uhci_td_ioc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ios =\t%" PRIx8 "\t(isochronous select)\n", uhci_td_ios_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ls =\t%" PRIx8 "\t(low speed device)\n", uhci_td_ls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ec =\t%" PRIx8 "\t(error count)\n", uhci_td_ec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spd =\t%" PRIx8 "\t(short packet detect)\n", uhci_td_spd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pid =\t%" PRIx8 "\t(packet indentification)\n", uhci_td_pid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " devaddr =\t%" PRIx8 "\t(device address)\n", uhci_td_devaddr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " endpt =\t%" PRIx8 "\t(endpoint)\n", uhci_td_endpt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " d =\t%" PRIx8 "\t(data toggle)\n", uhci_td_d_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " maxlen =\t%" PRIx16 "\t(maximum length)\n", uhci_td_maxlen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " buffer =\t%" PRIx32 "\t(buffer pointer)\n", uhci_td_buffer_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: uhci_qhe_t
 * Description: Queue head and element
 * Fields:
 *   t	(size 1, offset 0, init 0):	RW	terminate (qelp not valid)
 *   q	(size 1, offset 1, init 0):	RW	QH/TD select
 *   _anon2	(size 2, offset 2, init 0):	MBZ	_
 *   qelp	(size 28, offset 4, init 0):	RW	bits 31:4 of queue head or element link pointer
 */
typedef uint8_t *uhci_qhe_t;
typedef uint8_t uhci_qhe_array_t[4];
static const size_t uhci_qhe_size = sizeof(uhci_qhe_array_t );
static inline uint8_t uhci_qhe_t_extract(uhci_qhe_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_qhe_t_extract(uhci_qhe_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x1) >> 0);
}

static inline void uhci_qhe_t_insert(uhci_qhe_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_qhe_t_insert(uhci_qhe_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t uhci_qhe_q_extract(uhci_qhe_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t uhci_qhe_q_extract(uhci_qhe_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x2) >> 1);
}

static inline void uhci_qhe_q_insert(uhci_qhe_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_qhe_q_insert(uhci_qhe_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint32_t uhci_qhe_qelp_extract(uhci_qhe_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t uhci_qhe_qelp_extract(uhci_qhe_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xfffffff0) >> 4);
}

static inline void uhci_qhe_qelp_insert(uhci_qhe_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_qhe_qelp_insert(uhci_qhe_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0xf) | (0xfffffff0 & (_fieldval << 4)));
}

static inline int uhci_qhe_prtval(char *_s, size_t _size, uhci_qhe_t _regval) __attribute__ ((always_inline));
static inline int uhci_qhe_prtval(char *_s, size_t _size, uhci_qhe_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " t =\t%" PRIx8 "\t(terminate (qelp not valid))\n", uhci_qhe_t_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " q =\t%" PRIx8 "\t(QH/TD select)\n", uhci_qhe_q_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " qelp =\t%" PRIx32 "\t(bits 31:4 of queue head or element link pointer)\n", uhci_qhe_qelp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_io_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum uhci_initials {
    uhci_usbcmd_initial = 0x0,
    uhci_usbsts_initial = 0x0,
    uhci_usbintr_initial = 0x0,
    uhci_frnum_initial = 0x0,
    uhci_flbaseadd_initial = 0x0,
    uhci_sof_initial = 0x0,
    uhci_portsc_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void uhci_initialize(__DN(t) *_dev, mackerel_io_t base) __attribute__ ((always_inline));
static inline void uhci_initialize(__DN(t) *_dev, mackerel_io_t base)
{
    _dev->base = base;
}

/*
 * Register usbcmd: USB command
 * Type: uhci.usbcmd (Implicit type of USB command register)
 *   rs	(size 1, offset 0, init 0):	RW	Run/stop
 *   hcreset	(size 1, offset 1, init 0):	RW	Host controller reset
 *   greset	(size 1, offset 2, init 0):	RW	Global reset
 *   egsm	(size 1, offset 3, init 0):	RW	Enter global suspend mode
 *   fgr	(size 1, offset 4, init 0):	RW	Force global resume
 *   swdbg	(size 1, offset 5, init 0):	RW	Software debug
 *   cf	(size 1, offset 6, init 0):	RW	Configure flag
 *   maxp	(size 1, offset 7, init 0):	RW	Max packet (1=64 bytes, 0=32 bytes)
 *   _anon8	(size 8, offset 8, init 0):	RSVD	_
 */
static inline uhci_usbcmd_t uhci_usbcmd_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uhci_usbcmd_t uhci_usbcmd_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_16(_dev->base, 0x0));
}

static inline uhci_usbcmd_t uhci_usbcmd_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uhci_usbcmd_t uhci_usbcmd_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_16(_dev->base, 0x0));
}

static inline void uhci_usbcmd_rawwr(__DN(t) *_dev, uhci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline void uhci_usbcmd_rawwr(__DN(t) *_dev, uhci_usbcmd_t _regval)
{
    mackerel_write_io_16(_dev->base, 0x0, _regval);
}

static inline void uhci_usbcmd_wr(__DN(t) *_dev, uhci_usbcmd_t _regval) __attribute__ ((always_inline));
static inline void uhci_usbcmd_wr(__DN(t) *_dev, uhci_usbcmd_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    _regval = (_regval | (0xff00 & mackerel_read_io_16(_dev->base, 0x0)));
    mackerel_write_io_16(_dev->base, 0x0, _regval);
}

static inline int uhci_usbcmd_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int uhci_usbcmd_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uhci_usbcmd_t _regval = mackerel_read_io_16(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbcmd (USB command): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rs =\t%" PRIx8 "\t(Run/stop)\n", uhci_usbcmd_rs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcreset =\t%" PRIx8 "\t(Host controller reset)\n", uhci_usbcmd_hcreset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " greset =\t%" PRIx8 "\t(Global reset)\n", uhci_usbcmd_greset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " egsm =\t%" PRIx8 "\t(Enter global suspend mode)\n", uhci_usbcmd_egsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fgr =\t%" PRIx8 "\t(Force global resume)\n", uhci_usbcmd_fgr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " swdbg =\t%" PRIx8 "\t(Software debug)\n", uhci_usbcmd_swdbg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cf =\t%" PRIx8 "\t(Configure flag)\n", uhci_usbcmd_cf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " maxp =\t%" PRIx8 "\t(Max packet (1=64 bytes, 0=32 bytes))\n", uhci_usbcmd_maxp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t uhci_usbcmd_rs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbcmd_rs_rdf(__DN(t) *_dev)
{
    uhci_usbcmd_t _regval = mackerel_read_io_16(_dev->base, 0x0);
    return(uhci_usbcmd_rs_extract(_regval));
}

static inline uint8_t uhci_usbcmd_hcreset_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbcmd_hcreset_rdf(__DN(t) *_dev)
{
    uhci_usbcmd_t _regval = mackerel_read_io_16(_dev->base, 0x0);
    return(uhci_usbcmd_hcreset_extract(_regval));
}

static inline uint8_t uhci_usbcmd_greset_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbcmd_greset_rdf(__DN(t) *_dev)
{
    uhci_usbcmd_t _regval = mackerel_read_io_16(_dev->base, 0x0);
    return(uhci_usbcmd_greset_extract(_regval));
}

static inline uint8_t uhci_usbcmd_egsm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbcmd_egsm_rdf(__DN(t) *_dev)
{
    uhci_usbcmd_t _regval = mackerel_read_io_16(_dev->base, 0x0);
    return(uhci_usbcmd_egsm_extract(_regval));
}

static inline uint8_t uhci_usbcmd_fgr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbcmd_fgr_rdf(__DN(t) *_dev)
{
    uhci_usbcmd_t _regval = mackerel_read_io_16(_dev->base, 0x0);
    return(uhci_usbcmd_fgr_extract(_regval));
}

static inline uint8_t uhci_usbcmd_swdbg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbcmd_swdbg_rdf(__DN(t) *_dev)
{
    uhci_usbcmd_t _regval = mackerel_read_io_16(_dev->base, 0x0);
    return(uhci_usbcmd_swdbg_extract(_regval));
}

static inline uint8_t uhci_usbcmd_cf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbcmd_cf_rdf(__DN(t) *_dev)
{
    uhci_usbcmd_t _regval = mackerel_read_io_16(_dev->base, 0x0);
    return(uhci_usbcmd_cf_extract(_regval));
}

static inline uint8_t uhci_usbcmd_maxp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbcmd_maxp_rdf(__DN(t) *_dev)
{
    uhci_usbcmd_t _regval = mackerel_read_io_16(_dev->base, 0x0);
    return(uhci_usbcmd_maxp_extract(_regval));
}

static inline void uhci_usbcmd_rs_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbcmd_rs_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbcmd_t _regval = 0x1 & (((uhci_usbcmd_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffe & mackerel_read_io_16(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void uhci_usbcmd_hcreset_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbcmd_hcreset_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbcmd_t _regval = 0x2 & (((uhci_usbcmd_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffd & mackerel_read_io_16(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void uhci_usbcmd_greset_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbcmd_greset_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbcmd_t _regval = 0x4 & (((uhci_usbcmd_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffb & mackerel_read_io_16(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void uhci_usbcmd_egsm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbcmd_egsm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbcmd_t _regval = 0x8 & (((uhci_usbcmd_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfff7 & mackerel_read_io_16(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void uhci_usbcmd_fgr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbcmd_fgr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbcmd_t _regval = 0x10 & (((uhci_usbcmd_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffef & mackerel_read_io_16(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void uhci_usbcmd_swdbg_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbcmd_swdbg_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbcmd_t _regval = 0x20 & (((uhci_usbcmd_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffdf & mackerel_read_io_16(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void uhci_usbcmd_cf_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbcmd_cf_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbcmd_t _regval = 0x40 & (((uhci_usbcmd_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffbf & mackerel_read_io_16(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void uhci_usbcmd_maxp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbcmd_maxp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbcmd_t _regval = 0x80 & (((uhci_usbcmd_t )(_fieldval)) << 7);
    _regval = (_regval | (0xff7f & mackerel_read_io_16(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register usbsts: USB status
 * Type: uhci.usbsts (Implicit type of USB status register)
 *   usbint	(size 1, offset 0, init 0):	RWC	USB interrupt
 *   uei	(size 1, offset 1, init 0):	RWC	USB error interrupt
 *   rd	(size 1, offset 2, init 0):	RWC	Resume detect
 *   hse	(size 1, offset 3, init 0):	RWC	Host system error
 *   hcpe	(size 1, offset 4, init 0):	RWC	Host controller process error
 *   hch	(size 1, offset 5, init 0):	RWC	Host controller halted
 *   _anon6	(size 10, offset 6, init 0):	RSVD	_
 */
static inline uhci_usbsts_t uhci_usbsts_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uhci_usbsts_t uhci_usbsts_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_16(_dev->base, 0x2));
}

static inline uhci_usbsts_t uhci_usbsts_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uhci_usbsts_t uhci_usbsts_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_16(_dev->base, 0x2));
}

static inline void uhci_usbsts_rawwr(__DN(t) *_dev, uhci_usbsts_t _regval) __attribute__ ((always_inline));
static inline void uhci_usbsts_rawwr(__DN(t) *_dev, uhci_usbsts_t _regval)
{
    mackerel_write_io_16(_dev->base, 0x2, _regval);
}

static inline void uhci_usbsts_wr(__DN(t) *_dev, uhci_usbsts_t _regval) __attribute__ ((always_inline));
static inline void uhci_usbsts_wr(__DN(t) *_dev, uhci_usbsts_t _regval)
{
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    _regval = (_regval | (0xffc0 & mackerel_read_io_16(_dev->base, 0x2)));
    mackerel_write_io_16(_dev->base, 0x2, _regval);
}

static inline int uhci_usbsts_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int uhci_usbsts_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uhci_usbsts_t _regval = mackerel_read_io_16(_dev->base, 0x2);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbsts (USB status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " usbint =\t%" PRIx8 "\t(USB interrupt)\n", uhci_usbsts_usbint_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " uei =\t%" PRIx8 "\t(USB error interrupt)\n", uhci_usbsts_uei_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rd =\t%" PRIx8 "\t(Resume detect)\n", uhci_usbsts_rd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hse =\t%" PRIx8 "\t(Host system error)\n", uhci_usbsts_hse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcpe =\t%" PRIx8 "\t(Host controller process error)\n", uhci_usbsts_hcpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hch =\t%" PRIx8 "\t(Host controller halted)\n", uhci_usbsts_hch_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    return(_r);
}

static inline uint8_t uhci_usbsts_usbint_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbsts_usbint_rdf(__DN(t) *_dev)
{
    uhci_usbsts_t _regval = mackerel_read_io_16(_dev->base, 0x2);
    return(uhci_usbsts_usbint_extract(_regval));
}

static inline uint8_t uhci_usbsts_uei_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbsts_uei_rdf(__DN(t) *_dev)
{
    uhci_usbsts_t _regval = mackerel_read_io_16(_dev->base, 0x2);
    return(uhci_usbsts_uei_extract(_regval));
}

static inline uint8_t uhci_usbsts_rd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbsts_rd_rdf(__DN(t) *_dev)
{
    uhci_usbsts_t _regval = mackerel_read_io_16(_dev->base, 0x2);
    return(uhci_usbsts_rd_extract(_regval));
}

static inline uint8_t uhci_usbsts_hse_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbsts_hse_rdf(__DN(t) *_dev)
{
    uhci_usbsts_t _regval = mackerel_read_io_16(_dev->base, 0x2);
    return(uhci_usbsts_hse_extract(_regval));
}

static inline uint8_t uhci_usbsts_hcpe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbsts_hcpe_rdf(__DN(t) *_dev)
{
    uhci_usbsts_t _regval = mackerel_read_io_16(_dev->base, 0x2);
    return(uhci_usbsts_hcpe_extract(_regval));
}

static inline uint8_t uhci_usbsts_hch_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbsts_hch_rdf(__DN(t) *_dev)
{
    uhci_usbsts_t _regval = mackerel_read_io_16(_dev->base, 0x2);
    return(uhci_usbsts_hch_extract(_regval));
}

static inline void uhci_usbsts_usbint_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbsts_usbint_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbsts_t _regval = 0x1 & (((uhci_usbsts_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffc0 & mackerel_read_io_16(_dev->base, 0x2)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x2, _regval);
    // No shadow register to write to
}

static inline void uhci_usbsts_uei_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbsts_uei_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbsts_t _regval = 0x2 & (((uhci_usbsts_t )(_fieldval)) << 1);
    _regval = (_regval | (0xffc0 & mackerel_read_io_16(_dev->base, 0x2)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x2, _regval);
    // No shadow register to write to
}

static inline void uhci_usbsts_rd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbsts_rd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbsts_t _regval = 0x4 & (((uhci_usbsts_t )(_fieldval)) << 2);
    _regval = (_regval | (0xffc0 & mackerel_read_io_16(_dev->base, 0x2)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x2, _regval);
    // No shadow register to write to
}

static inline void uhci_usbsts_hse_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbsts_hse_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbsts_t _regval = 0x8 & (((uhci_usbsts_t )(_fieldval)) << 3);
    _regval = (_regval | (0xffc0 & mackerel_read_io_16(_dev->base, 0x2)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x2, _regval);
    // No shadow register to write to
}

static inline void uhci_usbsts_hcpe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbsts_hcpe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbsts_t _regval = 0x10 & (((uhci_usbsts_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffc0 & mackerel_read_io_16(_dev->base, 0x2)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x2, _regval);
    // No shadow register to write to
}

static inline void uhci_usbsts_hch_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbsts_hch_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbsts_t _regval = 0x20 & (((uhci_usbsts_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffc0 & mackerel_read_io_16(_dev->base, 0x2)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x2, _regval);
    // No shadow register to write to
}

/*
 * Register usbintr: USB interrupt enable
 * Type: uhci.usbintr (Implicit type of USB interrupt enable register)
 *   tc	(size 1, offset 0, init 0):	RW	Timeout/CRC interrupt enable
 *   ri	(size 1, offset 1, init 0):	RW	Resume interrupt enable
 *   ioc	(size 1, offset 2, init 0):	RW	Interrupt on complete enable
 *   sp	(size 1, offset 3, init 0):	RW	Short packet interrupt enable
 *   _anon4	(size 12, offset 4, init 0):	RSVD	_
 */
static inline uhci_usbintr_t uhci_usbintr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uhci_usbintr_t uhci_usbintr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_16(_dev->base, 0x4));
}

static inline uhci_usbintr_t uhci_usbintr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uhci_usbintr_t uhci_usbintr_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_16(_dev->base, 0x4));
}

static inline void uhci_usbintr_rawwr(__DN(t) *_dev, uhci_usbintr_t _regval) __attribute__ ((always_inline));
static inline void uhci_usbintr_rawwr(__DN(t) *_dev, uhci_usbintr_t _regval)
{
    mackerel_write_io_16(_dev->base, 0x4, _regval);
}

static inline void uhci_usbintr_wr(__DN(t) *_dev, uhci_usbintr_t _regval) __attribute__ ((always_inline));
static inline void uhci_usbintr_wr(__DN(t) *_dev, uhci_usbintr_t _regval)
{
    _regval = (_regval & 0xf);
    // No MB1 fields present
    _regval = (_regval | (0xfff0 & mackerel_read_io_16(_dev->base, 0x4)));
    mackerel_write_io_16(_dev->base, 0x4, _regval);
}

static inline int uhci_usbintr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int uhci_usbintr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uhci_usbintr_t _regval = mackerel_read_io_16(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register usbintr (USB interrupt enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc =\t%" PRIx8 "\t(Timeout/CRC interrupt enable)\n", uhci_usbintr_tc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ri =\t%" PRIx8 "\t(Resume interrupt enable)\n", uhci_usbintr_ri_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ioc =\t%" PRIx8 "\t(Interrupt on complete enable)\n", uhci_usbintr_ioc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sp =\t%" PRIx8 "\t(Short packet interrupt enable)\n", uhci_usbintr_sp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    return(_r);
}

static inline uint8_t uhci_usbintr_tc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbintr_tc_rdf(__DN(t) *_dev)
{
    uhci_usbintr_t _regval = mackerel_read_io_16(_dev->base, 0x4);
    return(uhci_usbintr_tc_extract(_regval));
}

static inline uint8_t uhci_usbintr_ri_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbintr_ri_rdf(__DN(t) *_dev)
{
    uhci_usbintr_t _regval = mackerel_read_io_16(_dev->base, 0x4);
    return(uhci_usbintr_ri_extract(_regval));
}

static inline uint8_t uhci_usbintr_ioc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbintr_ioc_rdf(__DN(t) *_dev)
{
    uhci_usbintr_t _regval = mackerel_read_io_16(_dev->base, 0x4);
    return(uhci_usbintr_ioc_extract(_regval));
}

static inline uint8_t uhci_usbintr_sp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_usbintr_sp_rdf(__DN(t) *_dev)
{
    uhci_usbintr_t _regval = mackerel_read_io_16(_dev->base, 0x4);
    return(uhci_usbintr_sp_extract(_regval));
}

static inline void uhci_usbintr_tc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbintr_tc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbintr_t _regval = 0x1 & (((uhci_usbintr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffe & mackerel_read_io_16(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void uhci_usbintr_ri_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbintr_ri_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbintr_t _regval = 0x2 & (((uhci_usbintr_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffd & mackerel_read_io_16(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void uhci_usbintr_ioc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbintr_ioc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbintr_t _regval = 0x4 & (((uhci_usbintr_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffb & mackerel_read_io_16(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void uhci_usbintr_sp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_usbintr_sp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_usbintr_t _regval = 0x8 & (((uhci_usbintr_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfff7 & mackerel_read_io_16(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

/*
 * Register frnum: Frame number
 * Type: uhci.frnum (Implicit type of Frame number register)
 *   flcifn	(size 11, offset 0, init 0):	RW	Frame list current index / frame number
 *   _anon11	(size 5, offset 11, init 0):	RSVD	_
 */
static inline uhci_frnum_t uhci_frnum_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uhci_frnum_t uhci_frnum_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_16(_dev->base, 0x6));
}

static inline uhci_frnum_t uhci_frnum_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uhci_frnum_t uhci_frnum_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_16(_dev->base, 0x6));
}

static inline void uhci_frnum_rawwr(__DN(t) *_dev, uhci_frnum_t _regval) __attribute__ ((always_inline));
static inline void uhci_frnum_rawwr(__DN(t) *_dev, uhci_frnum_t _regval)
{
    mackerel_write_io_16(_dev->base, 0x6, _regval);
}

static inline void uhci_frnum_wr(__DN(t) *_dev, uhci_frnum_t _regval) __attribute__ ((always_inline));
static inline void uhci_frnum_wr(__DN(t) *_dev, uhci_frnum_t _regval)
{
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    _regval = (_regval | (0xf800 & mackerel_read_io_16(_dev->base, 0x6)));
    mackerel_write_io_16(_dev->base, 0x6, _regval);
}

static inline int uhci_frnum_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int uhci_frnum_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uhci_frnum_t _regval = mackerel_read_io_16(_dev->base, 0x6);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register frnum (Frame number): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flcifn =\t%" PRIx16 "\t(Frame list current index / frame number)\n", uhci_frnum_flcifn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    return(_r);
}

static inline uint16_t uhci_frnum_flcifn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t uhci_frnum_flcifn_rdf(__DN(t) *_dev)
{
    uhci_frnum_t _regval = mackerel_read_io_16(_dev->base, 0x6);
    return(uhci_frnum_flcifn_extract(_regval));
}

static inline void uhci_frnum_flcifn_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_frnum_flcifn_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    uhci_frnum_t _regval = 0x7ff & (((uhci_frnum_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf800 & mackerel_read_io_16(_dev->base, 0x6)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x6, _regval);
    // No shadow register to write to
}

/*
 * Register flbaseadd: Frame list base address
 * Type: uhci.uint32 (primitive type)
 */
static inline uint32_t uhci_flbaseadd_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t uhci_flbaseadd_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x8));
}

static inline uint32_t uhci_flbaseadd_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t uhci_flbaseadd_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_32(_dev->base, 0x8));
}

static inline void uhci_flbaseadd_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void uhci_flbaseadd_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_io_32(_dev->base, 0x8, _regval);
}

static inline void uhci_flbaseadd_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void uhci_flbaseadd_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_32(_dev->base, 0x8, _regval);
}

static inline int uhci_flbaseadd_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int uhci_flbaseadd_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_io_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register flbaseadd (Frame list base address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register sof: Start of frame modify
 * Type: uhci.sof (Implicit type of Start of frame modify register)
 *   softv	(size 7, offset 0, init 0):	RW	SOF timing value
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 */
static inline uhci_sof_t uhci_sof_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uhci_sof_t uhci_sof_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0xc));
}

static inline uhci_sof_t uhci_sof_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uhci_sof_t uhci_sof_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0xc));
}

static inline void uhci_sof_rawwr(__DN(t) *_dev, uhci_sof_t _regval) __attribute__ ((always_inline));
static inline void uhci_sof_rawwr(__DN(t) *_dev, uhci_sof_t _regval)
{
    mackerel_write_io_8(_dev->base, 0xc, _regval);
}

static inline void uhci_sof_wr(__DN(t) *_dev, uhci_sof_t _regval) __attribute__ ((always_inline));
static inline void uhci_sof_wr(__DN(t) *_dev, uhci_sof_t _regval)
{
    _regval = (_regval & 0x7f);
    // No MB1 fields present
    _regval = (_regval | (0x80 & mackerel_read_io_8(_dev->base, 0xc)));
    mackerel_write_io_8(_dev->base, 0xc, _regval);
}

static inline int uhci_sof_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int uhci_sof_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uhci_sof_t _regval = mackerel_read_io_8(_dev->base, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sof (Start of frame modify): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " softv =\t%" PRIx8 "\t(SOF timing value)\n", uhci_sof_softv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    return(_r);
}

static inline uint8_t uhci_sof_softv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t uhci_sof_softv_rdf(__DN(t) *_dev)
{
    uhci_sof_t _regval = mackerel_read_io_8(_dev->base, 0xc);
    return(uhci_sof_softv_extract(_regval));
}

static inline void uhci_sof_softv_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_sof_softv_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    uhci_sof_t _regval = 0x7f & (((uhci_sof_t )(_fieldval)) << 0);
    _regval = (_regval | (0x80 & mackerel_read_io_8(_dev->base, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

/*
 * Register array portsc: Port status and control
 * Type: uhci.portsc (Implicit type of Port status and control register array)
 *   ccs	(size 1, offset 0, init 0):	RO	current connect status
 *   csc	(size 1, offset 1, init 0):	RWC	connect status change
 *   ped	(size 1, offset 2, init 0):	RW	port enabled/disabled
 *   pedc	(size 1, offset 3, init 0):	RWC	port enable/disable change
 *   ls	(size 2, offset 4, init 0):	RO	line status
 *   rd	(size 1, offset 6, init 0):	RW	resume detect
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 *   lsda	(size 1, offset 8, init 0):	RO	low-speed device attached
 *   pr	(size 1, offset 9, init 0):	RW	port reset
 *   _anon10	(size 2, offset 10, init 0):	RSVD	_
 *   susp	(size 1, offset 12, init 0):	RW	suspend
 *   _anon13	(size 3, offset 13, init 0):	RSVD	_
 */
static const size_t uhci_portsc_length = 2;
static inline uhci_portsc_t uhci_portsc_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uhci_portsc_t uhci_portsc_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8))));
}

static inline uhci_portsc_t uhci_portsc_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uhci_portsc_t uhci_portsc_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8))));
}

static inline void uhci_portsc_rawwr(__DN(t) *_dev, int _i, uhci_portsc_t _regval) __attribute__ ((always_inline));
static inline void uhci_portsc_rawwr(__DN(t) *_dev, int _i, uhci_portsc_t _regval)
{
    mackerel_write_io_16(_dev->base, 0x10 + (_i * (16 / 8)), _regval);
}

static inline void uhci_portsc_wr(__DN(t) *_dev, int _i, uhci_portsc_t _regval) __attribute__ ((always_inline));
static inline void uhci_portsc_wr(__DN(t) *_dev, int _i, uhci_portsc_t _regval)
{
    _regval = (_regval & 0x137f);
    // No MB1 fields present
    _regval = (_regval | (0xec80 & mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)))));
    mackerel_write_io_16(_dev->base, 0x10 + (_i * (16 / 8)), _regval);
}

static inline int uhci_portsc_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int uhci_portsc_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uhci_portsc_t _regval = mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "portsc", _i, "Port status and control");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ccs =\t%" PRIx8 "\t(current connect status)\n", uhci_portsc_ccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " csc =\t%" PRIx8 "\t(connect status change)\n", uhci_portsc_csc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ped =\t%" PRIx8 "\t(port enabled/disabled)\n", uhci_portsc_ped_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pedc =\t%" PRIx8 "\t(port enable/disable change)\n", uhci_portsc_pedc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ls =\t%" PRIx8 "\t(line status)\n", uhci_portsc_ls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rd =\t%" PRIx8 "\t(resume detect)\n", uhci_portsc_rd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsda =\t%" PRIx8 "\t(low-speed device attached)\n", uhci_portsc_lsda_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pr =\t%" PRIx8 "\t(port reset)\n", uhci_portsc_pr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " susp =\t%" PRIx8 "\t(suspend)\n", uhci_portsc_susp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    return(_r);
}

static inline int uhci_portsc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int uhci_portsc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = uhci_portsc_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t uhci_portsc_ccs_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_ccs_rdf(__DN(t) *_dev, int _i)
{
    uhci_portsc_t _regval = mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)));
    return(uhci_portsc_ccs_extract(_regval));
}

static inline uint8_t uhci_portsc_csc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_csc_rdf(__DN(t) *_dev, int _i)
{
    uhci_portsc_t _regval = mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)));
    return(uhci_portsc_csc_extract(_regval));
}

static inline uint8_t uhci_portsc_ped_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_ped_rdf(__DN(t) *_dev, int _i)
{
    uhci_portsc_t _regval = mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)));
    return(uhci_portsc_ped_extract(_regval));
}

static inline uint8_t uhci_portsc_pedc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_pedc_rdf(__DN(t) *_dev, int _i)
{
    uhci_portsc_t _regval = mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)));
    return(uhci_portsc_pedc_extract(_regval));
}

static inline uint8_t uhci_portsc_ls_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_ls_rdf(__DN(t) *_dev, int _i)
{
    uhci_portsc_t _regval = mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)));
    return(uhci_portsc_ls_extract(_regval));
}

static inline uint8_t uhci_portsc_rd_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_rd_rdf(__DN(t) *_dev, int _i)
{
    uhci_portsc_t _regval = mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)));
    return(uhci_portsc_rd_extract(_regval));
}

static inline uint8_t uhci_portsc_lsda_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_lsda_rdf(__DN(t) *_dev, int _i)
{
    uhci_portsc_t _regval = mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)));
    return(uhci_portsc_lsda_extract(_regval));
}

static inline uint8_t uhci_portsc_pr_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_pr_rdf(__DN(t) *_dev, int _i)
{
    uhci_portsc_t _regval = mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)));
    return(uhci_portsc_pr_extract(_regval));
}

static inline uint8_t uhci_portsc_susp_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t uhci_portsc_susp_rdf(__DN(t) *_dev, int _i)
{
    uhci_portsc_t _regval = mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)));
    return(uhci_portsc_susp_extract(_regval));
}

static inline void uhci_portsc_csc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_portsc_csc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    uhci_portsc_t _regval = 0x2 & (((uhci_portsc_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfec4 & mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x10 + (_i * (16 / 8)), _regval);
    // No shadow register to write to
}

static inline void uhci_portsc_ped_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_portsc_ped_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    uhci_portsc_t _regval = 0x4 & (((uhci_portsc_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfec0 & mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x10 + (_i * (16 / 8)), _regval);
    // No shadow register to write to
}

static inline void uhci_portsc_pedc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_portsc_pedc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    uhci_portsc_t _regval = 0x8 & (((uhci_portsc_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfec4 & mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x10 + (_i * (16 / 8)), _regval);
    // No shadow register to write to
}

static inline void uhci_portsc_rd_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_portsc_rd_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    uhci_portsc_t _regval = 0x40 & (((uhci_portsc_t )(_fieldval)) << 6);
    _regval = (_regval | (0xfe84 & mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x10 + (_i * (16 / 8)), _regval);
    // No shadow register to write to
}

static inline void uhci_portsc_pr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_portsc_pr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    uhci_portsc_t _regval = 0x200 & (((uhci_portsc_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfcc4 & mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x10 + (_i * (16 / 8)), _regval);
    // No shadow register to write to
}

static inline void uhci_portsc_susp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void uhci_portsc_susp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    uhci_portsc_t _regval = 0x1000 & (((uhci_portsc_t )(_fieldval)) << 12);
    _regval = (_regval | (0xeec4 & mackerel_read_io_16(_dev->base, 0x10 + (_i * (16 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_16(_dev->base, 0x10 + (_i * (16 / 8)), _regval);
    // No shadow register to write to
}

static inline int uhci_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int uhci_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device uhci (UHCI USB controller):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = uhci_usbcmd_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = uhci_usbsts_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = uhci_usbintr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = uhci_frnum_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = uhci_flbaseadd_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = uhci_sof_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = uhci_portsc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device uhci\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __uhci_DEV_H
