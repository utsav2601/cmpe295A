#ifndef __ahci_port_DEV_H
#define __ahci_port_DEV_H 1
/*
 * DEVICE DEFINITION: AHCI port
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) ahci_port ## _ ## x
/*
 * Constants defn: ahci_port.icct (Interface communication control)
 *  - no width specified
 */
typedef uint8_t ahci_port_icct_t;
#define ahci_port_slumber ((ahci_port_icct_t)0x6)
#define ahci_port_partial ((ahci_port_icct_t)0x2)
#define ahci_port_active ((ahci_port_icct_t)0x1)
#define ahci_port_idle ((ahci_port_icct_t)0x0)

static inline char *ahci_port_icct_describe(ahci_port_icct_t _e) __attribute__ ((always_inline));
static inline char *ahci_port_icct_describe(ahci_port_icct_t _e)
{
    switch (_e) {
    case ahci_port_slumber:
        return("slumber: Slumber");
    case ahci_port_partial:
        return("partial: Partial");
    case ahci_port_active:
        return("active: Active");
    case ahci_port_idle:
        return("idle: No-Op / Idle");
    default:
        return(NULL);
    }
}

static inline int ahci_port_icct_prtval(char *_s, size_t _size, ahci_port_icct_t _e) __attribute__ ((always_inline));
static inline int ahci_port_icct_prtval(char *_s, size_t _size, ahci_port_icct_t _e)
{
    char *d = ahci_port_icct_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ahci_port_icct_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ahci_port.speed (Interface speed)
 *  - no width specified
 */
typedef uint8_t ahci_port_speed_t;
#define ahci_port_gen1 ((ahci_port_speed_t)0x1)
#define ahci_port_gen2 ((ahci_port_speed_t)0x2)
#define ahci_port_gen3 ((ahci_port_speed_t)0x3)

static inline char *ahci_port_speed_describe(ahci_port_speed_t _e) __attribute__ ((always_inline));
static inline char *ahci_port_speed_describe(ahci_port_speed_t _e)
{
    switch (_e) {
    case ahci_port_gen1:
        return("gen1: Gen 1 (1.5 Gbps)");
    case ahci_port_gen2:
        return("gen2: Gen 2 (3 Gbps)");
    case ahci_port_gen3:
        return("gen3: Gen 3 (6 Gbps)");
    default:
        return(NULL);
    }
}

static inline int ahci_port_speed_prtval(char *_s, size_t _size, ahci_port_speed_t _e) __attribute__ ((always_inline));
static inline int ahci_port_speed_prtval(char *_s, size_t _size, ahci_port_speed_t _e)
{
    char *d = ahci_port_speed_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ahci_port_speed_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ahci_port.dets (Device detection state)
 *  - no width specified
 */
typedef uint8_t ahci_port_dets_t;
#define ahci_port_nodev ((ahci_port_dets_t)0x0)
#define ahci_port_nophy ((ahci_port_dets_t)0x1)
#define ahci_port_detect ((ahci_port_dets_t)0x3)
#define ahci_port_offline ((ahci_port_dets_t)0x4)

static inline char *ahci_port_dets_describe(ahci_port_dets_t _e) __attribute__ ((always_inline));
static inline char *ahci_port_dets_describe(ahci_port_dets_t _e)
{
    switch (_e) {
    case ahci_port_nodev:
        return("nodev: No device, no PHY");
    case ahci_port_nophy:
        return("nophy: Device detected, no PHY comm. established");
    case ahci_port_detect:
        return("detect: Device detected and PHY comm. established");
    case ahci_port_offline:
        return("offline: PHY in offline mode or loopback");
    default:
        return(NULL);
    }
}

static inline int ahci_port_dets_prtval(char *_s, size_t _size, ahci_port_dets_t _e) __attribute__ ((always_inline));
static inline int ahci_port_dets_prtval(char *_s, size_t _size, ahci_port_dets_t _e)
{
    char *d = ahci_port_dets_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ahci_port_dets_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ahci_port.ipmall (Interface transitions)
 *  - no width specified
 */
typedef uint8_t ahci_port_ipmall_t;
#define ahci_port_noipm ((ahci_port_ipmall_t)0x0)
#define ahci_port_noprtl ((ahci_port_ipmall_t)0x1)
#define ahci_port_noslmb ((ahci_port_ipmall_t)0x2)
#define ahci_port_noboth ((ahci_port_ipmall_t)0x3)

static inline char *ahci_port_ipmall_describe(ahci_port_ipmall_t _e) __attribute__ ((always_inline));
static inline char *ahci_port_ipmall_describe(ahci_port_ipmall_t _e)
{
    switch (_e) {
    case ahci_port_noipm:
        return("noipm: No interface restrictions");
    case ahci_port_noprtl:
        return("noprtl: Transitions to Partial state disabled");
    case ahci_port_noslmb:
        return("noslmb: Transitions to Slumber state disabled");
    case ahci_port_noboth:
        return("noboth: Transitions to both Partial and Slumber disabled");
    default:
        return(NULL);
    }
}

static inline int ahci_port_ipmall_prtval(char *_s, size_t _size, ahci_port_ipmall_t _e) __attribute__ ((always_inline));
static inline int ahci_port_ipmall_prtval(char *_s, size_t _size, ahci_port_ipmall_t _e)
{
    char *d = ahci_port_ipmall_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ahci_port_ipmall_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ahci_port.emtype (Enclosure message type)
 *  - no width specified
 */
typedef uint8_t ahci_port_emtype_t;
#define ahci_port_led ((ahci_port_emtype_t)0x0)
#define ahci_port_saf_te ((ahci_port_emtype_t)0x1)
#define ahci_port_ses_2 ((ahci_port_emtype_t)0x2)
#define ahci_port_sgpio ((ahci_port_emtype_t)0x3)

static inline char *ahci_port_emtype_describe(ahci_port_emtype_t _e) __attribute__ ((always_inline));
static inline char *ahci_port_emtype_describe(ahci_port_emtype_t _e)
{
    switch (_e) {
    case ahci_port_led:
        return("led: LED");
    case ahci_port_saf_te:
        return("saf_te: SAF-TE");
    case ahci_port_ses_2:
        return("ses_2: SES-2");
    case ahci_port_sgpio:
        return("sgpio: SGPOI (register-based interface");
    default:
        return(NULL);
    }
}

static inline int ahci_port_emtype_prtval(char *_s, size_t _size, ahci_port_emtype_t _e) __attribute__ ((always_inline));
static inline int ahci_port_emtype_prtval(char *_s, size_t _size, ahci_port_emtype_t _e)
{
    char *d = ahci_port_emtype_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ahci_port_emtype_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: ahci_port.emledstate (Enclosure LED state)
 *  - no width specified
 */
typedef uint8_t ahci_port_emledstate_t;
#define ahci_port_off ((ahci_port_emledstate_t)0x0)
#define ahci_port_solid ((ahci_port_emledstate_t)0x1)
#define ahci_port_vs1 ((ahci_port_emledstate_t)0x4)
#define ahci_port_vs2 ((ahci_port_emledstate_t)0x5)
#define ahci_port_vs3 ((ahci_port_emledstate_t)0x6)
#define ahci_port_vs4 ((ahci_port_emledstate_t)0x7)

static inline char *ahci_port_emledstate_describe(ahci_port_emledstate_t _e) __attribute__ ((always_inline));
static inline char *ahci_port_emledstate_describe(ahci_port_emledstate_t _e)
{
    switch (_e) {
    case ahci_port_off:
        return("off: LED shall be off");
    case ahci_port_solid:
        return("solid: LED shall be solid on");
    case ahci_port_vs1:
        return("vs1: Vendor specific 1");
    case ahci_port_vs2:
        return("vs2: Vendor specific 2");
    case ahci_port_vs3:
        return("vs3: Vendor specific 3");
    case ahci_port_vs4:
        return("vs4: Vendor specific 4");
    default:
        return(NULL);
    }
}

static inline int ahci_port_emledstate_prtval(char *_s, size_t _size, ahci_port_emledstate_t _e) __attribute__ ((always_inline));
static inline int ahci_port_emledstate_prtval(char *_s, size_t _size, ahci_port_emledstate_t _e)
{
    char *d = ahci_port_emledstate_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ahci_port_emledstate_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: ahci_port_is_t
 * Description: Implicit type of Interrupt status register
 * Fields:
 *   dhrs	(size 1, offset 0, init 0):	RWC	Device to host register FIS interrupt
 *   pss	(size 1, offset 1, init 0):	RWC	PIO setup FIS interrupt
 *   dss	(size 1, offset 2, init 0):	RWC	DMA setup FIS interrupt
 *   sdbs	(size 1, offset 3, init 0):	RWC	Set device bits interrupt
 *   ufs	(size 1, offset 4, init 0):	RO	Unknown FIS interrupt
 *   dps	(size 1, offset 5, init 0):	RWC	Descriptor processed
 *   pcs	(size 1, offset 6, init 0):	RO	Port connect change
 *   dmps	(size 1, offset 7, init 0):	RWC	Device mechanical presence
 *   _anon8	(size 14, offset 8, init 0):	RSVD	_
 *   prcs	(size 1, offset 22, init 0):	RO	PhyRdy change status
 *   ipms	(size 1, offset 23, init 0):	RWC	Incorrect port multiplier status
 *   ofs	(size 1, offset 24, init 0):	RWC	Overflow status
 *   _anon25	(size 1, offset 25, init 0):	RSVD	_
 *   infs	(size 1, offset 26, init 0):	RWC	Interface non-fatal error
 *   ifs	(size 1, offset 27, init 0):	RWC	Interface fatal error
 *   hbds	(size 1, offset 28, init 0):	RWC	Host bus data error
 *   hbfs	(size 1, offset 29, init 0):	RWC	Host bus fatal error
 *   tfes	(size 1, offset 30, init 0):	RWC	Task file error
 *   cpds	(size 1, offset 31, init 0):	RWC	Cold port detect
 */
typedef uint32_t ahci_port_is_t;
#define ahci_port_is_default 0x0
static inline uint8_t ahci_port_is_dhrs_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_dhrs_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ahci_port_is_t ahci_port_is_dhrs_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_dhrs_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ahci_port_is_t )(_fieldval)) << 0)));
}

static inline uint8_t ahci_port_is_pss_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_pss_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ahci_port_is_t ahci_port_is_pss_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_pss_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ahci_port_is_t )(_fieldval)) << 1)));
}

static inline uint8_t ahci_port_is_dss_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_dss_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ahci_port_is_t ahci_port_is_dss_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_dss_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ahci_port_is_t )(_fieldval)) << 2)));
}

static inline uint8_t ahci_port_is_sdbs_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_sdbs_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ahci_port_is_t ahci_port_is_sdbs_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_sdbs_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ahci_port_is_t )(_fieldval)) << 3)));
}

static inline uint8_t ahci_port_is_ufs_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_ufs_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ahci_port_is_t ahci_port_is_ufs_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_ufs_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ahci_port_is_t )(_fieldval)) << 4)));
}

static inline uint8_t ahci_port_is_dps_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_dps_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ahci_port_is_t ahci_port_is_dps_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_dps_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((ahci_port_is_t )(_fieldval)) << 5)));
}

static inline uint8_t ahci_port_is_pcs_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_pcs_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline ahci_port_is_t ahci_port_is_pcs_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_pcs_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((ahci_port_is_t )(_fieldval)) << 6)));
}

static inline uint8_t ahci_port_is_dmps_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_dmps_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline ahci_port_is_t ahci_port_is_dmps_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_dmps_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((ahci_port_is_t )(_fieldval)) << 7)));
}

static inline uint8_t ahci_port_is_prcs_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_prcs_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline ahci_port_is_t ahci_port_is_prcs_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_prcs_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((ahci_port_is_t )(_fieldval)) << 22)));
}

static inline uint8_t ahci_port_is_ipms_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_ipms_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline ahci_port_is_t ahci_port_is_ipms_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_ipms_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((ahci_port_is_t )(_fieldval)) << 23)));
}

static inline uint8_t ahci_port_is_ofs_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_ofs_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline ahci_port_is_t ahci_port_is_ofs_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_ofs_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((ahci_port_is_t )(_fieldval)) << 24)));
}

static inline uint8_t ahci_port_is_infs_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_infs_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline ahci_port_is_t ahci_port_is_infs_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_infs_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((ahci_port_is_t )(_fieldval)) << 26)));
}

static inline uint8_t ahci_port_is_ifs_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_ifs_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline ahci_port_is_t ahci_port_is_ifs_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_ifs_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((ahci_port_is_t )(_fieldval)) << 27)));
}

static inline uint8_t ahci_port_is_hbds_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_hbds_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline ahci_port_is_t ahci_port_is_hbds_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_hbds_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((ahci_port_is_t )(_fieldval)) << 28)));
}

static inline uint8_t ahci_port_is_hbfs_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_hbfs_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline ahci_port_is_t ahci_port_is_hbfs_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_hbfs_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((ahci_port_is_t )(_fieldval)) << 29)));
}

static inline uint8_t ahci_port_is_tfes_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_tfes_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline ahci_port_is_t ahci_port_is_tfes_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_tfes_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((ahci_port_is_t )(_fieldval)) << 30)));
}

static inline uint8_t ahci_port_is_cpds_extract(ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_cpds_extract(ahci_port_is_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline ahci_port_is_t ahci_port_is_cpds_insert(ahci_port_is_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_cpds_insert(ahci_port_is_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((ahci_port_is_t )(_fieldval)) << 31)));
}

static inline int ahci_port_is_prtval(char *_s, size_t _size, ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline int ahci_port_is_prtval(char *_s, size_t _size, ahci_port_is_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dhrs =\t%" PRIx8 "\t(Device to host register FIS interrupt)\n", ahci_port_is_dhrs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pss =\t%" PRIx8 "\t(PIO setup FIS interrupt)\n", ahci_port_is_pss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dss =\t%" PRIx8 "\t(DMA setup FIS interrupt)\n", ahci_port_is_dss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdbs =\t%" PRIx8 "\t(Set device bits interrupt)\n", ahci_port_is_sdbs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ufs =\t%" PRIx8 "\t(Unknown FIS interrupt)\n", ahci_port_is_ufs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dps =\t%" PRIx8 "\t(Descriptor processed)\n", ahci_port_is_dps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcs =\t%" PRIx8 "\t(Port connect change)\n", ahci_port_is_pcs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmps =\t%" PRIx8 "\t(Device mechanical presence)\n", ahci_port_is_dmps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prcs =\t%" PRIx8 "\t(PhyRdy change status)\n", ahci_port_is_prcs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipms =\t%" PRIx8 "\t(Incorrect port multiplier status)\n", ahci_port_is_ipms_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ofs =\t%" PRIx8 "\t(Overflow status)\n", ahci_port_is_ofs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " infs =\t%" PRIx8 "\t(Interface non-fatal error)\n", ahci_port_is_infs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ifs =\t%" PRIx8 "\t(Interface fatal error)\n", ahci_port_is_ifs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hbds =\t%" PRIx8 "\t(Host bus data error)\n", ahci_port_is_hbds_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hbfs =\t%" PRIx8 "\t(Host bus fatal error)\n", ahci_port_is_hbfs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tfes =\t%" PRIx8 "\t(Task file error)\n", ahci_port_is_tfes_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpds =\t%" PRIx8 "\t(Cold port detect)\n", ahci_port_is_cpds_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ahci_port_ie_t
 * Description: Implicit type of Interrupt enable register
 * Fields:
 *   dhre	(size 1, offset 0, init 0):	RW	Device to host register FIS interrupt
 *   pse	(size 1, offset 1, init 0):	RW	PIO setup FIS interrupt
 *   dse	(size 1, offset 2, init 0):	RW	DMA setup FIS interrupt
 *   sdbe	(size 1, offset 3, init 0):	RW	Set device bits interrupt
 *   ufe	(size 1, offset 4, init 0):	RO	Unknown FIS interrupt
 *   dpe	(size 1, offset 5, init 0):	RW	Descriptor processed
 *   pce	(size 1, offset 6, init 0):	RO	Port connect change
 *   dmpe	(size 1, offset 7, init 0):	RW	Device mechanical presence
 *   _anon8	(size 14, offset 8, init 0):	RSVD	_
 *   prce	(size 1, offset 22, init 0):	RO	PhyRdy change status
 *   ipme	(size 1, offset 23, init 0):	RW	Incorrect port multiplier status
 *   ofe	(size 1, offset 24, init 0):	RW	Overflow enable
 *   _anon25	(size 1, offset 25, init 0):	RSVD	_
 *   infe	(size 1, offset 26, init 0):	RW	Interface non-fatal error
 *   ife	(size 1, offset 27, init 0):	RW	Interface fatal error
 *   hbde	(size 1, offset 28, init 0):	RW	Host bus data error
 *   hbfe	(size 1, offset 29, init 0):	RW	Host bus fatal error
 *   tfee	(size 1, offset 30, init 0):	RW	Task file error
 *   cpde	(size 1, offset 31, init 0):	RW	Cold port detect
 */
typedef uint32_t ahci_port_ie_t;
#define ahci_port_ie_default 0x0
static inline uint8_t ahci_port_ie_dhre_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_dhre_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ahci_port_ie_t ahci_port_ie_dhre_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_dhre_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ahci_port_ie_t )(_fieldval)) << 0)));
}

static inline uint8_t ahci_port_ie_pse_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_pse_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ahci_port_ie_t ahci_port_ie_pse_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_pse_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ahci_port_ie_t )(_fieldval)) << 1)));
}

static inline uint8_t ahci_port_ie_dse_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_dse_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ahci_port_ie_t ahci_port_ie_dse_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_dse_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ahci_port_ie_t )(_fieldval)) << 2)));
}

static inline uint8_t ahci_port_ie_sdbe_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_sdbe_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ahci_port_ie_t ahci_port_ie_sdbe_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_sdbe_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ahci_port_ie_t )(_fieldval)) << 3)));
}

static inline uint8_t ahci_port_ie_ufe_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_ufe_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ahci_port_ie_t ahci_port_ie_ufe_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_ufe_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ahci_port_ie_t )(_fieldval)) << 4)));
}

static inline uint8_t ahci_port_ie_dpe_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_dpe_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ahci_port_ie_t ahci_port_ie_dpe_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_dpe_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((ahci_port_ie_t )(_fieldval)) << 5)));
}

static inline uint8_t ahci_port_ie_pce_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_pce_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline ahci_port_ie_t ahci_port_ie_pce_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_pce_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((ahci_port_ie_t )(_fieldval)) << 6)));
}

static inline uint8_t ahci_port_ie_dmpe_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_dmpe_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline ahci_port_ie_t ahci_port_ie_dmpe_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_dmpe_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((ahci_port_ie_t )(_fieldval)) << 7)));
}

static inline uint8_t ahci_port_ie_prce_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_prce_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline ahci_port_ie_t ahci_port_ie_prce_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_prce_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((ahci_port_ie_t )(_fieldval)) << 22)));
}

static inline uint8_t ahci_port_ie_ipme_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_ipme_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline ahci_port_ie_t ahci_port_ie_ipme_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_ipme_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((ahci_port_ie_t )(_fieldval)) << 23)));
}

static inline uint8_t ahci_port_ie_ofe_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_ofe_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline ahci_port_ie_t ahci_port_ie_ofe_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_ofe_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((ahci_port_ie_t )(_fieldval)) << 24)));
}

static inline uint8_t ahci_port_ie_infe_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_infe_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline ahci_port_ie_t ahci_port_ie_infe_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_infe_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((ahci_port_ie_t )(_fieldval)) << 26)));
}

static inline uint8_t ahci_port_ie_ife_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_ife_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline ahci_port_ie_t ahci_port_ie_ife_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_ife_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((ahci_port_ie_t )(_fieldval)) << 27)));
}

static inline uint8_t ahci_port_ie_hbde_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_hbde_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline ahci_port_ie_t ahci_port_ie_hbde_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_hbde_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((ahci_port_ie_t )(_fieldval)) << 28)));
}

static inline uint8_t ahci_port_ie_hbfe_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_hbfe_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline ahci_port_ie_t ahci_port_ie_hbfe_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_hbfe_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((ahci_port_ie_t )(_fieldval)) << 29)));
}

static inline uint8_t ahci_port_ie_tfee_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_tfee_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline ahci_port_ie_t ahci_port_ie_tfee_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_tfee_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((ahci_port_ie_t )(_fieldval)) << 30)));
}

static inline uint8_t ahci_port_ie_cpde_extract(ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_cpde_extract(ahci_port_ie_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline ahci_port_ie_t ahci_port_ie_cpde_insert(ahci_port_ie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_cpde_insert(ahci_port_ie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((ahci_port_ie_t )(_fieldval)) << 31)));
}

static inline int ahci_port_ie_prtval(char *_s, size_t _size, ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline int ahci_port_ie_prtval(char *_s, size_t _size, ahci_port_ie_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dhre =\t%" PRIx8 "\t(Device to host register FIS interrupt)\n", ahci_port_ie_dhre_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pse =\t%" PRIx8 "\t(PIO setup FIS interrupt)\n", ahci_port_ie_pse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dse =\t%" PRIx8 "\t(DMA setup FIS interrupt)\n", ahci_port_ie_dse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdbe =\t%" PRIx8 "\t(Set device bits interrupt)\n", ahci_port_ie_sdbe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ufe =\t%" PRIx8 "\t(Unknown FIS interrupt)\n", ahci_port_ie_ufe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpe =\t%" PRIx8 "\t(Descriptor processed)\n", ahci_port_ie_dpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pce =\t%" PRIx8 "\t(Port connect change)\n", ahci_port_ie_pce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmpe =\t%" PRIx8 "\t(Device mechanical presence)\n", ahci_port_ie_dmpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prce =\t%" PRIx8 "\t(PhyRdy change status)\n", ahci_port_ie_prce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipme =\t%" PRIx8 "\t(Incorrect port multiplier status)\n", ahci_port_ie_ipme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ofe =\t%" PRIx8 "\t(Overflow enable)\n", ahci_port_ie_ofe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " infe =\t%" PRIx8 "\t(Interface non-fatal error)\n", ahci_port_ie_infe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ife =\t%" PRIx8 "\t(Interface fatal error)\n", ahci_port_ie_ife_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hbde =\t%" PRIx8 "\t(Host bus data error)\n", ahci_port_ie_hbde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hbfe =\t%" PRIx8 "\t(Host bus fatal error)\n", ahci_port_ie_hbfe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tfee =\t%" PRIx8 "\t(Task file error)\n", ahci_port_ie_tfee_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpde =\t%" PRIx8 "\t(Cold port detect)\n", ahci_port_ie_cpde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ahci_port_cmd_t
 * Description: Implicit type of Command and status register
 * Fields:
 *   st	(size 1, offset 0, init 0):	RW	Start
 *   sud	(size 1, offset 1, init 0):	RW	Spin-up device
 *   pod	(size 1, offset 2, init 0):	RW	Power on device
 *   clo	(size 1, offset 3, init 0):	RW	Command list override
 *   fre	(size 1, offset 4, init 0):	RW	FIS receive enable
 *   _anon5	(size 3, offset 5, init 0):	RSVD	_
 *   ccs	(size 5, offset 8, init 0):	RO	Current command slot
 *   mpss	(size 1, offset 13, init 0):	RO	Mechanical presence switch state
 *   fr	(size 1, offset 14, init 0):	RO	FIS receive running
 *   cr	(size 1, offset 15, init 0):	RO	Command list running
 *   cps	(size 1, offset 16, init 0):	RO	Cold presence state
 *   pma	(size 1, offset 17, init 0):	RW	Port multiplier attached
 *   hpcp	(size 1, offset 18, init 0):	RO	Hot plug capable port
 *   mpsp	(size 1, offset 19, init 0):	RO	Mechanical presence switch
 *   cpd	(size 1, offset 20, init 0):	RO	Cold presence detection
 *   esp	(size 1, offset 21, init 0):	RO	External SATA port
 *   fbscp	(size 1, offset 22, init 0):	RO	FIS-based switching capable port
 *   apste	(size 1, offset 23, init 0):	RW	Automatic partial to slumber transitions enabled
 *   atapi	(size 1, offset 24, init 0):	RW	Device is ATAPI
 *   dlae	(size 1, offset 25, init 0):	RW	Drive LED on ATAPI enable
 *   alpe	(size 1, offset 26, init 0):	RW	Aggressive link power management enable
 *   asp	(size 1, offset 27, init 0):	RW	Aggressive slumber / partial
 *   icc	(size 4, offset 28, init 0):	RW	Interface communication control
 */
typedef uint32_t ahci_port_cmd_t;
#define ahci_port_cmd_default 0x0
static inline uint8_t ahci_port_cmd_st_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_st_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ahci_port_cmd_t ahci_port_cmd_st_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_st_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ahci_port_cmd_t )(_fieldval)) << 0)));
}

static inline uint8_t ahci_port_cmd_sud_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_sud_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ahci_port_cmd_t ahci_port_cmd_sud_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_sud_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ahci_port_cmd_t )(_fieldval)) << 1)));
}

static inline uint8_t ahci_port_cmd_pod_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_pod_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ahci_port_cmd_t ahci_port_cmd_pod_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_pod_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ahci_port_cmd_t )(_fieldval)) << 2)));
}

static inline uint8_t ahci_port_cmd_clo_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_clo_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ahci_port_cmd_t ahci_port_cmd_clo_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_clo_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ahci_port_cmd_t )(_fieldval)) << 3)));
}

static inline uint8_t ahci_port_cmd_fre_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_fre_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ahci_port_cmd_t ahci_port_cmd_fre_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_fre_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ahci_port_cmd_t )(_fieldval)) << 4)));
}

static inline uint8_t ahci_port_cmd_ccs_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_ccs_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x1f00) >> 8));
}

static inline ahci_port_cmd_t ahci_port_cmd_ccs_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_ccs_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffe0ff) | (0x1f00 & (((ahci_port_cmd_t )(_fieldval)) << 8)));
}

static inline uint8_t ahci_port_cmd_mpss_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_mpss_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline ahci_port_cmd_t ahci_port_cmd_mpss_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_mpss_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((ahci_port_cmd_t )(_fieldval)) << 13)));
}

static inline uint8_t ahci_port_cmd_fr_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_fr_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline ahci_port_cmd_t ahci_port_cmd_fr_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_fr_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((ahci_port_cmd_t )(_fieldval)) << 14)));
}

static inline uint8_t ahci_port_cmd_cr_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_cr_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline ahci_port_cmd_t ahci_port_cmd_cr_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_cr_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((ahci_port_cmd_t )(_fieldval)) << 15)));
}

static inline uint8_t ahci_port_cmd_cps_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_cps_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline ahci_port_cmd_t ahci_port_cmd_cps_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_cps_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((ahci_port_cmd_t )(_fieldval)) << 16)));
}

static inline uint8_t ahci_port_cmd_pma_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_pma_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline ahci_port_cmd_t ahci_port_cmd_pma_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_pma_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((ahci_port_cmd_t )(_fieldval)) << 17)));
}

static inline uint8_t ahci_port_cmd_hpcp_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_hpcp_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline ahci_port_cmd_t ahci_port_cmd_hpcp_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_hpcp_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((ahci_port_cmd_t )(_fieldval)) << 18)));
}

static inline uint8_t ahci_port_cmd_mpsp_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_mpsp_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline ahci_port_cmd_t ahci_port_cmd_mpsp_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_mpsp_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((ahci_port_cmd_t )(_fieldval)) << 19)));
}

static inline uint8_t ahci_port_cmd_cpd_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_cpd_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline ahci_port_cmd_t ahci_port_cmd_cpd_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_cpd_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((ahci_port_cmd_t )(_fieldval)) << 20)));
}

static inline uint8_t ahci_port_cmd_esp_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_esp_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline ahci_port_cmd_t ahci_port_cmd_esp_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_esp_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((ahci_port_cmd_t )(_fieldval)) << 21)));
}

static inline uint8_t ahci_port_cmd_fbscp_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_fbscp_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline ahci_port_cmd_t ahci_port_cmd_fbscp_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_fbscp_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((ahci_port_cmd_t )(_fieldval)) << 22)));
}

static inline uint8_t ahci_port_cmd_apste_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_apste_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline ahci_port_cmd_t ahci_port_cmd_apste_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_apste_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((ahci_port_cmd_t )(_fieldval)) << 23)));
}

static inline uint8_t ahci_port_cmd_atapi_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_atapi_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline ahci_port_cmd_t ahci_port_cmd_atapi_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_atapi_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((ahci_port_cmd_t )(_fieldval)) << 24)));
}

static inline uint8_t ahci_port_cmd_dlae_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_dlae_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline ahci_port_cmd_t ahci_port_cmd_dlae_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_dlae_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((ahci_port_cmd_t )(_fieldval)) << 25)));
}

static inline uint8_t ahci_port_cmd_alpe_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_alpe_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline ahci_port_cmd_t ahci_port_cmd_alpe_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_alpe_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((ahci_port_cmd_t )(_fieldval)) << 26)));
}

static inline uint8_t ahci_port_cmd_asp_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_asp_extract(ahci_port_cmd_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline ahci_port_cmd_t ahci_port_cmd_asp_insert(ahci_port_cmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_asp_insert(ahci_port_cmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((ahci_port_cmd_t )(_fieldval)) << 27)));
}

static inline ahci_port_icct_t ahci_port_cmd_icc_extract(ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline ahci_port_icct_t ahci_port_cmd_icc_extract(ahci_port_cmd_t _regval)
{
    return((ahci_port_icct_t )((_regval & 0xf0000000) >> 28));
}

static inline ahci_port_cmd_t ahci_port_cmd_icc_insert(ahci_port_cmd_t _regval, ahci_port_icct_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_icc_insert(ahci_port_cmd_t _regval, ahci_port_icct_t _fieldval)
{
    return((_regval & 0xfffffff) | (0xf0000000 & (((ahci_port_cmd_t )(_fieldval)) << 28)));
}

static inline int ahci_port_cmd_prtval(char *_s, size_t _size, ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline int ahci_port_cmd_prtval(char *_s, size_t _size, ahci_port_cmd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st =\t%" PRIx8 "\t(Start)\n", ahci_port_cmd_st_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sud =\t%" PRIx8 "\t(Spin-up device)\n", ahci_port_cmd_sud_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pod =\t%" PRIx8 "\t(Power on device)\n", ahci_port_cmd_pod_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clo =\t%" PRIx8 "\t(Command list override)\n", ahci_port_cmd_clo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fre =\t%" PRIx8 "\t(FIS receive enable)\n", ahci_port_cmd_fre_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ccs =\t%" PRIx8 "\t(Current command slot)\n", ahci_port_cmd_ccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mpss =\t%" PRIx8 "\t(Mechanical presence switch state)\n", ahci_port_cmd_mpss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fr =\t%" PRIx8 "\t(FIS receive running)\n", ahci_port_cmd_fr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cr =\t%" PRIx8 "\t(Command list running)\n", ahci_port_cmd_cr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cps =\t%" PRIx8 "\t(Cold presence state)\n", ahci_port_cmd_cps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pma =\t%" PRIx8 "\t(Port multiplier attached)\n", ahci_port_cmd_pma_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hpcp =\t%" PRIx8 "\t(Hot plug capable port)\n", ahci_port_cmd_hpcp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mpsp =\t%" PRIx8 "\t(Mechanical presence switch)\n", ahci_port_cmd_mpsp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpd =\t%" PRIx8 "\t(Cold presence detection)\n", ahci_port_cmd_cpd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " esp =\t%" PRIx8 "\t(External SATA port)\n", ahci_port_cmd_esp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fbscp =\t%" PRIx8 "\t(FIS-based switching capable port)\n", ahci_port_cmd_fbscp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apste =\t%" PRIx8 "\t(Automatic partial to slumber transitions enabled)\n", ahci_port_cmd_apste_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " atapi =\t%" PRIx8 "\t(Device is ATAPI)\n", ahci_port_cmd_atapi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlae =\t%" PRIx8 "\t(Drive LED on ATAPI enable)\n", ahci_port_cmd_dlae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " alpe =\t%" PRIx8 "\t(Aggressive link power management enable)\n", ahci_port_cmd_alpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " asp =\t%" PRIx8 "\t(Aggressive slumber / partial)\n", ahci_port_cmd_asp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " icc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_icct_prtval(_s + _r, _avail, ahci_port_cmd_icc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interface communication control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ahci_port_tfd_t
 * Description: Implicit type of Task file data register
 * Fields:
 *   sts	(size 8, offset 0, init 0):	RO	Status (task file status)
 *   err	(size 8, offset 8, init 0):	RO	Error
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t ahci_port_tfd_t;
#define ahci_port_tfd_default 0x0
static inline uint8_t ahci_port_tfd_sts_extract(ahci_port_tfd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_tfd_sts_extract(ahci_port_tfd_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline ahci_port_tfd_t ahci_port_tfd_sts_insert(ahci_port_tfd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_tfd_t ahci_port_tfd_sts_insert(ahci_port_tfd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((ahci_port_tfd_t )(_fieldval)) << 0)));
}

static inline uint8_t ahci_port_tfd_err_extract(ahci_port_tfd_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_tfd_err_extract(ahci_port_tfd_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline ahci_port_tfd_t ahci_port_tfd_err_insert(ahci_port_tfd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_tfd_t ahci_port_tfd_err_insert(ahci_port_tfd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((ahci_port_tfd_t )(_fieldval)) << 8)));
}

static inline int ahci_port_tfd_prtval(char *_s, size_t _size, ahci_port_tfd_t _regval) __attribute__ ((always_inline));
static inline int ahci_port_tfd_prtval(char *_s, size_t _size, ahci_port_tfd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sts =\t%" PRIx8 "\t(Status (task file status))\n", ahci_port_tfd_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err =\t%" PRIx8 "\t(Error)\n", ahci_port_tfd_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ahci_port_sig_t
 * Description: Implicit type of Signature register
 * Fields:
 *   sectors	(size 8, offset 0, init 0):	RO	Sector count
 *   lbal	(size 8, offset 8, init 0):	RO	LBA low
 *   lbam	(size 8, offset 16, init 0):	RO	LBA mid
 *   lbah	(size 8, offset 24, init 0):	RO	LBA high
 */
typedef uint32_t ahci_port_sig_t;
#define ahci_port_sig_default 0x0
static inline uint8_t ahci_port_sig_sectors_extract(ahci_port_sig_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_sig_sectors_extract(ahci_port_sig_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline ahci_port_sig_t ahci_port_sig_sectors_insert(ahci_port_sig_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_sig_t ahci_port_sig_sectors_insert(ahci_port_sig_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((ahci_port_sig_t )(_fieldval)) << 0)));
}

static inline uint8_t ahci_port_sig_lbal_extract(ahci_port_sig_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_sig_lbal_extract(ahci_port_sig_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline ahci_port_sig_t ahci_port_sig_lbal_insert(ahci_port_sig_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_sig_t ahci_port_sig_lbal_insert(ahci_port_sig_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((ahci_port_sig_t )(_fieldval)) << 8)));
}

static inline uint8_t ahci_port_sig_lbam_extract(ahci_port_sig_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_sig_lbam_extract(ahci_port_sig_t _regval)
{
    return((uint8_t )((_regval & 0xff0000) >> 16));
}

static inline ahci_port_sig_t ahci_port_sig_lbam_insert(ahci_port_sig_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_sig_t ahci_port_sig_lbam_insert(ahci_port_sig_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((ahci_port_sig_t )(_fieldval)) << 16)));
}

static inline uint8_t ahci_port_sig_lbah_extract(ahci_port_sig_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_sig_lbah_extract(ahci_port_sig_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline ahci_port_sig_t ahci_port_sig_lbah_insert(ahci_port_sig_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_sig_t ahci_port_sig_lbah_insert(ahci_port_sig_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((ahci_port_sig_t )(_fieldval)) << 24)));
}

static inline int ahci_port_sig_prtval(char *_s, size_t _size, ahci_port_sig_t _regval) __attribute__ ((always_inline));
static inline int ahci_port_sig_prtval(char *_s, size_t _size, ahci_port_sig_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sectors =\t%" PRIx8 "\t(Sector count)\n", ahci_port_sig_sectors_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbal =\t%" PRIx8 "\t(LBA low)\n", ahci_port_sig_lbal_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbam =\t%" PRIx8 "\t(LBA mid)\n", ahci_port_sig_lbam_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbah =\t%" PRIx8 "\t(LBA high)\n", ahci_port_sig_lbah_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ahci_port_ssts_t
 * Description: Implicit type of Serial ATA status register
 * Fields:
 *   det	(size 4, offset 0, init 0):	RO	Device detection
 *   spd	(size 4, offset 4, init 0):	RO	Current interface speed
 *   ipm	(size 4, offset 8, init 0):	RO	Interface power management
 *   _anon12	(size 20, offset 12, init 0):	RSVD	_
 */
typedef uint32_t ahci_port_ssts_t;
#define ahci_port_ssts_default 0x0
static inline ahci_port_dets_t ahci_port_ssts_det_extract(ahci_port_ssts_t _regval) __attribute__ ((always_inline));
static inline ahci_port_dets_t ahci_port_ssts_det_extract(ahci_port_ssts_t _regval)
{
    return((ahci_port_dets_t )((_regval & 0xf) >> 0));
}

static inline ahci_port_ssts_t ahci_port_ssts_det_insert(ahci_port_ssts_t _regval, ahci_port_dets_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ssts_t ahci_port_ssts_det_insert(ahci_port_ssts_t _regval, ahci_port_dets_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((ahci_port_ssts_t )(_fieldval)) << 0)));
}

static inline ahci_port_speed_t ahci_port_ssts_spd_extract(ahci_port_ssts_t _regval) __attribute__ ((always_inline));
static inline ahci_port_speed_t ahci_port_ssts_spd_extract(ahci_port_ssts_t _regval)
{
    return((ahci_port_speed_t )((_regval & 0xf0) >> 4));
}

static inline ahci_port_ssts_t ahci_port_ssts_spd_insert(ahci_port_ssts_t _regval, ahci_port_speed_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ssts_t ahci_port_ssts_spd_insert(ahci_port_ssts_t _regval, ahci_port_speed_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((ahci_port_ssts_t )(_fieldval)) << 4)));
}

static inline ahci_port_icct_t ahci_port_ssts_ipm_extract(ahci_port_ssts_t _regval) __attribute__ ((always_inline));
static inline ahci_port_icct_t ahci_port_ssts_ipm_extract(ahci_port_ssts_t _regval)
{
    return((ahci_port_icct_t )((_regval & 0xf00) >> 8));
}

static inline ahci_port_ssts_t ahci_port_ssts_ipm_insert(ahci_port_ssts_t _regval, ahci_port_icct_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_ssts_t ahci_port_ssts_ipm_insert(ahci_port_ssts_t _regval, ahci_port_icct_t _fieldval)
{
    return((_regval & 0xfffff0ff) | (0xf00 & (((ahci_port_ssts_t )(_fieldval)) << 8)));
}

static inline int ahci_port_ssts_prtval(char *_s, size_t _size, ahci_port_ssts_t _regval) __attribute__ ((always_inline));
static inline int ahci_port_ssts_prtval(char *_s, size_t _size, ahci_port_ssts_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " det =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_dets_prtval(_s + _r, _avail, ahci_port_ssts_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Device detection)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spd =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_speed_prtval(_s + _r, _avail, ahci_port_ssts_spd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Current interface speed)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipm =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_icct_prtval(_s + _r, _avail, ahci_port_ssts_ipm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interface power management)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ahci_port_sctl_t
 * Description: Implicit type of Serial ATA control register
 * Fields:
 *   det	(size 4, offset 0, init 0):	RW	Device detection initialization
 *   spd	(size 4, offset 4, init 0):	RW	Speed allowed
 *   ipm	(size 4, offset 8, init 0):	RW	Interface power mgmt transitions allowed
 *   _anon12	(size 4, offset 12, init 0):	RSVD	_
 *   _anon16	(size 4, offset 16, init 0):	RSVD	_
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
typedef uint32_t ahci_port_sctl_t;
#define ahci_port_sctl_default 0x0
static inline ahci_port_dets_t ahci_port_sctl_det_extract(ahci_port_sctl_t _regval) __attribute__ ((always_inline));
static inline ahci_port_dets_t ahci_port_sctl_det_extract(ahci_port_sctl_t _regval)
{
    return((ahci_port_dets_t )((_regval & 0xf) >> 0));
}

static inline ahci_port_sctl_t ahci_port_sctl_det_insert(ahci_port_sctl_t _regval, ahci_port_dets_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_sctl_t ahci_port_sctl_det_insert(ahci_port_sctl_t _regval, ahci_port_dets_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((ahci_port_sctl_t )(_fieldval)) << 0)));
}

static inline ahci_port_speed_t ahci_port_sctl_spd_extract(ahci_port_sctl_t _regval) __attribute__ ((always_inline));
static inline ahci_port_speed_t ahci_port_sctl_spd_extract(ahci_port_sctl_t _regval)
{
    return((ahci_port_speed_t )((_regval & 0xf0) >> 4));
}

static inline ahci_port_sctl_t ahci_port_sctl_spd_insert(ahci_port_sctl_t _regval, ahci_port_speed_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_sctl_t ahci_port_sctl_spd_insert(ahci_port_sctl_t _regval, ahci_port_speed_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((ahci_port_sctl_t )(_fieldval)) << 4)));
}

static inline ahci_port_ipmall_t ahci_port_sctl_ipm_extract(ahci_port_sctl_t _regval) __attribute__ ((always_inline));
static inline ahci_port_ipmall_t ahci_port_sctl_ipm_extract(ahci_port_sctl_t _regval)
{
    return((ahci_port_ipmall_t )((_regval & 0xf00) >> 8));
}

static inline ahci_port_sctl_t ahci_port_sctl_ipm_insert(ahci_port_sctl_t _regval, ahci_port_ipmall_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_sctl_t ahci_port_sctl_ipm_insert(ahci_port_sctl_t _regval, ahci_port_ipmall_t _fieldval)
{
    return((_regval & 0xfffff0ff) | (0xf00 & (((ahci_port_sctl_t )(_fieldval)) << 8)));
}

static inline int ahci_port_sctl_prtval(char *_s, size_t _size, ahci_port_sctl_t _regval) __attribute__ ((always_inline));
static inline int ahci_port_sctl_prtval(char *_s, size_t _size, ahci_port_sctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " det =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_dets_prtval(_s + _r, _avail, ahci_port_sctl_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Device detection initialization)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spd =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_speed_prtval(_s + _r, _avail, ahci_port_sctl_spd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Speed allowed)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipm =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_ipmall_prtval(_s + _r, _avail, ahci_port_sctl_ipm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interface power mgmt transitions allowed)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ahci_port_serr_t
 * Description: Implicit type of Serial ATA error register
 * Fields:
 *   ei	(size 1, offset 0, init 0):	RWC	Recovered data integrity error
 *   em	(size 1, offset 1, init 0):	RWC	Recovered communications error
 *   _anon2	(size 6, offset 2, init 0):	RSVD	_
 *   et	(size 1, offset 8, init 0):	RWC	Transient data integrity error
 *   ec	(size 1, offset 9, init 0):	RWC	Persistent communication or data integrity error
 *   ep	(size 1, offset 10, init 0):	RWC	Protocol error
 *   ee	(size 1, offset 11, init 0):	RWC	Internal error
 *   _anon12	(size 4, offset 12, init 0):	RSVD	_
 *   dn	(size 1, offset 16, init 0):	RWC	PhyRdy change
 *   di	(size 1, offset 17, init 0):	RWC	Phy internal error
 *   dw	(size 1, offset 18, init 0):	RWC	Comm wake
 *   db	(size 1, offset 19, init 0):	RWC	10b to 8b decode error
 *   dd	(size 1, offset 20, init 0):	RWC	Disparity error
 *   dc	(size 1, offset 21, init 0):	RWC	CRC error
 *   dh	(size 1, offset 22, init 0):	RWC	Handshake error
 *   ds	(size 1, offset 23, init 0):	RWC	Link sequence error
 *   dt	(size 1, offset 24, init 0):	RWC	Transport state transition error
 *   df	(size 1, offset 25, init 0):	RWC	Unknown FIS type
 *   dx	(size 1, offset 26, init 0):	RWC	Exchanged
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
typedef uint32_t ahci_port_serr_t;
#define ahci_port_serr_default 0x0
static inline uint8_t ahci_port_serr_ei_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_ei_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ahci_port_serr_t ahci_port_serr_ei_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_ei_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ahci_port_serr_t )(_fieldval)) << 0)));
}

static inline uint8_t ahci_port_serr_em_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_em_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ahci_port_serr_t ahci_port_serr_em_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_em_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ahci_port_serr_t )(_fieldval)) << 1)));
}

static inline uint8_t ahci_port_serr_et_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_et_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ahci_port_serr_t ahci_port_serr_et_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_et_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((ahci_port_serr_t )(_fieldval)) << 8)));
}

static inline uint8_t ahci_port_serr_ec_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_ec_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline ahci_port_serr_t ahci_port_serr_ec_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_ec_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((ahci_port_serr_t )(_fieldval)) << 9)));
}

static inline uint8_t ahci_port_serr_ep_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_ep_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline ahci_port_serr_t ahci_port_serr_ep_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_ep_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((ahci_port_serr_t )(_fieldval)) << 10)));
}

static inline uint8_t ahci_port_serr_ee_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_ee_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline ahci_port_serr_t ahci_port_serr_ee_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_ee_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((ahci_port_serr_t )(_fieldval)) << 11)));
}

static inline uint8_t ahci_port_serr_dn_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_dn_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline ahci_port_serr_t ahci_port_serr_dn_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_dn_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((ahci_port_serr_t )(_fieldval)) << 16)));
}

static inline uint8_t ahci_port_serr_di_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_di_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline ahci_port_serr_t ahci_port_serr_di_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_di_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((ahci_port_serr_t )(_fieldval)) << 17)));
}

static inline uint8_t ahci_port_serr_dw_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_dw_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline ahci_port_serr_t ahci_port_serr_dw_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_dw_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((ahci_port_serr_t )(_fieldval)) << 18)));
}

static inline uint8_t ahci_port_serr_db_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_db_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline ahci_port_serr_t ahci_port_serr_db_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_db_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((ahci_port_serr_t )(_fieldval)) << 19)));
}

static inline uint8_t ahci_port_serr_dd_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_dd_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline ahci_port_serr_t ahci_port_serr_dd_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_dd_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((ahci_port_serr_t )(_fieldval)) << 20)));
}

static inline uint8_t ahci_port_serr_dc_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_dc_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline ahci_port_serr_t ahci_port_serr_dc_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_dc_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((ahci_port_serr_t )(_fieldval)) << 21)));
}

static inline uint8_t ahci_port_serr_dh_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_dh_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline ahci_port_serr_t ahci_port_serr_dh_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_dh_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((ahci_port_serr_t )(_fieldval)) << 22)));
}

static inline uint8_t ahci_port_serr_ds_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_ds_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline ahci_port_serr_t ahci_port_serr_ds_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_ds_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((ahci_port_serr_t )(_fieldval)) << 23)));
}

static inline uint8_t ahci_port_serr_dt_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_dt_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline ahci_port_serr_t ahci_port_serr_dt_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_dt_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((ahci_port_serr_t )(_fieldval)) << 24)));
}

static inline uint8_t ahci_port_serr_df_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_df_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline ahci_port_serr_t ahci_port_serr_df_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_df_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((ahci_port_serr_t )(_fieldval)) << 25)));
}

static inline uint8_t ahci_port_serr_dx_extract(ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_dx_extract(ahci_port_serr_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline ahci_port_serr_t ahci_port_serr_dx_insert(ahci_port_serr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_dx_insert(ahci_port_serr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((ahci_port_serr_t )(_fieldval)) << 26)));
}

static inline int ahci_port_serr_prtval(char *_s, size_t _size, ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline int ahci_port_serr_prtval(char *_s, size_t _size, ahci_port_serr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ei =\t%" PRIx8 "\t(Recovered data integrity error)\n", ahci_port_serr_ei_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " em =\t%" PRIx8 "\t(Recovered communications error)\n", ahci_port_serr_em_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " et =\t%" PRIx8 "\t(Transient data integrity error)\n", ahci_port_serr_et_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ec =\t%" PRIx8 "\t(Persistent communication or data integrity error)\n", ahci_port_serr_ec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ep =\t%" PRIx8 "\t(Protocol error)\n", ahci_port_serr_ep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee =\t%" PRIx8 "\t(Internal error)\n", ahci_port_serr_ee_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dn =\t%" PRIx8 "\t(PhyRdy change)\n", ahci_port_serr_dn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " di =\t%" PRIx8 "\t(Phy internal error)\n", ahci_port_serr_di_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dw =\t%" PRIx8 "\t(Comm wake)\n", ahci_port_serr_dw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " db =\t%" PRIx8 "\t(10b to 8b decode error)\n", ahci_port_serr_db_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dd =\t%" PRIx8 "\t(Disparity error)\n", ahci_port_serr_dd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dc =\t%" PRIx8 "\t(CRC error)\n", ahci_port_serr_dc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dh =\t%" PRIx8 "\t(Handshake error)\n", ahci_port_serr_dh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ds =\t%" PRIx8 "\t(Link sequence error)\n", ahci_port_serr_ds_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dt =\t%" PRIx8 "\t(Transport state transition error)\n", ahci_port_serr_dt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " df =\t%" PRIx8 "\t(Unknown FIS type)\n", ahci_port_serr_df_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dx =\t%" PRIx8 "\t(Exchanged)\n", ahci_port_serr_dx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ahci_port_sntf_t
 * Description: Implicit type of Serial ATA notification register
 * Fields:
 *   pmn	(size 16, offset 0, init 0):	RWC	PMN notify
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint32_t ahci_port_sntf_t;
#define ahci_port_sntf_default 0x0
static inline uint16_t ahci_port_sntf_pmn_extract(ahci_port_sntf_t _regval) __attribute__ ((always_inline));
static inline uint16_t ahci_port_sntf_pmn_extract(ahci_port_sntf_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline ahci_port_sntf_t ahci_port_sntf_pmn_insert(ahci_port_sntf_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_sntf_t ahci_port_sntf_pmn_insert(ahci_port_sntf_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((ahci_port_sntf_t )(_fieldval)) << 0)));
}

static inline int ahci_port_sntf_prtval(char *_s, size_t _size, ahci_port_sntf_t _regval) __attribute__ ((always_inline));
static inline int ahci_port_sntf_prtval(char *_s, size_t _size, ahci_port_sntf_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmn =\t%" PRIx16 "\t(PMN notify)\n", ahci_port_sntf_pmn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ahci_port_fbs_t
 * Description: Implicit type of FIS-based switching control register
 * Fields:
 *   en	(size 1, offset 0, init 0):	RW	Enable
 *   dec	(size 1, offset 1, init 0):	RWC	Device error clear
 *   sde	(size 1, offset 2, init 0):	RO	Single device error
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   dev	(size 4, offset 8, init 0):	RW	Device to issue
 *   ado	(size 4, offset 12, init 0):	RO	Active device optimization
 *   dwe	(size 4, offset 16, init 0):	RO	Device with error
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t ahci_port_fbs_t;
#define ahci_port_fbs_default 0x0
static inline uint8_t ahci_port_fbs_en_extract(ahci_port_fbs_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_fbs_en_extract(ahci_port_fbs_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ahci_port_fbs_t ahci_port_fbs_en_insert(ahci_port_fbs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_fbs_t ahci_port_fbs_en_insert(ahci_port_fbs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ahci_port_fbs_t )(_fieldval)) << 0)));
}

static inline uint8_t ahci_port_fbs_dec_extract(ahci_port_fbs_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_fbs_dec_extract(ahci_port_fbs_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ahci_port_fbs_t ahci_port_fbs_dec_insert(ahci_port_fbs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_fbs_t ahci_port_fbs_dec_insert(ahci_port_fbs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ahci_port_fbs_t )(_fieldval)) << 1)));
}

static inline uint8_t ahci_port_fbs_sde_extract(ahci_port_fbs_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_fbs_sde_extract(ahci_port_fbs_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ahci_port_fbs_t ahci_port_fbs_sde_insert(ahci_port_fbs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_fbs_t ahci_port_fbs_sde_insert(ahci_port_fbs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ahci_port_fbs_t )(_fieldval)) << 2)));
}

static inline uint8_t ahci_port_fbs_dev_extract(ahci_port_fbs_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_fbs_dev_extract(ahci_port_fbs_t _regval)
{
    return((uint8_t )((_regval & 0xf00) >> 8));
}

static inline ahci_port_fbs_t ahci_port_fbs_dev_insert(ahci_port_fbs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_fbs_t ahci_port_fbs_dev_insert(ahci_port_fbs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff0ff) | (0xf00 & (((ahci_port_fbs_t )(_fieldval)) << 8)));
}

static inline uint8_t ahci_port_fbs_ado_extract(ahci_port_fbs_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_fbs_ado_extract(ahci_port_fbs_t _regval)
{
    return((uint8_t )((_regval & 0xf000) >> 12));
}

static inline ahci_port_fbs_t ahci_port_fbs_ado_insert(ahci_port_fbs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_fbs_t ahci_port_fbs_ado_insert(ahci_port_fbs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff0fff) | (0xf000 & (((ahci_port_fbs_t )(_fieldval)) << 12)));
}

static inline uint8_t ahci_port_fbs_dwe_extract(ahci_port_fbs_t _regval) __attribute__ ((always_inline));
static inline uint8_t ahci_port_fbs_dwe_extract(ahci_port_fbs_t _regval)
{
    return((uint8_t )((_regval & 0xf0000) >> 16));
}

static inline ahci_port_fbs_t ahci_port_fbs_dwe_insert(ahci_port_fbs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ahci_port_fbs_t ahci_port_fbs_dwe_insert(ahci_port_fbs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((ahci_port_fbs_t )(_fieldval)) << 16)));
}

static inline int ahci_port_fbs_prtval(char *_s, size_t _size, ahci_port_fbs_t _regval) __attribute__ ((always_inline));
static inline int ahci_port_fbs_prtval(char *_s, size_t _size, ahci_port_fbs_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en =\t%" PRIx8 "\t(Enable)\n", ahci_port_fbs_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dec =\t%" PRIx8 "\t(Device error clear)\n", ahci_port_fbs_dec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sde =\t%" PRIx8 "\t(Single device error)\n", ahci_port_fbs_sde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dev =\t%" PRIx8 "\t(Device to issue)\n", ahci_port_fbs_dev_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ado =\t%" PRIx8 "\t(Active device optimization)\n", ahci_port_fbs_ado_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dwe =\t%" PRIx8 "\t(Device with error)\n", ahci_port_fbs_dwe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ahci_port_chdr_t
 * Description: Command Header
 * Fields:
 *   cfl	(size 5, offset 0, init 0):	RW	Command FIS length
 *   a	(size 1, offset 5, init 0):	RW	ATAPI
 *   w	(size 1, offset 6, init 0):	RW	Write
 *   p	(size 1, offset 7, init 0):	RW	Prefetchable
 *   r	(size 1, offset 8, init 0):	RW	Reset
 *   b	(size 1, offset 9, init 0):	RW	BIST
 *   c	(size 1, offset 10, init 0):	RW	Clear busy upon R_OK
 *   _anon11	(size 1, offset 11, init 0):	RSVD	_
 *   pmp	(size 4, offset 12, init 0):	RW	Port multiplier port
 *   prdtl	(size 16, offset 16, init 0):	RW	Physical region descriptor table length
 *   prdbc	(size 32, offset 32, init 0):	RW	Physical region descriptor byte count
 *   ctba	(size 32, offset 64, init 0):	RW	Command table descriptor base address
 *   ctbau	(size 32, offset 96, init 0):	RW	Command table descriptor base address upper
 *   _anon128	(size 32, offset 128, init 0):	RSVD	_
 *   _anon160	(size 32, offset 160, init 0):	RSVD	_
 *   _anon192	(size 32, offset 192, init 0):	RSVD	_
 *   _anon224	(size 32, offset 224, init 0):	RSVD	_
 */
typedef uint8_t *ahci_port_chdr_t;
typedef uint8_t ahci_port_chdr_array_t[32];
static const size_t ahci_port_chdr_size = sizeof(ahci_port_chdr_array_t );
static inline uint8_t ahci_port_chdr_cfl_extract(ahci_port_chdr_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ahci_port_chdr_cfl_extract(ahci_port_chdr_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x1f) >> 0);
}

static inline void ahci_port_chdr_cfl_insert(ahci_port_chdr_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_chdr_cfl_insert(ahci_port_chdr_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xe0) | (0x1f & (_fieldval << 0)));
}

static inline uint8_t ahci_port_chdr_a_extract(ahci_port_chdr_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ahci_port_chdr_a_extract(ahci_port_chdr_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x20) >> 5);
}

static inline void ahci_port_chdr_a_insert(ahci_port_chdr_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_chdr_a_insert(ahci_port_chdr_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xdf) | (0x20 & (_fieldval << 5)));
}

static inline uint8_t ahci_port_chdr_w_extract(ahci_port_chdr_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ahci_port_chdr_w_extract(ahci_port_chdr_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x40) >> 6);
}

static inline void ahci_port_chdr_w_insert(ahci_port_chdr_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_chdr_w_insert(ahci_port_chdr_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t ahci_port_chdr_p_extract(ahci_port_chdr_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ahci_port_chdr_p_extract(ahci_port_chdr_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x80) >> 7);
}

static inline void ahci_port_chdr_p_insert(ahci_port_chdr_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_chdr_p_insert(ahci_port_chdr_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint8_t ahci_port_chdr_r_extract(ahci_port_chdr_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ahci_port_chdr_r_extract(ahci_port_chdr_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x1) >> 0);
}

static inline void ahci_port_chdr_r_insert(ahci_port_chdr_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_chdr_r_insert(ahci_port_chdr_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t ahci_port_chdr_b_extract(ahci_port_chdr_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ahci_port_chdr_b_extract(ahci_port_chdr_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x2) >> 1);
}

static inline void ahci_port_chdr_b_insert(ahci_port_chdr_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_chdr_b_insert(ahci_port_chdr_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t ahci_port_chdr_c_extract(ahci_port_chdr_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ahci_port_chdr_c_extract(ahci_port_chdr_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x4) >> 2);
}

static inline void ahci_port_chdr_c_insert(ahci_port_chdr_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_chdr_c_insert(ahci_port_chdr_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t ahci_port_chdr_pmp_extract(ahci_port_chdr_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ahci_port_chdr_pmp_extract(ahci_port_chdr_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0xf0) >> 4);
}

static inline void ahci_port_chdr_pmp_insert(ahci_port_chdr_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_chdr_pmp_insert(ahci_port_chdr_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xf) | (0xf0 & (_fieldval << 4)));
}

static inline uint16_t ahci_port_chdr_prdtl_extract(ahci_port_chdr_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t ahci_port_chdr_prdtl_extract(ahci_port_chdr_t _dtptr)
{
    return(((*((uint16_t *)(2 + _dtptr))) & 0xffff) >> 0);
}

static inline void ahci_port_chdr_prdtl_insert(ahci_port_chdr_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_chdr_prdtl_insert(ahci_port_chdr_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(2 + _dtptr)) = (((*((uint16_t *)(2 + _dtptr))) & 0x0) | (0xffff & (_fieldval << 0)));
}

static inline uint32_t ahci_port_chdr_prdbc_extract(ahci_port_chdr_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ahci_port_chdr_prdbc_extract(ahci_port_chdr_t _dtptr)
{
    return(((*((uint32_t *)(4 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ahci_port_chdr_prdbc_insert(ahci_port_chdr_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_chdr_prdbc_insert(ahci_port_chdr_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(4 + _dtptr)) = (((*((uint32_t *)(4 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline uint32_t ahci_port_chdr_ctba_extract(ahci_port_chdr_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ahci_port_chdr_ctba_extract(ahci_port_chdr_t _dtptr)
{
    return(((*((uint32_t *)(8 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ahci_port_chdr_ctba_insert(ahci_port_chdr_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_chdr_ctba_insert(ahci_port_chdr_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(8 + _dtptr)) = (((*((uint32_t *)(8 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline uint32_t ahci_port_chdr_ctbau_extract(ahci_port_chdr_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ahci_port_chdr_ctbau_extract(ahci_port_chdr_t _dtptr)
{
    return(((*((uint32_t *)(12 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ahci_port_chdr_ctbau_insert(ahci_port_chdr_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_chdr_ctbau_insert(ahci_port_chdr_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(12 + _dtptr)) = (((*((uint32_t *)(12 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline int ahci_port_chdr_prtval(char *_s, size_t _size, ahci_port_chdr_t _regval) __attribute__ ((always_inline));
static inline int ahci_port_chdr_prtval(char *_s, size_t _size, ahci_port_chdr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfl =\t%" PRIx8 "\t(Command FIS length)\n", ahci_port_chdr_cfl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " a =\t%" PRIx8 "\t(ATAPI)\n", ahci_port_chdr_a_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " w =\t%" PRIx8 "\t(Write)\n", ahci_port_chdr_w_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " p =\t%" PRIx8 "\t(Prefetchable)\n", ahci_port_chdr_p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx8 "\t(Reset)\n", ahci_port_chdr_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " b =\t%" PRIx8 "\t(BIST)\n", ahci_port_chdr_b_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " c =\t%" PRIx8 "\t(Clear busy upon R_OK)\n", ahci_port_chdr_c_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmp =\t%" PRIx8 "\t(Port multiplier port)\n", ahci_port_chdr_pmp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prdtl =\t%" PRIx16 "\t(Physical region descriptor table length)\n", ahci_port_chdr_prdtl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prdbc =\t%" PRIx32 "\t(Physical region descriptor byte count)\n", ahci_port_chdr_prdbc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ctba =\t%" PRIx32 "\t(Command table descriptor base address)\n", ahci_port_chdr_ctba_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ctbau =\t%" PRIx32 "\t(Command table descriptor base address upper)\n", ahci_port_chdr_ctbau_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ahci_port_prd_t
 * Description: Physical region descriptor
 * Fields:
 *   dba	(size 32, offset 0, init 0):	RW	Data base address
 *   dbau	(size 32, offset 32, init 0):	RW	Data base address upper
 *   _anon64	(size 32, offset 64, init 0):	RSVD	_
 *   dbc	(size 22, offset 96, init 0):	RW	Data byte count
 *   _anon118	(size 9, offset 118, init 0):	RSVD	_
 *   i	(size 1, offset 127, init 0):	RW	Interrupt on completion
 */
typedef uint8_t *ahci_port_prd_t;
typedef uint8_t ahci_port_prd_array_t[16];
static const size_t ahci_port_prd_size = sizeof(ahci_port_prd_array_t );
static inline uint32_t ahci_port_prd_dba_extract(ahci_port_prd_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ahci_port_prd_dba_extract(ahci_port_prd_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ahci_port_prd_dba_insert(ahci_port_prd_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_prd_dba_insert(ahci_port_prd_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline uint32_t ahci_port_prd_dbau_extract(ahci_port_prd_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ahci_port_prd_dbau_extract(ahci_port_prd_t _dtptr)
{
    return(((*((uint32_t *)(4 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void ahci_port_prd_dbau_insert(ahci_port_prd_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_prd_dbau_insert(ahci_port_prd_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(4 + _dtptr)) = (((*((uint32_t *)(4 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline uint32_t ahci_port_prd_dbc_extract(ahci_port_prd_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t ahci_port_prd_dbc_extract(ahci_port_prd_t _dtptr)
{
    return(((*((uint32_t *)(12 + _dtptr))) & 0x3fffff) >> 0);
}

static inline void ahci_port_prd_dbc_insert(ahci_port_prd_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_prd_dbc_insert(ahci_port_prd_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(12 + _dtptr)) = (((*((uint32_t *)(12 + _dtptr))) & 0xffc00000) | (0x3fffff & (_fieldval << 0)));
}

static inline uint8_t ahci_port_prd_i_extract(ahci_port_prd_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ahci_port_prd_i_extract(ahci_port_prd_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0x80) >> 7);
}

static inline void ahci_port_prd_i_insert(ahci_port_prd_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_prd_i_insert(ahci_port_prd_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline int ahci_port_prd_prtval(char *_s, size_t _size, ahci_port_prd_t _regval) __attribute__ ((always_inline));
static inline int ahci_port_prd_prtval(char *_s, size_t _size, ahci_port_prd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dba =\t%" PRIx32 "\t(Data base address)\n", ahci_port_prd_dba_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dbau =\t%" PRIx32 "\t(Data base address upper)\n", ahci_port_prd_dbau_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dbc =\t%" PRIx32 "\t(Data byte count)\n", ahci_port_prd_dbc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i =\t%" PRIx8 "\t(Interrupt on completion)\n", ahci_port_prd_i_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ahci_port_encmsg_t
 * Description: Enclosure management message
 * Fields:
 *   _anon0	(size 8, offset 0, init 0):	RSVD	_
 *   msize	(size 8, offset 8, init 0):	RW	Message size
 *   dsize	(size 8, offset 16, init 0):	RW	Data size
 *   mtype	(size 4, offset 24, init 0):	RW	Message type
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
typedef uint8_t *ahci_port_encmsg_t;
typedef uint8_t ahci_port_encmsg_array_t[4];
static const size_t ahci_port_encmsg_size = sizeof(ahci_port_encmsg_array_t );
static inline uint8_t ahci_port_encmsg_msize_extract(ahci_port_encmsg_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ahci_port_encmsg_msize_extract(ahci_port_encmsg_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0xff) >> 0);
}

static inline void ahci_port_encmsg_msize_insert(ahci_port_encmsg_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_encmsg_msize_insert(ahci_port_encmsg_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0x0) | (0xff & (_fieldval << 0)));
}

static inline uint8_t ahci_port_encmsg_dsize_extract(ahci_port_encmsg_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ahci_port_encmsg_dsize_extract(ahci_port_encmsg_t _dtptr)
{
    return(((*((uint8_t *)(2 + _dtptr))) & 0xff) >> 0);
}

static inline void ahci_port_encmsg_dsize_insert(ahci_port_encmsg_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_encmsg_dsize_insert(ahci_port_encmsg_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(2 + _dtptr)) = (((*((uint8_t *)(2 + _dtptr))) & 0x0) | (0xff & (_fieldval << 0)));
}

static inline ahci_port_emtype_t ahci_port_encmsg_mtype_extract(ahci_port_encmsg_t _dtptr) __attribute__ ((always_inline));
static inline ahci_port_emtype_t ahci_port_encmsg_mtype_extract(ahci_port_encmsg_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0xf) >> 0);
}

static inline void ahci_port_encmsg_mtype_insert(ahci_port_encmsg_t _dtptr, ahci_port_emtype_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_encmsg_mtype_insert(ahci_port_encmsg_t _dtptr, ahci_port_emtype_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0xf0) | (0xf & (_fieldval << 0)));
}

static inline int ahci_port_encmsg_prtval(char *_s, size_t _size, ahci_port_encmsg_t _regval) __attribute__ ((always_inline));
static inline int ahci_port_encmsg_prtval(char *_s, size_t _size, ahci_port_encmsg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msize =\t%" PRIx8 "\t(Message size)\n", ahci_port_encmsg_msize_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dsize =\t%" PRIx8 "\t(Data size)\n", ahci_port_encmsg_dsize_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mtype =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_emtype_prtval(_s + _r, _avail, ahci_port_encmsg_mtype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Message type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: ahci_port_emledmsg_t
 * Description: Enclosure LED message
 * Fields:
 *   hbapn	(size 5, offset 0, init 0):	RW	HBA port number for update
 *   vsm	(size 1, offset 5, init 0):	RW	Vendor-specific enclosure message
 *   _anon6	(size 2, offset 6, init 0):	RSVD	_
 *   pmi	(size 4, offset 8, init 0):	RW	Port multiplier information
 *   _anon12	(size 4, offset 12, init 0):	RSVD	_
 *   activity	(size 3, offset 16, init 0):	RW	Activity LED
 *   locate	(size 3, offset 19, init 0):	RW	Vendor-specific LED (e.g. locate)
 *   fault	(size 3, offset 22, init 0):	RW	Vendor-specific LED (e.g. fault)
 *   _anon25	(size 7, offset 25, init 0):	RSVD	_
 */
typedef uint8_t *ahci_port_emledmsg_t;
typedef uint8_t ahci_port_emledmsg_array_t[4];
static const size_t ahci_port_emledmsg_size = sizeof(ahci_port_emledmsg_array_t );
static inline uint8_t ahci_port_emledmsg_hbapn_extract(ahci_port_emledmsg_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ahci_port_emledmsg_hbapn_extract(ahci_port_emledmsg_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x1f) >> 0);
}

static inline void ahci_port_emledmsg_hbapn_insert(ahci_port_emledmsg_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_emledmsg_hbapn_insert(ahci_port_emledmsg_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xe0) | (0x1f & (_fieldval << 0)));
}

static inline uint8_t ahci_port_emledmsg_vsm_extract(ahci_port_emledmsg_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ahci_port_emledmsg_vsm_extract(ahci_port_emledmsg_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x20) >> 5);
}

static inline void ahci_port_emledmsg_vsm_insert(ahci_port_emledmsg_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_emledmsg_vsm_insert(ahci_port_emledmsg_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xdf) | (0x20 & (_fieldval << 5)));
}

static inline uint8_t ahci_port_emledmsg_pmi_extract(ahci_port_emledmsg_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t ahci_port_emledmsg_pmi_extract(ahci_port_emledmsg_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0xf) >> 0);
}

static inline void ahci_port_emledmsg_pmi_insert(ahci_port_emledmsg_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_emledmsg_pmi_insert(ahci_port_emledmsg_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xf0) | (0xf & (_fieldval << 0)));
}

static inline ahci_port_emledstate_t ahci_port_emledmsg_activity_extract(ahci_port_emledmsg_t _dtptr) __attribute__ ((always_inline));
static inline ahci_port_emledstate_t ahci_port_emledmsg_activity_extract(ahci_port_emledmsg_t _dtptr)
{
    return(((*((uint8_t *)(2 + _dtptr))) & 0x7) >> 0);
}

static inline void ahci_port_emledmsg_activity_insert(ahci_port_emledmsg_t _dtptr, ahci_port_emledstate_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_emledmsg_activity_insert(ahci_port_emledmsg_t _dtptr, ahci_port_emledstate_t _fieldval)
{
    *((uint8_t *)(2 + _dtptr)) = (((*((uint8_t *)(2 + _dtptr))) & 0xf8) | (0x7 & (_fieldval << 0)));
}

static inline ahci_port_emledstate_t ahci_port_emledmsg_locate_extract(ahci_port_emledmsg_t _dtptr) __attribute__ ((always_inline));
static inline ahci_port_emledstate_t ahci_port_emledmsg_locate_extract(ahci_port_emledmsg_t _dtptr)
{
    return(((*((uint8_t *)(2 + _dtptr))) & 0x38) >> 3);
}

static inline void ahci_port_emledmsg_locate_insert(ahci_port_emledmsg_t _dtptr, ahci_port_emledstate_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_emledmsg_locate_insert(ahci_port_emledmsg_t _dtptr, ahci_port_emledstate_t _fieldval)
{
    *((uint8_t *)(2 + _dtptr)) = (((*((uint8_t *)(2 + _dtptr))) & 0xc7) | (0x38 & (_fieldval << 3)));
}

static inline ahci_port_emledstate_t ahci_port_emledmsg_fault_extract(ahci_port_emledmsg_t _dtptr) __attribute__ ((always_inline));
static inline ahci_port_emledstate_t ahci_port_emledmsg_fault_extract(ahci_port_emledmsg_t _dtptr)
{
    return(((*((uint16_t *)(2 + _dtptr))) & 0x1c0) >> 6);
}

static inline void ahci_port_emledmsg_fault_insert(ahci_port_emledmsg_t _dtptr, ahci_port_emledstate_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_emledmsg_fault_insert(ahci_port_emledmsg_t _dtptr, ahci_port_emledstate_t _fieldval)
{
    *((uint16_t *)(2 + _dtptr)) = (((*((uint16_t *)(2 + _dtptr))) & 0xfe3f) | (0x1c0 & (_fieldval << 6)));
}

static inline int ahci_port_emledmsg_prtval(char *_s, size_t _size, ahci_port_emledmsg_t _regval) __attribute__ ((always_inline));
static inline int ahci_port_emledmsg_prtval(char *_s, size_t _size, ahci_port_emledmsg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hbapn =\t%" PRIx8 "\t(HBA port number for update)\n", ahci_port_emledmsg_hbapn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vsm =\t%" PRIx8 "\t(Vendor-specific enclosure message)\n", ahci_port_emledmsg_vsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmi =\t%" PRIx8 "\t(Port multiplier information)\n", ahci_port_emledmsg_pmi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " activity =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_emledstate_prtval(_s + _r, _avail, ahci_port_emledmsg_activity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Activity LED)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " locate =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_emledstate_prtval(_s + _r, _avail, ahci_port_emledmsg_locate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Vendor-specific LED (e.g. locate))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fault =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_emledstate_prtval(_s + _r, _avail, ahci_port_emledmsg_fault_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Vendor-specific LED (e.g. fault))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t b;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum ahci_port_initials {
    ahci_port_clb_initial = 0x0,
    ahci_port_fb_initial = 0x0,
    ahci_port_is_initial = 0x0,
    ahci_port_ie_initial = 0x0,
    ahci_port_cmd_initial = 0x0,
    ahci_port_tfd_initial = 0x0,
    ahci_port_sig_initial = 0x0,
    ahci_port_ssts_initial = 0x0,
    ahci_port_sctl_initial = 0x0,
    ahci_port_serr_initial = 0x0,
    ahci_port_sact_initial = 0x0,
    ahci_port_ci_initial = 0x0,
    ahci_port_sntf_initial = 0x0,
    ahci_port_fbs_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void ahci_port_initialize(__DN(t) *_dev, mackerel_addr_t b) __attribute__ ((always_inline));
static inline void ahci_port_initialize(__DN(t) *_dev, mackerel_addr_t b)
{
    _dev->b = b;
}

/*
 * Register clb: Command list base address
 * Type: ahci_port.uint64 (primitive type)
 */
static inline uint64_t ahci_port_clb_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint64_t ahci_port_clb_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->b, 0x0));
}

static inline uint64_t ahci_port_clb_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint64_t ahci_port_clb_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->b, 0x0));
}

static inline void ahci_port_clb_rawwr(__DN(t) *_dev, uint64_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_clb_rawwr(__DN(t) *_dev, uint64_t _regval)
{
    mackerel_write_addr_64(_dev->b, 0x0, _regval);
}

static inline void ahci_port_clb_wr(__DN(t) *_dev, uint64_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_clb_wr(__DN(t) *_dev, uint64_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_64(_dev->b, 0x0, _regval);
}

static inline int ahci_port_clb_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_port_clb_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint64_t _regval = mackerel_read_addr_64(_dev->b, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register clb (Command list base address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx64 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register fb: FIS base address
 * Type: ahci_port.uint64 (primitive type)
 */
static inline uint64_t ahci_port_fb_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint64_t ahci_port_fb_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->b, 0x8));
}

static inline uint64_t ahci_port_fb_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint64_t ahci_port_fb_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->b, 0x8));
}

static inline void ahci_port_fb_rawwr(__DN(t) *_dev, uint64_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_fb_rawwr(__DN(t) *_dev, uint64_t _regval)
{
    mackerel_write_addr_64(_dev->b, 0x8, _regval);
}

static inline void ahci_port_fb_wr(__DN(t) *_dev, uint64_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_fb_wr(__DN(t) *_dev, uint64_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_64(_dev->b, 0x8, _regval);
}

static inline int ahci_port_fb_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_port_fb_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint64_t _regval = mackerel_read_addr_64(_dev->b, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fb (FIS base address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx64 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register is: Interrupt status
 * Type: ahci_port.is (Implicit type of Interrupt status register)
 *   dhrs	(size 1, offset 0, init 0):	RWC	Device to host register FIS interrupt
 *   pss	(size 1, offset 1, init 0):	RWC	PIO setup FIS interrupt
 *   dss	(size 1, offset 2, init 0):	RWC	DMA setup FIS interrupt
 *   sdbs	(size 1, offset 3, init 0):	RWC	Set device bits interrupt
 *   ufs	(size 1, offset 4, init 0):	RO	Unknown FIS interrupt
 *   dps	(size 1, offset 5, init 0):	RWC	Descriptor processed
 *   pcs	(size 1, offset 6, init 0):	RO	Port connect change
 *   dmps	(size 1, offset 7, init 0):	RWC	Device mechanical presence
 *   _anon8	(size 14, offset 8, init 0):	RSVD	_
 *   prcs	(size 1, offset 22, init 0):	RO	PhyRdy change status
 *   ipms	(size 1, offset 23, init 0):	RWC	Incorrect port multiplier status
 *   ofs	(size 1, offset 24, init 0):	RWC	Overflow status
 *   _anon25	(size 1, offset 25, init 0):	RSVD	_
 *   infs	(size 1, offset 26, init 0):	RWC	Interface non-fatal error
 *   ifs	(size 1, offset 27, init 0):	RWC	Interface fatal error
 *   hbds	(size 1, offset 28, init 0):	RWC	Host bus data error
 *   hbfs	(size 1, offset 29, init 0):	RWC	Host bus fatal error
 *   tfes	(size 1, offset 30, init 0):	RWC	Task file error
 *   cpds	(size 1, offset 31, init 0):	RWC	Cold port detect
 */
static inline ahci_port_is_t ahci_port_is_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x10));
}

static inline ahci_port_is_t ahci_port_is_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_is_t ahci_port_is_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x10));
}

static inline void ahci_port_is_rawwr(__DN(t) *_dev, ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_is_rawwr(__DN(t) *_dev, ahci_port_is_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
}

static inline void ahci_port_is_wr(__DN(t) *_dev, ahci_port_is_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_is_wr(__DN(t) *_dev, ahci_port_is_t _regval)
{
    _regval = (_regval & 0xfdc000ff);
    // No MB1 fields present
    _regval = (_regval | (0x23fff00 & mackerel_read_addr_32(_dev->b, 0x10)));
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
}

static inline int ahci_port_is_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_port_is_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register is (Interrupt status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dhrs =\t%" PRIx8 "\t(Device to host register FIS interrupt)\n", ahci_port_is_dhrs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pss =\t%" PRIx8 "\t(PIO setup FIS interrupt)\n", ahci_port_is_pss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dss =\t%" PRIx8 "\t(DMA setup FIS interrupt)\n", ahci_port_is_dss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdbs =\t%" PRIx8 "\t(Set device bits interrupt)\n", ahci_port_is_sdbs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ufs =\t%" PRIx8 "\t(Unknown FIS interrupt)\n", ahci_port_is_ufs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dps =\t%" PRIx8 "\t(Descriptor processed)\n", ahci_port_is_dps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcs =\t%" PRIx8 "\t(Port connect change)\n", ahci_port_is_pcs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmps =\t%" PRIx8 "\t(Device mechanical presence)\n", ahci_port_is_dmps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prcs =\t%" PRIx8 "\t(PhyRdy change status)\n", ahci_port_is_prcs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipms =\t%" PRIx8 "\t(Incorrect port multiplier status)\n", ahci_port_is_ipms_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ofs =\t%" PRIx8 "\t(Overflow status)\n", ahci_port_is_ofs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " infs =\t%" PRIx8 "\t(Interface non-fatal error)\n", ahci_port_is_infs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ifs =\t%" PRIx8 "\t(Interface fatal error)\n", ahci_port_is_ifs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hbds =\t%" PRIx8 "\t(Host bus data error)\n", ahci_port_is_hbds_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hbfs =\t%" PRIx8 "\t(Host bus fatal error)\n", ahci_port_is_hbfs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tfes =\t%" PRIx8 "\t(Task file error)\n", ahci_port_is_tfes_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpds =\t%" PRIx8 "\t(Cold port detect)\n", ahci_port_is_cpds_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t ahci_port_is_dhrs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_dhrs_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_dhrs_extract(_regval));
}

static inline uint8_t ahci_port_is_pss_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_pss_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_pss_extract(_regval));
}

static inline uint8_t ahci_port_is_dss_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_dss_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_dss_extract(_regval));
}

static inline uint8_t ahci_port_is_sdbs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_sdbs_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_sdbs_extract(_regval));
}

static inline uint8_t ahci_port_is_ufs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_ufs_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_ufs_extract(_regval));
}

static inline uint8_t ahci_port_is_dps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_dps_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_dps_extract(_regval));
}

static inline uint8_t ahci_port_is_pcs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_pcs_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_pcs_extract(_regval));
}

static inline uint8_t ahci_port_is_dmps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_dmps_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_dmps_extract(_regval));
}

static inline uint8_t ahci_port_is_prcs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_prcs_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_prcs_extract(_regval));
}

static inline uint8_t ahci_port_is_ipms_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_ipms_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_ipms_extract(_regval));
}

static inline uint8_t ahci_port_is_ofs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_ofs_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_ofs_extract(_regval));
}

static inline uint8_t ahci_port_is_infs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_infs_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_infs_extract(_regval));
}

static inline uint8_t ahci_port_is_ifs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_ifs_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_ifs_extract(_regval));
}

static inline uint8_t ahci_port_is_hbds_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_hbds_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_hbds_extract(_regval));
}

static inline uint8_t ahci_port_is_hbfs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_hbfs_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_hbfs_extract(_regval));
}

static inline uint8_t ahci_port_is_tfes_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_tfes_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_tfes_extract(_regval));
}

static inline uint8_t ahci_port_is_cpds_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_is_cpds_rdf(__DN(t) *_dev)
{
    ahci_port_is_t _regval = mackerel_read_addr_32(_dev->b, 0x10);
    return(ahci_port_is_cpds_extract(_regval));
}

static inline void ahci_port_is_dhrs_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_is_dhrs_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_is_t _regval = 0x1 & (((ahci_port_is_t )(_fieldval)) << 0);
    _regval = (_regval | (0x23fff00 & mackerel_read_addr_32(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

static inline void ahci_port_is_pss_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_is_pss_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_is_t _regval = 0x2 & (((ahci_port_is_t )(_fieldval)) << 1);
    _regval = (_regval | (0x23fff00 & mackerel_read_addr_32(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

static inline void ahci_port_is_dss_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_is_dss_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_is_t _regval = 0x4 & (((ahci_port_is_t )(_fieldval)) << 2);
    _regval = (_regval | (0x23fff00 & mackerel_read_addr_32(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

static inline void ahci_port_is_sdbs_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_is_sdbs_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_is_t _regval = 0x8 & (((ahci_port_is_t )(_fieldval)) << 3);
    _regval = (_regval | (0x23fff00 & mackerel_read_addr_32(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

static inline void ahci_port_is_dps_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_is_dps_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_is_t _regval = 0x20 & (((ahci_port_is_t )(_fieldval)) << 5);
    _regval = (_regval | (0x23fff00 & mackerel_read_addr_32(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

static inline void ahci_port_is_dmps_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_is_dmps_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_is_t _regval = 0x80 & (((ahci_port_is_t )(_fieldval)) << 7);
    _regval = (_regval | (0x23fff00 & mackerel_read_addr_32(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

static inline void ahci_port_is_ipms_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_is_ipms_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_is_t _regval = 0x800000 & (((ahci_port_is_t )(_fieldval)) << 23);
    _regval = (_regval | (0x23fff00 & mackerel_read_addr_32(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

static inline void ahci_port_is_ofs_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_is_ofs_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_is_t _regval = 0x1000000 & (((ahci_port_is_t )(_fieldval)) << 24);
    _regval = (_regval | (0x23fff00 & mackerel_read_addr_32(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

static inline void ahci_port_is_infs_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_is_infs_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_is_t _regval = 0x4000000 & (((ahci_port_is_t )(_fieldval)) << 26);
    _regval = (_regval | (0x23fff00 & mackerel_read_addr_32(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

static inline void ahci_port_is_ifs_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_is_ifs_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_is_t _regval = 0x8000000 & (((ahci_port_is_t )(_fieldval)) << 27);
    _regval = (_regval | (0x23fff00 & mackerel_read_addr_32(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

static inline void ahci_port_is_hbds_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_is_hbds_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_is_t _regval = 0x10000000 & (((ahci_port_is_t )(_fieldval)) << 28);
    _regval = (_regval | (0x23fff00 & mackerel_read_addr_32(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

static inline void ahci_port_is_hbfs_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_is_hbfs_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_is_t _regval = 0x20000000 & (((ahci_port_is_t )(_fieldval)) << 29);
    _regval = (_regval | (0x23fff00 & mackerel_read_addr_32(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

static inline void ahci_port_is_tfes_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_is_tfes_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_is_t _regval = 0x40000000 & (((ahci_port_is_t )(_fieldval)) << 30);
    _regval = (_regval | (0x23fff00 & mackerel_read_addr_32(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

static inline void ahci_port_is_cpds_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_is_cpds_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_is_t _regval = 0x80000000 & (((ahci_port_is_t )(_fieldval)) << 31);
    _regval = (_regval | (0x23fff00 & mackerel_read_addr_32(_dev->b, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register ie: Interrupt enable
 * Type: ahci_port.ie (Implicit type of Interrupt enable register)
 *   dhre	(size 1, offset 0, init 0):	RW	Device to host register FIS interrupt
 *   pse	(size 1, offset 1, init 0):	RW	PIO setup FIS interrupt
 *   dse	(size 1, offset 2, init 0):	RW	DMA setup FIS interrupt
 *   sdbe	(size 1, offset 3, init 0):	RW	Set device bits interrupt
 *   ufe	(size 1, offset 4, init 0):	RO	Unknown FIS interrupt
 *   dpe	(size 1, offset 5, init 0):	RW	Descriptor processed
 *   pce	(size 1, offset 6, init 0):	RO	Port connect change
 *   dmpe	(size 1, offset 7, init 0):	RW	Device mechanical presence
 *   _anon8	(size 14, offset 8, init 0):	RSVD	_
 *   prce	(size 1, offset 22, init 0):	RO	PhyRdy change status
 *   ipme	(size 1, offset 23, init 0):	RW	Incorrect port multiplier status
 *   ofe	(size 1, offset 24, init 0):	RW	Overflow enable
 *   _anon25	(size 1, offset 25, init 0):	RSVD	_
 *   infe	(size 1, offset 26, init 0):	RW	Interface non-fatal error
 *   ife	(size 1, offset 27, init 0):	RW	Interface fatal error
 *   hbde	(size 1, offset 28, init 0):	RW	Host bus data error
 *   hbfe	(size 1, offset 29, init 0):	RW	Host bus fatal error
 *   tfee	(size 1, offset 30, init 0):	RW	Task file error
 *   cpde	(size 1, offset 31, init 0):	RW	Cold port detect
 */
static inline ahci_port_ie_t ahci_port_ie_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x14));
}

static inline ahci_port_ie_t ahci_port_ie_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_ie_t ahci_port_ie_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x14));
}

static inline void ahci_port_ie_rawwr(__DN(t) *_dev, ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_ie_rawwr(__DN(t) *_dev, ahci_port_ie_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
}

static inline void ahci_port_ie_wr(__DN(t) *_dev, ahci_port_ie_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_ie_wr(__DN(t) *_dev, ahci_port_ie_t _regval)
{
    _regval = (_regval & 0xfdc000ff);
    // No MB1 fields present
    _regval = (_regval | (0x23fff00 & mackerel_read_addr_32(_dev->b, 0x14)));
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
}

static inline int ahci_port_ie_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_port_ie_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ie (Interrupt enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dhre =\t%" PRIx8 "\t(Device to host register FIS interrupt)\n", ahci_port_ie_dhre_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pse =\t%" PRIx8 "\t(PIO setup FIS interrupt)\n", ahci_port_ie_pse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dse =\t%" PRIx8 "\t(DMA setup FIS interrupt)\n", ahci_port_ie_dse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdbe =\t%" PRIx8 "\t(Set device bits interrupt)\n", ahci_port_ie_sdbe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ufe =\t%" PRIx8 "\t(Unknown FIS interrupt)\n", ahci_port_ie_ufe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpe =\t%" PRIx8 "\t(Descriptor processed)\n", ahci_port_ie_dpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pce =\t%" PRIx8 "\t(Port connect change)\n", ahci_port_ie_pce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmpe =\t%" PRIx8 "\t(Device mechanical presence)\n", ahci_port_ie_dmpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prce =\t%" PRIx8 "\t(PhyRdy change status)\n", ahci_port_ie_prce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipme =\t%" PRIx8 "\t(Incorrect port multiplier status)\n", ahci_port_ie_ipme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ofe =\t%" PRIx8 "\t(Overflow enable)\n", ahci_port_ie_ofe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " infe =\t%" PRIx8 "\t(Interface non-fatal error)\n", ahci_port_ie_infe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ife =\t%" PRIx8 "\t(Interface fatal error)\n", ahci_port_ie_ife_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hbde =\t%" PRIx8 "\t(Host bus data error)\n", ahci_port_ie_hbde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hbfe =\t%" PRIx8 "\t(Host bus fatal error)\n", ahci_port_ie_hbfe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tfee =\t%" PRIx8 "\t(Task file error)\n", ahci_port_ie_tfee_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpde =\t%" PRIx8 "\t(Cold port detect)\n", ahci_port_ie_cpde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t ahci_port_ie_dhre_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_dhre_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_dhre_extract(_regval));
}

static inline uint8_t ahci_port_ie_pse_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_pse_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_pse_extract(_regval));
}

static inline uint8_t ahci_port_ie_dse_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_dse_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_dse_extract(_regval));
}

static inline uint8_t ahci_port_ie_sdbe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_sdbe_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_sdbe_extract(_regval));
}

static inline uint8_t ahci_port_ie_ufe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_ufe_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_ufe_extract(_regval));
}

static inline uint8_t ahci_port_ie_dpe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_dpe_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_dpe_extract(_regval));
}

static inline uint8_t ahci_port_ie_pce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_pce_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_pce_extract(_regval));
}

static inline uint8_t ahci_port_ie_dmpe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_dmpe_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_dmpe_extract(_regval));
}

static inline uint8_t ahci_port_ie_prce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_prce_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_prce_extract(_regval));
}

static inline uint8_t ahci_port_ie_ipme_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_ipme_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_ipme_extract(_regval));
}

static inline uint8_t ahci_port_ie_ofe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_ofe_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_ofe_extract(_regval));
}

static inline uint8_t ahci_port_ie_infe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_infe_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_infe_extract(_regval));
}

static inline uint8_t ahci_port_ie_ife_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_ife_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_ife_extract(_regval));
}

static inline uint8_t ahci_port_ie_hbde_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_hbde_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_hbde_extract(_regval));
}

static inline uint8_t ahci_port_ie_hbfe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_hbfe_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_hbfe_extract(_regval));
}

static inline uint8_t ahci_port_ie_tfee_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_tfee_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_tfee_extract(_regval));
}

static inline uint8_t ahci_port_ie_cpde_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_ie_cpde_rdf(__DN(t) *_dev)
{
    ahci_port_ie_t _regval = mackerel_read_addr_32(_dev->b, 0x14);
    return(ahci_port_ie_cpde_extract(_regval));
}

static inline void ahci_port_ie_dhre_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_ie_dhre_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_ie_t _regval = 0x1 & (((ahci_port_ie_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffbfffae & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

static inline void ahci_port_ie_pse_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_ie_pse_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_ie_t _regval = 0x2 & (((ahci_port_ie_t )(_fieldval)) << 1);
    _regval = (_regval | (0xffbfffad & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

static inline void ahci_port_ie_dse_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_ie_dse_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_ie_t _regval = 0x4 & (((ahci_port_ie_t )(_fieldval)) << 2);
    _regval = (_regval | (0xffbfffab & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

static inline void ahci_port_ie_sdbe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_ie_sdbe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_ie_t _regval = 0x8 & (((ahci_port_ie_t )(_fieldval)) << 3);
    _regval = (_regval | (0xffbfffa7 & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

static inline void ahci_port_ie_dpe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_ie_dpe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_ie_t _regval = 0x20 & (((ahci_port_ie_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffbfff8f & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

static inline void ahci_port_ie_dmpe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_ie_dmpe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_ie_t _regval = 0x80 & (((ahci_port_ie_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffbfff2f & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

static inline void ahci_port_ie_ipme_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_ie_ipme_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_ie_t _regval = 0x800000 & (((ahci_port_ie_t )(_fieldval)) << 23);
    _regval = (_regval | (0xff3fffaf & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

static inline void ahci_port_ie_ofe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_ie_ofe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_ie_t _regval = 0x1000000 & (((ahci_port_ie_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfebfffaf & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

static inline void ahci_port_ie_infe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_ie_infe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_ie_t _regval = 0x4000000 & (((ahci_port_ie_t )(_fieldval)) << 26);
    _regval = (_regval | (0xfbbfffaf & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

static inline void ahci_port_ie_ife_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_ie_ife_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_ie_t _regval = 0x8000000 & (((ahci_port_ie_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf7bfffaf & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

static inline void ahci_port_ie_hbde_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_ie_hbde_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_ie_t _regval = 0x10000000 & (((ahci_port_ie_t )(_fieldval)) << 28);
    _regval = (_regval | (0xefbfffaf & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

static inline void ahci_port_ie_hbfe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_ie_hbfe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_ie_t _regval = 0x20000000 & (((ahci_port_ie_t )(_fieldval)) << 29);
    _regval = (_regval | (0xdfbfffaf & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

static inline void ahci_port_ie_tfee_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_ie_tfee_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_ie_t _regval = 0x40000000 & (((ahci_port_ie_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfbfffaf & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

static inline void ahci_port_ie_cpde_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_ie_cpde_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_ie_t _regval = 0x80000000 & (((ahci_port_ie_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fbfffaf & mackerel_read_addr_32(_dev->b, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x14, _regval);
    // No shadow register to write to
}

/*
 * Register cmd: Command and status
 * Type: ahci_port.cmd (Implicit type of Command and status register)
 *   st	(size 1, offset 0, init 0):	RW	Start
 *   sud	(size 1, offset 1, init 0):	RW	Spin-up device
 *   pod	(size 1, offset 2, init 0):	RW	Power on device
 *   clo	(size 1, offset 3, init 0):	RW	Command list override
 *   fre	(size 1, offset 4, init 0):	RW	FIS receive enable
 *   _anon5	(size 3, offset 5, init 0):	RSVD	_
 *   ccs	(size 5, offset 8, init 0):	RO	Current command slot
 *   mpss	(size 1, offset 13, init 0):	RO	Mechanical presence switch state
 *   fr	(size 1, offset 14, init 0):	RO	FIS receive running
 *   cr	(size 1, offset 15, init 0):	RO	Command list running
 *   cps	(size 1, offset 16, init 0):	RO	Cold presence state
 *   pma	(size 1, offset 17, init 0):	RW	Port multiplier attached
 *   hpcp	(size 1, offset 18, init 0):	RO	Hot plug capable port
 *   mpsp	(size 1, offset 19, init 0):	RO	Mechanical presence switch
 *   cpd	(size 1, offset 20, init 0):	RO	Cold presence detection
 *   esp	(size 1, offset 21, init 0):	RO	External SATA port
 *   fbscp	(size 1, offset 22, init 0):	RO	FIS-based switching capable port
 *   apste	(size 1, offset 23, init 0):	RW	Automatic partial to slumber transitions enabled
 *   atapi	(size 1, offset 24, init 0):	RW	Device is ATAPI
 *   dlae	(size 1, offset 25, init 0):	RW	Drive LED on ATAPI enable
 *   alpe	(size 1, offset 26, init 0):	RW	Aggressive link power management enable
 *   asp	(size 1, offset 27, init 0):	RW	Aggressive slumber / partial
 *   icc	(size 4, offset 28, init 0):	RW	Interface communication control
 */
static inline ahci_port_cmd_t ahci_port_cmd_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x18));
}

static inline ahci_port_cmd_t ahci_port_cmd_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_cmd_t ahci_port_cmd_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x18));
}

static inline void ahci_port_cmd_rawwr(__DN(t) *_dev, ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_cmd_rawwr(__DN(t) *_dev, ahci_port_cmd_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x18, _regval);
}

static inline void ahci_port_cmd_wr(__DN(t) *_dev, ahci_port_cmd_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_cmd_wr(__DN(t) *_dev, ahci_port_cmd_t _regval)
{
    _regval = (_regval & 0xffffff1f);
    // No MB1 fields present
    _regval = (_regval | (0xe0 & mackerel_read_addr_32(_dev->b, 0x18)));
    mackerel_write_addr_32(_dev->b, 0x18, _regval);
}

static inline int ahci_port_cmd_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_port_cmd_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cmd (Command and status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " st =\t%" PRIx8 "\t(Start)\n", ahci_port_cmd_st_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sud =\t%" PRIx8 "\t(Spin-up device)\n", ahci_port_cmd_sud_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pod =\t%" PRIx8 "\t(Power on device)\n", ahci_port_cmd_pod_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clo =\t%" PRIx8 "\t(Command list override)\n", ahci_port_cmd_clo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fre =\t%" PRIx8 "\t(FIS receive enable)\n", ahci_port_cmd_fre_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ccs =\t%" PRIx8 "\t(Current command slot)\n", ahci_port_cmd_ccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mpss =\t%" PRIx8 "\t(Mechanical presence switch state)\n", ahci_port_cmd_mpss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fr =\t%" PRIx8 "\t(FIS receive running)\n", ahci_port_cmd_fr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cr =\t%" PRIx8 "\t(Command list running)\n", ahci_port_cmd_cr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cps =\t%" PRIx8 "\t(Cold presence state)\n", ahci_port_cmd_cps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pma =\t%" PRIx8 "\t(Port multiplier attached)\n", ahci_port_cmd_pma_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hpcp =\t%" PRIx8 "\t(Hot plug capable port)\n", ahci_port_cmd_hpcp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mpsp =\t%" PRIx8 "\t(Mechanical presence switch)\n", ahci_port_cmd_mpsp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpd =\t%" PRIx8 "\t(Cold presence detection)\n", ahci_port_cmd_cpd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " esp =\t%" PRIx8 "\t(External SATA port)\n", ahci_port_cmd_esp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fbscp =\t%" PRIx8 "\t(FIS-based switching capable port)\n", ahci_port_cmd_fbscp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apste =\t%" PRIx8 "\t(Automatic partial to slumber transitions enabled)\n", ahci_port_cmd_apste_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " atapi =\t%" PRIx8 "\t(Device is ATAPI)\n", ahci_port_cmd_atapi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlae =\t%" PRIx8 "\t(Drive LED on ATAPI enable)\n", ahci_port_cmd_dlae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " alpe =\t%" PRIx8 "\t(Aggressive link power management enable)\n", ahci_port_cmd_alpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " asp =\t%" PRIx8 "\t(Aggressive slumber / partial)\n", ahci_port_cmd_asp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " icc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_icct_prtval(_s + _r, _avail, ahci_port_cmd_icc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interface communication control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t ahci_port_cmd_st_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_st_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_st_extract(_regval));
}

static inline uint8_t ahci_port_cmd_sud_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_sud_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_sud_extract(_regval));
}

static inline uint8_t ahci_port_cmd_pod_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_pod_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_pod_extract(_regval));
}

static inline uint8_t ahci_port_cmd_clo_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_clo_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_clo_extract(_regval));
}

static inline uint8_t ahci_port_cmd_fre_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_fre_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_fre_extract(_regval));
}

static inline uint8_t ahci_port_cmd_ccs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_ccs_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_ccs_extract(_regval));
}

static inline uint8_t ahci_port_cmd_mpss_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_mpss_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_mpss_extract(_regval));
}

static inline uint8_t ahci_port_cmd_fr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_fr_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_fr_extract(_regval));
}

static inline uint8_t ahci_port_cmd_cr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_cr_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_cr_extract(_regval));
}

static inline uint8_t ahci_port_cmd_cps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_cps_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_cps_extract(_regval));
}

static inline uint8_t ahci_port_cmd_pma_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_pma_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_pma_extract(_regval));
}

static inline uint8_t ahci_port_cmd_hpcp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_hpcp_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_hpcp_extract(_regval));
}

static inline uint8_t ahci_port_cmd_mpsp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_mpsp_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_mpsp_extract(_regval));
}

static inline uint8_t ahci_port_cmd_cpd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_cpd_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_cpd_extract(_regval));
}

static inline uint8_t ahci_port_cmd_esp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_esp_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_esp_extract(_regval));
}

static inline uint8_t ahci_port_cmd_fbscp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_fbscp_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_fbscp_extract(_regval));
}

static inline uint8_t ahci_port_cmd_apste_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_apste_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_apste_extract(_regval));
}

static inline uint8_t ahci_port_cmd_atapi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_atapi_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_atapi_extract(_regval));
}

static inline uint8_t ahci_port_cmd_dlae_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_dlae_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_dlae_extract(_regval));
}

static inline uint8_t ahci_port_cmd_alpe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_alpe_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_alpe_extract(_regval));
}

static inline uint8_t ahci_port_cmd_asp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_cmd_asp_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_asp_extract(_regval));
}

static inline ahci_port_icct_t ahci_port_cmd_icc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_icct_t ahci_port_cmd_icc_rdf(__DN(t) *_dev)
{
    ahci_port_cmd_t _regval = mackerel_read_addr_32(_dev->b, 0x18);
    return(ahci_port_cmd_icc_extract(_regval));
}

static inline void ahci_port_cmd_st_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_cmd_st_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_cmd_t _regval = 0x1 & (((ahci_port_cmd_t )(_fieldval)) << 0);
    _regval = (_regval | (0xff8200fe & mackerel_read_addr_32(_dev->b, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x18, _regval);
    // No shadow register to write to
}

static inline void ahci_port_cmd_sud_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_cmd_sud_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_cmd_t _regval = 0x2 & (((ahci_port_cmd_t )(_fieldval)) << 1);
    _regval = (_regval | (0xff8200fd & mackerel_read_addr_32(_dev->b, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x18, _regval);
    // No shadow register to write to
}

static inline void ahci_port_cmd_pod_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_cmd_pod_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_cmd_t _regval = 0x4 & (((ahci_port_cmd_t )(_fieldval)) << 2);
    _regval = (_regval | (0xff8200fb & mackerel_read_addr_32(_dev->b, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x18, _regval);
    // No shadow register to write to
}

static inline void ahci_port_cmd_clo_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_cmd_clo_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_cmd_t _regval = 0x8 & (((ahci_port_cmd_t )(_fieldval)) << 3);
    _regval = (_regval | (0xff8200f7 & mackerel_read_addr_32(_dev->b, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x18, _regval);
    // No shadow register to write to
}

static inline void ahci_port_cmd_fre_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_cmd_fre_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_cmd_t _regval = 0x10 & (((ahci_port_cmd_t )(_fieldval)) << 4);
    _regval = (_regval | (0xff8200ef & mackerel_read_addr_32(_dev->b, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x18, _regval);
    // No shadow register to write to
}

static inline void ahci_port_cmd_pma_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_cmd_pma_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_cmd_t _regval = 0x20000 & (((ahci_port_cmd_t )(_fieldval)) << 17);
    _regval = (_regval | (0xff8000ff & mackerel_read_addr_32(_dev->b, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x18, _regval);
    // No shadow register to write to
}

static inline void ahci_port_cmd_apste_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_cmd_apste_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_cmd_t _regval = 0x800000 & (((ahci_port_cmd_t )(_fieldval)) << 23);
    _regval = (_regval | (0xff0200ff & mackerel_read_addr_32(_dev->b, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x18, _regval);
    // No shadow register to write to
}

static inline void ahci_port_cmd_atapi_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_cmd_atapi_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_cmd_t _regval = 0x1000000 & (((ahci_port_cmd_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfe8200ff & mackerel_read_addr_32(_dev->b, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x18, _regval);
    // No shadow register to write to
}

static inline void ahci_port_cmd_dlae_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_cmd_dlae_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_cmd_t _regval = 0x2000000 & (((ahci_port_cmd_t )(_fieldval)) << 25);
    _regval = (_regval | (0xfd8200ff & mackerel_read_addr_32(_dev->b, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x18, _regval);
    // No shadow register to write to
}

static inline void ahci_port_cmd_alpe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_cmd_alpe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_cmd_t _regval = 0x4000000 & (((ahci_port_cmd_t )(_fieldval)) << 26);
    _regval = (_regval | (0xfb8200ff & mackerel_read_addr_32(_dev->b, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x18, _regval);
    // No shadow register to write to
}

static inline void ahci_port_cmd_asp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_cmd_asp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_cmd_t _regval = 0x8000000 & (((ahci_port_cmd_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf78200ff & mackerel_read_addr_32(_dev->b, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x18, _regval);
    // No shadow register to write to
}

static inline void ahci_port_cmd_icc_wrf(__DN(t) *_dev, ahci_port_icct_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_cmd_icc_wrf(__DN(t) *_dev, ahci_port_icct_t _fieldval)
{
    ahci_port_cmd_t _regval = 0xf0000000 & (((ahci_port_cmd_t )(_fieldval)) << 28);
    _regval = (_regval | (0xf8200ff & mackerel_read_addr_32(_dev->b, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x18, _regval);
    // No shadow register to write to
}

/*
 * Register tfd: Task file data
 * Type: ahci_port.tfd (Implicit type of Task file data register)
 *   sts	(size 8, offset 0, init 0):	RO	Status (task file status)
 *   err	(size 8, offset 8, init 0):	RO	Error
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline ahci_port_tfd_t ahci_port_tfd_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_tfd_t ahci_port_tfd_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x20));
}

static inline ahci_port_tfd_t ahci_port_tfd_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_tfd_t ahci_port_tfd_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x20));
}

static inline void ahci_port_tfd_rawwr(__DN(t) *_dev, ahci_port_tfd_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_tfd_rawwr(__DN(t) *_dev, ahci_port_tfd_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x20, _regval);
}

// Register tfd is not writeable
static inline int ahci_port_tfd_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_port_tfd_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_port_tfd_t _regval = mackerel_read_addr_32(_dev->b, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tfd (Task file data): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sts =\t%" PRIx8 "\t(Status (task file status))\n", ahci_port_tfd_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " err =\t%" PRIx8 "\t(Error)\n", ahci_port_tfd_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t ahci_port_tfd_sts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_tfd_sts_rdf(__DN(t) *_dev)
{
    ahci_port_tfd_t _regval = mackerel_read_addr_32(_dev->b, 0x20);
    return(ahci_port_tfd_sts_extract(_regval));
}

static inline uint8_t ahci_port_tfd_err_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_tfd_err_rdf(__DN(t) *_dev)
{
    ahci_port_tfd_t _regval = mackerel_read_addr_32(_dev->b, 0x20);
    return(ahci_port_tfd_err_extract(_regval));
}

/*
 * Register sig: Signature
 * Type: ahci_port.sig (Implicit type of Signature register)
 *   sectors	(size 8, offset 0, init 0):	RO	Sector count
 *   lbal	(size 8, offset 8, init 0):	RO	LBA low
 *   lbam	(size 8, offset 16, init 0):	RO	LBA mid
 *   lbah	(size 8, offset 24, init 0):	RO	LBA high
 */
static inline ahci_port_sig_t ahci_port_sig_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_sig_t ahci_port_sig_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x24));
}

static inline ahci_port_sig_t ahci_port_sig_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_sig_t ahci_port_sig_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x24));
}

static inline void ahci_port_sig_rawwr(__DN(t) *_dev, ahci_port_sig_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_sig_rawwr(__DN(t) *_dev, ahci_port_sig_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x24, _regval);
}

// Register sig is not writeable
static inline int ahci_port_sig_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_port_sig_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_port_sig_t _regval = mackerel_read_addr_32(_dev->b, 0x24);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sig (Signature): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sectors =\t%" PRIx8 "\t(Sector count)\n", ahci_port_sig_sectors_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbal =\t%" PRIx8 "\t(LBA low)\n", ahci_port_sig_lbal_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbam =\t%" PRIx8 "\t(LBA mid)\n", ahci_port_sig_lbam_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbah =\t%" PRIx8 "\t(LBA high)\n", ahci_port_sig_lbah_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t ahci_port_sig_sectors_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_sig_sectors_rdf(__DN(t) *_dev)
{
    ahci_port_sig_t _regval = mackerel_read_addr_32(_dev->b, 0x24);
    return(ahci_port_sig_sectors_extract(_regval));
}

static inline uint8_t ahci_port_sig_lbal_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_sig_lbal_rdf(__DN(t) *_dev)
{
    ahci_port_sig_t _regval = mackerel_read_addr_32(_dev->b, 0x24);
    return(ahci_port_sig_lbal_extract(_regval));
}

static inline uint8_t ahci_port_sig_lbam_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_sig_lbam_rdf(__DN(t) *_dev)
{
    ahci_port_sig_t _regval = mackerel_read_addr_32(_dev->b, 0x24);
    return(ahci_port_sig_lbam_extract(_regval));
}

static inline uint8_t ahci_port_sig_lbah_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_sig_lbah_rdf(__DN(t) *_dev)
{
    ahci_port_sig_t _regval = mackerel_read_addr_32(_dev->b, 0x24);
    return(ahci_port_sig_lbah_extract(_regval));
}

/*
 * Register ssts: Serial ATA status
 * Type: ahci_port.ssts (Implicit type of Serial ATA status register)
 *   det	(size 4, offset 0, init 0):	RO	Device detection
 *   spd	(size 4, offset 4, init 0):	RO	Current interface speed
 *   ipm	(size 4, offset 8, init 0):	RO	Interface power management
 *   _anon12	(size 20, offset 12, init 0):	RSVD	_
 */
static inline ahci_port_ssts_t ahci_port_ssts_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_ssts_t ahci_port_ssts_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x28));
}

static inline ahci_port_ssts_t ahci_port_ssts_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_ssts_t ahci_port_ssts_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x28));
}

static inline void ahci_port_ssts_rawwr(__DN(t) *_dev, ahci_port_ssts_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_ssts_rawwr(__DN(t) *_dev, ahci_port_ssts_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x28, _regval);
}

// Register ssts is not writeable
static inline int ahci_port_ssts_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_port_ssts_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_port_ssts_t _regval = mackerel_read_addr_32(_dev->b, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ssts (Serial ATA status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " det =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_dets_prtval(_s + _r, _avail, ahci_port_ssts_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Device detection)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spd =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_speed_prtval(_s + _r, _avail, ahci_port_ssts_spd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Current interface speed)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipm =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_icct_prtval(_s + _r, _avail, ahci_port_ssts_ipm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interface power management)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    return(_r);
}

static inline ahci_port_dets_t ahci_port_ssts_det_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_dets_t ahci_port_ssts_det_rdf(__DN(t) *_dev)
{
    ahci_port_ssts_t _regval = mackerel_read_addr_32(_dev->b, 0x28);
    return(ahci_port_ssts_det_extract(_regval));
}

static inline ahci_port_speed_t ahci_port_ssts_spd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_speed_t ahci_port_ssts_spd_rdf(__DN(t) *_dev)
{
    ahci_port_ssts_t _regval = mackerel_read_addr_32(_dev->b, 0x28);
    return(ahci_port_ssts_spd_extract(_regval));
}

static inline ahci_port_icct_t ahci_port_ssts_ipm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_icct_t ahci_port_ssts_ipm_rdf(__DN(t) *_dev)
{
    ahci_port_ssts_t _regval = mackerel_read_addr_32(_dev->b, 0x28);
    return(ahci_port_ssts_ipm_extract(_regval));
}

/*
 * Register sctl: Serial ATA control
 * Type: ahci_port.sctl (Implicit type of Serial ATA control register)
 *   det	(size 4, offset 0, init 0):	RW	Device detection initialization
 *   spd	(size 4, offset 4, init 0):	RW	Speed allowed
 *   ipm	(size 4, offset 8, init 0):	RW	Interface power mgmt transitions allowed
 *   _anon12	(size 4, offset 12, init 0):	RSVD	_
 *   _anon16	(size 4, offset 16, init 0):	RSVD	_
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
static inline ahci_port_sctl_t ahci_port_sctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_sctl_t ahci_port_sctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x2c));
}

static inline ahci_port_sctl_t ahci_port_sctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_sctl_t ahci_port_sctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x2c));
}

static inline void ahci_port_sctl_rawwr(__DN(t) *_dev, ahci_port_sctl_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_sctl_rawwr(__DN(t) *_dev, ahci_port_sctl_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x2c, _regval);
}

static inline void ahci_port_sctl_wr(__DN(t) *_dev, ahci_port_sctl_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_sctl_wr(__DN(t) *_dev, ahci_port_sctl_t _regval)
{
    _regval = (_regval & 0xfff);
    // No MB1 fields present
    _regval = (_regval | (0xfffff000 & mackerel_read_addr_32(_dev->b, 0x2c)));
    mackerel_write_addr_32(_dev->b, 0x2c, _regval);
}

static inline int ahci_port_sctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_port_sctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_port_sctl_t _regval = mackerel_read_addr_32(_dev->b, 0x2c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sctl (Serial ATA control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " det =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_dets_prtval(_s + _r, _avail, ahci_port_sctl_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Device detection initialization)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spd =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_speed_prtval(_s + _r, _avail, ahci_port_sctl_spd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Speed allowed)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipm =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_ipmall_prtval(_s + _r, _avail, ahci_port_sctl_ipm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Interface power mgmt transitions allowed)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    // _anon16 is anonymous
    // _anon20 is anonymous
    return(_r);
}

static inline ahci_port_dets_t ahci_port_sctl_det_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_dets_t ahci_port_sctl_det_rdf(__DN(t) *_dev)
{
    ahci_port_sctl_t _regval = mackerel_read_addr_32(_dev->b, 0x2c);
    return(ahci_port_sctl_det_extract(_regval));
}

static inline ahci_port_speed_t ahci_port_sctl_spd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_speed_t ahci_port_sctl_spd_rdf(__DN(t) *_dev)
{
    ahci_port_sctl_t _regval = mackerel_read_addr_32(_dev->b, 0x2c);
    return(ahci_port_sctl_spd_extract(_regval));
}

static inline ahci_port_ipmall_t ahci_port_sctl_ipm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_ipmall_t ahci_port_sctl_ipm_rdf(__DN(t) *_dev)
{
    ahci_port_sctl_t _regval = mackerel_read_addr_32(_dev->b, 0x2c);
    return(ahci_port_sctl_ipm_extract(_regval));
}

static inline void ahci_port_sctl_det_wrf(__DN(t) *_dev, ahci_port_dets_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_sctl_det_wrf(__DN(t) *_dev, ahci_port_dets_t _fieldval)
{
    ahci_port_sctl_t _regval = 0xf & (((ahci_port_sctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->b, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ahci_port_sctl_spd_wrf(__DN(t) *_dev, ahci_port_speed_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_sctl_spd_wrf(__DN(t) *_dev, ahci_port_speed_t _fieldval)
{
    ahci_port_sctl_t _regval = 0xf0 & (((ahci_port_sctl_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffff0f & mackerel_read_addr_32(_dev->b, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x2c, _regval);
    // No shadow register to write to
}

static inline void ahci_port_sctl_ipm_wrf(__DN(t) *_dev, ahci_port_ipmall_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_sctl_ipm_wrf(__DN(t) *_dev, ahci_port_ipmall_t _fieldval)
{
    ahci_port_sctl_t _regval = 0xf00 & (((ahci_port_sctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffff0ff & mackerel_read_addr_32(_dev->b, 0x2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x2c, _regval);
    // No shadow register to write to
}

/*
 * Register serr: Serial ATA error
 * Type: ahci_port.serr (Implicit type of Serial ATA error register)
 *   ei	(size 1, offset 0, init 0):	RWC	Recovered data integrity error
 *   em	(size 1, offset 1, init 0):	RWC	Recovered communications error
 *   _anon2	(size 6, offset 2, init 0):	RSVD	_
 *   et	(size 1, offset 8, init 0):	RWC	Transient data integrity error
 *   ec	(size 1, offset 9, init 0):	RWC	Persistent communication or data integrity error
 *   ep	(size 1, offset 10, init 0):	RWC	Protocol error
 *   ee	(size 1, offset 11, init 0):	RWC	Internal error
 *   _anon12	(size 4, offset 12, init 0):	RSVD	_
 *   dn	(size 1, offset 16, init 0):	RWC	PhyRdy change
 *   di	(size 1, offset 17, init 0):	RWC	Phy internal error
 *   dw	(size 1, offset 18, init 0):	RWC	Comm wake
 *   db	(size 1, offset 19, init 0):	RWC	10b to 8b decode error
 *   dd	(size 1, offset 20, init 0):	RWC	Disparity error
 *   dc	(size 1, offset 21, init 0):	RWC	CRC error
 *   dh	(size 1, offset 22, init 0):	RWC	Handshake error
 *   ds	(size 1, offset 23, init 0):	RWC	Link sequence error
 *   dt	(size 1, offset 24, init 0):	RWC	Transport state transition error
 *   df	(size 1, offset 25, init 0):	RWC	Unknown FIS type
 *   dx	(size 1, offset 26, init 0):	RWC	Exchanged
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
static inline ahci_port_serr_t ahci_port_serr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x30));
}

static inline ahci_port_serr_t ahci_port_serr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_serr_t ahci_port_serr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x30));
}

static inline void ahci_port_serr_rawwr(__DN(t) *_dev, ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_serr_rawwr(__DN(t) *_dev, ahci_port_serr_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
}

static inline void ahci_port_serr_wr(__DN(t) *_dev, ahci_port_serr_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_serr_wr(__DN(t) *_dev, ahci_port_serr_t _regval)
{
    _regval = (_regval & 0x7ff0f03);
    // No MB1 fields present
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
}

static inline int ahci_port_serr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_port_serr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register serr (Serial ATA error): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ei =\t%" PRIx8 "\t(Recovered data integrity error)\n", ahci_port_serr_ei_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " em =\t%" PRIx8 "\t(Recovered communications error)\n", ahci_port_serr_em_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " et =\t%" PRIx8 "\t(Transient data integrity error)\n", ahci_port_serr_et_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ec =\t%" PRIx8 "\t(Persistent communication or data integrity error)\n", ahci_port_serr_ec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ep =\t%" PRIx8 "\t(Protocol error)\n", ahci_port_serr_ep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee =\t%" PRIx8 "\t(Internal error)\n", ahci_port_serr_ee_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dn =\t%" PRIx8 "\t(PhyRdy change)\n", ahci_port_serr_dn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " di =\t%" PRIx8 "\t(Phy internal error)\n", ahci_port_serr_di_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dw =\t%" PRIx8 "\t(Comm wake)\n", ahci_port_serr_dw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " db =\t%" PRIx8 "\t(10b to 8b decode error)\n", ahci_port_serr_db_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dd =\t%" PRIx8 "\t(Disparity error)\n", ahci_port_serr_dd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dc =\t%" PRIx8 "\t(CRC error)\n", ahci_port_serr_dc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dh =\t%" PRIx8 "\t(Handshake error)\n", ahci_port_serr_dh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ds =\t%" PRIx8 "\t(Link sequence error)\n", ahci_port_serr_ds_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dt =\t%" PRIx8 "\t(Transport state transition error)\n", ahci_port_serr_dt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " df =\t%" PRIx8 "\t(Unknown FIS type)\n", ahci_port_serr_df_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dx =\t%" PRIx8 "\t(Exchanged)\n", ahci_port_serr_dx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon27 is anonymous
    return(_r);
}

static inline uint8_t ahci_port_serr_ei_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_ei_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_ei_extract(_regval));
}

static inline uint8_t ahci_port_serr_em_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_em_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_em_extract(_regval));
}

static inline uint8_t ahci_port_serr_et_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_et_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_et_extract(_regval));
}

static inline uint8_t ahci_port_serr_ec_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_ec_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_ec_extract(_regval));
}

static inline uint8_t ahci_port_serr_ep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_ep_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_ep_extract(_regval));
}

static inline uint8_t ahci_port_serr_ee_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_ee_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_ee_extract(_regval));
}

static inline uint8_t ahci_port_serr_dn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_dn_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_dn_extract(_regval));
}

static inline uint8_t ahci_port_serr_di_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_di_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_di_extract(_regval));
}

static inline uint8_t ahci_port_serr_dw_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_dw_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_dw_extract(_regval));
}

static inline uint8_t ahci_port_serr_db_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_db_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_db_extract(_regval));
}

static inline uint8_t ahci_port_serr_dd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_dd_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_dd_extract(_regval));
}

static inline uint8_t ahci_port_serr_dc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_dc_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_dc_extract(_regval));
}

static inline uint8_t ahci_port_serr_dh_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_dh_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_dh_extract(_regval));
}

static inline uint8_t ahci_port_serr_ds_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_ds_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_ds_extract(_regval));
}

static inline uint8_t ahci_port_serr_dt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_dt_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_dt_extract(_regval));
}

static inline uint8_t ahci_port_serr_df_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_df_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_df_extract(_regval));
}

static inline uint8_t ahci_port_serr_dx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_serr_dx_rdf(__DN(t) *_dev)
{
    ahci_port_serr_t _regval = mackerel_read_addr_32(_dev->b, 0x30);
    return(ahci_port_serr_dx_extract(_regval));
}

static inline void ahci_port_serr_ei_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_ei_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x1 & (((ahci_port_serr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

static inline void ahci_port_serr_em_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_em_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x2 & (((ahci_port_serr_t )(_fieldval)) << 1);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

static inline void ahci_port_serr_et_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_et_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x100 & (((ahci_port_serr_t )(_fieldval)) << 8);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

static inline void ahci_port_serr_ec_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_ec_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x200 & (((ahci_port_serr_t )(_fieldval)) << 9);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

static inline void ahci_port_serr_ep_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_ep_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x400 & (((ahci_port_serr_t )(_fieldval)) << 10);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

static inline void ahci_port_serr_ee_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_ee_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x800 & (((ahci_port_serr_t )(_fieldval)) << 11);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

static inline void ahci_port_serr_dn_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_dn_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x10000 & (((ahci_port_serr_t )(_fieldval)) << 16);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

static inline void ahci_port_serr_di_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_di_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x20000 & (((ahci_port_serr_t )(_fieldval)) << 17);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

static inline void ahci_port_serr_dw_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_dw_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x40000 & (((ahci_port_serr_t )(_fieldval)) << 18);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

static inline void ahci_port_serr_db_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_db_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x80000 & (((ahci_port_serr_t )(_fieldval)) << 19);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

static inline void ahci_port_serr_dd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_dd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x100000 & (((ahci_port_serr_t )(_fieldval)) << 20);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

static inline void ahci_port_serr_dc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_dc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x200000 & (((ahci_port_serr_t )(_fieldval)) << 21);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

static inline void ahci_port_serr_dh_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_dh_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x400000 & (((ahci_port_serr_t )(_fieldval)) << 22);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

static inline void ahci_port_serr_ds_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_ds_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x800000 & (((ahci_port_serr_t )(_fieldval)) << 23);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

static inline void ahci_port_serr_dt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_dt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x1000000 & (((ahci_port_serr_t )(_fieldval)) << 24);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

static inline void ahci_port_serr_df_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_df_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x2000000 & (((ahci_port_serr_t )(_fieldval)) << 25);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

static inline void ahci_port_serr_dx_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_serr_dx_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_serr_t _regval = 0x4000000 & (((ahci_port_serr_t )(_fieldval)) << 26);
    _regval = (_regval | (0xf800f0fc & mackerel_read_addr_32(_dev->b, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x30, _regval);
    // No shadow register to write to
}

/*
 * Register sact: Serial ATA active
 * Type: ahci_port.uint32 (primitive type)
 */
static inline uint32_t ahci_port_sact_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ahci_port_sact_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x34));
}

static inline uint32_t ahci_port_sact_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ahci_port_sact_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x34));
}

static inline void ahci_port_sact_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_sact_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x34, _regval);
}

static inline void ahci_port_sact_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_sact_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->b, 0x34, _regval);
}

static inline int ahci_port_sact_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_port_sact_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->b, 0x34);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sact (Serial ATA active): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ci: Command issue
 * Type: ahci_port.uint32 (primitive type)
 */
static inline uint32_t ahci_port_ci_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ahci_port_ci_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x38));
}

static inline uint32_t ahci_port_ci_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ahci_port_ci_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x38));
}

static inline void ahci_port_ci_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_ci_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x38, _regval);
}

static inline void ahci_port_ci_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_ci_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->b, 0x38, _regval);
}

static inline int ahci_port_ci_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_port_ci_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->b, 0x38);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ci (Command issue): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register sntf: Serial ATA notification
 * Type: ahci_port.sntf (Implicit type of Serial ATA notification register)
 *   pmn	(size 16, offset 0, init 0):	RWC	PMN notify
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static inline ahci_port_sntf_t ahci_port_sntf_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_sntf_t ahci_port_sntf_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x3c));
}

static inline ahci_port_sntf_t ahci_port_sntf_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_sntf_t ahci_port_sntf_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x3c));
}

static inline void ahci_port_sntf_rawwr(__DN(t) *_dev, ahci_port_sntf_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_sntf_rawwr(__DN(t) *_dev, ahci_port_sntf_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x3c, _regval);
}

static inline void ahci_port_sntf_wr(__DN(t) *_dev, ahci_port_sntf_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_sntf_wr(__DN(t) *_dev, ahci_port_sntf_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->b, 0x3c, _regval);
}

static inline int ahci_port_sntf_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_port_sntf_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_port_sntf_t _regval = mackerel_read_addr_32(_dev->b, 0x3c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sntf (Serial ATA notification): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmn =\t%" PRIx16 "\t(PMN notify)\n", ahci_port_sntf_pmn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t ahci_port_sntf_pmn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ahci_port_sntf_pmn_rdf(__DN(t) *_dev)
{
    ahci_port_sntf_t _regval = mackerel_read_addr_32(_dev->b, 0x3c);
    return(ahci_port_sntf_pmn_extract(_regval));
}

static inline void ahci_port_sntf_pmn_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_sntf_pmn_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    ahci_port_sntf_t _regval = 0xffff & (((ahci_port_sntf_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x3c, _regval);
    // No shadow register to write to
}

/*
 * Register fbs: FIS-based switching control
 * Type: ahci_port.fbs (Implicit type of FIS-based switching control register)
 *   en	(size 1, offset 0, init 0):	RW	Enable
 *   dec	(size 1, offset 1, init 0):	RWC	Device error clear
 *   sde	(size 1, offset 2, init 0):	RO	Single device error
 *   _anon3	(size 5, offset 3, init 0):	MBZ	_
 *   dev	(size 4, offset 8, init 0):	RW	Device to issue
 *   ado	(size 4, offset 12, init 0):	RO	Active device optimization
 *   dwe	(size 4, offset 16, init 0):	RO	Device with error
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline ahci_port_fbs_t ahci_port_fbs_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_fbs_t ahci_port_fbs_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x40));
}

static inline ahci_port_fbs_t ahci_port_fbs_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ahci_port_fbs_t ahci_port_fbs_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x40));
}

static inline void ahci_port_fbs_rawwr(__DN(t) *_dev, ahci_port_fbs_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_fbs_rawwr(__DN(t) *_dev, ahci_port_fbs_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x40, _regval);
}

static inline void ahci_port_fbs_wr(__DN(t) *_dev, ahci_port_fbs_t _regval) __attribute__ ((always_inline));
static inline void ahci_port_fbs_wr(__DN(t) *_dev, ahci_port_fbs_t _regval)
{
    _regval = (_regval & 0xfff07);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->b, 0x40, _regval);
}

static inline int ahci_port_fbs_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_port_fbs_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ahci_port_fbs_t _regval = mackerel_read_addr_32(_dev->b, 0x40);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fbs (FIS-based switching control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en =\t%" PRIx8 "\t(Enable)\n", ahci_port_fbs_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dec =\t%" PRIx8 "\t(Device error clear)\n", ahci_port_fbs_dec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sde =\t%" PRIx8 "\t(Single device error)\n", ahci_port_fbs_sde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dev =\t%" PRIx8 "\t(Device to issue)\n", ahci_port_fbs_dev_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ado =\t%" PRIx8 "\t(Active device optimization)\n", ahci_port_fbs_ado_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dwe =\t%" PRIx8 "\t(Device with error)\n", ahci_port_fbs_dwe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline uint8_t ahci_port_fbs_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_fbs_en_rdf(__DN(t) *_dev)
{
    ahci_port_fbs_t _regval = mackerel_read_addr_32(_dev->b, 0x40);
    return(ahci_port_fbs_en_extract(_regval));
}

static inline uint8_t ahci_port_fbs_dec_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_fbs_dec_rdf(__DN(t) *_dev)
{
    ahci_port_fbs_t _regval = mackerel_read_addr_32(_dev->b, 0x40);
    return(ahci_port_fbs_dec_extract(_regval));
}

static inline uint8_t ahci_port_fbs_sde_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_fbs_sde_rdf(__DN(t) *_dev)
{
    ahci_port_fbs_t _regval = mackerel_read_addr_32(_dev->b, 0x40);
    return(ahci_port_fbs_sde_extract(_regval));
}

static inline uint8_t ahci_port_fbs_dev_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_fbs_dev_rdf(__DN(t) *_dev)
{
    ahci_port_fbs_t _regval = mackerel_read_addr_32(_dev->b, 0x40);
    return(ahci_port_fbs_dev_extract(_regval));
}

static inline uint8_t ahci_port_fbs_ado_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_fbs_ado_rdf(__DN(t) *_dev)
{
    ahci_port_fbs_t _regval = mackerel_read_addr_32(_dev->b, 0x40);
    return(ahci_port_fbs_ado_extract(_regval));
}

static inline uint8_t ahci_port_fbs_dwe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ahci_port_fbs_dwe_rdf(__DN(t) *_dev)
{
    ahci_port_fbs_t _regval = mackerel_read_addr_32(_dev->b, 0x40);
    return(ahci_port_fbs_dwe_extract(_regval));
}

static inline void ahci_port_fbs_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_fbs_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_fbs_t _regval = 0x1 & (((ahci_port_fbs_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf00 & mackerel_read_addr_32(_dev->b, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xfff07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x40, _regval);
    // No shadow register to write to
}

static inline void ahci_port_fbs_dec_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_fbs_dec_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_fbs_t _regval = 0x2 & (((ahci_port_fbs_t )(_fieldval)) << 1);
    _regval = (_regval | (0xf01 & mackerel_read_addr_32(_dev->b, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xfff07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x40, _regval);
    // No shadow register to write to
}

static inline void ahci_port_fbs_dev_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ahci_port_fbs_dev_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ahci_port_fbs_t _regval = 0xf00 & (((ahci_port_fbs_t )(_fieldval)) << 8);
    _regval = (_regval | (0x1 & mackerel_read_addr_32(_dev->b, 0x40)));
    // No read of register shadow required
    _regval = (_regval & 0xfff07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->b, 0x40, _regval);
    // No shadow register to write to
}

static inline int ahci_port_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ahci_port_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device ahci_port (AHCI port):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_clb_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_fb_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_is_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_ie_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_cmd_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_tfd_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_sig_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_ssts_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_sctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_serr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_sact_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_ci_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_sntf_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ahci_port_fbs_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device ahci_port\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __ahci_port_DEV_H
