/*
 * DEVICE DEFINITION: LPC Timer
 * 
 * Copyright (c) 2007, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich.
 *  Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED: DO NOT EDIT!
 */

#ifndef __lpc_timer_H
#define __lpc_timer_H

#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR
#define __DN(x) lpc_timer ## _ ## x
#ifdef lpc_timer_PREFIX
#define __DP(x) __DP1(x,lpc_timer_PREFIX)
#define __DP1(x1,x2) __DP2(x1,x2)
#define __DP2(x1,x2) x2 ## x1
#else
#define __DP(x) lpc_timer##_ ##x
#endif
#define __STR(x) #x
#define __XTR(x) __STR(x)

/*
 * Constant definition: lpc_timer.cnt_mode (Counter mode)
 */
typedef enum lpc_timer_cnt_mode_t {
    __DP(oseoc) = (0x0),
    __DP(hr1s) = (0x1),
    __DP(rtgen) = (0x2),
    __DP(rtgen_) = (0x6),
    __DP(sqwav) = (0x3),
    __DP(sqwav_) = (0x7),
    __DP(swstr) = (0x4),
    __DP(hwstr) = (0x5),
} lpc_timer_cnt_mode_t;

static inline int lpc_timer_cnt_mode_prt( char * s, size_t sz, lpc_timer_cnt_mode_t e ) __attribute__ ((always_inline));
static inline int lpc_timer_cnt_mode_prt( char * s, size_t sz, lpc_timer_cnt_mode_t e )
{
    switch (e) {
        case __DP(oseoc):
        return snprintf(s, sz, "%s", "Out signal on end of count (mode 0)");
        case __DP(hr1s):
        return snprintf(s, sz, "%s", "Hardware retriggerable one-shot (mode 1)");
        case __DP(rtgen):
        return snprintf(s, sz, "%s", "Rate generator (mode 2)");
        case __DP(rtgen_):
        return snprintf(s, sz, "%s", "Rate generator (mode 2)");
        case __DP(sqwav):
        return snprintf(s, sz, "%s", "Square wave output (mode 3)");
        case __DP(sqwav_):
        return snprintf(s, sz, "%s", "Square wave output (mode 3)");
        case __DP(swstr):
        return snprintf(s, sz, "%s", "Software triggered strobe (mode 4)");
        case __DP(hwstr):
        return snprintf(s, sz, "%s", "Hardware triggered strobe (mode 5)");
        default:
        return snprintf(s, sz, "Unknown " __XTR(lpc_timer_cnt_mode_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int lpc_timer_cnt_mode_chk( lpc_timer_cnt_mode_t e ) __attribute__ ((always_inline));
static inline int lpc_timer_cnt_mode_chk( lpc_timer_cnt_mode_t e )
{
    switch (e) {
        case __DP(oseoc):
        return 1;
        case __DP(hr1s):
        return 1;
        case __DP(rtgen):
        return 1;
        case __DP(rtgen_):
        return 1;
        case __DP(sqwav):
        return 1;
        case __DP(sqwav_):
        return 1;
        case __DP(swstr):
        return 1;
        case __DP(hwstr):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: lpc_timer.timer_rwsel (Read/write select)
 */
typedef enum lpc_timer_timer_rwsel_t {
    __DP(clc) = (0x0),
    __DP(lsb) = (0x1),
    __DP(msb) = (0x2),
    __DP(lmsb) = (0x3),
} lpc_timer_timer_rwsel_t;

static inline int lpc_timer_timer_rwsel_prt( char * s, size_t sz, lpc_timer_timer_rwsel_t e ) __attribute__ ((always_inline));
static inline int lpc_timer_timer_rwsel_prt( char * s, size_t sz, lpc_timer_timer_rwsel_t e )
{
    switch (e) {
        case __DP(clc):
        return snprintf(s, sz, "%s", "Counter latch cmd");
        case __DP(lsb):
        return snprintf(s, sz, "%s", "R/w least sig. byte");
        case __DP(msb):
        return snprintf(s, sz, "%s", "R/w most sig. byte");
        case __DP(lmsb):
        return snprintf(s, sz, "%s", "R/w lsb then msb");
        default:
        return snprintf(s, sz, "Unknown " __XTR(lpc_timer_timer_rwsel_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int lpc_timer_timer_rwsel_chk( lpc_timer_timer_rwsel_t e ) __attribute__ ((always_inline));
static inline int lpc_timer_timer_rwsel_chk( lpc_timer_timer_rwsel_t e )
{
    switch (e) {
        case __DP(clc):
        return 1;
        case __DP(lsb):
        return 1;
        case __DP(msb):
        return 1;
        case __DP(lmsb):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: lpc_timer.timer_cntsel (Counter select)
 */
typedef enum lpc_timer_timer_cntsel_t {
    __DP(c0) = (0x0),
    __DP(c1) = (0x1),
    __DP(c2) = (0x2),
    __DP(rb) = (0x3),
} lpc_timer_timer_cntsel_t;

static inline int lpc_timer_timer_cntsel_prt( char * s, size_t sz, lpc_timer_timer_cntsel_t e ) __attribute__ ((always_inline));
static inline int lpc_timer_timer_cntsel_prt( char * s, size_t sz, lpc_timer_timer_cntsel_t e )
{
    switch (e) {
        case __DP(c0):
        return snprintf(s, sz, "%s", "Counter 0");
        case __DP(c1):
        return snprintf(s, sz, "%s", "Counter 1");
        case __DP(c2):
        return snprintf(s, sz, "%s", "Counter 2");
        case __DP(rb):
        return snprintf(s, sz, "%s", "Read back cmd");
        default:
        return snprintf(s, sz, "Unknown " __XTR(lpc_timer_timer_cntsel_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int lpc_timer_timer_cntsel_chk( lpc_timer_timer_cntsel_t e ) __attribute__ ((always_inline));
static inline int lpc_timer_timer_cntsel_chk( lpc_timer_timer_cntsel_t e )
{
    switch (e) {
        case __DP(c0):
        return 1;
        case __DP(c1):
        return 1;
        case __DP(c2):
        return 1;
        case __DP(rb):
        return 1;
        default:
        return 0;
    }
}


/*
 * Register type: Implicit type of Timer Control Word register
 */

/*
 * Dump of fields for register type: lpc_timer_tcw_t
 *   bcd (size 1, offset 0):	 WO	  Binary coded decimal select
 *   mode (size 3, offset 1):	 WO	  Counter mode
 *   rwsel (size 2, offset 4):	 WO	  Read/write select
 *   select (size 2, offset 6):	 WO	  Counter select
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct lpc_timer_tcw_t {
    uint8_t	bcd	:1;
    lpc_timer_cnt_mode_t	mode	:3;
    lpc_timer_timer_rwsel_t	rwsel	:2;
    lpc_timer_timer_cntsel_t	select	:2;
} __attribute__ ((packed))
 lpc_timer_tcw_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(lpc_timer_tcw_t, sizeof(uint8_t));

typedef union lpc_timer_tcw_un {
    lpc_timer_tcw_t	val;
    uint8_t	raw;
}
 lpc_timer_tcw_un;
static inline int lpc_timer_tcw_prtval( char * s, size_t sz, lpc_timer_tcw_t v ) __attribute__ ((always_inline));
static inline int lpc_timer_tcw_prtval( char * s, size_t sz, lpc_timer_tcw_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " bcd=0x%"PRIx8" (Binary coded decimal select)\n", (uint8_t)(v.bcd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " mode=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = lpc_timer_cnt_mode_prt(s+r, _avail, v.mode);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Counter mode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " rwsel=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = lpc_timer_timer_rwsel_prt(s+r, _avail, v.rwsel);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Read/write select)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " select=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = lpc_timer_timer_cntsel_prt(s+r, _avail, v.select);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Counter select)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Read back command register
 */

/*
 * Dump of fields for register type: lpc_timer_rdbk_cmd_t
 *   _anon0 (size 1, offset 0):	 MBZ	  _
 *   c0 (size 1, offset 1):	 WO	  Counter 0 select
 *   c1 (size 1, offset 2):	 WO	  Counter 1 select
 *   c2 (size 1, offset 3):	 WO	  Counter 2 select
 *   stat (size 1, offset 4):	 WO	  Latch status of selected counters
 *   count (size 1, offset 5):	 WO	  Latch count of selected counters
 *   _anon6 (size 2, offset 6):	 MB1	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct lpc_timer_rdbk_cmd_t {
    uint8_t	_anon0	:1;
    uint8_t	c0	:1;
    uint8_t	c1	:1;
    uint8_t	c2	:1;
    uint8_t	stat	:1;
    uint8_t	count	:1;
    uint8_t	_anon6	:2;
} __attribute__ ((packed))
 lpc_timer_rdbk_cmd_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(lpc_timer_rdbk_cmd_t, sizeof(uint8_t));

typedef union lpc_timer_rdbk_cmd_un {
    lpc_timer_rdbk_cmd_t	val;
    uint8_t	raw;
}
 lpc_timer_rdbk_cmd_un;
static inline int lpc_timer_rdbk_cmd_prtval( char * s, size_t sz, lpc_timer_rdbk_cmd_t v ) __attribute__ ((always_inline));
static inline int lpc_timer_rdbk_cmd_prtval( char * s, size_t sz, lpc_timer_rdbk_cmd_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " c0=0x%"PRIx8" (Counter 0 select)\n", (uint8_t)(v.c0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " c1=0x%"PRIx8" (Counter 1 select)\n", (uint8_t)(v.c1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " c2=0x%"PRIx8" (Counter 2 select)\n", (uint8_t)(v.c2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " stat=0x%"PRIx8" (Latch status of selected counters)\n", (uint8_t)(v.stat));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " count=0x%"PRIx8" (Latch count of selected counters)\n", (uint8_t)(v.count));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Counter latch command register
 */

/*
 * Dump of fields for register type: lpc_timer_ltch_cmd_t
 *   _anon0 (size 6, offset 0):	 MBZ	  _
 *   select (size 2, offset 6):	 WO	  Counter select
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct lpc_timer_ltch_cmd_t {
    uint8_t	_anon0	:6;
    lpc_timer_timer_cntsel_t	select	:2;
} __attribute__ ((packed))
 lpc_timer_ltch_cmd_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(lpc_timer_ltch_cmd_t, sizeof(uint8_t));

typedef union lpc_timer_ltch_cmd_un {
    lpc_timer_ltch_cmd_t	val;
    uint8_t	raw;
}
 lpc_timer_ltch_cmd_un;
static inline int lpc_timer_ltch_cmd_prtval( char * s, size_t sz, lpc_timer_ltch_cmd_t v ) __attribute__ ((always_inline));
static inline int lpc_timer_ltch_cmd_prtval( char * s, size_t sz, lpc_timer_ltch_cmd_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " select=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = lpc_timer_timer_cntsel_prt(s+r, _avail, v.select);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Counter select)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Interval timer status byte format
 */

/*
 * Dump of fields for register type: lpc_timer_sbyte_fmt_t
 *   bcd (size 1, offset 0):	 NOATTR	  Binary coded decimal select
 *   mode (size 3, offset 1):	 NOATTR	  Counter mode
 *   rwsel (size 2, offset 4):	 NOATTR	  Read/write select
 *   cnt_stat (size 1, offset 6):	 NOATTR	  Count register status
 *   cnt_out (size 1, offset 7):	 NOATTR	  Counter OUT pin status
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct lpc_timer_sbyte_fmt_t {
    uint8_t	bcd	:1;
    lpc_timer_cnt_mode_t	mode	:3;
    lpc_timer_timer_rwsel_t	rwsel	:2;
    uint8_t	cnt_stat	:1;
    uint8_t	cnt_out	:1;
} __attribute__ ((packed))
 lpc_timer_sbyte_fmt_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(lpc_timer_sbyte_fmt_t, sizeof(uint8_t));

typedef union lpc_timer_sbyte_fmt_un {
    lpc_timer_sbyte_fmt_t	val;
    uint8_t	raw;
}
 lpc_timer_sbyte_fmt_un;
static inline int lpc_timer_sbyte_fmt_prtval( char * s, size_t sz, lpc_timer_sbyte_fmt_t v ) __attribute__ ((always_inline));
static inline int lpc_timer_sbyte_fmt_prtval( char * s, size_t sz, lpc_timer_sbyte_fmt_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " bcd=0x%"PRIx8" (Binary coded decimal select)\n", (uint8_t)(v.bcd));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " mode=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = lpc_timer_cnt_mode_prt(s+r, _avail, v.mode);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Counter mode)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " rwsel=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = lpc_timer_timer_rwsel_prt(s+r, _avail, v.rwsel);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Read/write select)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cnt_stat=0x%"PRIx8" (Count register status)\n", (uint8_t)(v.cnt_stat));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cnt_out=0x%"PRIx8" (Counter OUT pin status)\n", (uint8_t)(v.cnt_out));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Device representation structure
 */
typedef struct __DN(t) {
    // Device arguments
    mackerel_io_t	base;
    // Shadow registers
    lpc_timer_tcw_un	tcw_shadow;
    lpc_timer_rdbk_cmd_un	rdbk_cmd_shadow;
    lpc_timer_ltch_cmd_un	ltch_cmd_shadow;
}
 __DN(t);

/*
 * Device Initialization function
 */
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_io_t base ) __attribute__ ((always_inline));
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_io_t base )
{
    /* Setting up device arguments*/
    _dev->base = base;
    /* Setting up shadow registers*/
    _dev->tcw_shadow.raw = 0x0;
    _dev->rdbk_cmd_shadow.raw = 0x0;
    _dev->ltch_cmd_shadow.raw = 0x0;
}

// No user-defined spaces

/*
 * Register tcw (Timer Control Word); type lpc_timer.tcw (Implicit type of Timer Control Word register)
 */

/*
 * Dump of fields for register: tcw
 *   bcd (size 1, offset 0):	 WO	  Binary coded decimal select
 *   mode (size 3, offset 1):	 WO	  Counter mode
 *   rwsel (size 2, offset 4):	 WO	  Read/write select
 *   select (size 2, offset 6):	 WO	  Counter select
 */

// Register tcw is not readable
static inline lpc_timer_tcw_t __DP(tcw_rd_shadow)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline lpc_timer_tcw_t __DP(tcw_rd_shadow)( __DN(t) * _dev )
{
    return _dev->tcw_shadow.val;
}

static inline void __DP(tcw_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tcw_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_io_8(_dev->base,(0x3),val);
}

static inline void __DP(tcw_wr)( __DN(t) * _dev, lpc_timer_tcw_t val ) __attribute__ ((always_inline));
static inline void __DP(tcw_wr)( __DN(t) * _dev, lpc_timer_tcw_t val )
{
    lpc_timer_tcw_un  u;
    u.val = val;
    mackerel_write_io_8(_dev->base,(0x3),u.raw);
    _dev->tcw_shadow.val = u.val;
}

static inline void __DP(tcw_bcd_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(tcw_bcd_wrf)( __DN(t) * _dev, uint8_t val )
{
    lpc_timer_tcw_un  u;
    u.val.mode = _dev->tcw_shadow.val.mode;
    u.val.rwsel = _dev->tcw_shadow.val.rwsel;
    u.val.select = _dev->tcw_shadow.val.select;
    u.val.bcd = val;
    mackerel_write_io_8(_dev->base,(0x3),u.raw);
    _dev->tcw_shadow.val = u.val;
}

static inline void __DP(tcw_mode_wrf)( __DN(t) * _dev, lpc_timer_cnt_mode_t val ) __attribute__ ((always_inline));
static inline void __DP(tcw_mode_wrf)( __DN(t) * _dev, lpc_timer_cnt_mode_t val )
{
    lpc_timer_tcw_un  u;
    u.val.bcd = _dev->tcw_shadow.val.bcd;
    u.val.rwsel = _dev->tcw_shadow.val.rwsel;
    u.val.select = _dev->tcw_shadow.val.select;
    u.val.mode = val;
    mackerel_write_io_8(_dev->base,(0x3),u.raw);
    _dev->tcw_shadow.val = u.val;
}

static inline void __DP(tcw_rwsel_wrf)( __DN(t) * _dev, lpc_timer_timer_rwsel_t val ) __attribute__ ((always_inline));
static inline void __DP(tcw_rwsel_wrf)( __DN(t) * _dev, lpc_timer_timer_rwsel_t val )
{
    lpc_timer_tcw_un  u;
    u.val.bcd = _dev->tcw_shadow.val.bcd;
    u.val.mode = _dev->tcw_shadow.val.mode;
    u.val.select = _dev->tcw_shadow.val.select;
    u.val.rwsel = val;
    mackerel_write_io_8(_dev->base,(0x3),u.raw);
    _dev->tcw_shadow.val = u.val;
}

static inline void __DP(tcw_select_wrf)( __DN(t) * _dev, lpc_timer_timer_cntsel_t val ) __attribute__ ((always_inline));
static inline void __DP(tcw_select_wrf)( __DN(t) * _dev, lpc_timer_timer_cntsel_t val )
{
    lpc_timer_tcw_un  u;
    u.val.bcd = _dev->tcw_shadow.val.bcd;
    u.val.mode = _dev->tcw_shadow.val.mode;
    u.val.rwsel = _dev->tcw_shadow.val.rwsel;
    u.val.select = val;
    mackerel_write_io_8(_dev->base,(0x3),u.raw);
    _dev->tcw_shadow.val = u.val;
}


static inline int __DP(tcw_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tcw_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is not readable
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tcw (Timer Control Word):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)_dev->tcw_shadow.val.bcd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bcd =\t0x%"PRIx8" (SHADOW of Binary coded decimal select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->tcw_shadow.val.mode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mode =\t0x%"PRIx8" (SHADOW of Counter mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = lpc_timer_cnt_mode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->tcw_shadow.val.rwsel;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rwsel =\t0x%"PRIx8" (SHADOW of Read/write select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = lpc_timer_timer_rwsel_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->tcw_shadow.val.select;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " select =\t0x%"PRIx8" (SHADOW of Counter select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = lpc_timer_timer_cntsel_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register rdbk_cmd (Read back command); type lpc_timer.rdbk_cmd (Implicit type of Read back command register)
 */

/*
 * Dump of fields for register: rdbk_cmd
 *   _anon0 (size 1, offset 0):	 MBZ	  _
 *   c0 (size 1, offset 1):	 WO	  Counter 0 select
 *   c1 (size 1, offset 2):	 WO	  Counter 1 select
 *   c2 (size 1, offset 3):	 WO	  Counter 2 select
 *   stat (size 1, offset 4):	 WO	  Latch status of selected counters
 *   count (size 1, offset 5):	 WO	  Latch count of selected counters
 *   _anon6 (size 2, offset 6):	 MB1	  _
 */

// Register rdbk_cmd is not readable
static inline lpc_timer_rdbk_cmd_t __DP(rdbk_cmd_rd_shadow)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline lpc_timer_rdbk_cmd_t __DP(rdbk_cmd_rd_shadow)( __DN(t) * _dev )
{
    return _dev->rdbk_cmd_shadow.val;
}

static inline void __DP(rdbk_cmd_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rdbk_cmd_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_io_8(_dev->base,(0x3),val);
}

static inline void __DP(rdbk_cmd_wr)( __DN(t) * _dev, lpc_timer_rdbk_cmd_t val ) __attribute__ ((always_inline));
static inline void __DP(rdbk_cmd_wr)( __DN(t) * _dev, lpc_timer_rdbk_cmd_t val )
{
    lpc_timer_rdbk_cmd_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    u.val._anon6 	= -1;
    mackerel_write_io_8(_dev->base,(0x3),u.raw);
    _dev->rdbk_cmd_shadow.val = u.val;
}

static inline void __DP(rdbk_cmd_c0_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rdbk_cmd_c0_wrf)( __DN(t) * _dev, uint8_t val )
{
    lpc_timer_rdbk_cmd_un  u;
    u.val.c1 = _dev->rdbk_cmd_shadow.val.c1;
    u.val.c2 = _dev->rdbk_cmd_shadow.val.c2;
    u.val.stat = _dev->rdbk_cmd_shadow.val.stat;
    u.val.count = _dev->rdbk_cmd_shadow.val.count;
    u.val._anon0 	= 0;
    u.val._anon6 	= -1;
    u.val.c0 = val;
    mackerel_write_io_8(_dev->base,(0x3),u.raw);
    _dev->rdbk_cmd_shadow.val = u.val;
}

static inline void __DP(rdbk_cmd_c1_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rdbk_cmd_c1_wrf)( __DN(t) * _dev, uint8_t val )
{
    lpc_timer_rdbk_cmd_un  u;
    u.val.c0 = _dev->rdbk_cmd_shadow.val.c0;
    u.val.c2 = _dev->rdbk_cmd_shadow.val.c2;
    u.val.stat = _dev->rdbk_cmd_shadow.val.stat;
    u.val.count = _dev->rdbk_cmd_shadow.val.count;
    u.val._anon0 	= 0;
    u.val._anon6 	= -1;
    u.val.c1 = val;
    mackerel_write_io_8(_dev->base,(0x3),u.raw);
    _dev->rdbk_cmd_shadow.val = u.val;
}

static inline void __DP(rdbk_cmd_c2_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rdbk_cmd_c2_wrf)( __DN(t) * _dev, uint8_t val )
{
    lpc_timer_rdbk_cmd_un  u;
    u.val.c0 = _dev->rdbk_cmd_shadow.val.c0;
    u.val.c1 = _dev->rdbk_cmd_shadow.val.c1;
    u.val.stat = _dev->rdbk_cmd_shadow.val.stat;
    u.val.count = _dev->rdbk_cmd_shadow.val.count;
    u.val._anon0 	= 0;
    u.val._anon6 	= -1;
    u.val.c2 = val;
    mackerel_write_io_8(_dev->base,(0x3),u.raw);
    _dev->rdbk_cmd_shadow.val = u.val;
}

static inline void __DP(rdbk_cmd_stat_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rdbk_cmd_stat_wrf)( __DN(t) * _dev, uint8_t val )
{
    lpc_timer_rdbk_cmd_un  u;
    u.val.c0 = _dev->rdbk_cmd_shadow.val.c0;
    u.val.c1 = _dev->rdbk_cmd_shadow.val.c1;
    u.val.c2 = _dev->rdbk_cmd_shadow.val.c2;
    u.val.count = _dev->rdbk_cmd_shadow.val.count;
    u.val._anon0 	= 0;
    u.val._anon6 	= -1;
    u.val.stat = val;
    mackerel_write_io_8(_dev->base,(0x3),u.raw);
    _dev->rdbk_cmd_shadow.val = u.val;
}

static inline void __DP(rdbk_cmd_count_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rdbk_cmd_count_wrf)( __DN(t) * _dev, uint8_t val )
{
    lpc_timer_rdbk_cmd_un  u;
    u.val.c0 = _dev->rdbk_cmd_shadow.val.c0;
    u.val.c1 = _dev->rdbk_cmd_shadow.val.c1;
    u.val.c2 = _dev->rdbk_cmd_shadow.val.c2;
    u.val.stat = _dev->rdbk_cmd_shadow.val.stat;
    u.val._anon0 	= 0;
    u.val._anon6 	= -1;
    u.val.count = val;
    mackerel_write_io_8(_dev->base,(0x3),u.raw);
    _dev->rdbk_cmd_shadow.val = u.val;
}


static inline int __DP(rdbk_cmd_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rdbk_cmd_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is not readable
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rdbk_cmd (Read back command):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)_dev->rdbk_cmd_shadow.val.c0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " c0 =\t0x%"PRIx8" (SHADOW of Counter 0 select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->rdbk_cmd_shadow.val.c1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " c1 =\t0x%"PRIx8" (SHADOW of Counter 1 select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->rdbk_cmd_shadow.val.c2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " c2 =\t0x%"PRIx8" (SHADOW of Counter 2 select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->rdbk_cmd_shadow.val.stat;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " stat =\t0x%"PRIx8" (SHADOW of Latch status of selected counters", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)_dev->rdbk_cmd_shadow.val.count;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " count =\t0x%"PRIx8" (SHADOW of Latch count of selected counters", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register ltch_cmd (Counter latch command); type lpc_timer.ltch_cmd (Implicit type of Counter latch command register)
 */

/*
 * Dump of fields for register: ltch_cmd
 *   _anon0 (size 6, offset 0):	 MBZ	  _
 *   select (size 2, offset 6):	 WO	  Counter select
 */

// Register ltch_cmd is not readable
static inline lpc_timer_ltch_cmd_t __DP(ltch_cmd_rd_shadow)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline lpc_timer_ltch_cmd_t __DP(ltch_cmd_rd_shadow)( __DN(t) * _dev )
{
    return _dev->ltch_cmd_shadow.val;
}

static inline void __DP(ltch_cmd_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(ltch_cmd_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_io_8(_dev->base,(0x3),val);
}

static inline void __DP(ltch_cmd_wr)( __DN(t) * _dev, lpc_timer_ltch_cmd_t val ) __attribute__ ((always_inline));
static inline void __DP(ltch_cmd_wr)( __DN(t) * _dev, lpc_timer_ltch_cmd_t val )
{
    lpc_timer_ltch_cmd_un  u;
    u.val = val;
    u.val._anon0 	= 0;
    mackerel_write_io_8(_dev->base,(0x3),u.raw);
    _dev->ltch_cmd_shadow.val = u.val;
}

static inline void __DP(ltch_cmd_select_wrf)( __DN(t) * _dev, lpc_timer_timer_cntsel_t val ) __attribute__ ((always_inline));
static inline void __DP(ltch_cmd_select_wrf)( __DN(t) * _dev, lpc_timer_timer_cntsel_t val )
{
    lpc_timer_ltch_cmd_un  u;
    u.val._anon0 	= 0;
    u.val.select = val;
    mackerel_write_io_8(_dev->base,(0x3),u.raw);
    _dev->ltch_cmd_shadow.val = u.val;
}


static inline int __DP(ltch_cmd_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ltch_cmd_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is not readable
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ltch_cmd (Counter latch command):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)_dev->ltch_cmd_shadow.val.select;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " select =\t0x%"PRIx8" (SHADOW of Counter select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = lpc_timer_timer_cntsel_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register sbyte_fmt0 (Int. timer 0 status format); type lpc_timer.sbyte_fmt (Interval timer status byte format)
 */

/*
 * Dump of fields for register: sbyte_fmt0
 *   bcd (size 1, offset 0):	 RO	  Binary coded decimal select
 *   mode (size 3, offset 1):	 RO	  Counter mode
 *   rwsel (size 2, offset 4):	 RO	  Read/write select
 *   cnt_stat (size 1, offset 6):	 RO	  Count register status
 *   cnt_out (size 1, offset 7):	 RO	  Counter OUT pin status
 */

static inline uint8_t __DP(sbyte_fmt0_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(sbyte_fmt0_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_io_8(_dev->base,(0x0));
}

static inline lpc_timer_sbyte_fmt_t __DP(sbyte_fmt0_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline lpc_timer_sbyte_fmt_t __DP(sbyte_fmt0_rd)( __DN(t) * _dev )
{
    lpc_timer_sbyte_fmt_un  u;
    u.raw = mackerel_read_io_8(_dev->base,(0x0));
    return u.val;
}

// Register sbyte_fmt0 is not writeable


static inline int __DP(sbyte_fmt0_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(sbyte_fmt0_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    lpc_timer_sbyte_fmt_un  u;
    u.raw = mackerel_read_io_8(_dev->base,(0x0));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register sbyte_fmt0 (Int. timer 0 status format):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.bcd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bcd =\t0x%"PRIx8" (Binary coded decimal select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mode =\t0x%"PRIx8" (Counter mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = lpc_timer_cnt_mode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rwsel;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rwsel =\t0x%"PRIx8" (Read/write select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = lpc_timer_timer_rwsel_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cnt_stat;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cnt_stat =\t0x%"PRIx8" (Count register status", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cnt_out;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cnt_out =\t0x%"PRIx8" (Counter OUT pin status", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register sbyte_fmt1 (Int. timer 1 status format); type lpc_timer.sbyte_fmt (Interval timer status byte format)
 */

/*
 * Dump of fields for register: sbyte_fmt1
 *   bcd (size 1, offset 0):	 RO	  Binary coded decimal select
 *   mode (size 3, offset 1):	 RO	  Counter mode
 *   rwsel (size 2, offset 4):	 RO	  Read/write select
 *   cnt_stat (size 1, offset 6):	 RO	  Count register status
 *   cnt_out (size 1, offset 7):	 RO	  Counter OUT pin status
 */

static inline uint8_t __DP(sbyte_fmt1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(sbyte_fmt1_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_io_8(_dev->base,(0x1));
}

static inline lpc_timer_sbyte_fmt_t __DP(sbyte_fmt1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline lpc_timer_sbyte_fmt_t __DP(sbyte_fmt1_rd)( __DN(t) * _dev )
{
    lpc_timer_sbyte_fmt_un  u;
    u.raw = mackerel_read_io_8(_dev->base,(0x1));
    return u.val;
}

// Register sbyte_fmt1 is not writeable


static inline int __DP(sbyte_fmt1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(sbyte_fmt1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    lpc_timer_sbyte_fmt_un  u;
    u.raw = mackerel_read_io_8(_dev->base,(0x1));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register sbyte_fmt1 (Int. timer 1 status format):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.bcd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bcd =\t0x%"PRIx8" (Binary coded decimal select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mode =\t0x%"PRIx8" (Counter mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = lpc_timer_cnt_mode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rwsel;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rwsel =\t0x%"PRIx8" (Read/write select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = lpc_timer_timer_rwsel_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cnt_stat;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cnt_stat =\t0x%"PRIx8" (Count register status", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cnt_out;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cnt_out =\t0x%"PRIx8" (Counter OUT pin status", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register sbyte_fmt2 (Int. timer 2 status format); type lpc_timer.sbyte_fmt (Interval timer status byte format)
 */

/*
 * Dump of fields for register: sbyte_fmt2
 *   bcd (size 1, offset 0):	 RO	  Binary coded decimal select
 *   mode (size 3, offset 1):	 RO	  Counter mode
 *   rwsel (size 2, offset 4):	 RO	  Read/write select
 *   cnt_stat (size 1, offset 6):	 RO	  Count register status
 *   cnt_out (size 1, offset 7):	 RO	  Counter OUT pin status
 */

static inline uint8_t __DP(sbyte_fmt2_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(sbyte_fmt2_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_io_8(_dev->base,(0x2));
}

static inline lpc_timer_sbyte_fmt_t __DP(sbyte_fmt2_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline lpc_timer_sbyte_fmt_t __DP(sbyte_fmt2_rd)( __DN(t) * _dev )
{
    lpc_timer_sbyte_fmt_un  u;
    u.raw = mackerel_read_io_8(_dev->base,(0x2));
    return u.val;
}

// Register sbyte_fmt2 is not writeable


static inline int __DP(sbyte_fmt2_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(sbyte_fmt2_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    lpc_timer_sbyte_fmt_un  u;
    u.raw = mackerel_read_io_8(_dev->base,(0x2));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register sbyte_fmt2 (Int. timer 2 status format):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.bcd;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bcd =\t0x%"PRIx8" (Binary coded decimal select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mode =\t0x%"PRIx8" (Counter mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = lpc_timer_cnt_mode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rwsel;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rwsel =\t0x%"PRIx8" (Read/write select", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = lpc_timer_timer_rwsel_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cnt_stat;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cnt_stat =\t0x%"PRIx8" (Count register status", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cnt_out;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cnt_out =\t0x%"PRIx8" (Counter OUT pin status", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register cntacc0 (Counter 0 access); type lpc_timer.uint8
 */

static inline uint8_t __DP(cntacc0_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(cntacc0_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_io_8(_dev->base,(0x0));
}

static inline uint8_t __DP(cntacc0_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(cntacc0_rd)( __DN(t) * _dev )
{
    return mackerel_read_io_8(_dev->base,(0x0));
}

static inline void __DP(cntacc0_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cntacc0_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_io_8(_dev->base,(0x0),val);
}

static inline void __DP(cntacc0_wr)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cntacc0_wr)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_io_8(_dev->base,(0x0),val);
}


static inline int __DP(cntacc0_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cntacc0_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cntacc0 (Counter 0 access):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_io_8(_dev->base,(0x0)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register cntacc1 (Counter 1 access); type lpc_timer.uint8
 */

static inline uint8_t __DP(cntacc1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(cntacc1_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_io_8(_dev->base,(0x1));
}

static inline uint8_t __DP(cntacc1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(cntacc1_rd)( __DN(t) * _dev )
{
    return mackerel_read_io_8(_dev->base,(0x1));
}

static inline void __DP(cntacc1_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cntacc1_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_io_8(_dev->base,(0x1),val);
}

static inline void __DP(cntacc1_wr)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cntacc1_wr)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_io_8(_dev->base,(0x1),val);
}


static inline int __DP(cntacc1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cntacc1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cntacc1 (Counter 1 access):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_io_8(_dev->base,(0x1)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register cntacc2 (Counter 2 access); type lpc_timer.uint8
 */

static inline uint8_t __DP(cntacc2_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(cntacc2_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_io_8(_dev->base,(0x2));
}

static inline uint8_t __DP(cntacc2_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(cntacc2_rd)( __DN(t) * _dev )
{
    return mackerel_read_io_8(_dev->base,(0x2));
}

static inline void __DP(cntacc2_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cntacc2_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_io_8(_dev->base,(0x2),val);
}

static inline void __DP(cntacc2_wr)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cntacc2_wr)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_io_8(_dev->base,(0x2),val);
}


static inline int __DP(cntacc2_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cntacc2_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cntacc2 (Counter 2 access):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_io_8(_dev->base,(0x2)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Dump of device lpc_timer (LPC Timer):\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tcw_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rdbk_cmd_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ltch_cmd_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(sbyte_fmt0_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(sbyte_fmt1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(sbyte_fmt2_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cntacc0_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cntacc1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cntacc2_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "End of dump of device lpc_timer\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR


#endif // __lpc_timer_H
