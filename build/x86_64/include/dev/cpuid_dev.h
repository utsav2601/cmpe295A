/*
 * DEVICE DEFINITION: ia32 / Intel64 CPUID instruction results
 * 
 * Copyright (c) 2007, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich.
 *  Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED: DO NOT EDIT!
 */

#ifndef __cpuid_H
#define __cpuid_H

#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR
#define __DN(x) cpuid ## _ ## x
#ifdef cpuid_PREFIX
#define __DP(x) __DP1(x,cpuid_PREFIX)
#define __DP1(x1,x2) __DP2(x1,x2)
#define __DP2(x1,x2) x2 ## x1
#else
#define __DP(x) cpuid##_ ##x
#endif
#define __STR(x) #x
#define __XTR(x) __STR(x)

/*
 * Constant definition: cpuid.intel_cache_desc (Intel Cache & TLB descriptors)
 */
typedef enum cpuid_intel_cache_desc_t {
    __DP(null_cd) = (0x0),
    __DP(itlb_4k_4w_32) = (0x1),
    __DP(itlb_4m_4w_2) = (0x2),
    __DP(dtlb_4k_4w_64) = (0x3),
    __DP(dtlb_4m_4w_8) = (0x4),
    __DP(dtlb1_4m_4w_32) = (0x5),
    __DP(l1i_8k_4w_32) = (0x6),
    __DP(l1i_16k_4w_32) = (0x8),
    __DP(l1d_8k_2w_32) = (0xa),
    __DP(itlb_4m_4w_4) = (0xb),
    __DP(l1d_16k_4w_32) = (0xc),
    __DP(l3_512k_4w_64_2) = (0x22),
    __DP(l3_1m_8w_64_2) = (0x23),
    __DP(l3_2m_8w_64_2) = (0x25),
    __DP(l3_4m_8w_64_2) = (0x29),
    __DP(l1d_32k_8w_64) = (0x2c),
    __DP(l1i_32k_8w_64) = (0x30),
    __DP(no_l2_l3) = (0x40),
    __DP(l2_128k_4w_32) = (0x41),
    __DP(l2_256k_4w_32) = (0x42),
    __DP(l2_512k_4w_32) = (0x43),
    __DP(l2_1m_4w_32) = (0x44),
    __DP(l2_2m_4w_32) = (0x45),
    __DP(l3_4m_4w_64) = (0x46),
    __DP(l3_8m_8w_64) = (0x47),
    __DP(l2_4m_16w_64) = (0x49),
    __DP(itlb_4k2m4n_64) = (0x50),
    __DP(itlb_4k2m4n_128) = (0x51),
    __DP(itlb_4k2m4n_256) = (0x52),
    __DP(dtlb0_4m_4w_16) = (0x56),
    __DP(dtlb0_4k_4w_16) = (0x57),
    __DP(dtlb_4k4m_64) = (0x5b),
    __DP(dtlb_4k4m_128) = (0x5c),
    __DP(dtlb_4k4m_256) = (0x5d),
    __DP(l1d_16k_8w_64) = (0x60),
    __DP(l1d_8k_4w_64) = (0x66),
    __DP(l1d_16k_4w_64) = (0x67),
    __DP(l1d_32k_4w_64) = (0x68),
    __DP(tc_12k_8w) = (0x70),
    __DP(tc_16k_8w) = (0x71),
    __DP(tc_32k_8w) = (0x72),
    __DP(l2_1M_4w_64) = (0x78),
    __DP(l2_128k_8w_64_2) = (0x79),
    __DP(l2_256k_8w_64_2) = (0x7a),
    __DP(l2_512k_8w_64_2) = (0x7b),
    __DP(l2_1M_8w_64_2) = (0x7c),
    __DP(l2_2M_8w_64) = (0x7d),
    __DP(l2_512k_2w_64) = (0x7f),
    __DP(l2_256k_8w_32) = (0x82),
    __DP(l2_512k_8w_32) = (0x83),
    __DP(l2_1M_8w_32) = (0x84),
    __DP(l2_2M_8w_32) = (0x85),
    __DP(l2_512k_4w_64) = (0x86),
    __DP(l2_1M_8w_64) = (0x87),
    __DP(itlb_4k_4w_128) = (0xb0),
    __DP(dtlb_4k_4w_128) = (0xb3),
    __DP(dtlb1_4k_4w_256) = (0xb4),
    __DP(pref_64) = (0xf0),
    __DP(pref_128) = (0xf1),
} cpuid_intel_cache_desc_t;

static inline int cpuid_intel_cache_desc_prt( char * s, size_t sz, cpuid_intel_cache_desc_t e ) __attribute__ ((always_inline));
static inline int cpuid_intel_cache_desc_prt( char * s, size_t sz, cpuid_intel_cache_desc_t e )
{
    switch (e) {
        case __DP(null_cd):
        return snprintf(s, sz, "%s", "Null descriptor");
        case __DP(itlb_4k_4w_32):
        return snprintf(s, sz, "%s", "ITLB, 4k pages, 4-way, 32 entries");
        case __DP(itlb_4m_4w_2):
        return snprintf(s, sz, "%s", "ITLB, 4M pages, 4-way, 2 entries");
        case __DP(dtlb_4k_4w_64):
        return snprintf(s, sz, "%s", "DTLB, 4k pages, 4-way, 64 entries");
        case __DP(dtlb_4m_4w_8):
        return snprintf(s, sz, "%s", "DTLB, 4M pages, 4-way, 8 entries");
        case __DP(dtlb1_4m_4w_32):
        return snprintf(s, sz, "%s", "DTLB1, 4M pages, 4-way, 32 entries");
        case __DP(l1i_8k_4w_32):
        return snprintf(s, sz, "%s", "L1 Icache, 8k, 4-way, 32b lines");
        case __DP(l1i_16k_4w_32):
        return snprintf(s, sz, "%s", "L1 Icache, 16k, 4-way, 32b lines");
        case __DP(l1d_8k_2w_32):
        return snprintf(s, sz, "%s", "L1 Dcache, 8k, 2-way, 32b lines");
        case __DP(itlb_4m_4w_4):
        return snprintf(s, sz, "%s", "ITLB, 4M pages, 4-way, 4 entries");
        case __DP(l1d_16k_4w_32):
        return snprintf(s, sz, "%s", "L1 Dcache, 16k, 4-way, 32b lines");
        case __DP(l3_512k_4w_64_2):
        return snprintf(s, sz, "%s", "L3 cache, 512k, 4-way, 64b lines, 2/sector");
        case __DP(l3_1m_8w_64_2):
        return snprintf(s, sz, "%s", "L3 cache, 1M, 8-way, 64b lines, 2/sector");
        case __DP(l3_2m_8w_64_2):
        return snprintf(s, sz, "%s", "L3 cache, 2M, 8-way, 64b lines, 2/sector");
        case __DP(l3_4m_8w_64_2):
        return snprintf(s, sz, "%s", "L3 cache, 4M, 8-way, 64b lines, 2/sector");
        case __DP(l1d_32k_8w_64):
        return snprintf(s, sz, "%s", "L1 Dcache, 32k, 8-way, 64b lines");
        case __DP(l1i_32k_8w_64):
        return snprintf(s, sz, "%s", "L1 Icache, 32k, 8-way, 64b lines");
        case __DP(no_l2_l3):
        return snprintf(s, sz, "%s", "No L2 or L3 cache");
        case __DP(l2_128k_4w_32):
        return snprintf(s, sz, "%s", "L2 cache, 128k, 4-way, 32b lines");
        case __DP(l2_256k_4w_32):
        return snprintf(s, sz, "%s", "L2 cache, 256k, 4-way, 32b lines");
        case __DP(l2_512k_4w_32):
        return snprintf(s, sz, "%s", "L2 cache, 512k, 4-way, 32b lines");
        case __DP(l2_1m_4w_32):
        return snprintf(s, sz, "%s", "L2 cache, 1M, 4-way, 32b lines");
        case __DP(l2_2m_4w_32):
        return snprintf(s, sz, "%s", "L2 cache, 2M, 4-way, 32b lines");
        case __DP(l3_4m_4w_64):
        return snprintf(s, sz, "%s", "L3 cache, 4M, 4-way, 64b lines");
        case __DP(l3_8m_8w_64):
        return snprintf(s, sz, "%s", "L3 cache, 8M, 8-way, 64b lines");
        case __DP(l2_4m_16w_64):
        return snprintf(s, sz, "%s", "L2 cache, 4M, 16-way, 64b lines");
        case __DP(itlb_4k2m4n_64):
        return snprintf(s, sz, "%s", "ITLB, 4k & 2M or 4M pages, 64 entries");
        case __DP(itlb_4k2m4n_128):
        return snprintf(s, sz, "%s", "ITLB, 4k & 2M or 4M pages, 128 entries");
        case __DP(itlb_4k2m4n_256):
        return snprintf(s, sz, "%s", "ITLB, 4k & 2M or 4M pages, 256 entries");
        case __DP(dtlb0_4m_4w_16):
        return snprintf(s, sz, "%s", "DTLB0, 4M pages, 4-way, 16 entries");
        case __DP(dtlb0_4k_4w_16):
        return snprintf(s, sz, "%s", "DTLB0, 4k pages, 4-way, 16 entries");
        case __DP(dtlb_4k4m_64):
        return snprintf(s, sz, "%s", "DTLB, 4k & 4M pages, 64 entries");
        case __DP(dtlb_4k4m_128):
        return snprintf(s, sz, "%s", "DTLB, 4k & 4M pages, 128 entries");
        case __DP(dtlb_4k4m_256):
        return snprintf(s, sz, "%s", "DTLB, 4k & 4M pages, 256 entries");
        case __DP(l1d_16k_8w_64):
        return snprintf(s, sz, "%s", "L1 Dcache, 16k, 8-way, 64b lines");
        case __DP(l1d_8k_4w_64):
        return snprintf(s, sz, "%s", "L1 Dcache, 8k, 4-way, 64b lines");
        case __DP(l1d_16k_4w_64):
        return snprintf(s, sz, "%s", "L1 Dcache, 16k, 4-way, 64b lines");
        case __DP(l1d_32k_4w_64):
        return snprintf(s, sz, "%s", "L1 Dcache, 32k, 4-way, 64b lines");
        case __DP(tc_12k_8w):
        return snprintf(s, sz, "%s", "Trace cache, 12k-uop, 8-way");
        case __DP(tc_16k_8w):
        return snprintf(s, sz, "%s", "Trace cache, 16k-uop, 8-way");
        case __DP(tc_32k_8w):
        return snprintf(s, sz, "%s", "Trace cache, 32k-uop, 8-way");
        case __DP(l2_1M_4w_64):
        return snprintf(s, sz, "%s", "L2 cache, 1M, 4-way, 64b lines");
        case __DP(l2_128k_8w_64_2):
        return snprintf(s, sz, "%s", "L2 cache, 128k, 8-way, 64b lines, 2/sector");
        case __DP(l2_256k_8w_64_2):
        return snprintf(s, sz, "%s", "L2 cache, 256k, 8-way, 64b lines, 2/sector");
        case __DP(l2_512k_8w_64_2):
        return snprintf(s, sz, "%s", "L2 cache, 512k, 8-way, 64b lines, 2/sector");
        case __DP(l2_1M_8w_64_2):
        return snprintf(s, sz, "%s", "L2 cache, 1M, 8-way, 64b lines, 2/sector");
        case __DP(l2_2M_8w_64):
        return snprintf(s, sz, "%s", "L2 cache, 2M, 8-way, 64b lines");
        case __DP(l2_512k_2w_64):
        return snprintf(s, sz, "%s", "L2 cache, 512k, 2-way, 64b lines");
        case __DP(l2_256k_8w_32):
        return snprintf(s, sz, "%s", "L2 cache, 256k, 8-way, 32b lines");
        case __DP(l2_512k_8w_32):
        return snprintf(s, sz, "%s", "L2 cache, 512k, 8-way, 32b lines");
        case __DP(l2_1M_8w_32):
        return snprintf(s, sz, "%s", "L2 cache, 1M, 8-way, 32b lines");
        case __DP(l2_2M_8w_32):
        return snprintf(s, sz, "%s", "L2 cache, 2M, 8-way, 32b lines");
        case __DP(l2_512k_4w_64):
        return snprintf(s, sz, "%s", "L2 cache, 512k, 4-way, 64b lines");
        case __DP(l2_1M_8w_64):
        return snprintf(s, sz, "%s", "L2 cache, 1M, 8-way, 64b lines");
        case __DP(itlb_4k_4w_128):
        return snprintf(s, sz, "%s", "ITLB, 4k pages, 4-way, 128 entries");
        case __DP(dtlb_4k_4w_128):
        return snprintf(s, sz, "%s", "DTLB, 4k pages, 4-way, 128 entries");
        case __DP(dtlb1_4k_4w_256):
        return snprintf(s, sz, "%s", "DTLB1, 4k pages, 4-way, 256 entries");
        case __DP(pref_64):
        return snprintf(s, sz, "%s", "64-byte prefetching");
        case __DP(pref_128):
        return snprintf(s, sz, "%s", "128-byte prefetching");
        default:
        return snprintf(s, sz, "Unknown " __XTR(cpuid_intel_cache_desc_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int cpuid_intel_cache_desc_chk( cpuid_intel_cache_desc_t e ) __attribute__ ((always_inline));
static inline int cpuid_intel_cache_desc_chk( cpuid_intel_cache_desc_t e )
{
    switch (e) {
        case __DP(null_cd):
        return 1;
        case __DP(itlb_4k_4w_32):
        return 1;
        case __DP(itlb_4m_4w_2):
        return 1;
        case __DP(dtlb_4k_4w_64):
        return 1;
        case __DP(dtlb_4m_4w_8):
        return 1;
        case __DP(dtlb1_4m_4w_32):
        return 1;
        case __DP(l1i_8k_4w_32):
        return 1;
        case __DP(l1i_16k_4w_32):
        return 1;
        case __DP(l1d_8k_2w_32):
        return 1;
        case __DP(itlb_4m_4w_4):
        return 1;
        case __DP(l1d_16k_4w_32):
        return 1;
        case __DP(l3_512k_4w_64_2):
        return 1;
        case __DP(l3_1m_8w_64_2):
        return 1;
        case __DP(l3_2m_8w_64_2):
        return 1;
        case __DP(l3_4m_8w_64_2):
        return 1;
        case __DP(l1d_32k_8w_64):
        return 1;
        case __DP(l1i_32k_8w_64):
        return 1;
        case __DP(no_l2_l3):
        return 1;
        case __DP(l2_128k_4w_32):
        return 1;
        case __DP(l2_256k_4w_32):
        return 1;
        case __DP(l2_512k_4w_32):
        return 1;
        case __DP(l2_1m_4w_32):
        return 1;
        case __DP(l2_2m_4w_32):
        return 1;
        case __DP(l3_4m_4w_64):
        return 1;
        case __DP(l3_8m_8w_64):
        return 1;
        case __DP(l2_4m_16w_64):
        return 1;
        case __DP(itlb_4k2m4n_64):
        return 1;
        case __DP(itlb_4k2m4n_128):
        return 1;
        case __DP(itlb_4k2m4n_256):
        return 1;
        case __DP(dtlb0_4m_4w_16):
        return 1;
        case __DP(dtlb0_4k_4w_16):
        return 1;
        case __DP(dtlb_4k4m_64):
        return 1;
        case __DP(dtlb_4k4m_128):
        return 1;
        case __DP(dtlb_4k4m_256):
        return 1;
        case __DP(l1d_16k_8w_64):
        return 1;
        case __DP(l1d_8k_4w_64):
        return 1;
        case __DP(l1d_16k_4w_64):
        return 1;
        case __DP(l1d_32k_4w_64):
        return 1;
        case __DP(tc_12k_8w):
        return 1;
        case __DP(tc_16k_8w):
        return 1;
        case __DP(tc_32k_8w):
        return 1;
        case __DP(l2_1M_4w_64):
        return 1;
        case __DP(l2_128k_8w_64_2):
        return 1;
        case __DP(l2_256k_8w_64_2):
        return 1;
        case __DP(l2_512k_8w_64_2):
        return 1;
        case __DP(l2_1M_8w_64_2):
        return 1;
        case __DP(l2_2M_8w_64):
        return 1;
        case __DP(l2_512k_2w_64):
        return 1;
        case __DP(l2_256k_8w_32):
        return 1;
        case __DP(l2_512k_8w_32):
        return 1;
        case __DP(l2_1M_8w_32):
        return 1;
        case __DP(l2_2M_8w_32):
        return 1;
        case __DP(l2_512k_4w_64):
        return 1;
        case __DP(l2_1M_8w_64):
        return 1;
        case __DP(itlb_4k_4w_128):
        return 1;
        case __DP(dtlb_4k_4w_128):
        return 1;
        case __DP(dtlb1_4k_4w_256):
        return 1;
        case __DP(pref_64):
        return 1;
        case __DP(pref_128):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: cpuid.intel_cache_type (Intel cache type field)
 */
typedef enum cpuid_intel_cache_type_t {
    __DP(ct_null) = (0x0),
    __DP(ct_data) = (0x1),
    __DP(ct_instruction) = (0x2),
    __DP(ct_unified) = (0x3),
} cpuid_intel_cache_type_t;

static inline int cpuid_intel_cache_type_prt( char * s, size_t sz, cpuid_intel_cache_type_t e ) __attribute__ ((always_inline));
static inline int cpuid_intel_cache_type_prt( char * s, size_t sz, cpuid_intel_cache_type_t e )
{
    switch (e) {
        case __DP(ct_null):
        return snprintf(s, sz, "%s", "Null, no more caches");
        case __DP(ct_data):
        return snprintf(s, sz, "%s", "Data cache");
        case __DP(ct_instruction):
        return snprintf(s, sz, "%s", "Instruction cache");
        case __DP(ct_unified):
        return snprintf(s, sz, "%s", "Unified cache");
        default:
        return snprintf(s, sz, "Unknown " __XTR(cpuid_intel_cache_type_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int cpuid_intel_cache_type_chk( cpuid_intel_cache_type_t e ) __attribute__ ((always_inline));
static inline int cpuid_intel_cache_type_chk( cpuid_intel_cache_type_t e )
{
    switch (e) {
        case __DP(ct_null):
        return 1;
        case __DP(ct_data):
        return 1;
        case __DP(ct_instruction):
        return 1;
        case __DP(ct_unified):
        return 1;
        default:
        return 0;
    }
}


/*
 * Register type: Implicit type of Version information register
 */

/*
 * Dump of fields for register type: cpuid_ver_info_t
 *   stepping (size 4, offset 0):	 RO	  Stepping ID
 *   model (size 4, offset 4):	 RO	  Model ID
 *   family (size 4, offset 8):	 RO	  Family ID
 *   proc_type (size 2, offset 12):	 RO	  Processor type (Intel only)
 *   _anon14 (size 2, offset 14):	 MBZ	  _
 *   extmodel (size 4, offset 16):	 RO	  Extended model ID
 *   extfamily (size 8, offset 20):	 RO	  Extended family ID
 *   _anon28 (size 4, offset 28):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_ver_info_t {
    uint8_t	stepping	:4;
    uint8_t	model	:4;
    uint8_t	family	:4;
    uint8_t	proc_type	:2;
    uint8_t	_anon14	:2;
    uint8_t	extmodel	:4;
    uint8_t	extfamily	:8;
    uint8_t	_anon28	:4;
} __attribute__ ((packed))
 cpuid_ver_info_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_ver_info_t, sizeof(uint32_t));

typedef union cpuid_ver_info_un {
    cpuid_ver_info_t	val;
    uint32_t	raw;
}
 cpuid_ver_info_un;
static inline int cpuid_ver_info_prtval( char * s, size_t sz, cpuid_ver_info_t v ) __attribute__ ((always_inline));
static inline int cpuid_ver_info_prtval( char * s, size_t sz, cpuid_ver_info_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " stepping=0x%"PRIx8" (Stepping ID)\n", (uint8_t)(v.stepping));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " model=0x%"PRIx8" (Model ID)\n", (uint8_t)(v.model));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " family=0x%"PRIx8" (Family ID)\n", (uint8_t)(v.family));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " proc_type=0x%"PRIx8" (Processor type (Intel only))\n", (uint8_t)(v.proc_type));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " extmodel=0x%"PRIx8" (Extended model ID)\n", (uint8_t)(v.extmodel));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " extfamily=0x%"PRIx8" (Extended family ID)\n", (uint8_t)(v.extfamily));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Brand Index, APIC info register
 */

/*
 * Dump of fields for register type: cpuid_brand_ndx_t
 *   brand (size 8, offset 0):	 RO	  Brand index
 *   cflush_sz (size 8, offset 8):	 RO	  CFLUSH line size
 *   max_log_proc (size 8, offset 16):	 RO	  Max. # logical processors in this package
 *   init_apic_id (size 8, offset 24):	 RO	  Initial local APIC physical ID
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_brand_ndx_t {
    uint8_t	brand	:8;
    uint8_t	cflush_sz	:8;
    uint8_t	max_log_proc	:8;
    uint8_t	init_apic_id	:8;
} __attribute__ ((packed))
 cpuid_brand_ndx_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_brand_ndx_t, sizeof(uint32_t));

typedef union cpuid_brand_ndx_un {
    cpuid_brand_ndx_t	val;
    uint32_t	raw;
}
 cpuid_brand_ndx_un;
static inline int cpuid_brand_ndx_prtval( char * s, size_t sz, cpuid_brand_ndx_t v ) __attribute__ ((always_inline));
static inline int cpuid_brand_ndx_prtval( char * s, size_t sz, cpuid_brand_ndx_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " brand=0x%"PRIx8" (Brand index)\n", (uint8_t)(v.brand));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cflush_sz=0x%"PRIx8" (CFLUSH line size)\n", (uint8_t)(v.cflush_sz));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " max_log_proc=0x%"PRIx8" (Max. # logical processors in this package)\n", (uint8_t)(v.max_log_proc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " init_apic_id=0x%"PRIx8" (Initial local APIC physical ID)\n", (uint8_t)(v.init_apic_id));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Feature information register
 */

/*
 * Dump of fields for register type: cpuid_feat_info_t
 *   fpu_x87 (size 1, offset 0):	 RO	  FPU on chip
 *   vme (size 1, offset 1):	 RO	  Virtual-8086 mode enhancement
 *   de (size 1, offset 2):	 RO	  Debugging extensions
 *   pse (size 1, offset 3):	 RO	  Page size extensions
 *   tsc (size 1, offset 4):	 RO	  Time stamp counter
 *   msr (size 1, offset 5):	 RO	  RDMSR and WRMSR support
 *   pae (size 1, offset 6):	 RO	  Physical address extensions
 *   mce (size 1, offset 7):	 RO	  Machine check exception
 *   cx8 (size 1, offset 8):	 RO	  CMPXCHG8B instruction
 *   apic (size 1, offset 9):	 RO	  APIC on chip
 *   _anon10 (size 1, offset 10):	 RSVD	  _
 *   sep (size 1, offset 11):	 RO	  SYSENTER and SYSEXIT
 *   mtrr (size 1, offset 12):	 RO	  Memory type range registers
 *   pge (size 1, offset 13):	 RO	  PTE global bit
 *   mca (size 1, offset 14):	 RO	  Machine check architecture
 *   cmov (size 1, offset 15):	 RO	  Conditional move/compare instruction
 *   pat (size 1, offset 16):	 RO	  Page attribute table
 *   pse36 (size 1, offset 17):	 RO	  Page size extension
 *   psn (size 1, offset 18):	 RO	  Processor serial number
 *   clfsh (size 1, offset 19):	 RO	  CFLUSH instruction
 *   _anon20 (size 1, offset 20):	 RSVD	  _
 *   ds (size 1, offset 21):	 RO	  Debug store
 *   acpi (size 1, offset 22):	 RO	  Thermal monitor and clock control
 *   mmx (size 1, offset 23):	 RO	  MMX technology
 *   fxsr (size 1, offset 24):	 RO	  FXSAVE / FXRSTOR
 *   sse (size 1, offset 25):	 RO	  SSE instructions
 *   sse2 (size 1, offset 26):	 RO	  SSE2 instructions
 *   ss (size 1, offset 27):	 RO	  Self-snoop
 *   htt (size 1, offset 28):	 RO	  Multi-threading
 *   tm (size 1, offset 29):	 RO	  Thermal monitor
 *   _anon30 (size 1, offset 30):	 RSVD	  _
 *   pbe (size 1, offset 31):	 RO	  Pending break enable
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_feat_info_t {
    uint8_t	fpu_x87	:1;
    uint8_t	vme	:1;
    uint8_t	de	:1;
    uint8_t	pse	:1;
    uint8_t	tsc	:1;
    uint8_t	msr	:1;
    uint8_t	pae	:1;
    uint8_t	mce	:1;
    uint8_t	cx8	:1;
    uint8_t	apic	:1;
    uint8_t	_anon10	:1;
    uint8_t	sep	:1;
    uint8_t	mtrr	:1;
    uint8_t	pge	:1;
    uint8_t	mca	:1;
    uint8_t	cmov	:1;
    uint8_t	pat	:1;
    uint8_t	pse36	:1;
    uint8_t	psn	:1;
    uint8_t	clfsh	:1;
    uint8_t	_anon20	:1;
    uint8_t	ds	:1;
    uint8_t	acpi	:1;
    uint8_t	mmx	:1;
    uint8_t	fxsr	:1;
    uint8_t	sse	:1;
    uint8_t	sse2	:1;
    uint8_t	ss	:1;
    uint8_t	htt	:1;
    uint8_t	tm	:1;
    uint8_t	_anon30	:1;
    uint8_t	pbe	:1;
} __attribute__ ((packed))
 cpuid_feat_info_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_feat_info_t, sizeof(uint32_t));

typedef union cpuid_feat_info_un {
    cpuid_feat_info_t	val;
    uint32_t	raw;
}
 cpuid_feat_info_un;
static inline int cpuid_feat_info_prtval( char * s, size_t sz, cpuid_feat_info_t v ) __attribute__ ((always_inline));
static inline int cpuid_feat_info_prtval( char * s, size_t sz, cpuid_feat_info_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fpu_x87=0x%"PRIx8" (FPU on chip)\n", (uint8_t)(v.fpu_x87));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vme=0x%"PRIx8" (Virtual-8086 mode enhancement)\n", (uint8_t)(v.vme));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " de=0x%"PRIx8" (Debugging extensions)\n", (uint8_t)(v.de));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pse=0x%"PRIx8" (Page size extensions)\n", (uint8_t)(v.pse));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tsc=0x%"PRIx8" (Time stamp counter)\n", (uint8_t)(v.tsc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " msr=0x%"PRIx8" (RDMSR and WRMSR support)\n", (uint8_t)(v.msr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pae=0x%"PRIx8" (Physical address extensions)\n", (uint8_t)(v.pae));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mce=0x%"PRIx8" (Machine check exception)\n", (uint8_t)(v.mce));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cx8=0x%"PRIx8" (CMPXCHG8B instruction)\n", (uint8_t)(v.cx8));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " apic=0x%"PRIx8" (APIC on chip)\n", (uint8_t)(v.apic));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sep=0x%"PRIx8" (SYSENTER and SYSEXIT)\n", (uint8_t)(v.sep));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mtrr=0x%"PRIx8" (Memory type range registers)\n", (uint8_t)(v.mtrr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pge=0x%"PRIx8" (PTE global bit)\n", (uint8_t)(v.pge));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mca=0x%"PRIx8" (Machine check architecture)\n", (uint8_t)(v.mca));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cmov=0x%"PRIx8" (Conditional move/compare instruction)\n", (uint8_t)(v.cmov));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pat=0x%"PRIx8" (Page attribute table)\n", (uint8_t)(v.pat));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pse36=0x%"PRIx8" (Page size extension)\n", (uint8_t)(v.pse36));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " psn=0x%"PRIx8" (Processor serial number)\n", (uint8_t)(v.psn));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " clfsh=0x%"PRIx8" (CFLUSH instruction)\n", (uint8_t)(v.clfsh));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ds=0x%"PRIx8" (Debug store)\n", (uint8_t)(v.ds));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " acpi=0x%"PRIx8" (Thermal monitor and clock control)\n", (uint8_t)(v.acpi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mmx=0x%"PRIx8" (MMX technology)\n", (uint8_t)(v.mmx));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fxsr=0x%"PRIx8" (FXSAVE / FXRSTOR)\n", (uint8_t)(v.fxsr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sse=0x%"PRIx8" (SSE instructions)\n", (uint8_t)(v.sse));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sse2=0x%"PRIx8" (SSE2 instructions)\n", (uint8_t)(v.sse2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ss=0x%"PRIx8" (Self-snoop)\n", (uint8_t)(v.ss));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " htt=0x%"PRIx8" (Multi-threading)\n", (uint8_t)(v.htt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tm=0x%"PRIx8" (Thermal monitor)\n", (uint8_t)(v.tm));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pbe=0x%"PRIx8" (Pending break enable)\n", (uint8_t)(v.pbe));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Extended feature information register
 */

/*
 * Dump of fields for register type: cpuid_ext_feat_info_t
 *   sse3 (size 1, offset 0):	 RO	  SSE3 extensions
 *   _anon1 (size 2, offset 1):	 RSVD	  _
 *   monitor (size 1, offset 3):	 RO	  MONITOR/MWAIT
 *   ds_cpl (size 1, offset 4):	 RO	  CPL qualified debug store
 *   vmx (size 1, offset 5):	 RO	  Virtual machine extensions
 *   smx (size 1, offset 6):	 RO	  Safer mode extensions
 *   est (size 1, offset 7):	 RO	  Enhanced Intel SpeedStep(tm) technology
 *   tm2 (size 1, offset 8):	 RO	  Thermal monitor 2
 *   ssse3 (size 1, offset 9):	 RO	  Supplemental SSE3 extensions
 *   cnxt_id (size 1, offset 10):	 RO	  L1 context ID
 *   _anon11 (size 2, offset 11):	 RSVD	  _
 *   cmpxchg16b (size 1, offset 13):	 RO	  CMPXCHG16B available
 *   xtpr_up (size 1, offset 14):	 RO	  xTPR update control
 *   pdcm (size 1, offset 15):	 RO	  Perfmon and debug capability
 *   _anon16 (size 3, offset 16):	 RSVD	  _
 *   sse4_1 (size 1, offset 19):	 RO	  SSE4.1
 *   sse4_2 (size 1, offset 20):	 RO	  SSE4.2
 *   _anon21 (size 2, offset 21):	 RSVD	  _
 *   popcnt (size 1, offset 23):	 RO	  POPCNT instruction
 *   _anon24 (size 8, offset 24):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_ext_feat_info_t {
    uint8_t	sse3	:1;
    uint8_t	_anon1	:2;
    uint8_t	monitor	:1;
    uint8_t	ds_cpl	:1;
    uint8_t	vmx	:1;
    uint8_t	smx	:1;
    uint8_t	est	:1;
    uint8_t	tm2	:1;
    uint8_t	ssse3	:1;
    uint8_t	cnxt_id	:1;
    uint8_t	_anon11	:2;
    uint8_t	cmpxchg16b	:1;
    uint8_t	xtpr_up	:1;
    uint8_t	pdcm	:1;
    uint8_t	_anon16	:3;
    uint8_t	sse4_1	:1;
    uint8_t	sse4_2	:1;
    uint8_t	_anon21	:2;
    uint8_t	popcnt	:1;
    uint8_t	_anon24	:8;
} __attribute__ ((packed))
 cpuid_ext_feat_info_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_ext_feat_info_t, sizeof(uint32_t));

typedef union cpuid_ext_feat_info_un {
    cpuid_ext_feat_info_t	val;
    uint32_t	raw;
}
 cpuid_ext_feat_info_un;
static inline int cpuid_ext_feat_info_prtval( char * s, size_t sz, cpuid_ext_feat_info_t v ) __attribute__ ((always_inline));
static inline int cpuid_ext_feat_info_prtval( char * s, size_t sz, cpuid_ext_feat_info_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sse3=0x%"PRIx8" (SSE3 extensions)\n", (uint8_t)(v.sse3));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " monitor=0x%"PRIx8" (MONITOR/MWAIT)\n", (uint8_t)(v.monitor));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ds_cpl=0x%"PRIx8" (CPL qualified debug store)\n", (uint8_t)(v.ds_cpl));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vmx=0x%"PRIx8" (Virtual machine extensions)\n", (uint8_t)(v.vmx));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " smx=0x%"PRIx8" (Safer mode extensions)\n", (uint8_t)(v.smx));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " est=0x%"PRIx8" (Enhanced Intel SpeedStep(tm) technology)\n", (uint8_t)(v.est));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tm2=0x%"PRIx8" (Thermal monitor 2)\n", (uint8_t)(v.tm2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ssse3=0x%"PRIx8" (Supplemental SSE3 extensions)\n", (uint8_t)(v.ssse3));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cnxt_id=0x%"PRIx8" (L1 context ID)\n", (uint8_t)(v.cnxt_id));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cmpxchg16b=0x%"PRIx8" (CMPXCHG16B available)\n", (uint8_t)(v.cmpxchg16b));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " xtpr_up=0x%"PRIx8" (xTPR update control)\n", (uint8_t)(v.xtpr_up));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pdcm=0x%"PRIx8" (Perfmon and debug capability)\n", (uint8_t)(v.pdcm));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sse4_1=0x%"PRIx8" (SSE4.1)\n", (uint8_t)(v.sse4_1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sse4_2=0x%"PRIx8" (SSE4.2)\n", (uint8_t)(v.sse4_2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " popcnt=0x%"PRIx8" (POPCNT instruction)\n", (uint8_t)(v.popcnt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Cache type information register array
 */

/*
 * Dump of fields for register type: cpuid_cache_type_t
 *   ctf (size 5, offset 0):	 NOATTR	  Cache type
 *   level (size 3, offset 5):	 NOATTR	  Cache level (starts at 1)
 *   self_init (size 1, offset 8):	 NOATTR	  Self initializing
 *   fully_assoc (size 1, offset 9):	 NOATTR	  Fully associative
 *   wb_inval (size 1, offset 10):	 NOATTR	  Write-back invalidate/invalidate
 *   inclusiveness (size 1, offset 11):	 NOATTR	  Cache inclusiveness
 *   _anon12 (size 2, offset 12):	 RSVD	  _
 *   max_threads (size 12, offset 14):	 NOATTR	  Max. # threads sharing this cache in package
 *   max_procs (size 6, offset 26):	 NOATTR	  Max. # processor cores in this package
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_cache_type_t {
    cpuid_intel_cache_type_t	ctf	:5;
    uint8_t	level	:3;
    uint8_t	self_init	:1;
    uint8_t	fully_assoc	:1;
    uint8_t	wb_inval	:1;
    uint8_t	inclusiveness	:1;
    uint8_t	_anon12	:2;
    uint16_t	max_threads	:12;
    uint8_t	max_procs	:6;
} __attribute__ ((packed))
 cpuid_cache_type_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_cache_type_t, sizeof(uint32_t));

typedef union cpuid_cache_type_un {
    cpuid_cache_type_t	val;
    uint32_t	raw;
}
 cpuid_cache_type_un;
static inline int cpuid_cache_type_prtval( char * s, size_t sz, cpuid_cache_type_t v ) __attribute__ ((always_inline));
static inline int cpuid_cache_type_prtval( char * s, size_t sz, cpuid_cache_type_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " ctf=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = cpuid_intel_cache_type_prt(s+r, _avail, v.ctf);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Cache type)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " level=0x%"PRIx8" (Cache level (starts at 1))\n", (uint8_t)(v.level));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " self_init=0x%"PRIx8" (Self initializing)\n", (uint8_t)(v.self_init));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fully_assoc=0x%"PRIx8" (Fully associative)\n", (uint8_t)(v.fully_assoc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wb_inval=0x%"PRIx8" (Write-back invalidate/invalidate)\n", (uint8_t)(v.wb_inval));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " inclusiveness=0x%"PRIx8" (Cache inclusiveness)\n", (uint8_t)(v.inclusiveness));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " max_threads=0x%0"PRIx16" (Max. # threads sharing this cache in package)\n", (uint16_t)(v.max_threads));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " max_procs=0x%"PRIx8" (Max. # processor cores in this package)\n", (uint8_t)(v.max_procs));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Cache parameters register array
 */

/*
 * Dump of fields for register type: cpuid_cache_pars_t
 *   l (size 12, offset 0):	 NOATTR	  System coherency line size (-1)
 *   p (size 10, offset 12):	 NOATTR	  Physical line partitions (-1)
 *   w (size 10, offset 22):	 NOATTR	  Ways of associativity (-1)
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_cache_pars_t {
    uint16_t	l	:12;
    uint16_t	p	:10;
    uint16_t	w	:10;
} __attribute__ ((packed))
 cpuid_cache_pars_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_cache_pars_t, sizeof(uint32_t));

typedef union cpuid_cache_pars_un {
    cpuid_cache_pars_t	val;
    uint32_t	raw;
}
 cpuid_cache_pars_un;
static inline int cpuid_cache_pars_prtval( char * s, size_t sz, cpuid_cache_pars_t v ) __attribute__ ((always_inline));
static inline int cpuid_cache_pars_prtval( char * s, size_t sz, cpuid_cache_pars_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " l=0x%0"PRIx16" (System coherency line size (-1))\n", (uint16_t)(v.l));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " p=0x%0"PRIx16" (Physical line partitions (-1))\n", (uint16_t)(v.p));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " w=0x%0"PRIx16" (Ways of associativity (-1))\n", (uint16_t)(v.w));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Smallest monitor-line size) register
 */

/*
 * Dump of fields for register type: cpuid_min_monitor_t
 *   sz (size 16, offset 0):	 RO	  Smallest monitor-line size (bytes)
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_min_monitor_t {
    uint16_t	sz	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 cpuid_min_monitor_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_min_monitor_t, sizeof(uint32_t));

typedef union cpuid_min_monitor_un {
    cpuid_min_monitor_t	val;
    uint32_t	raw;
}
 cpuid_min_monitor_un;
static inline int cpuid_min_monitor_prtval( char * s, size_t sz, cpuid_min_monitor_t v ) __attribute__ ((always_inline));
static inline int cpuid_min_monitor_prtval( char * s, size_t sz, cpuid_min_monitor_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sz=0x%0"PRIx16" (Smallest monitor-line size (bytes))\n", (uint16_t)(v.sz));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Largest monitor-line size) register
 */

/*
 * Dump of fields for register type: cpuid_max_monitor_t
 *   sz (size 16, offset 0):	 RO	  Largest monitor-line size (bytes)
 *   _anon16 (size 16, offset 16):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_max_monitor_t {
    uint16_t	sz	:16;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 cpuid_max_monitor_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_max_monitor_t, sizeof(uint32_t));

typedef union cpuid_max_monitor_un {
    cpuid_max_monitor_t	val;
    uint32_t	raw;
}
 cpuid_max_monitor_un;
static inline int cpuid_max_monitor_prtval( char * s, size_t sz, cpuid_max_monitor_t v ) __attribute__ ((always_inline));
static inline int cpuid_max_monitor_prtval( char * s, size_t sz, cpuid_max_monitor_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sz=0x%0"PRIx16" (Largest monitor-line size (bytes))\n", (uint16_t)(v.sz));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of MONITOR/MWAIT features register
 */

/*
 * Dump of fields for register type: cpuid_mwait_feat_t
 *   emx (size 1, offset 0):	 RO	  Supports enum. of Monitor/Mwait extensions
 *   ibe (size 1, offset 1):	 RO	  Supports interrupts as break event
 *   _anon2 (size 30, offset 2):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_mwait_feat_t {
    uint8_t	emx	:1;
    uint8_t	ibe	:1;
    uint32_t	_anon2	:30;
} __attribute__ ((packed))
 cpuid_mwait_feat_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_mwait_feat_t, sizeof(uint32_t));

typedef union cpuid_mwait_feat_un {
    cpuid_mwait_feat_t	val;
    uint32_t	raw;
}
 cpuid_mwait_feat_un;
static inline int cpuid_mwait_feat_prtval( char * s, size_t sz, cpuid_mwait_feat_t v ) __attribute__ ((always_inline));
static inline int cpuid_mwait_feat_prtval( char * s, size_t sz, cpuid_mwait_feat_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " emx=0x%"PRIx8" (Supports enum. of Monitor/Mwait extensions)\n", (uint8_t)(v.emx));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ibe=0x%"PRIx8" (Supports interrupts as break event)\n", (uint8_t)(v.ibe));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of sub-C states supported by MWAIT register
 */

/*
 * Dump of fields for register type: cpuid_mwait_cstates_t
 *   c0 (size 4, offset 0):	 RO	  # C0 sub-C-states supported
 *   c1 (size 4, offset 4):	 RO	  # C1 sub-C-states supported
 *   c2 (size 4, offset 8):	 RO	  # C2 sub-C-states supported
 *   c3 (size 4, offset 12):	 RO	  # C3 sub-C-states supported
 *   c4 (size 4, offset 16):	 RO	  # C4 sub-C-states supported
 *   _anon20 (size 12, offset 20):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_mwait_cstates_t {
    uint8_t	c0	:4;
    uint8_t	c1	:4;
    uint8_t	c2	:4;
    uint8_t	c3	:4;
    uint8_t	c4	:4;
    uint16_t	_anon20	:12;
} __attribute__ ((packed))
 cpuid_mwait_cstates_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_mwait_cstates_t, sizeof(uint32_t));

typedef union cpuid_mwait_cstates_un {
    cpuid_mwait_cstates_t	val;
    uint32_t	raw;
}
 cpuid_mwait_cstates_un;
static inline int cpuid_mwait_cstates_prtval( char * s, size_t sz, cpuid_mwait_cstates_t v ) __attribute__ ((always_inline));
static inline int cpuid_mwait_cstates_prtval( char * s, size_t sz, cpuid_mwait_cstates_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " c0=0x%"PRIx8" (# C0 sub-C-states supported)\n", (uint8_t)(v.c0));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " c1=0x%"PRIx8" (# C1 sub-C-states supported)\n", (uint8_t)(v.c1));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " c2=0x%"PRIx8" (# C2 sub-C-states supported)\n", (uint8_t)(v.c2));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " c3=0x%"PRIx8" (# C3 sub-C-states supported)\n", (uint8_t)(v.c3));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " c4=0x%"PRIx8" (# C4 sub-C-states supported)\n", (uint8_t)(v.c4));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Thermal features register
 */

/*
 * Dump of fields for register type: cpuid_tpm_feat_t
 *   dts (size 1, offset 0):	 RO	  Digital temperature sensor supported
 *   ida (size 1, offset 1):	 RO	  Intel dynamic acceleration enabled
 *   _anon2 (size 30, offset 2):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_tpm_feat_t {
    uint8_t	dts	:1;
    uint8_t	ida	:1;
    uint32_t	_anon2	:30;
} __attribute__ ((packed))
 cpuid_tpm_feat_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_tpm_feat_t, sizeof(uint32_t));

typedef union cpuid_tpm_feat_un {
    cpuid_tpm_feat_t	val;
    uint32_t	raw;
}
 cpuid_tpm_feat_un;
static inline int cpuid_tpm_feat_prtval( char * s, size_t sz, cpuid_tpm_feat_t v ) __attribute__ ((always_inline));
static inline int cpuid_tpm_feat_prtval( char * s, size_t sz, cpuid_tpm_feat_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dts=0x%"PRIx8" (Digital temperature sensor supported)\n", (uint8_t)(v.dts));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ida=0x%"PRIx8" (Intel dynamic acceleration enabled)\n", (uint8_t)(v.ida));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of # interrupt thresholds in sensor register
 */

/*
 * Dump of fields for register type: cpuid_tpm_thresh_t
 *   val (size 4, offset 0):	 RO	  # interrupt thresholds in sensor
 *   _anon4 (size 28, offset 4):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_tpm_thresh_t {
    uint8_t	val	:4;
    uint32_t	_anon4	:28;
} __attribute__ ((packed))
 cpuid_tpm_thresh_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_tpm_thresh_t, sizeof(uint32_t));

typedef union cpuid_tpm_thresh_un {
    cpuid_tpm_thresh_t	val;
    uint32_t	raw;
}
 cpuid_tpm_thresh_un;
static inline int cpuid_tpm_thresh_prtval( char * s, size_t sz, cpuid_tpm_thresh_t v ) __attribute__ ((always_inline));
static inline int cpuid_tpm_thresh_prtval( char * s, size_t sz, cpuid_tpm_thresh_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " val=0x%"PRIx8" (# interrupt thresholds in sensor)\n", (uint8_t)(v.val));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Hardware coordination feedback register
 */

/*
 * Dump of fields for register type: cpuid_tpm_hcfc_t
 *   en (size 1, offset 0):	 RO	  HCFC present (MCNT/ACNT MSRs)
 *   _anon1 (size 31, offset 1):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_tpm_hcfc_t {
    uint8_t	en	:1;
    uint32_t	_anon1	:31;
} __attribute__ ((packed))
 cpuid_tpm_hcfc_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_tpm_hcfc_t, sizeof(uint32_t));

typedef union cpuid_tpm_hcfc_un {
    cpuid_tpm_hcfc_t	val;
    uint32_t	raw;
}
 cpuid_tpm_hcfc_un;
static inline int cpuid_tpm_hcfc_prtval( char * s, size_t sz, cpuid_tpm_hcfc_t v ) __attribute__ ((always_inline));
static inline int cpuid_tpm_hcfc_prtval( char * s, size_t sz, cpuid_tpm_hcfc_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " en=0x%"PRIx8" (HCFC present (MCNT/ACNT MSRs))\n", (uint8_t)(v.en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Gen-purpose perf. counter info register
 */

/*
 * Dump of fields for register type: cpuid_apm_gen_t
 *   version (size 8, offset 0):	 RO	  Version ID
 *   num_counters (size 8, offset 8):	 RO	  # GP perf. counters per logical processor
 *   width (size 8, offset 16):	 RO	  Bit width of GP perf. counters
 *   vec_length (size 8, offset 24):	 RO	  EBX bit vector length to enumerate events
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_apm_gen_t {
    uint8_t	version	:8;
    uint8_t	num_counters	:8;
    uint8_t	width	:8;
    uint8_t	vec_length	:8;
} __attribute__ ((packed))
 cpuid_apm_gen_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_apm_gen_t, sizeof(uint32_t));

typedef union cpuid_apm_gen_un {
    cpuid_apm_gen_t	val;
    uint32_t	raw;
}
 cpuid_apm_gen_un;
static inline int cpuid_apm_gen_prtval( char * s, size_t sz, cpuid_apm_gen_t v ) __attribute__ ((always_inline));
static inline int cpuid_apm_gen_prtval( char * s, size_t sz, cpuid_apm_gen_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " version=0x%"PRIx8" (Version ID)\n", (uint8_t)(v.version));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " num_counters=0x%"PRIx8" (# GP perf. counters per logical processor)\n", (uint8_t)(v.num_counters));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " width=0x%"PRIx8" (Bit width of GP perf. counters)\n", (uint8_t)(v.width));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vec_length=0x%"PRIx8" (EBX bit vector length to enumerate events)\n", (uint8_t)(v.vec_length));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Performance monitoring event availability register
 */

/*
 * Dump of fields for register type: cpuid_apm_feat_t
 *   cc (size 1, offset 0):	 RO	  Core cycle event
 *   ir (size 1, offset 1):	 RO	  Instruction retired
 *   rc (size 1, offset 2):	 RO	  Reference cycles
 *   llcr (size 1, offset 3):	 RO	  Last-level cache reference
 *   llcm (size 1, offset 4):	 RO	  Last-level cache miss
 *   bir (size 1, offset 5):	 RO	  Branch instruction retired
 *   bmr (size 1, offset 6):	 RO	  Branch mispredict retired
 *   _anon7 (size 25, offset 7):	 MBZ	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_apm_feat_t {
    uint8_t	cc	:1;
    uint8_t	ir	:1;
    uint8_t	rc	:1;
    uint8_t	llcr	:1;
    uint8_t	llcm	:1;
    uint8_t	bir	:1;
    uint8_t	bmr	:1;
    uint32_t	_anon7	:25;
} __attribute__ ((packed))
 cpuid_apm_feat_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_apm_feat_t, sizeof(uint32_t));

typedef union cpuid_apm_feat_un {
    cpuid_apm_feat_t	val;
    uint32_t	raw;
}
 cpuid_apm_feat_un;
static inline int cpuid_apm_feat_prtval( char * s, size_t sz, cpuid_apm_feat_t v ) __attribute__ ((always_inline));
static inline int cpuid_apm_feat_prtval( char * s, size_t sz, cpuid_apm_feat_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cc=0x%"PRIx8" (Core cycle event)\n", (uint8_t)(v.cc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ir=0x%"PRIx8" (Instruction retired)\n", (uint8_t)(v.ir));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rc=0x%"PRIx8" (Reference cycles)\n", (uint8_t)(v.rc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " llcr=0x%"PRIx8" (Last-level cache reference)\n", (uint8_t)(v.llcr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " llcm=0x%"PRIx8" (Last-level cache miss)\n", (uint8_t)(v.llcm));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " bir=0x%"PRIx8" (Branch instruction retired)\n", (uint8_t)(v.bir));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " bmr=0x%"PRIx8" (Branch mispredict retired)\n", (uint8_t)(v.bmr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Fixed-function perf. counter infos register
 */

/*
 * Dump of fields for register type: cpuid_apm_fixed_t
 *   num (size 5, offset 0):	 RO	  # Fixed-function perf. counters
 *   width (size 8, offset 5):	 RO	  Width of fixed-function perf. counters
 *   _anon13 (size 19, offset 13):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_apm_fixed_t {
    uint8_t	num	:5;
    uint8_t	width	:8;
    uint32_t	_anon13	:19;
} __attribute__ ((packed))
 cpuid_apm_fixed_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_apm_fixed_t, sizeof(uint32_t));

typedef union cpuid_apm_fixed_un {
    cpuid_apm_fixed_t	val;
    uint32_t	raw;
}
 cpuid_apm_fixed_un;
static inline int cpuid_apm_fixed_prtval( char * s, size_t sz, cpuid_apm_fixed_t v ) __attribute__ ((always_inline));
static inline int cpuid_apm_fixed_prtval( char * s, size_t sz, cpuid_apm_fixed_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " num=0x%"PRIx8" (# Fixed-function perf. counters)\n", (uint8_t)(v.num));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " width=0x%"PRIx8" (Width of fixed-function perf. counters)\n", (uint8_t)(v.width));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Brand ID identifier register
 */

/*
 * Dump of fields for register type: cpuid_brandid_t
 *   id (size 16, offset 0):	 RO	  Extended brand ID
 *   _anon16 (size 12, offset 16):	 RSVD	  _
 *   pkgtype (size 4, offset 28):	 RO	  Package type
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_brandid_t {
    uint16_t	id	:16;
    uint16_t	_anon16	:12;
    uint8_t	pkgtype	:4;
} __attribute__ ((packed))
 cpuid_brandid_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_brandid_t, sizeof(uint32_t));

typedef union cpuid_brandid_un {
    cpuid_brandid_t	val;
    uint32_t	raw;
}
 cpuid_brandid_un;
static inline int cpuid_brandid_prtval( char * s, size_t sz, cpuid_brandid_t v ) __attribute__ ((always_inline));
static inline int cpuid_brandid_prtval( char * s, size_t sz, cpuid_brandid_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " id=0x%0"PRIx16" (Extended brand ID)\n", (uint16_t)(v.id));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pkgtype=0x%"PRIx8" (Package type)\n", (uint8_t)(v.pkgtype));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Extend misc. features 1 register
 */

/*
 * Dump of fields for register type: cpuid_ext_featc_t
 *   lahfsahf (size 1, offset 0):	 RO	  LAHF & SAHF support in 64-bit mode
 *   cmplegacy (size 1, offset 1):	 RO	  Core multiprocessing legacy mode
 *   svm (size 1, offset 2):	 RO	  Secure virtual machine
 *   extapicspace (size 1, offset 3):	 RO	  Extended APIC space
 *   altmovcr8 (size 1, offset 4):	 RO	  LOCK MOV CR0 means MOV CR8
 *   abm (size 1, offset 5):	 RO	  Advanced bit manipulation
 *   sse4a (size 1, offset 6):	 RO	  EXTRQ/INSERTQ/MOVNTSS/MOVNTSD support
 *   misalignsse (size 1, offset 7):	 RO	  Misaligned SSE mode
 *   pref3dnow (size 1, offset 8):	 RO	  PREFETCH/PREFETCHW support
 *   osvw (size 1, offset 9):	 RO	  OS visible workaround
 *   ibs (size 1, offset 10):	 RO	  Instruction-based sampling
 *   sse5 (size 1, offset 11):	 RO	  SSE 5 instruction support
 *   skinit (size 1, offset 12):	 RO	  SKINIT/STGI supported
 *   wdt (size 1, offset 13):	 RO	  Watchdog timer support
 *   _anon14 (size 18, offset 14):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_ext_featc_t {
    uint8_t	lahfsahf	:1;
    uint8_t	cmplegacy	:1;
    uint8_t	svm	:1;
    uint8_t	extapicspace	:1;
    uint8_t	altmovcr8	:1;
    uint8_t	abm	:1;
    uint8_t	sse4a	:1;
    uint8_t	misalignsse	:1;
    uint8_t	pref3dnow	:1;
    uint8_t	osvw	:1;
    uint8_t	ibs	:1;
    uint8_t	sse5	:1;
    uint8_t	skinit	:1;
    uint8_t	wdt	:1;
    uint32_t	_anon14	:18;
} __attribute__ ((packed))
 cpuid_ext_featc_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_ext_featc_t, sizeof(uint32_t));

typedef union cpuid_ext_featc_un {
    cpuid_ext_featc_t	val;
    uint32_t	raw;
}
 cpuid_ext_featc_un;
static inline int cpuid_ext_featc_prtval( char * s, size_t sz, cpuid_ext_featc_t v ) __attribute__ ((always_inline));
static inline int cpuid_ext_featc_prtval( char * s, size_t sz, cpuid_ext_featc_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lahfsahf=0x%"PRIx8" (LAHF & SAHF support in 64-bit mode)\n", (uint8_t)(v.lahfsahf));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cmplegacy=0x%"PRIx8" (Core multiprocessing legacy mode)\n", (uint8_t)(v.cmplegacy));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " svm=0x%"PRIx8" (Secure virtual machine)\n", (uint8_t)(v.svm));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " extapicspace=0x%"PRIx8" (Extended APIC space)\n", (uint8_t)(v.extapicspace));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " altmovcr8=0x%"PRIx8" (LOCK MOV CR0 means MOV CR8)\n", (uint8_t)(v.altmovcr8));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " abm=0x%"PRIx8" (Advanced bit manipulation)\n", (uint8_t)(v.abm));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sse4a=0x%"PRIx8" (EXTRQ/INSERTQ/MOVNTSS/MOVNTSD support)\n", (uint8_t)(v.sse4a));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " misalignsse=0x%"PRIx8" (Misaligned SSE mode)\n", (uint8_t)(v.misalignsse));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pref3dnow=0x%"PRIx8" (PREFETCH/PREFETCHW support)\n", (uint8_t)(v.pref3dnow));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " osvw=0x%"PRIx8" (OS visible workaround)\n", (uint8_t)(v.osvw));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ibs=0x%"PRIx8" (Instruction-based sampling)\n", (uint8_t)(v.ibs));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sse5=0x%"PRIx8" (SSE 5 instruction support)\n", (uint8_t)(v.sse5));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " skinit=0x%"PRIx8" (SKINIT/STGI supported)\n", (uint8_t)(v.skinit));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " wdt=0x%"PRIx8" (Watchdog timer support)\n", (uint8_t)(v.wdt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Extend misc. features 2 register
 */

/*
 * Dump of fields for register type: cpuid_ext_featd_t
 *   _anon0 (size 11, offset 0):	 RSVD	  _
 *   syscallsysret (size 1, offset 11):	 RO	  SYSCALL/SYSRET available in 64-bit mode
 *   _anon12 (size 8, offset 12):	 RSVD	  _
 *   nx (size 1, offset 20):	 RO	  No-execute page protection
 *   _anon21 (size 1, offset 21):	 RSVD	  _
 *   mmxext (size 1, offset 22):	 RO	  AMD extensions to MMX instructions
 *   _anon23 (size 2, offset 23):	 RSVD	  _
 *   ffxsr (size 1, offset 25):	 RO	  FFXSR instruction optimizations
 *   page1fb (size 1, offset 26):	 RO	  1-GB large page support
 *   rdtscp (size 1, offset 27):	 RO	  RDTSCP instruction
 *   _anon28 (size 1, offset 28):	 RSVD	  _
 *   longmode (size 1, offset 29):	 RO	  Long mode / Intel64 available
 *   i3dnowext (size 1, offset 30):	 RO	  AMD extensions to 3DNow! instructions
 *   i3dnow (size 1, offset 31):	 RO	  3DNow! instructions
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_ext_featd_t {
    uint16_t	_anon0	:11;
    uint8_t	syscallsysret	:1;
    uint8_t	_anon12	:8;
    uint8_t	nx	:1;
    uint8_t	_anon21	:1;
    uint8_t	mmxext	:1;
    uint8_t	_anon23	:2;
    uint8_t	ffxsr	:1;
    uint8_t	page1fb	:1;
    uint8_t	rdtscp	:1;
    uint8_t	_anon28	:1;
    uint8_t	longmode	:1;
    uint8_t	i3dnowext	:1;
    uint8_t	i3dnow	:1;
} __attribute__ ((packed))
 cpuid_ext_featd_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_ext_featd_t, sizeof(uint32_t));

typedef union cpuid_ext_featd_un {
    cpuid_ext_featd_t	val;
    uint32_t	raw;
}
 cpuid_ext_featd_un;
static inline int cpuid_ext_featd_prtval( char * s, size_t sz, cpuid_ext_featd_t v ) __attribute__ ((always_inline));
static inline int cpuid_ext_featd_prtval( char * s, size_t sz, cpuid_ext_featd_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " syscallsysret=0x%"PRIx8" (SYSCALL/SYSRET available in 64-bit mode)\n", (uint8_t)(v.syscallsysret));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " nx=0x%"PRIx8" (No-execute page protection)\n", (uint8_t)(v.nx));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mmxext=0x%"PRIx8" (AMD extensions to MMX instructions)\n", (uint8_t)(v.mmxext));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ffxsr=0x%"PRIx8" (FFXSR instruction optimizations)\n", (uint8_t)(v.ffxsr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " page1fb=0x%"PRIx8" (1-GB large page support)\n", (uint8_t)(v.page1fb));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rdtscp=0x%"PRIx8" (RDTSCP instruction)\n", (uint8_t)(v.rdtscp));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " longmode=0x%"PRIx8" (Long mode / Intel64 available)\n", (uint8_t)(v.longmode));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " i3dnowext=0x%"PRIx8" (AMD extensions to 3DNow! instructions)\n", (uint8_t)(v.i3dnowext));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " i3dnow=0x%"PRIx8" (3DNow! instructions)\n", (uint8_t)(v.i3dnow));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: AMD TLB information
 */

/*
 * Dump of fields for register type: cpuid_amd_tlbinfo1_t
 *   itlb_sz (size 8, offset 0):	 NOATTR	  Number of instruction TLB entries
 *   itlb_asc (size 8, offset 8):	 NOATTR	  Instruction TLB associativity
 *   dtlb_sz (size 8, offset 16):	 NOATTR	  Number of data DTLB entries
 *   dtlb_asc (size 8, offset 24):	 NOATTR	  Data TLB associativity
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_amd_tlbinfo1_t {
    uint8_t	itlb_sz	:8;
    uint8_t	itlb_asc	:8;
    uint8_t	dtlb_sz	:8;
    uint8_t	dtlb_asc	:8;
} __attribute__ ((packed))
 cpuid_amd_tlbinfo1_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_amd_tlbinfo1_t, sizeof(uint32_t));

typedef union cpuid_amd_tlbinfo1_un {
    cpuid_amd_tlbinfo1_t	val;
    uint32_t	raw;
}
 cpuid_amd_tlbinfo1_un;
static inline int cpuid_amd_tlbinfo1_prtval( char * s, size_t sz, cpuid_amd_tlbinfo1_t v ) __attribute__ ((always_inline));
static inline int cpuid_amd_tlbinfo1_prtval( char * s, size_t sz, cpuid_amd_tlbinfo1_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " itlb_sz=0x%"PRIx8" (Number of instruction TLB entries)\n", (uint8_t)(v.itlb_sz));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " itlb_asc=0x%"PRIx8" (Instruction TLB associativity)\n", (uint8_t)(v.itlb_asc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dtlb_sz=0x%"PRIx8" (Number of data DTLB entries)\n", (uint8_t)(v.dtlb_sz));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dtlb_asc=0x%"PRIx8" (Data TLB associativity)\n", (uint8_t)(v.dtlb_asc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: AMD cache information
 */

/*
 * Dump of fields for register type: cpuid_amd_cacheinfo1_t
 *   linesize (size 8, offset 0):	 NOATTR	  line size
 *   lpt (size 8, offset 8):	 NOATTR	  lines per tag
 *   assoc (size 8, offset 16):	 NOATTR	  associativity
 *   size (size 8, offset 24):	 NOATTR	  size in Kb
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_amd_cacheinfo1_t {
    uint8_t	linesize	:8;
    uint8_t	lpt	:8;
    uint8_t	assoc	:8;
    uint8_t	size	:8;
} __attribute__ ((packed))
 cpuid_amd_cacheinfo1_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_amd_cacheinfo1_t, sizeof(uint32_t));

typedef union cpuid_amd_cacheinfo1_un {
    cpuid_amd_cacheinfo1_t	val;
    uint32_t	raw;
}
 cpuid_amd_cacheinfo1_un;
static inline int cpuid_amd_cacheinfo1_prtval( char * s, size_t sz, cpuid_amd_cacheinfo1_t v ) __attribute__ ((always_inline));
static inline int cpuid_amd_cacheinfo1_prtval( char * s, size_t sz, cpuid_amd_cacheinfo1_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " linesize=0x%"PRIx8" (line size)\n", (uint8_t)(v.linesize));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lpt=0x%"PRIx8" (lines per tag)\n", (uint8_t)(v.lpt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " assoc=0x%"PRIx8" (associativity)\n", (uint8_t)(v.assoc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " size=0x%"PRIx8" (size in Kb)\n", (uint8_t)(v.size));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: AMD TLB information
 */

/*
 * Dump of fields for register type: cpuid_amd_tlbinfo23_t
 *   itlb_sz (size 12, offset 0):	 NOATTR	  Number of instruction TLB entries
 *   itlb_asc (size 4, offset 12):	 NOATTR	  Instruction TLB associativity
 *   dtlb_sz (size 12, offset 16):	 NOATTR	  Number of data DTLB entries
 *   dtlb_asc (size 4, offset 28):	 NOATTR	  Data TLB associativity
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_amd_tlbinfo23_t {
    uint16_t	itlb_sz	:12;
    uint8_t	itlb_asc	:4;
    uint16_t	dtlb_sz	:12;
    uint8_t	dtlb_asc	:4;
} __attribute__ ((packed))
 cpuid_amd_tlbinfo23_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_amd_tlbinfo23_t, sizeof(uint32_t));

typedef union cpuid_amd_tlbinfo23_un {
    cpuid_amd_tlbinfo23_t	val;
    uint32_t	raw;
}
 cpuid_amd_tlbinfo23_un;
static inline int cpuid_amd_tlbinfo23_prtval( char * s, size_t sz, cpuid_amd_tlbinfo23_t v ) __attribute__ ((always_inline));
static inline int cpuid_amd_tlbinfo23_prtval( char * s, size_t sz, cpuid_amd_tlbinfo23_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " itlb_sz=0x%0"PRIx16" (Number of instruction TLB entries)\n", (uint16_t)(v.itlb_sz));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " itlb_asc=0x%"PRIx8" (Instruction TLB associativity)\n", (uint8_t)(v.itlb_asc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dtlb_sz=0x%0"PRIx16" (Number of data DTLB entries)\n", (uint16_t)(v.dtlb_sz));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " dtlb_asc=0x%"PRIx8" (Data TLB associativity)\n", (uint8_t)(v.dtlb_asc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: AMD cache information
 */

/*
 * Dump of fields for register type: cpuid_amd_cacheinfo23_t
 *   linesize (size 8, offset 0):	 NOATTR	  line size
 *   lpt (size 4, offset 8):	 NOATTR	  lines per tag
 *   assoc (size 4, offset 12):	 NOATTR	  associativity
 *   size (size 16, offset 16):	 NOATTR	  size in Kb
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_amd_cacheinfo23_t {
    uint8_t	linesize	:8;
    uint8_t	lpt	:4;
    uint8_t	assoc	:4;
    uint16_t	size	:16;
} __attribute__ ((packed))
 cpuid_amd_cacheinfo23_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_amd_cacheinfo23_t, sizeof(uint32_t));

typedef union cpuid_amd_cacheinfo23_un {
    cpuid_amd_cacheinfo23_t	val;
    uint32_t	raw;
}
 cpuid_amd_cacheinfo23_un;
static inline int cpuid_amd_cacheinfo23_prtval( char * s, size_t sz, cpuid_amd_cacheinfo23_t v ) __attribute__ ((always_inline));
static inline int cpuid_amd_cacheinfo23_prtval( char * s, size_t sz, cpuid_amd_cacheinfo23_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " linesize=0x%"PRIx8" (line size)\n", (uint8_t)(v.linesize));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lpt=0x%"PRIx8" (lines per tag)\n", (uint8_t)(v.lpt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " assoc=0x%"PRIx8" (associativity)\n", (uint8_t)(v.assoc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " size=0x%0"PRIx16" (size in Kb)\n", (uint16_t)(v.size));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of AMD Advanced Power Mgmt register
 */

/*
 * Dump of fields for register type: cpuid_amd_apm_t
 *   ts (size 1, offset 0):	 RO	  Temperature sensor
 *   fid (size 1, offset 1):	 RO	  Frequency ID control
 *   vid (size 1, offset 2):	 RO	  Voltage ID control
 *   ttp (size 1, offset 3):	 RO	  THERMTRIP
 *   tm (size 1, offset 4):	 RO	  Hardware thermal control
 *   stc (size 1, offset 5):	 RO	  Software thermal control
 *   Mhz100steps (size 1, offset 6):	 RO	  100MHz multiplier control
 *   hpwstate (size 1, offset 7):	 RO	  Hardware P-State control
 *   tscinvariant (size 1, offset 8):	 RO	  TSC rate invariant
 *   _anon9 (size 23, offset 9):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_amd_apm_t {
    uint8_t	ts	:1;
    uint8_t	fid	:1;
    uint8_t	vid	:1;
    uint8_t	ttp	:1;
    uint8_t	tm	:1;
    uint8_t	stc	:1;
    uint8_t	Mhz100steps	:1;
    uint8_t	hpwstate	:1;
    uint8_t	tscinvariant	:1;
    uint32_t	_anon9	:23;
} __attribute__ ((packed))
 cpuid_amd_apm_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_amd_apm_t, sizeof(uint32_t));

typedef union cpuid_amd_apm_un {
    cpuid_amd_apm_t	val;
    uint32_t	raw;
}
 cpuid_amd_apm_un;
static inline int cpuid_amd_apm_prtval( char * s, size_t sz, cpuid_amd_apm_t v ) __attribute__ ((always_inline));
static inline int cpuid_amd_apm_prtval( char * s, size_t sz, cpuid_amd_apm_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ts=0x%"PRIx8" (Temperature sensor)\n", (uint8_t)(v.ts));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fid=0x%"PRIx8" (Frequency ID control)\n", (uint8_t)(v.fid));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vid=0x%"PRIx8" (Voltage ID control)\n", (uint8_t)(v.vid));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ttp=0x%"PRIx8" (THERMTRIP)\n", (uint8_t)(v.ttp));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tm=0x%"PRIx8" (Hardware thermal control)\n", (uint8_t)(v.tm));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " stc=0x%"PRIx8" (Software thermal control)\n", (uint8_t)(v.stc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " Mhz100steps=0x%"PRIx8" (100MHz multiplier control)\n", (uint8_t)(v.Mhz100steps));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " hpwstate=0x%"PRIx8" (Hardware P-State control)\n", (uint8_t)(v.hpwstate));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tscinvariant=0x%"PRIx8" (TSC rate invariant)\n", (uint8_t)(v.tscinvariant));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Address size register
 */

/*
 * Dump of fields for register type: cpuid_addr_size_t
 *   phys (size 8, offset 0):	 RO	  Max physical byte address size in bits
 *   linear (size 8, offset 8):	 RO	  Max linear byte address size in bits
 *   guest (size 8, offset 16):	 RO	  Max guest physical byte address size in bits
 *   _anon24 (size 8, offset 24):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_addr_size_t {
    uint8_t	phys	:8;
    uint8_t	linear	:8;
    uint8_t	guest	:8;
    uint8_t	_anon24	:8;
} __attribute__ ((packed))
 cpuid_addr_size_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_addr_size_t, sizeof(uint32_t));

typedef union cpuid_addr_size_un {
    cpuid_addr_size_t	val;
    uint32_t	raw;
}
 cpuid_addr_size_un;
static inline int cpuid_addr_size_prtval( char * s, size_t sz, cpuid_addr_size_t v ) __attribute__ ((always_inline));
static inline int cpuid_addr_size_prtval( char * s, size_t sz, cpuid_addr_size_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " phys=0x%"PRIx8" (Max physical byte address size in bits)\n", (uint8_t)(v.phys));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " linear=0x%"PRIx8" (Max linear byte address size in bits)\n", (uint8_t)(v.linear));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " guest=0x%"PRIx8" (Max guest physical byte address size in bits)\n", (uint8_t)(v.guest));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Core count register
 */

/*
 * Dump of fields for register type: cpuid_core_count_t
 *   nc (size 8, offset 0):	 RO	  Number of CPU cores -1 
 *   _anon8 (size 4, offset 8):	 RSVD	  _
 *   apiccoreidsz (size 4, offset 12):	 RO	  APIC core ID size in bits
 *   _anon16 (size 16, offset 16):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_core_count_t {
    uint8_t	nc	:8;
    uint8_t	_anon8	:4;
    uint8_t	apiccoreidsz	:4;
    uint16_t	_anon16	:16;
} __attribute__ ((packed))
 cpuid_core_count_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_core_count_t, sizeof(uint32_t));

typedef union cpuid_core_count_un {
    cpuid_core_count_t	val;
    uint32_t	raw;
}
 cpuid_core_count_un;
static inline int cpuid_core_count_prtval( char * s, size_t sz, cpuid_core_count_t v ) __attribute__ ((always_inline));
static inline int cpuid_core_count_prtval( char * s, size_t sz, cpuid_core_count_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " nc=0x%"PRIx8" (Number of CPU cores -1 )\n", (uint8_t)(v.nc));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " apiccoreidsz=0x%"PRIx8" (APIC core ID size in bits)\n", (uint8_t)(v.apiccoreidsz));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Secure Virtual Machine rev. register
 */

/*
 * Dump of fields for register type: cpuid_svmrev_t
 *   rev (size 8, offset 0):	 RO	  SVM revision number
 *   _anon8 (size 24, offset 8):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_svmrev_t {
    uint8_t	rev	:8;
    uint32_t	_anon8	:24;
} __attribute__ ((packed))
 cpuid_svmrev_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_svmrev_t, sizeof(uint32_t));

typedef union cpuid_svmrev_un {
    cpuid_svmrev_t	val;
    uint32_t	raw;
}
 cpuid_svmrev_un;
static inline int cpuid_svmrev_prtval( char * s, size_t sz, cpuid_svmrev_t v ) __attribute__ ((always_inline));
static inline int cpuid_svmrev_prtval( char * s, size_t sz, cpuid_svmrev_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rev=0x%"PRIx8" (SVM revision number)\n", (uint8_t)(v.rev));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of SVM features register
 */

/*
 * Dump of fields for register type: cpuid_svmfeat_t
 *   np (size 1, offset 0):	 RO	  Nested paging
 *   lbrvirt (size 1, offset 1):	 RO	  LBR virtualization
 *   svml (size 1, offset 2):	 RO	  SVM lock
 *   nrips (size 1, offset 3):	 RO	  NRIP save
 *   _anon4 (size 5, offset 4):	 RSVD	  _
 *   ssse3sse5dis (size 1, offset 9):	 RO	  SSSE3 and SSE5 opcode set disable
 *   _anon10 (size 22, offset 10):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_svmfeat_t {
    uint8_t	np	:1;
    uint8_t	lbrvirt	:1;
    uint8_t	svml	:1;
    uint8_t	nrips	:1;
    uint8_t	_anon4	:5;
    uint8_t	ssse3sse5dis	:1;
    uint32_t	_anon10	:22;
} __attribute__ ((packed))
 cpuid_svmfeat_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_svmfeat_t, sizeof(uint32_t));

typedef union cpuid_svmfeat_un {
    cpuid_svmfeat_t	val;
    uint32_t	raw;
}
 cpuid_svmfeat_un;
static inline int cpuid_svmfeat_prtval( char * s, size_t sz, cpuid_svmfeat_t v ) __attribute__ ((always_inline));
static inline int cpuid_svmfeat_prtval( char * s, size_t sz, cpuid_svmfeat_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " np=0x%"PRIx8" (Nested paging)\n", (uint8_t)(v.np));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " lbrvirt=0x%"PRIx8" (LBR virtualization)\n", (uint8_t)(v.lbrvirt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " svml=0x%"PRIx8" (SVM lock)\n", (uint8_t)(v.svml));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " nrips=0x%"PRIx8" (NRIP save)\n", (uint8_t)(v.nrips));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " ssse3sse5dis=0x%"PRIx8" (SSSE3 and SSE5 opcode set disable)\n", (uint8_t)(v.ssse3sse5dis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Perf. optimization identifiers register
 */

/*
 * Dump of fields for register type: cpuid_opt_id_t
 *   fp128 (size 1, offset 0):	 RO	  128-bit SSE has full-width execution
 *   movu (size 1, offset 1):	 RO	  MOVU SSE instructions faster than MOVL
 *   _anon2 (size 30, offset 2):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct cpuid_opt_id_t {
    uint8_t	fp128	:1;
    uint8_t	movu	:1;
    uint32_t	_anon2	:30;
} __attribute__ ((packed))
 cpuid_opt_id_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(cpuid_opt_id_t, sizeof(uint32_t));

typedef union cpuid_opt_id_un {
    cpuid_opt_id_t	val;
    uint32_t	raw;
}
 cpuid_opt_id_un;
static inline int cpuid_opt_id_prtval( char * s, size_t sz, cpuid_opt_id_t v ) __attribute__ ((always_inline));
static inline int cpuid_opt_id_prtval( char * s, size_t sz, cpuid_opt_id_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " fp128=0x%"PRIx8" (128-bit SSE has full-width execution)\n", (uint8_t)(v.fp128));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " movu=0x%"PRIx8" (MOVU SSE instructions faster than MOVL)\n", (uint8_t)(v.movu));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Device representation structure
 */
typedef struct __DN(t) {
    // Device arguments
    // Shadow registers
}
 __DN(t);

/*
 * Device Initialization function
 */
static inline void __DN(initialize)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline void __DN(initialize)( __DN(t) * _dev )
{
    /* Setting up device arguments*/
    /* Setting up shadow registers*/
}

// Include access functions for user-defined spaces
#include "cpuid_spaces.h"

/*
 * Register max_biv (Maximum input val for basic CPUID info); type cpuid.uint32
 */

static inline uint32_t __DP(max_biv_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(max_biv_rd_raw)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x0));
}

static inline uint32_t __DP(max_biv_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(max_biv_rd)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x0));
}

// Register max_biv is not writeable


static inline int __DP(max_biv_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(max_biv_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register max_biv (Maximum input val for basic CPUID info):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(eax_read_32)(_dev, (0x0)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register vendor0 (Vendor string part 1); type cpuid.uint32
 */

static inline uint32_t __DP(vendor0_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(vendor0_rd_raw)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x0));
}

static inline uint32_t __DP(vendor0_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(vendor0_rd)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x0));
}

// Register vendor0 is not writeable


static inline int __DP(vendor0_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(vendor0_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register vendor0 (Vendor string part 1):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(ebx_read_32)(_dev, (0x0)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register vendor1 (Vendor string part 2); type cpuid.uint32
 */

static inline uint32_t __DP(vendor1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(vendor1_rd_raw)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x0));
}

static inline uint32_t __DP(vendor1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(vendor1_rd)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x0));
}

// Register vendor1 is not writeable


static inline int __DP(vendor1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(vendor1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register vendor1 (Vendor string part 2):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(edx_read_32)(_dev, (0x0)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register vendor2 (Vendor string part 3); type cpuid.uint32
 */

static inline uint32_t __DP(vendor2_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(vendor2_rd_raw)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x0));
}

static inline uint32_t __DP(vendor2_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(vendor2_rd)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x0));
}

// Register vendor2 is not writeable


static inline int __DP(vendor2_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(vendor2_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register vendor2 (Vendor string part 3):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(ecx_read_32)(_dev, (0x0)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register ver_info (Version information); type cpuid.ver_info (Implicit type of Version information register)
 */

/*
 * Dump of fields for register: ver_info
 *   stepping (size 4, offset 0):	 RO	  Stepping ID
 *   model (size 4, offset 4):	 RO	  Model ID
 *   family (size 4, offset 8):	 RO	  Family ID
 *   proc_type (size 2, offset 12):	 RO	  Processor type (Intel only)
 *   _anon14 (size 2, offset 14):	 MBZ	  _
 *   extmodel (size 4, offset 16):	 RO	  Extended model ID
 *   extfamily (size 8, offset 20):	 RO	  Extended family ID
 *   _anon28 (size 4, offset 28):	 MBZ	  _
 */

static inline uint32_t __DP(ver_info_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ver_info_rd_raw)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x1));
}

static inline cpuid_ver_info_t __DP(ver_info_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_ver_info_t __DP(ver_info_rd)( __DN(t) * _dev )
{
    cpuid_ver_info_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x1));
    return u.val;
}

// Register ver_info is not writeable


static inline int __DP(ver_info_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ver_info_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_ver_info_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x1));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ver_info (Version information):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.stepping;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " stepping =\t0x%"PRIx8" (Stepping ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.model;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " model =\t0x%"PRIx8" (Model ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.family;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " family =\t0x%"PRIx8" (Family ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.proc_type;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " proc_type =\t0x%"PRIx8" (Processor type (Intel only)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.extmodel;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " extmodel =\t0x%"PRIx8" (Extended model ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.extfamily;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " extfamily =\t0x%"PRIx8" (Extended family ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register brand_ndx (Brand Index, APIC info); type cpuid.brand_ndx (Implicit type of Brand Index, APIC info register)
 */

/*
 * Dump of fields for register: brand_ndx
 *   brand (size 8, offset 0):	 RO	  Brand index
 *   cflush_sz (size 8, offset 8):	 RO	  CFLUSH line size
 *   max_log_proc (size 8, offset 16):	 RO	  Max. # logical processors in this package
 *   init_apic_id (size 8, offset 24):	 RO	  Initial local APIC physical ID
 */

static inline uint32_t __DP(brand_ndx_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand_ndx_rd_raw)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x1));
}

static inline cpuid_brand_ndx_t __DP(brand_ndx_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_brand_ndx_t __DP(brand_ndx_rd)( __DN(t) * _dev )
{
    cpuid_brand_ndx_un  u;
    u.raw = __DP(ebx_read_32)(_dev, (0x1));
    return u.val;
}

// Register brand_ndx is not writeable


static inline int __DP(brand_ndx_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(brand_ndx_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_brand_ndx_un  u;
    u.raw = __DP(ebx_read_32)(_dev, (0x1));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register brand_ndx (Brand Index, APIC info):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.brand;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " brand =\t0x%"PRIx8" (Brand index", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cflush_sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cflush_sz =\t0x%"PRIx8" (CFLUSH line size", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.max_log_proc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " max_log_proc =\t0x%"PRIx8" (Max. # logical processors in this package", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.init_apic_id;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " init_apic_id =\t0x%"PRIx8" (Initial local APIC physical ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register feat_info (Feature information); type cpuid.feat_info (Implicit type of Feature information register)
 */

/*
 * Dump of fields for register: feat_info
 *   fpu_x87 (size 1, offset 0):	 RO	  FPU on chip
 *   vme (size 1, offset 1):	 RO	  Virtual-8086 mode enhancement
 *   de (size 1, offset 2):	 RO	  Debugging extensions
 *   pse (size 1, offset 3):	 RO	  Page size extensions
 *   tsc (size 1, offset 4):	 RO	  Time stamp counter
 *   msr (size 1, offset 5):	 RO	  RDMSR and WRMSR support
 *   pae (size 1, offset 6):	 RO	  Physical address extensions
 *   mce (size 1, offset 7):	 RO	  Machine check exception
 *   cx8 (size 1, offset 8):	 RO	  CMPXCHG8B instruction
 *   apic (size 1, offset 9):	 RO	  APIC on chip
 *   _anon10 (size 1, offset 10):	 RSVD	  _
 *   sep (size 1, offset 11):	 RO	  SYSENTER and SYSEXIT
 *   mtrr (size 1, offset 12):	 RO	  Memory type range registers
 *   pge (size 1, offset 13):	 RO	  PTE global bit
 *   mca (size 1, offset 14):	 RO	  Machine check architecture
 *   cmov (size 1, offset 15):	 RO	  Conditional move/compare instruction
 *   pat (size 1, offset 16):	 RO	  Page attribute table
 *   pse36 (size 1, offset 17):	 RO	  Page size extension
 *   psn (size 1, offset 18):	 RO	  Processor serial number
 *   clfsh (size 1, offset 19):	 RO	  CFLUSH instruction
 *   _anon20 (size 1, offset 20):	 RSVD	  _
 *   ds (size 1, offset 21):	 RO	  Debug store
 *   acpi (size 1, offset 22):	 RO	  Thermal monitor and clock control
 *   mmx (size 1, offset 23):	 RO	  MMX technology
 *   fxsr (size 1, offset 24):	 RO	  FXSAVE / FXRSTOR
 *   sse (size 1, offset 25):	 RO	  SSE instructions
 *   sse2 (size 1, offset 26):	 RO	  SSE2 instructions
 *   ss (size 1, offset 27):	 RO	  Self-snoop
 *   htt (size 1, offset 28):	 RO	  Multi-threading
 *   tm (size 1, offset 29):	 RO	  Thermal monitor
 *   _anon30 (size 1, offset 30):	 RSVD	  _
 *   pbe (size 1, offset 31):	 RO	  Pending break enable
 */

static inline uint32_t __DP(feat_info_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(feat_info_rd_raw)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x1));
}

static inline cpuid_feat_info_t __DP(feat_info_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_feat_info_t __DP(feat_info_rd)( __DN(t) * _dev )
{
    cpuid_feat_info_un  u;
    u.raw = __DP(edx_read_32)(_dev, (0x1));
    return u.val;
}

// Register feat_info is not writeable


static inline int __DP(feat_info_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(feat_info_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_feat_info_un  u;
    u.raw = __DP(edx_read_32)(_dev, (0x1));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register feat_info (Feature information):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.fpu_x87;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fpu_x87 =\t0x%"PRIx8" (FPU on chip", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vme;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vme =\t0x%"PRIx8" (Virtual-8086 mode enhancement", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.de;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " de =\t0x%"PRIx8" (Debugging extensions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pse;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pse =\t0x%"PRIx8" (Page size extensions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tsc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tsc =\t0x%"PRIx8" (Time stamp counter", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.msr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " msr =\t0x%"PRIx8" (RDMSR and WRMSR support", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pae;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pae =\t0x%"PRIx8" (Physical address extensions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mce;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mce =\t0x%"PRIx8" (Machine check exception", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cx8;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cx8 =\t0x%"PRIx8" (CMPXCHG8B instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.apic;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " apic =\t0x%"PRIx8" (APIC on chip", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.sep;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sep =\t0x%"PRIx8" (SYSENTER and SYSEXIT", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mtrr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mtrr =\t0x%"PRIx8" (Memory type range registers", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pge;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pge =\t0x%"PRIx8" (PTE global bit", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mca;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mca =\t0x%"PRIx8" (Machine check architecture", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cmov;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cmov =\t0x%"PRIx8" (Conditional move/compare instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pat;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pat =\t0x%"PRIx8" (Page attribute table", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pse36;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pse36 =\t0x%"PRIx8" (Page size extension", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.psn;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " psn =\t0x%"PRIx8" (Processor serial number", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.clfsh;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " clfsh =\t0x%"PRIx8" (CFLUSH instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.ds;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ds =\t0x%"PRIx8" (Debug store", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.acpi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " acpi =\t0x%"PRIx8" (Thermal monitor and clock control", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mmx;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mmx =\t0x%"PRIx8" (MMX technology", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fxsr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fxsr =\t0x%"PRIx8" (FXSAVE / FXRSTOR", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sse;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sse =\t0x%"PRIx8" (SSE instructions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sse2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sse2 =\t0x%"PRIx8" (SSE2 instructions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ss;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ss =\t0x%"PRIx8" (Self-snoop", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.htt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " htt =\t0x%"PRIx8" (Multi-threading", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tm;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tm =\t0x%"PRIx8" (Thermal monitor", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.pbe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pbe =\t0x%"PRIx8" (Pending break enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register ext_feat_info (Extended feature information); type cpuid.ext_feat_info (Implicit type of Extended feature information register)
 */

/*
 * Dump of fields for register: ext_feat_info
 *   sse3 (size 1, offset 0):	 RO	  SSE3 extensions
 *   _anon1 (size 2, offset 1):	 RSVD	  _
 *   monitor (size 1, offset 3):	 RO	  MONITOR/MWAIT
 *   ds_cpl (size 1, offset 4):	 RO	  CPL qualified debug store
 *   vmx (size 1, offset 5):	 RO	  Virtual machine extensions
 *   smx (size 1, offset 6):	 RO	  Safer mode extensions
 *   est (size 1, offset 7):	 RO	  Enhanced Intel SpeedStep(tm) technology
 *   tm2 (size 1, offset 8):	 RO	  Thermal monitor 2
 *   ssse3 (size 1, offset 9):	 RO	  Supplemental SSE3 extensions
 *   cnxt_id (size 1, offset 10):	 RO	  L1 context ID
 *   _anon11 (size 2, offset 11):	 RSVD	  _
 *   cmpxchg16b (size 1, offset 13):	 RO	  CMPXCHG16B available
 *   xtpr_up (size 1, offset 14):	 RO	  xTPR update control
 *   pdcm (size 1, offset 15):	 RO	  Perfmon and debug capability
 *   _anon16 (size 3, offset 16):	 RSVD	  _
 *   sse4_1 (size 1, offset 19):	 RO	  SSE4.1
 *   sse4_2 (size 1, offset 20):	 RO	  SSE4.2
 *   _anon21 (size 2, offset 21):	 RSVD	  _
 *   popcnt (size 1, offset 23):	 RO	  POPCNT instruction
 *   _anon24 (size 8, offset 24):	 RSVD	  _
 */

static inline uint32_t __DP(ext_feat_info_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ext_feat_info_rd_raw)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x1));
}

static inline cpuid_ext_feat_info_t __DP(ext_feat_info_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_ext_feat_info_t __DP(ext_feat_info_rd)( __DN(t) * _dev )
{
    cpuid_ext_feat_info_un  u;
    u.raw = __DP(ecx_read_32)(_dev, (0x1));
    return u.val;
}

// Register ext_feat_info is not writeable


static inline int __DP(ext_feat_info_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ext_feat_info_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_ext_feat_info_un  u;
    u.raw = __DP(ecx_read_32)(_dev, (0x1));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ext_feat_info (Extended feature information):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.sse3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sse3 =\t0x%"PRIx8" (SSE3 extensions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.monitor;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " monitor =\t0x%"PRIx8" (MONITOR/MWAIT", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ds_cpl;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ds_cpl =\t0x%"PRIx8" (CPL qualified debug store", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vmx;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vmx =\t0x%"PRIx8" (Virtual machine extensions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.smx;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " smx =\t0x%"PRIx8" (Safer mode extensions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.est;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " est =\t0x%"PRIx8" (Enhanced Intel SpeedStep(tm) technology", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tm2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tm2 =\t0x%"PRIx8" (Thermal monitor 2", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ssse3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ssse3 =\t0x%"PRIx8" (Supplemental SSE3 extensions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cnxt_id;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cnxt_id =\t0x%"PRIx8" (L1 context ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.cmpxchg16b;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cmpxchg16b =\t0x%"PRIx8" (CMPXCHG16B available", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.xtpr_up;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " xtpr_up =\t0x%"PRIx8" (xTPR update control", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pdcm;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pdcm =\t0x%"PRIx8" (Perfmon and debug capability", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.sse4_1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sse4_1 =\t0x%"PRIx8" (SSE4.1", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sse4_2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sse4_2 =\t0x%"PRIx8" (SSE4.2", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.popcnt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " popcnt =\t0x%"PRIx8" (POPCNT instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register pns0 (Processor serial no. bits 0-31); type cpuid.uint32
 */

static inline uint32_t __DP(pns0_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(pns0_rd_raw)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x3));
}

static inline uint32_t __DP(pns0_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(pns0_rd)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x3));
}

// Register pns0 is not writeable


static inline int __DP(pns0_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pns0_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register pns0 (Processor serial no. bits 0-31):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(ecx_read_32)(_dev, (0x3)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register pns1 (Processor serial no. bits 32-63); type cpuid.uint32
 */

static inline uint32_t __DP(pns1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(pns1_rd_raw)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x3));
}

static inline uint32_t __DP(pns1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(pns1_rd)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x3));
}

// Register pns1 is not writeable


static inline int __DP(pns1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pns1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register pns1 (Processor serial no. bits 32-63):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(edx_read_32)(_dev, (0x3)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register cache_type (Cache type information); type cpuid.cache_type (Implicit type of Cache type information register array)
 */

/*
 * Dump of fields for register: cache_type
 *   ctf (size 5, offset 0):	 RO	  Cache type
 *   level (size 3, offset 5):	 RO	  Cache level (starts at 1)
 *   self_init (size 1, offset 8):	 RO	  Self initializing
 *   fully_assoc (size 1, offset 9):	 RO	  Fully associative
 *   wb_inval (size 1, offset 10):	 RO	  Write-back invalidate/invalidate
 *   inclusiveness (size 1, offset 11):	 RO	  Cache inclusiveness
 *   _anon12 (size 2, offset 12):	 RSVD	  _
 *   max_threads (size 12, offset 14):	 RO	  Max. # threads sharing this cache in package
 *   max_procs (size 6, offset 26):	 RO	  Max. # processor cores in this package
 */
static const int __DP(cache_type_length) = 0x4;
static inline uint32_t __DP(cache_type_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(cache_type_rd_raw)( __DN(t) * _dev, int _i )
{
    return __DP(dcpa_read_32)(_dev, (0x0) + (_i));
}

static inline cpuid_cache_type_t __DP(cache_type_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline cpuid_cache_type_t __DP(cache_type_rd)( __DN(t) * _dev, int _i )
{
    cpuid_cache_type_un  u;
    u.raw = __DP(dcpa_read_32)(_dev, (0x0) + (_i));
    return u.val;
}

// Register cache_type is not writeable


static inline int __DP(cache_type_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(cache_type_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    cpuid_cache_type_un  u;
    u.raw = __DP(dcpa_read_32)(_dev, (0x0) + (_i));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register cache_type[%d] (Cache type information):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.ctf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ctf =\t0x%"PRIx8" (Cache type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = cpuid_intel_cache_type_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.level;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " level =\t0x%"PRIx8" (Cache level (starts at 1)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.self_init;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " self_init =\t0x%"PRIx8" (Self initializing", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fully_assoc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fully_assoc =\t0x%"PRIx8" (Fully associative", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wb_inval;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wb_inval =\t0x%"PRIx8" (Write-back invalidate/invalidate", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.inclusiveness;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " inclusiveness =\t0x%"PRIx8" (Cache inclusiveness", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint16_t pv = (uint16_t)u.val.max_threads;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " max_threads =\t0x%0"PRIx16" (Max. # threads sharing this cache in package", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.max_procs;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " max_procs =\t0x%"PRIx8" (Max. # processor cores in this package", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}
static inline int __DP(cache_type_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cache_type_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x4; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(cache_type_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register cache_pars (Cache parameters); type cpuid.cache_pars (Implicit type of Cache parameters register array)
 */

/*
 * Dump of fields for register: cache_pars
 *   l (size 12, offset 0):	 RO	  System coherency line size (-1)
 *   p (size 10, offset 12):	 RO	  Physical line partitions (-1)
 *   w (size 10, offset 22):	 RO	  Ways of associativity (-1)
 */
static const int __DP(cache_pars_length) = 0x4;
static inline uint32_t __DP(cache_pars_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(cache_pars_rd_raw)( __DN(t) * _dev, int _i )
{
    return __DP(dcpb_read_32)(_dev, (0x0) + (_i));
}

static inline cpuid_cache_pars_t __DP(cache_pars_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline cpuid_cache_pars_t __DP(cache_pars_rd)( __DN(t) * _dev, int _i )
{
    cpuid_cache_pars_un  u;
    u.raw = __DP(dcpb_read_32)(_dev, (0x0) + (_i));
    return u.val;
}

// Register cache_pars is not writeable


static inline int __DP(cache_pars_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(cache_pars_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    cpuid_cache_pars_un  u;
    u.raw = __DP(dcpb_read_32)(_dev, (0x0) + (_i));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register cache_pars[%d] (Cache parameters):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.l;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " l =\t0x%0"PRIx16" (System coherency line size (-1)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.p;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " p =\t0x%0"PRIx16" (Physical line partitions (-1)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.w;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " w =\t0x%0"PRIx16" (Ways of associativity (-1)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}
static inline int __DP(cache_pars_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cache_pars_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x4; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(cache_pars_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register num_sets (Number of sets); type cpuid.uint32
 */
static const int __DP(num_sets_length) = 0x4;
static inline uint32_t __DP(num_sets_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(num_sets_rd_raw)( __DN(t) * _dev, int _i )
{
    return __DP(dcpc_read_32)(_dev, (0x0) + (_i));
}

static inline uint32_t __DP(num_sets_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(num_sets_rd)( __DN(t) * _dev, int _i )
{
    return __DP(dcpc_read_32)(_dev, (0x0) + (_i));
}

// Register num_sets is not writeable


static inline int __DP(num_sets_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(num_sets_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register num_sets[%d] (Number of sets):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(dcpc_read_32)(_dev, (0x0) + (_i)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(num_sets_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(num_sets_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x4; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(num_sets_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register min_monitor (Smallest monitor-line size)); type cpuid.min_monitor (Implicit type of Smallest monitor-line size) register)
 */

/*
 * Dump of fields for register: min_monitor
 *   sz (size 16, offset 0):	 RO	  Smallest monitor-line size (bytes)
 *   _anon16 (size 16, offset 16):	 MBZ	  _
 */

static inline uint32_t __DP(min_monitor_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(min_monitor_rd_raw)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x5));
}

static inline cpuid_min_monitor_t __DP(min_monitor_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_min_monitor_t __DP(min_monitor_rd)( __DN(t) * _dev )
{
    cpuid_min_monitor_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x5));
    return u.val;
}

// Register min_monitor is not writeable


static inline int __DP(min_monitor_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(min_monitor_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_min_monitor_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x5));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register min_monitor (Smallest monitor-line size)):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sz =\t0x%0"PRIx16" (Smallest monitor-line size (bytes)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register max_monitor (Largest monitor-line size)); type cpuid.max_monitor (Implicit type of Largest monitor-line size) register)
 */

/*
 * Dump of fields for register: max_monitor
 *   sz (size 16, offset 0):	 RO	  Largest monitor-line size (bytes)
 *   _anon16 (size 16, offset 16):	 RSVD	  _
 */

static inline uint32_t __DP(max_monitor_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(max_monitor_rd_raw)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x5));
}

static inline cpuid_max_monitor_t __DP(max_monitor_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_max_monitor_t __DP(max_monitor_rd)( __DN(t) * _dev )
{
    cpuid_max_monitor_un  u;
    u.raw = __DP(ebx_read_32)(_dev, (0x5));
    return u.val;
}

// Register max_monitor is not writeable


static inline int __DP(max_monitor_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(max_monitor_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_max_monitor_un  u;
    u.raw = __DP(ebx_read_32)(_dev, (0x5));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register max_monitor (Largest monitor-line size)):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sz =\t0x%0"PRIx16" (Largest monitor-line size (bytes)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register mwait_feat (MONITOR/MWAIT features); type cpuid.mwait_feat (Implicit type of MONITOR/MWAIT features register)
 */

/*
 * Dump of fields for register: mwait_feat
 *   emx (size 1, offset 0):	 RO	  Supports enum. of Monitor/Mwait extensions
 *   ibe (size 1, offset 1):	 RO	  Supports interrupts as break event
 *   _anon2 (size 30, offset 2):	 RSVD	  _
 */

static inline uint32_t __DP(mwait_feat_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mwait_feat_rd_raw)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x5));
}

static inline cpuid_mwait_feat_t __DP(mwait_feat_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_mwait_feat_t __DP(mwait_feat_rd)( __DN(t) * _dev )
{
    cpuid_mwait_feat_un  u;
    u.raw = __DP(ecx_read_32)(_dev, (0x5));
    return u.val;
}

// Register mwait_feat is not writeable


static inline int __DP(mwait_feat_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(mwait_feat_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_mwait_feat_un  u;
    u.raw = __DP(ecx_read_32)(_dev, (0x5));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register mwait_feat (MONITOR/MWAIT features):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.emx;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " emx =\t0x%"PRIx8" (Supports enum. of Monitor/Mwait extensions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ibe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ibe =\t0x%"PRIx8" (Supports interrupts as break event", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register mwait_cstates (sub-C states supported by MWAIT); type cpuid.mwait_cstates (Implicit type of sub-C states supported by MWAIT register)
 */

/*
 * Dump of fields for register: mwait_cstates
 *   c0 (size 4, offset 0):	 RO	  # C0 sub-C-states supported
 *   c1 (size 4, offset 4):	 RO	  # C1 sub-C-states supported
 *   c2 (size 4, offset 8):	 RO	  # C2 sub-C-states supported
 *   c3 (size 4, offset 12):	 RO	  # C3 sub-C-states supported
 *   c4 (size 4, offset 16):	 RO	  # C4 sub-C-states supported
 *   _anon20 (size 12, offset 20):	 MBZ	  _
 */

static inline uint32_t __DP(mwait_cstates_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(mwait_cstates_rd_raw)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x5));
}

static inline cpuid_mwait_cstates_t __DP(mwait_cstates_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_mwait_cstates_t __DP(mwait_cstates_rd)( __DN(t) * _dev )
{
    cpuid_mwait_cstates_un  u;
    u.raw = __DP(edx_read_32)(_dev, (0x5));
    return u.val;
}

// Register mwait_cstates is not writeable


static inline int __DP(mwait_cstates_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(mwait_cstates_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_mwait_cstates_un  u;
    u.raw = __DP(edx_read_32)(_dev, (0x5));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register mwait_cstates (sub-C states supported by MWAIT):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.c0;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " c0 =\t0x%"PRIx8" (# C0 sub-C-states supported", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.c1;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " c1 =\t0x%"PRIx8" (# C1 sub-C-states supported", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.c2;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " c2 =\t0x%"PRIx8" (# C2 sub-C-states supported", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.c3;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " c3 =\t0x%"PRIx8" (# C3 sub-C-states supported", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.c4;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " c4 =\t0x%"PRIx8" (# C4 sub-C-states supported", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register tpm_feat (Thermal features); type cpuid.tpm_feat (Implicit type of Thermal features register)
 */

/*
 * Dump of fields for register: tpm_feat
 *   dts (size 1, offset 0):	 RO	  Digital temperature sensor supported
 *   ida (size 1, offset 1):	 RO	  Intel dynamic acceleration enabled
 *   _anon2 (size 30, offset 2):	 MBZ	  _
 */

static inline uint32_t __DP(tpm_feat_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tpm_feat_rd_raw)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x6));
}

static inline cpuid_tpm_feat_t __DP(tpm_feat_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_tpm_feat_t __DP(tpm_feat_rd)( __DN(t) * _dev )
{
    cpuid_tpm_feat_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x6));
    return u.val;
}

// Register tpm_feat is not writeable


static inline int __DP(tpm_feat_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tpm_feat_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_tpm_feat_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x6));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tpm_feat (Thermal features):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.dts;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dts =\t0x%"PRIx8" (Digital temperature sensor supported", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ida;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ida =\t0x%"PRIx8" (Intel dynamic acceleration enabled", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register tpm_thresh (# interrupt thresholds in sensor); type cpuid.tpm_thresh (Implicit type of # interrupt thresholds in sensor register)
 */

/*
 * Dump of fields for register: tpm_thresh
 *   val (size 4, offset 0):	 RO	  # interrupt thresholds in sensor
 *   _anon4 (size 28, offset 4):	 RSVD	  _
 */

static inline uint32_t __DP(tpm_thresh_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tpm_thresh_rd_raw)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x6));
}

static inline cpuid_tpm_thresh_t __DP(tpm_thresh_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_tpm_thresh_t __DP(tpm_thresh_rd)( __DN(t) * _dev )
{
    cpuid_tpm_thresh_un  u;
    u.raw = __DP(ebx_read_32)(_dev, (0x6));
    return u.val;
}

// Register tpm_thresh is not writeable


static inline int __DP(tpm_thresh_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tpm_thresh_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_tpm_thresh_un  u;
    u.raw = __DP(ebx_read_32)(_dev, (0x6));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tpm_thresh (# interrupt thresholds in sensor):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.val;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " val =\t0x%"PRIx8" (# interrupt thresholds in sensor", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register tpm_hcfc (Hardware coordination feedback); type cpuid.tpm_hcfc (Implicit type of Hardware coordination feedback register)
 */

/*
 * Dump of fields for register: tpm_hcfc
 *   en (size 1, offset 0):	 RO	  HCFC present (MCNT/ACNT MSRs)
 *   _anon1 (size 31, offset 1):	 RSVD	  _
 */

static inline uint32_t __DP(tpm_hcfc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(tpm_hcfc_rd_raw)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x6));
}

static inline cpuid_tpm_hcfc_t __DP(tpm_hcfc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_tpm_hcfc_t __DP(tpm_hcfc_rd)( __DN(t) * _dev )
{
    cpuid_tpm_hcfc_un  u;
    u.raw = __DP(ecx_read_32)(_dev, (0x6));
    return u.val;
}

// Register tpm_hcfc is not writeable


static inline int __DP(tpm_hcfc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(tpm_hcfc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_tpm_hcfc_un  u;
    u.raw = __DP(ecx_read_32)(_dev, (0x6));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register tpm_hcfc (Hardware coordination feedback):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " en =\t0x%"PRIx8" (HCFC present (MCNT/ACNT MSRs)", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register apm_gen (Gen-purpose perf. counter info); type cpuid.apm_gen (Implicit type of Gen-purpose perf. counter info register)
 */

/*
 * Dump of fields for register: apm_gen
 *   version (size 8, offset 0):	 RO	  Version ID
 *   num_counters (size 8, offset 8):	 RO	  # GP perf. counters per logical processor
 *   width (size 8, offset 16):	 RO	  Bit width of GP perf. counters
 *   vec_length (size 8, offset 24):	 RO	  EBX bit vector length to enumerate events
 */

static inline uint32_t __DP(apm_gen_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(apm_gen_rd_raw)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0xa));
}

static inline cpuid_apm_gen_t __DP(apm_gen_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_apm_gen_t __DP(apm_gen_rd)( __DN(t) * _dev )
{
    cpuid_apm_gen_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0xa));
    return u.val;
}

// Register apm_gen is not writeable


static inline int __DP(apm_gen_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(apm_gen_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_apm_gen_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0xa));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register apm_gen (Gen-purpose perf. counter info):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.version;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " version =\t0x%"PRIx8" (Version ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.num_counters;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " num_counters =\t0x%"PRIx8" (# GP perf. counters per logical processor", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.width;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " width =\t0x%"PRIx8" (Bit width of GP perf. counters", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vec_length;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vec_length =\t0x%"PRIx8" (EBX bit vector length to enumerate events", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register apm_feat (Performance monitoring event availability); type cpuid.apm_feat (Implicit type of Performance monitoring event availability register)
 */

/*
 * Dump of fields for register: apm_feat
 *   cc (size 1, offset 0):	 RO	  Core cycle event
 *   ir (size 1, offset 1):	 RO	  Instruction retired
 *   rc (size 1, offset 2):	 RO	  Reference cycles
 *   llcr (size 1, offset 3):	 RO	  Last-level cache reference
 *   llcm (size 1, offset 4):	 RO	  Last-level cache miss
 *   bir (size 1, offset 5):	 RO	  Branch instruction retired
 *   bmr (size 1, offset 6):	 RO	  Branch mispredict retired
 *   _anon7 (size 25, offset 7):	 MBZ	  _
 */

static inline uint32_t __DP(apm_feat_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(apm_feat_rd_raw)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0xa));
}

static inline cpuid_apm_feat_t __DP(apm_feat_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_apm_feat_t __DP(apm_feat_rd)( __DN(t) * _dev )
{
    cpuid_apm_feat_un  u;
    u.raw = __DP(ebx_read_32)(_dev, (0xa));
    return u.val;
}

// Register apm_feat is not writeable


static inline int __DP(apm_feat_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(apm_feat_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_apm_feat_un  u;
    u.raw = __DP(ebx_read_32)(_dev, (0xa));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register apm_feat (Performance monitoring event availability):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.cc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cc =\t0x%"PRIx8" (Core cycle event", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ir;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ir =\t0x%"PRIx8" (Instruction retired", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rc =\t0x%"PRIx8" (Reference cycles", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.llcr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " llcr =\t0x%"PRIx8" (Last-level cache reference", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.llcm;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " llcm =\t0x%"PRIx8" (Last-level cache miss", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.bir;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bir =\t0x%"PRIx8" (Branch instruction retired", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.bmr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " bmr =\t0x%"PRIx8" (Branch mispredict retired", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register apm_fixed (Fixed-function perf. counter infos); type cpuid.apm_fixed (Implicit type of Fixed-function perf. counter infos register)
 */

/*
 * Dump of fields for register: apm_fixed
 *   num (size 5, offset 0):	 RO	  # Fixed-function perf. counters
 *   width (size 8, offset 5):	 RO	  Width of fixed-function perf. counters
 *   _anon13 (size 19, offset 13):	 RSVD	  _
 */

static inline uint32_t __DP(apm_fixed_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(apm_fixed_rd_raw)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0xa));
}

static inline cpuid_apm_fixed_t __DP(apm_fixed_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_apm_fixed_t __DP(apm_fixed_rd)( __DN(t) * _dev )
{
    cpuid_apm_fixed_un  u;
    u.raw = __DP(edx_read_32)(_dev, (0xa));
    return u.val;
}

// Register apm_fixed is not writeable


static inline int __DP(apm_fixed_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(apm_fixed_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_apm_fixed_un  u;
    u.raw = __DP(edx_read_32)(_dev, (0xa));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register apm_fixed (Fixed-function perf. counter infos):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.num;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " num =\t0x%"PRIx8" (# Fixed-function perf. counters", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.width;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " width =\t0x%"PRIx8" (Width of fixed-function perf. counters", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register ext_biv (Max input val for ext. CPUID info); type cpuid.uint32
 */

static inline uint32_t __DP(ext_biv_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ext_biv_rd_raw)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x80000000));
}

static inline uint32_t __DP(ext_biv_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ext_biv_rd)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x80000000));
}

// Register ext_biv is not writeable


static inline int __DP(ext_biv_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ext_biv_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ext_biv (Max input val for ext. CPUID info):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(eax_read_32)(_dev, (0x80000000)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register evendor0 (Ext. Vendor string pt 1); type cpuid.uint32
 */

static inline uint32_t __DP(evendor0_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(evendor0_rd_raw)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x80000000));
}

static inline uint32_t __DP(evendor0_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(evendor0_rd)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x80000000));
}

// Register evendor0 is not writeable


static inline int __DP(evendor0_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(evendor0_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register evendor0 (Ext. Vendor string pt 1):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(ebx_read_32)(_dev, (0x80000000)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register evendor1 (Ext. Vendor string pt 2); type cpuid.uint32
 */

static inline uint32_t __DP(evendor1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(evendor1_rd_raw)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x80000000));
}

static inline uint32_t __DP(evendor1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(evendor1_rd)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x80000000));
}

// Register evendor1 is not writeable


static inline int __DP(evendor1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(evendor1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register evendor1 (Ext. Vendor string pt 2):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(edx_read_32)(_dev, (0x80000000)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register evendor2 (Ext. Vendor string pt 3); type cpuid.uint32
 */

static inline uint32_t __DP(evendor2_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(evendor2_rd_raw)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x80000000));
}

static inline uint32_t __DP(evendor2_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(evendor2_rd)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x80000000));
}

// Register evendor2 is not writeable


static inline int __DP(evendor2_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(evendor2_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register evendor2 (Ext. Vendor string pt 3):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(ecx_read_32)(_dev, (0x80000000)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register brandid (Brand ID identifier); type cpuid.brandid (Implicit type of Brand ID identifier register)
 */

/*
 * Dump of fields for register: brandid
 *   id (size 16, offset 0):	 RO	  Extended brand ID
 *   _anon16 (size 12, offset 16):	 RSVD	  _
 *   pkgtype (size 4, offset 28):	 RO	  Package type
 */

static inline uint32_t __DP(brandid_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brandid_rd_raw)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x80000001));
}

static inline cpuid_brandid_t __DP(brandid_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_brandid_t __DP(brandid_rd)( __DN(t) * _dev )
{
    cpuid_brandid_un  u;
    u.raw = __DP(ebx_read_32)(_dev, (0x80000001));
    return u.val;
}

// Register brandid is not writeable


static inline int __DP(brandid_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(brandid_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_brandid_un  u;
    u.raw = __DP(ebx_read_32)(_dev, (0x80000001));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register brandid (Brand ID identifier):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.id;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " id =\t0x%0"PRIx16" (Extended brand ID", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.pkgtype;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pkgtype =\t0x%"PRIx8" (Package type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register ext_featc (Extend misc. features 1); type cpuid.ext_featc (Implicit type of Extend misc. features 1 register)
 */

/*
 * Dump of fields for register: ext_featc
 *   lahfsahf (size 1, offset 0):	 RO	  LAHF & SAHF support in 64-bit mode
 *   cmplegacy (size 1, offset 1):	 RO	  Core multiprocessing legacy mode
 *   svm (size 1, offset 2):	 RO	  Secure virtual machine
 *   extapicspace (size 1, offset 3):	 RO	  Extended APIC space
 *   altmovcr8 (size 1, offset 4):	 RO	  LOCK MOV CR0 means MOV CR8
 *   abm (size 1, offset 5):	 RO	  Advanced bit manipulation
 *   sse4a (size 1, offset 6):	 RO	  EXTRQ/INSERTQ/MOVNTSS/MOVNTSD support
 *   misalignsse (size 1, offset 7):	 RO	  Misaligned SSE mode
 *   pref3dnow (size 1, offset 8):	 RO	  PREFETCH/PREFETCHW support
 *   osvw (size 1, offset 9):	 RO	  OS visible workaround
 *   ibs (size 1, offset 10):	 RO	  Instruction-based sampling
 *   sse5 (size 1, offset 11):	 RO	  SSE 5 instruction support
 *   skinit (size 1, offset 12):	 RO	  SKINIT/STGI supported
 *   wdt (size 1, offset 13):	 RO	  Watchdog timer support
 *   _anon14 (size 18, offset 14):	 RSVD	  _
 */

static inline uint32_t __DP(ext_featc_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ext_featc_rd_raw)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x80000001));
}

static inline cpuid_ext_featc_t __DP(ext_featc_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_ext_featc_t __DP(ext_featc_rd)( __DN(t) * _dev )
{
    cpuid_ext_featc_un  u;
    u.raw = __DP(ecx_read_32)(_dev, (0x80000001));
    return u.val;
}

// Register ext_featc is not writeable


static inline int __DP(ext_featc_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ext_featc_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_ext_featc_un  u;
    u.raw = __DP(ecx_read_32)(_dev, (0x80000001));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ext_featc (Extend misc. features 1):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.lahfsahf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lahfsahf =\t0x%"PRIx8" (LAHF & SAHF support in 64-bit mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cmplegacy;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cmplegacy =\t0x%"PRIx8" (Core multiprocessing legacy mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.svm;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " svm =\t0x%"PRIx8" (Secure virtual machine", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.extapicspace;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " extapicspace =\t0x%"PRIx8" (Extended APIC space", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.altmovcr8;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " altmovcr8 =\t0x%"PRIx8" (LOCK MOV CR0 means MOV CR8", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.abm;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " abm =\t0x%"PRIx8" (Advanced bit manipulation", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sse4a;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sse4a =\t0x%"PRIx8" (EXTRQ/INSERTQ/MOVNTSS/MOVNTSD support", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.misalignsse;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " misalignsse =\t0x%"PRIx8" (Misaligned SSE mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pref3dnow;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pref3dnow =\t0x%"PRIx8" (PREFETCH/PREFETCHW support", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.osvw;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " osvw =\t0x%"PRIx8" (OS visible workaround", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ibs;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ibs =\t0x%"PRIx8" (Instruction-based sampling", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sse5;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sse5 =\t0x%"PRIx8" (SSE 5 instruction support", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.skinit;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " skinit =\t0x%"PRIx8" (SKINIT/STGI supported", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.wdt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " wdt =\t0x%"PRIx8" (Watchdog timer support", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register ext_featd (Extend misc. features 2); type cpuid.ext_featd (Implicit type of Extend misc. features 2 register)
 */

/*
 * Dump of fields for register: ext_featd
 *   _anon0 (size 11, offset 0):	 RSVD	  _
 *   syscallsysret (size 1, offset 11):	 RO	  SYSCALL/SYSRET available in 64-bit mode
 *   _anon12 (size 8, offset 12):	 RSVD	  _
 *   nx (size 1, offset 20):	 RO	  No-execute page protection
 *   _anon21 (size 1, offset 21):	 RSVD	  _
 *   mmxext (size 1, offset 22):	 RO	  AMD extensions to MMX instructions
 *   _anon23 (size 2, offset 23):	 RSVD	  _
 *   ffxsr (size 1, offset 25):	 RO	  FFXSR instruction optimizations
 *   page1fb (size 1, offset 26):	 RO	  1-GB large page support
 *   rdtscp (size 1, offset 27):	 RO	  RDTSCP instruction
 *   _anon28 (size 1, offset 28):	 RSVD	  _
 *   longmode (size 1, offset 29):	 RO	  Long mode / Intel64 available
 *   i3dnowext (size 1, offset 30):	 RO	  AMD extensions to 3DNow! instructions
 *   i3dnow (size 1, offset 31):	 RO	  3DNow! instructions
 */

static inline uint32_t __DP(ext_featd_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(ext_featd_rd_raw)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x80000001));
}

static inline cpuid_ext_featd_t __DP(ext_featd_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_ext_featd_t __DP(ext_featd_rd)( __DN(t) * _dev )
{
    cpuid_ext_featd_un  u;
    u.raw = __DP(edx_read_32)(_dev, (0x80000001));
    return u.val;
}

// Register ext_featd is not writeable


static inline int __DP(ext_featd_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(ext_featd_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_ext_featd_un  u;
    u.raw = __DP(edx_read_32)(_dev, (0x80000001));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register ext_featd (Extend misc. features 2):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.syscallsysret;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " syscallsysret =\t0x%"PRIx8" (SYSCALL/SYSRET available in 64-bit mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.nx;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " nx =\t0x%"PRIx8" (No-execute page protection", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.mmxext;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mmxext =\t0x%"PRIx8" (AMD extensions to MMX instructions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.ffxsr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ffxsr =\t0x%"PRIx8" (FFXSR instruction optimizations", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.page1fb;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " page1fb =\t0x%"PRIx8" (1-GB large page support", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rdtscp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rdtscp =\t0x%"PRIx8" (RDTSCP instruction", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.longmode;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " longmode =\t0x%"PRIx8" (Long mode / Intel64 available", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.i3dnowext;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " i3dnowext =\t0x%"PRIx8" (AMD extensions to 3DNow! instructions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.i3dnow;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " i3dnow =\t0x%"PRIx8" (3DNow! instructions", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register brand0 (Brand string contd.); type cpuid.uint32
 */

static inline uint32_t __DP(brand0_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand0_rd_raw)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x80000002));
}

static inline uint32_t __DP(brand0_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand0_rd)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x80000002));
}

// Register brand0 is not writeable


static inline int __DP(brand0_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(brand0_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register brand0 (Brand string contd.):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(eax_read_32)(_dev, (0x80000002)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register brand1 (Brand string contd.); type cpuid.uint32
 */

static inline uint32_t __DP(brand1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand1_rd_raw)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x80000002));
}

static inline uint32_t __DP(brand1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand1_rd)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x80000002));
}

// Register brand1 is not writeable


static inline int __DP(brand1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(brand1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register brand1 (Brand string contd.):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(ebx_read_32)(_dev, (0x80000002)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register brand2 (Brand string contd.); type cpuid.uint32
 */

static inline uint32_t __DP(brand2_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand2_rd_raw)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x80000002));
}

static inline uint32_t __DP(brand2_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand2_rd)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x80000002));
}

// Register brand2 is not writeable


static inline int __DP(brand2_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(brand2_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register brand2 (Brand string contd.):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(ecx_read_32)(_dev, (0x80000002)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register brand3 (Brand string contd.); type cpuid.uint32
 */

static inline uint32_t __DP(brand3_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand3_rd_raw)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x80000002));
}

static inline uint32_t __DP(brand3_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand3_rd)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x80000002));
}

// Register brand3 is not writeable


static inline int __DP(brand3_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(brand3_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register brand3 (Brand string contd.):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(edx_read_32)(_dev, (0x80000002)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register brand4 (Brand string contd.); type cpuid.uint32
 */

static inline uint32_t __DP(brand4_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand4_rd_raw)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x80000003));
}

static inline uint32_t __DP(brand4_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand4_rd)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x80000003));
}

// Register brand4 is not writeable


static inline int __DP(brand4_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(brand4_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register brand4 (Brand string contd.):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(eax_read_32)(_dev, (0x80000003)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register brand5 (Brand string contd.); type cpuid.uint32
 */

static inline uint32_t __DP(brand5_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand5_rd_raw)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x80000003));
}

static inline uint32_t __DP(brand5_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand5_rd)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x80000003));
}

// Register brand5 is not writeable


static inline int __DP(brand5_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(brand5_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register brand5 (Brand string contd.):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(ebx_read_32)(_dev, (0x80000003)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register brand6 (Brand string contd.); type cpuid.uint32
 */

static inline uint32_t __DP(brand6_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand6_rd_raw)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x80000003));
}

static inline uint32_t __DP(brand6_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand6_rd)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x80000003));
}

// Register brand6 is not writeable


static inline int __DP(brand6_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(brand6_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register brand6 (Brand string contd.):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(ecx_read_32)(_dev, (0x80000003)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register brand7 (Brand string contd.); type cpuid.uint32
 */

static inline uint32_t __DP(brand7_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand7_rd_raw)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x80000003));
}

static inline uint32_t __DP(brand7_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand7_rd)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x80000003));
}

// Register brand7 is not writeable


static inline int __DP(brand7_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(brand7_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register brand7 (Brand string contd.):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(edx_read_32)(_dev, (0x80000003)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register brand8 (Brand string contd.); type cpuid.uint32
 */

static inline uint32_t __DP(brand8_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand8_rd_raw)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x80000004));
}

static inline uint32_t __DP(brand8_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand8_rd)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x80000004));
}

// Register brand8 is not writeable


static inline int __DP(brand8_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(brand8_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register brand8 (Brand string contd.):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(eax_read_32)(_dev, (0x80000004)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register brand9 (Brand string contd.); type cpuid.uint32
 */

static inline uint32_t __DP(brand9_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand9_rd_raw)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x80000004));
}

static inline uint32_t __DP(brand9_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brand9_rd)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x80000004));
}

// Register brand9 is not writeable


static inline int __DP(brand9_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(brand9_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register brand9 (Brand string contd.):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(ebx_read_32)(_dev, (0x80000004)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register branda (Brand string contd.); type cpuid.uint32
 */

static inline uint32_t __DP(branda_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(branda_rd_raw)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x80000004));
}

static inline uint32_t __DP(branda_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(branda_rd)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x80000004));
}

// Register branda is not writeable


static inline int __DP(branda_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(branda_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register branda (Brand string contd.):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(ecx_read_32)(_dev, (0x80000004)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register brandb (Brand string contd.); type cpuid.uint32
 */

static inline uint32_t __DP(brandb_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brandb_rd_raw)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x80000004));
}

static inline uint32_t __DP(brandb_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(brandb_rd)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x80000004));
}

// Register brandb is not writeable


static inline int __DP(brandb_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(brandb_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register brandb (Brand string contd.):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(edx_read_32)(_dev, (0x80000004)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register l1_24m (AMD L1 TLB info for 2MB/4MB pages); type cpuid.amd_tlbinfo1 (AMD TLB information)
 */

/*
 * Dump of fields for register: l1_24m
 *   itlb_sz (size 8, offset 0):	 RO	  Number of instruction TLB entries
 *   itlb_asc (size 8, offset 8):	 RO	  Instruction TLB associativity
 *   dtlb_sz (size 8, offset 16):	 RO	  Number of data DTLB entries
 *   dtlb_asc (size 8, offset 24):	 RO	  Data TLB associativity
 */

static inline uint32_t __DP(l1_24m_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(l1_24m_rd_raw)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x80000005));
}

static inline cpuid_amd_tlbinfo1_t __DP(l1_24m_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_amd_tlbinfo1_t __DP(l1_24m_rd)( __DN(t) * _dev )
{
    cpuid_amd_tlbinfo1_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x80000005));
    return u.val;
}

// Register l1_24m is not writeable


static inline int __DP(l1_24m_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(l1_24m_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_amd_tlbinfo1_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x80000005));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register l1_24m (AMD L1 TLB info for 2MB/4MB pages):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.itlb_sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " itlb_sz =\t0x%"PRIx8" (Number of instruction TLB entries", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.itlb_asc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " itlb_asc =\t0x%"PRIx8" (Instruction TLB associativity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dtlb_sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dtlb_sz =\t0x%"PRIx8" (Number of data DTLB entries", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dtlb_asc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dtlb_asc =\t0x%"PRIx8" (Data TLB associativity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register l1_4k (AMD L1 TLB info for 4k pages); type cpuid.amd_tlbinfo1 (AMD TLB information)
 */

/*
 * Dump of fields for register: l1_4k
 *   itlb_sz (size 8, offset 0):	 RO	  Number of instruction TLB entries
 *   itlb_asc (size 8, offset 8):	 RO	  Instruction TLB associativity
 *   dtlb_sz (size 8, offset 16):	 RO	  Number of data DTLB entries
 *   dtlb_asc (size 8, offset 24):	 RO	  Data TLB associativity
 */

static inline uint32_t __DP(l1_4k_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(l1_4k_rd_raw)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x80000005));
}

static inline cpuid_amd_tlbinfo1_t __DP(l1_4k_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_amd_tlbinfo1_t __DP(l1_4k_rd)( __DN(t) * _dev )
{
    cpuid_amd_tlbinfo1_un  u;
    u.raw = __DP(ebx_read_32)(_dev, (0x80000005));
    return u.val;
}

// Register l1_4k is not writeable


static inline int __DP(l1_4k_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(l1_4k_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_amd_tlbinfo1_un  u;
    u.raw = __DP(ebx_read_32)(_dev, (0x80000005));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register l1_4k (AMD L1 TLB info for 4k pages):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.itlb_sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " itlb_sz =\t0x%"PRIx8" (Number of instruction TLB entries", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.itlb_asc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " itlb_asc =\t0x%"PRIx8" (Instruction TLB associativity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dtlb_sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dtlb_sz =\t0x%"PRIx8" (Number of data DTLB entries", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dtlb_asc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dtlb_asc =\t0x%"PRIx8" (Data TLB associativity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register l1_dci (AMD L1 DCache info); type cpuid.amd_cacheinfo1 (AMD cache information)
 */

/*
 * Dump of fields for register: l1_dci
 *   linesize (size 8, offset 0):	 RO	  line size
 *   lpt (size 8, offset 8):	 RO	  lines per tag
 *   assoc (size 8, offset 16):	 RO	  associativity
 *   size (size 8, offset 24):	 RO	  size in Kb
 */

static inline uint32_t __DP(l1_dci_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(l1_dci_rd_raw)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x80000005));
}

static inline cpuid_amd_cacheinfo1_t __DP(l1_dci_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_amd_cacheinfo1_t __DP(l1_dci_rd)( __DN(t) * _dev )
{
    cpuid_amd_cacheinfo1_un  u;
    u.raw = __DP(ecx_read_32)(_dev, (0x80000005));
    return u.val;
}

// Register l1_dci is not writeable


static inline int __DP(l1_dci_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(l1_dci_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_amd_cacheinfo1_un  u;
    u.raw = __DP(ecx_read_32)(_dev, (0x80000005));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register l1_dci (AMD L1 DCache info):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.linesize;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " linesize =\t0x%"PRIx8" (line size", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lpt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lpt =\t0x%"PRIx8" (lines per tag", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.assoc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " assoc =\t0x%"PRIx8" (associativity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.size;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " size =\t0x%"PRIx8" (size in Kb", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register l1_ici (AMD L1 ICache info); type cpuid.amd_cacheinfo1 (AMD cache information)
 */

/*
 * Dump of fields for register: l1_ici
 *   linesize (size 8, offset 0):	 RO	  line size
 *   lpt (size 8, offset 8):	 RO	  lines per tag
 *   assoc (size 8, offset 16):	 RO	  associativity
 *   size (size 8, offset 24):	 RO	  size in Kb
 */

static inline uint32_t __DP(l1_ici_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(l1_ici_rd_raw)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x80000005));
}

static inline cpuid_amd_cacheinfo1_t __DP(l1_ici_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_amd_cacheinfo1_t __DP(l1_ici_rd)( __DN(t) * _dev )
{
    cpuid_amd_cacheinfo1_un  u;
    u.raw = __DP(edx_read_32)(_dev, (0x80000005));
    return u.val;
}

// Register l1_ici is not writeable


static inline int __DP(l1_ici_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(l1_ici_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_amd_cacheinfo1_un  u;
    u.raw = __DP(edx_read_32)(_dev, (0x80000005));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register l1_ici (AMD L1 ICache info):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.linesize;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " linesize =\t0x%"PRIx8" (line size", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lpt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lpt =\t0x%"PRIx8" (lines per tag", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.assoc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " assoc =\t0x%"PRIx8" (associativity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.size;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " size =\t0x%"PRIx8" (size in Kb", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register l2_24m (AMD L2 TLB info for 2MB/4MB pages); type cpuid.amd_tlbinfo23 (AMD TLB information)
 */

/*
 * Dump of fields for register: l2_24m
 *   itlb_sz (size 12, offset 0):	 RO	  Number of instruction TLB entries
 *   itlb_asc (size 4, offset 12):	 RO	  Instruction TLB associativity
 *   dtlb_sz (size 12, offset 16):	 RO	  Number of data DTLB entries
 *   dtlb_asc (size 4, offset 28):	 RO	  Data TLB associativity
 */

static inline uint32_t __DP(l2_24m_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(l2_24m_rd_raw)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x80000006));
}

static inline cpuid_amd_tlbinfo23_t __DP(l2_24m_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_amd_tlbinfo23_t __DP(l2_24m_rd)( __DN(t) * _dev )
{
    cpuid_amd_tlbinfo23_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x80000006));
    return u.val;
}

// Register l2_24m is not writeable


static inline int __DP(l2_24m_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(l2_24m_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_amd_tlbinfo23_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x80000006));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register l2_24m (AMD L2 TLB info for 2MB/4MB pages):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.itlb_sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " itlb_sz =\t0x%0"PRIx16" (Number of instruction TLB entries", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.itlb_asc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " itlb_asc =\t0x%"PRIx8" (Instruction TLB associativity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.dtlb_sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dtlb_sz =\t0x%0"PRIx16" (Number of data DTLB entries", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dtlb_asc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dtlb_asc =\t0x%"PRIx8" (Data TLB associativity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register l2_4k (AMD L2 TLB info for 4k pages); type cpuid.amd_tlbinfo23 (AMD TLB information)
 */

/*
 * Dump of fields for register: l2_4k
 *   itlb_sz (size 12, offset 0):	 RO	  Number of instruction TLB entries
 *   itlb_asc (size 4, offset 12):	 RO	  Instruction TLB associativity
 *   dtlb_sz (size 12, offset 16):	 RO	  Number of data DTLB entries
 *   dtlb_asc (size 4, offset 28):	 RO	  Data TLB associativity
 */

static inline uint32_t __DP(l2_4k_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(l2_4k_rd_raw)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x80000006));
}

static inline cpuid_amd_tlbinfo23_t __DP(l2_4k_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_amd_tlbinfo23_t __DP(l2_4k_rd)( __DN(t) * _dev )
{
    cpuid_amd_tlbinfo23_un  u;
    u.raw = __DP(ebx_read_32)(_dev, (0x80000006));
    return u.val;
}

// Register l2_4k is not writeable


static inline int __DP(l2_4k_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(l2_4k_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_amd_tlbinfo23_un  u;
    u.raw = __DP(ebx_read_32)(_dev, (0x80000006));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register l2_4k (AMD L2 TLB info for 4k pages):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.itlb_sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " itlb_sz =\t0x%0"PRIx16" (Number of instruction TLB entries", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.itlb_asc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " itlb_asc =\t0x%"PRIx8" (Instruction TLB associativity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.dtlb_sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dtlb_sz =\t0x%0"PRIx16" (Number of data DTLB entries", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dtlb_asc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dtlb_asc =\t0x%"PRIx8" (Data TLB associativity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register l2_ci (AMD L2 cache info); type cpuid.amd_cacheinfo23 (AMD cache information)
 */

/*
 * Dump of fields for register: l2_ci
 *   linesize (size 8, offset 0):	 RO	  line size
 *   lpt (size 4, offset 8):	 RO	  lines per tag
 *   assoc (size 4, offset 12):	 RO	  associativity
 *   size (size 16, offset 16):	 RO	  size in Kb
 */

static inline uint32_t __DP(l2_ci_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(l2_ci_rd_raw)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x80000006));
}

static inline cpuid_amd_cacheinfo23_t __DP(l2_ci_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_amd_cacheinfo23_t __DP(l2_ci_rd)( __DN(t) * _dev )
{
    cpuid_amd_cacheinfo23_un  u;
    u.raw = __DP(ecx_read_32)(_dev, (0x80000006));
    return u.val;
}

// Register l2_ci is not writeable


static inline int __DP(l2_ci_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(l2_ci_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_amd_cacheinfo23_un  u;
    u.raw = __DP(ecx_read_32)(_dev, (0x80000006));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register l2_ci (AMD L2 cache info):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.linesize;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " linesize =\t0x%"PRIx8" (line size", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lpt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lpt =\t0x%"PRIx8" (lines per tag", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.assoc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " assoc =\t0x%"PRIx8" (associativity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.size;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " size =\t0x%0"PRIx16" (size in Kb", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register l3_ci (AMD L3 cache info); type cpuid.amd_cacheinfo23 (AMD cache information)
 */

/*
 * Dump of fields for register: l3_ci
 *   linesize (size 8, offset 0):	 RO	  line size
 *   lpt (size 4, offset 8):	 RO	  lines per tag
 *   assoc (size 4, offset 12):	 RO	  associativity
 *   size (size 16, offset 16):	 RO	  size in Kb
 */

static inline uint32_t __DP(l3_ci_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(l3_ci_rd_raw)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x80000006));
}

static inline cpuid_amd_cacheinfo23_t __DP(l3_ci_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_amd_cacheinfo23_t __DP(l3_ci_rd)( __DN(t) * _dev )
{
    cpuid_amd_cacheinfo23_un  u;
    u.raw = __DP(edx_read_32)(_dev, (0x80000006));
    return u.val;
}

// Register l3_ci is not writeable


static inline int __DP(l3_ci_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(l3_ci_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_amd_cacheinfo23_un  u;
    u.raw = __DP(edx_read_32)(_dev, (0x80000006));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register l3_ci (AMD L3 cache info):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.linesize;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " linesize =\t0x%"PRIx8" (line size", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lpt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lpt =\t0x%"PRIx8" (lines per tag", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.assoc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " assoc =\t0x%"PRIx8" (associativity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.size;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " size =\t0x%0"PRIx16" (size in Kb", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register amd_apm (AMD Advanced Power Mgmt); type cpuid.amd_apm (Implicit type of AMD Advanced Power Mgmt register)
 */

/*
 * Dump of fields for register: amd_apm
 *   ts (size 1, offset 0):	 RO	  Temperature sensor
 *   fid (size 1, offset 1):	 RO	  Frequency ID control
 *   vid (size 1, offset 2):	 RO	  Voltage ID control
 *   ttp (size 1, offset 3):	 RO	  THERMTRIP
 *   tm (size 1, offset 4):	 RO	  Hardware thermal control
 *   stc (size 1, offset 5):	 RO	  Software thermal control
 *   Mhz100steps (size 1, offset 6):	 RO	  100MHz multiplier control
 *   hpwstate (size 1, offset 7):	 RO	  Hardware P-State control
 *   tscinvariant (size 1, offset 8):	 RO	  TSC rate invariant
 *   _anon9 (size 23, offset 9):	 RSVD	  _
 */

static inline uint32_t __DP(amd_apm_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(amd_apm_rd_raw)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x80000007));
}

static inline cpuid_amd_apm_t __DP(amd_apm_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_amd_apm_t __DP(amd_apm_rd)( __DN(t) * _dev )
{
    cpuid_amd_apm_un  u;
    u.raw = __DP(edx_read_32)(_dev, (0x80000007));
    return u.val;
}

// Register amd_apm is not writeable


static inline int __DP(amd_apm_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(amd_apm_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_amd_apm_un  u;
    u.raw = __DP(edx_read_32)(_dev, (0x80000007));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register amd_apm (AMD Advanced Power Mgmt):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.ts;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ts =\t0x%"PRIx8" (Temperature sensor", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.fid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fid =\t0x%"PRIx8" (Frequency ID control", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vid;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vid =\t0x%"PRIx8" (Voltage ID control", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.ttp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ttp =\t0x%"PRIx8" (THERMTRIP", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tm;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tm =\t0x%"PRIx8" (Hardware thermal control", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.stc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " stc =\t0x%"PRIx8" (Software thermal control", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.Mhz100steps;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " Mhz100steps =\t0x%"PRIx8" (100MHz multiplier control", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.hpwstate;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " hpwstate =\t0x%"PRIx8" (Hardware P-State control", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tscinvariant;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tscinvariant =\t0x%"PRIx8" (TSC rate invariant", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register addr_size (Address size); type cpuid.addr_size (Implicit type of Address size register)
 */

/*
 * Dump of fields for register: addr_size
 *   phys (size 8, offset 0):	 RO	  Max physical byte address size in bits
 *   linear (size 8, offset 8):	 RO	  Max linear byte address size in bits
 *   guest (size 8, offset 16):	 RO	  Max guest physical byte address size in bits
 *   _anon24 (size 8, offset 24):	 RSVD	  _
 */

static inline uint32_t __DP(addr_size_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(addr_size_rd_raw)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x80000008));
}

static inline cpuid_addr_size_t __DP(addr_size_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_addr_size_t __DP(addr_size_rd)( __DN(t) * _dev )
{
    cpuid_addr_size_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x80000008));
    return u.val;
}

// Register addr_size is not writeable


static inline int __DP(addr_size_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(addr_size_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_addr_size_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x80000008));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register addr_size (Address size):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.phys;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " phys =\t0x%"PRIx8" (Max physical byte address size in bits", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.linear;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " linear =\t0x%"PRIx8" (Max linear byte address size in bits", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.guest;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " guest =\t0x%"PRIx8" (Max guest physical byte address size in bits", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register core_count (Core count); type cpuid.core_count (Implicit type of Core count register)
 */

/*
 * Dump of fields for register: core_count
 *   nc (size 8, offset 0):	 RO	  Number of CPU cores -1 
 *   _anon8 (size 4, offset 8):	 RSVD	  _
 *   apiccoreidsz (size 4, offset 12):	 RO	  APIC core ID size in bits
 *   _anon16 (size 16, offset 16):	 RSVD	  _
 */

static inline uint32_t __DP(core_count_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(core_count_rd_raw)( __DN(t) * _dev )
{
    return __DP(ecx_read_32)(_dev, (0x80000008));
}

static inline cpuid_core_count_t __DP(core_count_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_core_count_t __DP(core_count_rd)( __DN(t) * _dev )
{
    cpuid_core_count_un  u;
    u.raw = __DP(ecx_read_32)(_dev, (0x80000008));
    return u.val;
}

// Register core_count is not writeable


static inline int __DP(core_count_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(core_count_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_core_count_un  u;
    u.raw = __DP(ecx_read_32)(_dev, (0x80000008));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register core_count (Core count):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.nc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " nc =\t0x%"PRIx8" (Number of CPU cores -1 ", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.apiccoreidsz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " apiccoreidsz =\t0x%"PRIx8" (APIC core ID size in bits", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register svmrev (Secure Virtual Machine rev.); type cpuid.svmrev (Implicit type of Secure Virtual Machine rev. register)
 */

/*
 * Dump of fields for register: svmrev
 *   rev (size 8, offset 0):	 RO	  SVM revision number
 *   _anon8 (size 24, offset 8):	 RSVD	  _
 */

static inline uint32_t __DP(svmrev_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(svmrev_rd_raw)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x8000000a));
}

static inline cpuid_svmrev_t __DP(svmrev_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_svmrev_t __DP(svmrev_rd)( __DN(t) * _dev )
{
    cpuid_svmrev_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x8000000a));
    return u.val;
}

// Register svmrev is not writeable


static inline int __DP(svmrev_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(svmrev_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_svmrev_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x8000000a));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register svmrev (Secure Virtual Machine rev.):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.rev;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rev =\t0x%"PRIx8" (SVM revision number", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register nasid (# Addr. space identifiers); type cpuid.uint32
 */

static inline uint32_t __DP(nasid_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(nasid_rd_raw)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x8000000a));
}

static inline uint32_t __DP(nasid_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(nasid_rd)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x8000000a));
}

// Register nasid is not writeable


static inline int __DP(nasid_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(nasid_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register nasid (# Addr. space identifiers):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", __DP(ebx_read_32)(_dev, (0x8000000a)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register svmfeat (SVM features); type cpuid.svmfeat (Implicit type of SVM features register)
 */

/*
 * Dump of fields for register: svmfeat
 *   np (size 1, offset 0):	 RO	  Nested paging
 *   lbrvirt (size 1, offset 1):	 RO	  LBR virtualization
 *   svml (size 1, offset 2):	 RO	  SVM lock
 *   nrips (size 1, offset 3):	 RO	  NRIP save
 *   _anon4 (size 5, offset 4):	 RSVD	  _
 *   ssse3sse5dis (size 1, offset 9):	 RO	  SSSE3 and SSE5 opcode set disable
 *   _anon10 (size 22, offset 10):	 RSVD	  _
 */

static inline uint32_t __DP(svmfeat_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(svmfeat_rd_raw)( __DN(t) * _dev )
{
    return __DP(edx_read_32)(_dev, (0x8000000a));
}

static inline cpuid_svmfeat_t __DP(svmfeat_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_svmfeat_t __DP(svmfeat_rd)( __DN(t) * _dev )
{
    cpuid_svmfeat_un  u;
    u.raw = __DP(edx_read_32)(_dev, (0x8000000a));
    return u.val;
}

// Register svmfeat is not writeable


static inline int __DP(svmfeat_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(svmfeat_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_svmfeat_un  u;
    u.raw = __DP(edx_read_32)(_dev, (0x8000000a));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register svmfeat (SVM features):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.np;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " np =\t0x%"PRIx8" (Nested paging", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.lbrvirt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " lbrvirt =\t0x%"PRIx8" (LBR virtualization", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.svml;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " svml =\t0x%"PRIx8" (SVM lock", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.nrips;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " nrips =\t0x%"PRIx8" (NRIP save", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.ssse3sse5dis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " ssse3sse5dis =\t0x%"PRIx8" (SSSE3 and SSE5 opcode set disable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register l1_1G (AMD L1 TLB info for 1GB pages); type cpuid.amd_tlbinfo23 (AMD TLB information)
 */

/*
 * Dump of fields for register: l1_1G
 *   itlb_sz (size 12, offset 0):	 RO	  Number of instruction TLB entries
 *   itlb_asc (size 4, offset 12):	 RO	  Instruction TLB associativity
 *   dtlb_sz (size 12, offset 16):	 RO	  Number of data DTLB entries
 *   dtlb_asc (size 4, offset 28):	 RO	  Data TLB associativity
 */

static inline uint32_t __DP(l1_1G_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(l1_1G_rd_raw)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x80000019));
}

static inline cpuid_amd_tlbinfo23_t __DP(l1_1G_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_amd_tlbinfo23_t __DP(l1_1G_rd)( __DN(t) * _dev )
{
    cpuid_amd_tlbinfo23_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x80000019));
    return u.val;
}

// Register l1_1G is not writeable


static inline int __DP(l1_1G_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(l1_1G_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_amd_tlbinfo23_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x80000019));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register l1_1G (AMD L1 TLB info for 1GB pages):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.itlb_sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " itlb_sz =\t0x%0"PRIx16" (Number of instruction TLB entries", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.itlb_asc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " itlb_asc =\t0x%"PRIx8" (Instruction TLB associativity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.dtlb_sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dtlb_sz =\t0x%0"PRIx16" (Number of data DTLB entries", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dtlb_asc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dtlb_asc =\t0x%"PRIx8" (Data TLB associativity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register l2_1G (AMD L2 TLB info for 1GB pages); type cpuid.amd_tlbinfo23 (AMD TLB information)
 */

/*
 * Dump of fields for register: l2_1G
 *   itlb_sz (size 12, offset 0):	 RO	  Number of instruction TLB entries
 *   itlb_asc (size 4, offset 12):	 RO	  Instruction TLB associativity
 *   dtlb_sz (size 12, offset 16):	 RO	  Number of data DTLB entries
 *   dtlb_asc (size 4, offset 28):	 RO	  Data TLB associativity
 */

static inline uint32_t __DP(l2_1G_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(l2_1G_rd_raw)( __DN(t) * _dev )
{
    return __DP(ebx_read_32)(_dev, (0x80000019));
}

static inline cpuid_amd_tlbinfo23_t __DP(l2_1G_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_amd_tlbinfo23_t __DP(l2_1G_rd)( __DN(t) * _dev )
{
    cpuid_amd_tlbinfo23_un  u;
    u.raw = __DP(ebx_read_32)(_dev, (0x80000019));
    return u.val;
}

// Register l2_1G is not writeable


static inline int __DP(l2_1G_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(l2_1G_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_amd_tlbinfo23_un  u;
    u.raw = __DP(ebx_read_32)(_dev, (0x80000019));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register l2_1G (AMD L2 TLB info for 1GB pages):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.itlb_sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " itlb_sz =\t0x%0"PRIx16" (Number of instruction TLB entries", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.itlb_asc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " itlb_asc =\t0x%"PRIx8" (Instruction TLB associativity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.dtlb_sz;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dtlb_sz =\t0x%0"PRIx16" (Number of data DTLB entries", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.dtlb_asc;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " dtlb_asc =\t0x%"PRIx8" (Data TLB associativity", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register opt_id (Perf. optimization identifiers); type cpuid.opt_id (Implicit type of Perf. optimization identifiers register)
 */

/*
 * Dump of fields for register: opt_id
 *   fp128 (size 1, offset 0):	 RO	  128-bit SSE has full-width execution
 *   movu (size 1, offset 1):	 RO	  MOVU SSE instructions faster than MOVL
 *   _anon2 (size 30, offset 2):	 RSVD	  _
 */

static inline uint32_t __DP(opt_id_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(opt_id_rd_raw)( __DN(t) * _dev )
{
    return __DP(eax_read_32)(_dev, (0x8000001a));
}

static inline cpuid_opt_id_t __DP(opt_id_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline cpuid_opt_id_t __DP(opt_id_rd)( __DN(t) * _dev )
{
    cpuid_opt_id_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x8000001a));
    return u.val;
}

// Register opt_id is not writeable


static inline int __DP(opt_id_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(opt_id_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    cpuid_opt_id_un  u;
    u.raw = __DP(eax_read_32)(_dev, (0x8000001a));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register opt_id (Perf. optimization identifiers):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.fp128;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fp128 =\t0x%"PRIx8" (128-bit SSE has full-width execution", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.movu;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " movu =\t0x%"PRIx8" (MOVU SSE instructions faster than MOVL", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}

static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Dump of device cpuid (ia32 / Intel64 CPUID instruction results):\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(max_biv_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(vendor0_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(vendor1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(vendor2_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ver_info_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(brand_ndx_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(feat_info_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ext_feat_info_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(pns0_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(pns1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cache_type_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cache_pars_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(num_sets_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(min_monitor_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(max_monitor_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(mwait_feat_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(mwait_cstates_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tpm_feat_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tpm_thresh_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(tpm_hcfc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(apm_gen_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(apm_feat_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(apm_fixed_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ext_biv_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(evendor0_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(evendor1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(evendor2_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(brandid_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ext_featc_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(ext_featd_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(brand0_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(brand1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(brand2_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(brand3_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(brand4_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(brand5_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(brand6_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(brand7_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(brand8_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(brand9_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(branda_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(brandb_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(l1_24m_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(l1_4k_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(l1_dci_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(l1_ici_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(l2_24m_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(l2_4k_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(l2_ci_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(l3_ci_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(amd_apm_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(addr_size_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(core_count_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(svmrev_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(nasid_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(svmfeat_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(l1_1G_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(l2_1G_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(opt_id_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "End of dump of device cpuid\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR


#endif // __cpuid_H
