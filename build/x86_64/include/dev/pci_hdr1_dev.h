/*
 * DEVICE DEFINITION: PCI Type 1 Configuration
 * 
 * Copyright (c) 2007, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich.
 *  Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED: DO NOT EDIT!
 */

#ifndef __pci_hdr1_H
#define __pci_hdr1_H

#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR
#define __DN(x) pci_hdr1 ## _ ## x
#ifdef pci_hdr1_PREFIX
#define __DP(x) __DP1(x,pci_hdr1_PREFIX)
#define __DP1(x1,x2) __DP2(x1,x2)
#define __DP2(x1,x2) x2 ## x1
#else
#define __DP(x) pci_hdr1##_ ##x
#endif
#define __STR(x) #x
#define __XTR(x) __STR(x)

/*
 * Constant definition: pci_hdr1.classcode (Class code)
 */
typedef enum pci_hdr1_classcode_t {
    __DP(bridge) = (0x6),
} pci_hdr1_classcode_t;

static inline int pci_hdr1_classcode_prt( char * s, size_t sz, pci_hdr1_classcode_t e ) __attribute__ ((always_inline));
static inline int pci_hdr1_classcode_prt( char * s, size_t sz, pci_hdr1_classcode_t e )
{
    switch (e) {
        case __DP(bridge):
        return snprintf(s, sz, "%s", "Bridge device");
        default:
        return snprintf(s, sz, "Unknown " __XTR(pci_hdr1_classcode_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int pci_hdr1_classcode_chk( pci_hdr1_classcode_t e ) __attribute__ ((always_inline));
static inline int pci_hdr1_classcode_chk( pci_hdr1_classcode_t e )
{
    switch (e) {
        case __DP(bridge):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: pci_hdr1.hdrtype (Configuration header types)
 */
typedef enum pci_hdr1_hdrtype_t {
    __DP(nonbridge) = (0x0),
    __DP(pci2pci) = (0x1),
    __DP(cardbus) = (0x2),
} pci_hdr1_hdrtype_t;

static inline int pci_hdr1_hdrtype_prt( char * s, size_t sz, pci_hdr1_hdrtype_t e ) __attribute__ ((always_inline));
static inline int pci_hdr1_hdrtype_prt( char * s, size_t sz, pci_hdr1_hdrtype_t e )
{
    switch (e) {
        case __DP(nonbridge):
        return snprintf(s, sz, "%s", "non-bridge function");
        case __DP(pci2pci):
        return snprintf(s, sz, "%s", "PCI-to-PCI bridge");
        case __DP(cardbus):
        return snprintf(s, sz, "%s", "CardBus bridge");
        default:
        return snprintf(s, sz, "Unknown " __XTR(pci_hdr1_hdrtype_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int pci_hdr1_hdrtype_chk( pci_hdr1_hdrtype_t e ) __attribute__ ((always_inline));
static inline int pci_hdr1_hdrtype_chk( pci_hdr1_hdrtype_t e )
{
    switch (e) {
        case __DP(nonbridge):
        return 1;
        case __DP(pci2pci):
        return 1;
        case __DP(cardbus):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: pci_hdr1.bardecoder (BAR decoder type)
 */
typedef enum pci_hdr1_bardecoder_t {
    __DP(bar_32bit) = (0x0),
    __DP(bar_64bit) = (0x2),
} pci_hdr1_bardecoder_t;

static inline int pci_hdr1_bardecoder_prt( char * s, size_t sz, pci_hdr1_bardecoder_t e ) __attribute__ ((always_inline));
static inline int pci_hdr1_bardecoder_prt( char * s, size_t sz, pci_hdr1_bardecoder_t e )
{
    switch (e) {
        case __DP(bar_32bit):
        return snprintf(s, sz, "%s", "32-bit decoder");
        case __DP(bar_64bit):
        return snprintf(s, sz, "%s", "64-bit decoder");
        default:
        return snprintf(s, sz, "Unknown " __XTR(pci_hdr1_bardecoder_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int pci_hdr1_bardecoder_chk( pci_hdr1_bardecoder_t e ) __attribute__ ((always_inline));
static inline int pci_hdr1_bardecoder_chk( pci_hdr1_bardecoder_t e )
{
    switch (e) {
        case __DP(bar_32bit):
        return 1;
        case __DP(bar_64bit):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: pci_hdr1.iobl_decode (I/O Base and limit decode type)
 */
typedef enum pci_hdr1_iobl_decode_t {
    __DP(io_16bit) = (0x0),
    __DP(io_32bit) = (0x1),
} pci_hdr1_iobl_decode_t;

static inline int pci_hdr1_iobl_decode_prt( char * s, size_t sz, pci_hdr1_iobl_decode_t e ) __attribute__ ((always_inline));
static inline int pci_hdr1_iobl_decode_prt( char * s, size_t sz, pci_hdr1_iobl_decode_t e )
{
    switch (e) {
        case __DP(io_16bit):
        return snprintf(s, sz, "%s", "16-bit I/O decode");
        case __DP(io_32bit):
        return snprintf(s, sz, "%s", "32-bit I/O decode");
        default:
        return snprintf(s, sz, "Unknown " __XTR(pci_hdr1_iobl_decode_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int pci_hdr1_iobl_decode_chk( pci_hdr1_iobl_decode_t e ) __attribute__ ((always_inline));
static inline int pci_hdr1_iobl_decode_chk( pci_hdr1_iobl_decode_t e )
{
    switch (e) {
        case __DP(io_16bit):
        return 1;
        case __DP(io_32bit):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: pci_hdr1.pref_decode (Prefetchable memory base and limit decode type)
 */
typedef enum pci_hdr1_pref_decode_t {
    __DP(mem_32bit) = (0x0),
    __DP(mem_64bit) = (0x1),
} pci_hdr1_pref_decode_t;

static inline int pci_hdr1_pref_decode_prt( char * s, size_t sz, pci_hdr1_pref_decode_t e ) __attribute__ ((always_inline));
static inline int pci_hdr1_pref_decode_prt( char * s, size_t sz, pci_hdr1_pref_decode_t e )
{
    switch (e) {
        case __DP(mem_32bit):
        return snprintf(s, sz, "%s", "32-bit memory decode");
        case __DP(mem_64bit):
        return snprintf(s, sz, "%s", "64-bit memory decode");
        default:
        return snprintf(s, sz, "Unknown " __XTR(pci_hdr1_pref_decode_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int pci_hdr1_pref_decode_chk( pci_hdr1_pref_decode_t e ) __attribute__ ((always_inline));
static inline int pci_hdr1_pref_decode_chk( pci_hdr1_pref_decode_t e )
{
    switch (e) {
        case __DP(mem_32bit):
        return 1;
        case __DP(mem_64bit):
        return 1;
        default:
        return 0;
    }
}


/*
 * Register type: Implicit type of Command register
 */

/*
 * Dump of fields for register type: pci_hdr1_command_t
 *   io_space (size 1, offset 0):	 RW	  I/O space enable
 *   mem_space (size 1, offset 1):	 RW	  Memory space enable
 *   master (size 1, offset 2):	 RW	  Bus master
 *   special (size 1, offset 3):	 RO	  Special cycles
 *   mem_inval (size 1, offset 4):	 RO	  Memory write and invalidate enable
 *   vga_snoop (size 1, offset 5):	 RO	  VGA palette snoop enable
 *   parity (size 1, offset 6):	 RW	  Parity error response
 *   stepping (size 1, offset 7):	 RO	  IDSEL stepping/wait cycle control
 *   serr (size 1, offset 8):	 RW	  SERR# enable
 *   back2back (size 1, offset 9):	 RO	  Fast back-to-back enable
 *   int_dis (size 1, offset 10):	 RW	  Interrupt disable
 *   _anon11 (size 5, offset 11):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr1_command_t {
    uint8_t	io_space	:1;
    uint8_t	mem_space	:1;
    uint8_t	master	:1;
    uint8_t	special	:1;
    uint8_t	mem_inval	:1;
    uint8_t	vga_snoop	:1;
    uint8_t	parity	:1;
    uint8_t	stepping	:1;
    uint8_t	serr	:1;
    uint8_t	back2back	:1;
    uint8_t	int_dis	:1;
    uint8_t	_anon11	:5;
} __attribute__ ((packed))
 pci_hdr1_command_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr1_command_t, sizeof(uint16_t));

typedef union pci_hdr1_command_un {
    pci_hdr1_command_t	val;
    uint16_t	raw;
}
 pci_hdr1_command_un;
static inline int pci_hdr1_command_prtval( char * s, size_t sz, pci_hdr1_command_t v ) __attribute__ ((always_inline));
static inline int pci_hdr1_command_prtval( char * s, size_t sz, pci_hdr1_command_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " io_space=0x%"PRIx8" (I/O space enable)\n", (uint8_t)(v.io_space));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mem_space=0x%"PRIx8" (Memory space enable)\n", (uint8_t)(v.mem_space));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " master=0x%"PRIx8" (Bus master)\n", (uint8_t)(v.master));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " special=0x%"PRIx8" (Special cycles)\n", (uint8_t)(v.special));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mem_inval=0x%"PRIx8" (Memory write and invalidate enable)\n", (uint8_t)(v.mem_inval));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vga_snoop=0x%"PRIx8" (VGA palette snoop enable)\n", (uint8_t)(v.vga_snoop));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " parity=0x%"PRIx8" (Parity error response)\n", (uint8_t)(v.parity));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " stepping=0x%"PRIx8" (IDSEL stepping/wait cycle control)\n", (uint8_t)(v.stepping));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " serr=0x%"PRIx8" (SERR# enable)\n", (uint8_t)(v.serr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " back2back=0x%"PRIx8" (Fast back-to-back enable)\n", (uint8_t)(v.back2back));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " int_dis=0x%"PRIx8" (Interrupt disable)\n", (uint8_t)(v.int_dis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Interface status
 */

/*
 * Dump of fields for register type: pci_hdr1_statreg_t
 *   _anon0 (size 3, offset 0):	 RSVD	  _
 *   intstat (size 1, offset 3):	 RO	  Interrupt status
 *   caplist (size 1, offset 4):	 RO	  Capabilities list
 *   m66 (size 1, offset 5):	 RO	  66MHz capable
 *   udf (size 1, offset 6):	 RO	  UDF supported
 *   back2back (size 1, offset 7):	 RO	  Fast Back-to-Back enable
 *   md_parity (size 1, offset 8):	 RWC	  Master data parity error
 *   devsel (size 2, offset 9):	 RO	  DEVSEL timing
 *   sig_t_abrt (size 1, offset 11):	 RWC	  Signalled target abort
 *   rx_t_abrt (size 1, offset 12):	 RWC	  Received target abort
 *   rx_m_abrt (size 1, offset 13):	 RWC	  Received master abort
 *   system_err (size 1, offset 14):	 RWC	  Signalled system error
 *   parity_err (size 1, offset 15):	 RWC	  Detected parity error
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr1_statreg_t {
    uint8_t	_anon0	:3;
    uint8_t	intstat	:1;
    uint8_t	caplist	:1;
    uint8_t	m66	:1;
    uint8_t	udf	:1;
    uint8_t	back2back	:1;
    uint8_t	md_parity	:1;
    uint8_t	devsel	:2;
    uint8_t	sig_t_abrt	:1;
    uint8_t	rx_t_abrt	:1;
    uint8_t	rx_m_abrt	:1;
    uint8_t	system_err	:1;
    uint8_t	parity_err	:1;
} __attribute__ ((packed))
 pci_hdr1_statreg_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr1_statreg_t, sizeof(uint16_t));

typedef union pci_hdr1_statreg_un {
    pci_hdr1_statreg_t	val;
    uint16_t	raw;
}
 pci_hdr1_statreg_un;
static inline int pci_hdr1_statreg_prtval( char * s, size_t sz, pci_hdr1_statreg_t v ) __attribute__ ((always_inline));
static inline int pci_hdr1_statreg_prtval( char * s, size_t sz, pci_hdr1_statreg_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " intstat=0x%"PRIx8" (Interrupt status)\n", (uint8_t)(v.intstat));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " caplist=0x%"PRIx8" (Capabilities list)\n", (uint8_t)(v.caplist));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " m66=0x%"PRIx8" (66MHz capable)\n", (uint8_t)(v.m66));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " udf=0x%"PRIx8" (UDF supported)\n", (uint8_t)(v.udf));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " back2back=0x%"PRIx8" (Fast Back-to-Back enable)\n", (uint8_t)(v.back2back));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " md_parity=0x%"PRIx8" (Master data parity error)\n", (uint8_t)(v.md_parity));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " devsel=0x%"PRIx8" (DEVSEL timing)\n", (uint8_t)(v.devsel));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sig_t_abrt=0x%"PRIx8" (Signalled target abort)\n", (uint8_t)(v.sig_t_abrt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rx_t_abrt=0x%"PRIx8" (Received target abort)\n", (uint8_t)(v.rx_t_abrt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rx_m_abrt=0x%"PRIx8" (Received master abort)\n", (uint8_t)(v.rx_m_abrt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " system_err=0x%"PRIx8" (Signalled system error)\n", (uint8_t)(v.system_err));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " parity_err=0x%"PRIx8" (Detected parity error)\n", (uint8_t)(v.parity_err));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Class code register
 */

/*
 * Dump of fields for register type: pci_hdr1_class_code_t
 *   _anon0 (size 8, offset 0):	 RSVD	  _
 *   prog_if (size 8, offset 8):	 RO	  Programming intf
 *   subclss (size 8, offset 16):	 RO	  Subclass code
 *   clss (size 8, offset 24):	 RO	  Class code
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr1_class_code_t {
    uint8_t	_anon0	:8;
    uint8_t	prog_if	:8;
    uint8_t	subclss	:8;
    pci_hdr1_classcode_t	clss	:8;
} __attribute__ ((packed))
 pci_hdr1_class_code_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr1_class_code_t, sizeof(uint32_t));

typedef union pci_hdr1_class_code_un {
    pci_hdr1_class_code_t	val;
    uint32_t	raw;
}
 pci_hdr1_class_code_un;
static inline int pci_hdr1_class_code_prtval( char * s, size_t sz, pci_hdr1_class_code_t v ) __attribute__ ((always_inline));
static inline int pci_hdr1_class_code_prtval( char * s, size_t sz, pci_hdr1_class_code_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " prog_if=0x%"PRIx8" (Programming intf)\n", (uint8_t)(v.prog_if));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " subclss=0x%"PRIx8" (Subclass code)\n", (uint8_t)(v.subclss));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " clss=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = pci_hdr1_classcode_prt(s+r, _avail, v.clss);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Class code)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Header type register
 */

/*
 * Dump of fields for register type: pci_hdr1_hdr_type_t
 *   fmt (size 7, offset 0):	 RO	  Configuration header format
 *   multi (size 1, offset 7):	 RO	  Multifunction device
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr1_hdr_type_t {
    pci_hdr1_hdrtype_t	fmt	:7;
    uint8_t	multi	:1;
} __attribute__ ((packed))
 pci_hdr1_hdr_type_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr1_hdr_type_t, sizeof(uint8_t));

typedef union pci_hdr1_hdr_type_un {
    pci_hdr1_hdr_type_t	val;
    uint8_t	raw;
}
 pci_hdr1_hdr_type_un;
static inline int pci_hdr1_hdr_type_prtval( char * s, size_t sz, pci_hdr1_hdr_type_t v ) __attribute__ ((always_inline));
static inline int pci_hdr1_hdr_type_prtval( char * s, size_t sz, pci_hdr1_hdr_type_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " fmt=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = pci_hdr1_hdrtype_prt(s+r, _avail, v.fmt);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Configuration header format)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " multi=0x%"PRIx8" (Multifunction device)\n", (uint8_t)(v.multi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Built-in self-test register
 */

/*
 * Dump of fields for register type: pci_hdr1_bist_t
 *   comp (size 4, offset 0):	 RO	  Completion code
 *   _anon4 (size 2, offset 4):	 RSVD	  _
 *   start (size 1, offset 6):	 RW	  Start BIST
 *   cap (size 1, offset 7):	 RO	  BIST capable
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr1_bist_t {
    uint8_t	comp	:4;
    uint8_t	_anon4	:2;
    uint8_t	start	:1;
    uint8_t	cap	:1;
} __attribute__ ((packed))
 pci_hdr1_bist_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr1_bist_t, sizeof(uint8_t));

typedef union pci_hdr1_bist_un {
    pci_hdr1_bist_t	val;
    uint8_t	raw;
}
 pci_hdr1_bist_un;
static inline int pci_hdr1_bist_prtval( char * s, size_t sz, pci_hdr1_bist_t v ) __attribute__ ((always_inline));
static inline int pci_hdr1_bist_prtval( char * s, size_t sz, pci_hdr1_bist_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " comp=0x%"PRIx8" (Completion code)\n", (uint8_t)(v.comp));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " start=0x%"PRIx8" (Start BIST)\n", (uint8_t)(v.start));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cap=0x%"PRIx8" (BIST capable)\n", (uint8_t)(v.cap));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: 32-bit memory base address
 */

/*
 * Dump of fields for register type: pci_hdr1_bar32_t
 *   space (size 1, offset 0):	 RO	  Memory space indicator
 *   tpe (size 2, offset 1):	 RO	  Memory decoder type
 *   prefetch (size 1, offset 3):	 RO	  Prefetchable
 *   _anon4 (size 3, offset 4):	 RSVD	  _
 *   base (size 25, offset 7):	 RW	  Base address
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr1_bar32_t {
    uint8_t	space	:1;
    pci_hdr1_bardecoder_t	tpe	:2;
    uint8_t	prefetch	:1;
    uint8_t	_anon4	:3;
    uint32_t	base	:25;
} __attribute__ ((packed))
 pci_hdr1_bar32_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr1_bar32_t, sizeof(uint32_t));

typedef union pci_hdr1_bar32_un {
    pci_hdr1_bar32_t	val;
    uint32_t	raw;
}
 pci_hdr1_bar32_un;
static inline int pci_hdr1_bar32_prtval( char * s, size_t sz, pci_hdr1_bar32_t v ) __attribute__ ((always_inline));
static inline int pci_hdr1_bar32_prtval( char * s, size_t sz, pci_hdr1_bar32_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " space=0x%"PRIx8" (Memory space indicator)\n", (uint8_t)(v.space));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " tpe=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = pci_hdr1_bardecoder_prt(s+r, _avail, v.tpe);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Memory decoder type)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " prefetch=0x%"PRIx8" (Prefetchable)\n", (uint8_t)(v.prefetch));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " base=0x%0"PRIx32" (Base address)\n", (uint32_t)(v.base));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: 64-bit memory base address
 */

/*
 * Dump of fields for register type: pci_hdr1_bar64_t
 *   space (size 1, offset 0):	 RO	  Memory space indicator
 *   tpe (size 2, offset 1):	 RO	  Memory decoder type
 *   prefetch (size 1, offset 3):	 RO	  Prefetchable
 *   _anon4 (size 3, offset 4):	 RSVD	  _
 *   base (size 57, offset 7):	 RW	  Base address
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr1_bar64_t {
    uint8_t	space	:1;
    pci_hdr1_bardecoder_t	tpe	:2;
    uint8_t	prefetch	:1;
    uint8_t	_anon4	:3;
    uint64_t	base	:57;
} __attribute__ ((packed))
 pci_hdr1_bar64_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr1_bar64_t, sizeof(uint64_t));

typedef union pci_hdr1_bar64_un {
    pci_hdr1_bar64_t	val;
    uint64_t	raw;
}
 pci_hdr1_bar64_un;
static inline int pci_hdr1_bar64_prtval( char * s, size_t sz, pci_hdr1_bar64_t v ) __attribute__ ((always_inline));
static inline int pci_hdr1_bar64_prtval( char * s, size_t sz, pci_hdr1_bar64_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " space=0x%"PRIx8" (Memory space indicator)\n", (uint8_t)(v.space));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " tpe=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = pci_hdr1_bardecoder_prt(s+r, _avail, v.tpe);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Memory decoder type)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " prefetch=0x%"PRIx8" (Prefetchable)\n", (uint8_t)(v.prefetch));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " base=0x%0"PRIx64" (Base address)\n", (uint64_t)(v.base));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: I/O space base address
 */

/*
 * Dump of fields for register type: pci_hdr1_bario_t
 *   space (size 1, offset 0):	 RO	  I/O space indicator
 *   _anon1 (size 1, offset 1):	 RSVD	  _
 *   base (size 30, offset 2):	 RW	  Base address
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr1_bario_t {
    uint8_t	space	:1;
    uint8_t	_anon1	:1;
    uint32_t	base	:30;
} __attribute__ ((packed))
 pci_hdr1_bario_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr1_bario_t, sizeof(uint32_t));

typedef union pci_hdr1_bario_un {
    pci_hdr1_bario_t	val;
    uint32_t	raw;
}
 pci_hdr1_bario_un;
static inline int pci_hdr1_bario_prtval( char * s, size_t sz, pci_hdr1_bario_t v ) __attribute__ ((always_inline));
static inline int pci_hdr1_bario_prtval( char * s, size_t sz, pci_hdr1_bario_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " space=0x%"PRIx8" (I/O space indicator)\n", (uint8_t)(v.space));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " base=0x%0"PRIx32" (Base address)\n", (uint32_t)(v.base));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Bus configuration register register
 */

/*
 * Dump of fields for register type: pci_hdr1_bcfg_t
 *   pri_bus (size 8, offset 0):	 RW	  Primary bus number
 *   sec_bus (size 8, offset 8):	 RW	  Secondary bus number
 *   sub_bus (size 8, offset 16):	 RW	  Subordinate bus number
 *   sec_lat (size 8, offset 24):	 RW	  Secondary latency timer
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr1_bcfg_t {
    uint8_t	pri_bus	:8;
    uint8_t	sec_bus	:8;
    uint8_t	sub_bus	:8;
    uint8_t	sec_lat	:8;
} __attribute__ ((packed))
 pci_hdr1_bcfg_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr1_bcfg_t, sizeof(uint32_t));

typedef union pci_hdr1_bcfg_un {
    pci_hdr1_bcfg_t	val;
    uint32_t	raw;
}
 pci_hdr1_bcfg_un;
static inline int pci_hdr1_bcfg_prtval( char * s, size_t sz, pci_hdr1_bcfg_t v ) __attribute__ ((always_inline));
static inline int pci_hdr1_bcfg_prtval( char * s, size_t sz, pci_hdr1_bcfg_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pri_bus=0x%"PRIx8" (Primary bus number)\n", (uint8_t)(v.pri_bus));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sec_bus=0x%"PRIx8" (Secondary bus number)\n", (uint8_t)(v.sec_bus));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sub_bus=0x%"PRIx8" (Subordinate bus number)\n", (uint8_t)(v.sub_bus));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sec_lat=0x%"PRIx8" (Secondary latency timer)\n", (uint8_t)(v.sec_lat));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: I/O Base and limit
 */

/*
 * Dump of fields for register type: pci_hdr1_iobl_t
 *   tpe (size 4, offset 0):	 RO	  Decode type
 *   val (size 4, offset 4):	 RW	  Low bits of address
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr1_iobl_t {
    pci_hdr1_iobl_decode_t	tpe	:4;
    uint8_t	val	:4;
} __attribute__ ((packed))
 pci_hdr1_iobl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr1_iobl_t, sizeof(uint8_t));

typedef union pci_hdr1_iobl_un {
    pci_hdr1_iobl_t	val;
    uint8_t	raw;
}
 pci_hdr1_iobl_un;
static inline int pci_hdr1_iobl_prtval( char * s, size_t sz, pci_hdr1_iobl_t v ) __attribute__ ((always_inline));
static inline int pci_hdr1_iobl_prtval( char * s, size_t sz, pci_hdr1_iobl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " tpe=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = pci_hdr1_iobl_decode_prt(s+r, _avail, v.tpe);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Decode type)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " val=0x%"PRIx8" (Low bits of address)\n", (uint8_t)(v.val));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Memory base and limit register
 */

/*
 * Dump of fields for register type: pci_hdr1_membl_t
 *   base (size 16, offset 0):	 RW	  Base
 *   limit (size 16, offset 16):	 RW	  Limit
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr1_membl_t {
    uint16_t	base	:16;
    uint16_t	limit	:16;
} __attribute__ ((packed))
 pci_hdr1_membl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr1_membl_t, sizeof(uint32_t));

typedef union pci_hdr1_membl_un {
    pci_hdr1_membl_t	val;
    uint32_t	raw;
}
 pci_hdr1_membl_un;
static inline int pci_hdr1_membl_prtval( char * s, size_t sz, pci_hdr1_membl_t v ) __attribute__ ((always_inline));
static inline int pci_hdr1_membl_prtval( char * s, size_t sz, pci_hdr1_membl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " base=0x%0"PRIx16" (Base)\n", (uint16_t)(v.base));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " limit=0x%0"PRIx16" (Limit)\n", (uint16_t)(v.limit));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Prefetchable memory base and limit
 */

/*
 * Dump of fields for register type: pci_hdr1_prefbl_t
 *   tpe (size 4, offset 0):	 RO	  Decode type
 *   val (size 12, offset 4):	 RW	  Low bits of address
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr1_prefbl_t {
    pci_hdr1_iobl_decode_t	tpe	:4;
    uint16_t	val	:12;
} __attribute__ ((packed))
 pci_hdr1_prefbl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr1_prefbl_t, sizeof(uint16_t));

typedef union pci_hdr1_prefbl_un {
    pci_hdr1_prefbl_t	val;
    uint16_t	raw;
}
 pci_hdr1_prefbl_un;
static inline int pci_hdr1_prefbl_prtval( char * s, size_t sz, pci_hdr1_prefbl_t v ) __attribute__ ((always_inline));
static inline int pci_hdr1_prefbl_prtval( char * s, size_t sz, pci_hdr1_prefbl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " tpe=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = pci_hdr1_iobl_decode_prt(s+r, _avail, v.tpe);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Decode type)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " val=0x%0"PRIx16" (Low bits of address)\n", (uint16_t)(v.val));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Expansion ROM base addr register
 */

/*
 * Dump of fields for register type: pci_hdr1_rom_base_t
 *   enable (size 1, offset 0):	 RW	  ROM address decoder enable
 *   _anon1 (size 10, offset 1):	 RSVD	  _
 *   base (size 21, offset 11):	 RW	  ROM Base address high bits
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr1_rom_base_t {
    uint8_t	enable	:1;
    uint16_t	_anon1	:10;
    uint32_t	base	:21;
} __attribute__ ((packed))
 pci_hdr1_rom_base_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr1_rom_base_t, sizeof(uint32_t));

typedef union pci_hdr1_rom_base_un {
    pci_hdr1_rom_base_t	val;
    uint32_t	raw;
}
 pci_hdr1_rom_base_un;
static inline int pci_hdr1_rom_base_prtval( char * s, size_t sz, pci_hdr1_rom_base_t v ) __attribute__ ((always_inline));
static inline int pci_hdr1_rom_base_prtval( char * s, size_t sz, pci_hdr1_rom_base_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " enable=0x%"PRIx8" (ROM address decoder enable)\n", (uint8_t)(v.enable));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " base=0x%0"PRIx32" (ROM Base address high bits)\n", (uint32_t)(v.base));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Bridge control register
 */

/*
 * Dump of fields for register type: pci_hdr1_brdg_ctrl_t
 *   parity (size 1, offset 0):	 RW	  Parity error response
 *   serr_en (size 1, offset 1):	 RW	  SERR# enable
 *   isa (size 1, offset 2):	 RW	  ISA enable
 *   vga (size 1, offset 3):	 RW	  VGA enable
 *   _anon4 (size 1, offset 4):	 RSVD	  _
 *   mabort (size 1, offset 5):	 RW	  Master abort mode
 *   sec_reset (size 1, offset 6):	 RW	  Secondary bus reset
 *   back2back (size 1, offset 7):	 RO	  Fast back-to-back enable
 *   pritm_dis (size 1, offset 8):	 RO	  Primary discard timeout
 *   sectm_dis (size 1, offset 9):	 RO	  Secondary discard timeout
 *   tstat_dis (size 1, offset 10):	 RO	  Discard timer status
 *   serr_dis (size 1, offset 11):	 RO	  Discard timer SERR# enable
 *   _anon12 (size 4, offset 12):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr1_brdg_ctrl_t {
    uint8_t	parity	:1;
    uint8_t	serr_en	:1;
    uint8_t	isa	:1;
    uint8_t	vga	:1;
    uint8_t	_anon4	:1;
    uint8_t	mabort	:1;
    uint8_t	sec_reset	:1;
    uint8_t	back2back	:1;
    uint8_t	pritm_dis	:1;
    uint8_t	sectm_dis	:1;
    uint8_t	tstat_dis	:1;
    uint8_t	serr_dis	:1;
    uint8_t	_anon12	:4;
} __attribute__ ((packed))
 pci_hdr1_brdg_ctrl_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr1_brdg_ctrl_t, sizeof(uint16_t));

typedef union pci_hdr1_brdg_ctrl_un {
    pci_hdr1_brdg_ctrl_t	val;
    uint16_t	raw;
}
 pci_hdr1_brdg_ctrl_un;
static inline int pci_hdr1_brdg_ctrl_prtval( char * s, size_t sz, pci_hdr1_brdg_ctrl_t v ) __attribute__ ((always_inline));
static inline int pci_hdr1_brdg_ctrl_prtval( char * s, size_t sz, pci_hdr1_brdg_ctrl_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " parity=0x%"PRIx8" (Parity error response)\n", (uint8_t)(v.parity));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " serr_en=0x%"PRIx8" (SERR# enable)\n", (uint8_t)(v.serr_en));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " isa=0x%"PRIx8" (ISA enable)\n", (uint8_t)(v.isa));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vga=0x%"PRIx8" (VGA enable)\n", (uint8_t)(v.vga));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mabort=0x%"PRIx8" (Master abort mode)\n", (uint8_t)(v.mabort));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sec_reset=0x%"PRIx8" (Secondary bus reset)\n", (uint8_t)(v.sec_reset));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " back2back=0x%"PRIx8" (Fast back-to-back enable)\n", (uint8_t)(v.back2back));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " pritm_dis=0x%"PRIx8" (Primary discard timeout)\n", (uint8_t)(v.pritm_dis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sectm_dis=0x%"PRIx8" (Secondary discard timeout)\n", (uint8_t)(v.sectm_dis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " tstat_dis=0x%"PRIx8" (Discard timer status)\n", (uint8_t)(v.tstat_dis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " serr_dis=0x%"PRIx8" (Discard timer SERR# enable)\n", (uint8_t)(v.serr_dis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Device representation structure
 */
typedef struct __DN(t) {
    // Device arguments
    mackerel_pci_t	base;
    // Shadow registers
}
 __DN(t);

/*
 * Device Initialization function
 */
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_pci_t base ) __attribute__ ((always_inline));
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_pci_t base )
{
    /* Setting up device arguments*/
    _dev->base = base;
    /* Setting up shadow registers*/
}

// No user-defined spaces

/*
 * Register vendor_id (Vendor ID); type pci_hdr1.uint16
 */

static inline uint16_t __DP(vendor_id_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(vendor_id_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x0));
}

static inline uint16_t __DP(vendor_id_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(vendor_id_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x0));
}

// Register vendor_id is not writeable


static inline int __DP(vendor_id_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(vendor_id_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register vendor_id (Vendor ID):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_pci_16(_dev->base,(0x0)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register device_id (Device ID); type pci_hdr1.uint16
 */

static inline uint16_t __DP(device_id_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(device_id_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x2));
}

static inline uint16_t __DP(device_id_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(device_id_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x2));
}

// Register device_id is not writeable


static inline int __DP(device_id_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(device_id_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register device_id (Device ID):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_pci_16(_dev->base,(0x2)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register command (Command); type pci_hdr1.command (Implicit type of Command register)
 */

/*
 * Dump of fields for register: command
 *   io_space (size 1, offset 0):	 RW	  I/O space enable
 *   mem_space (size 1, offset 1):	 RW	  Memory space enable
 *   master (size 1, offset 2):	 RW	  Bus master
 *   special (size 1, offset 3):	 RO	  Special cycles
 *   mem_inval (size 1, offset 4):	 RO	  Memory write and invalidate enable
 *   vga_snoop (size 1, offset 5):	 RO	  VGA palette snoop enable
 *   parity (size 1, offset 6):	 RW	  Parity error response
 *   stepping (size 1, offset 7):	 RO	  IDSEL stepping/wait cycle control
 *   serr (size 1, offset 8):	 RW	  SERR# enable
 *   back2back (size 1, offset 9):	 RO	  Fast back-to-back enable
 *   int_dis (size 1, offset 10):	 RW	  Interrupt disable
 *   _anon11 (size 5, offset 11):	 RSVD	  _
 */

static inline uint16_t __DP(command_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(command_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x4));
}

static inline pci_hdr1_command_t __DP(command_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr1_command_t __DP(command_rd)( __DN(t) * _dev )
{
    pci_hdr1_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    return u.val;
}

static inline void __DP(command_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(command_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_pci_16(_dev->base,(0x4),val);
}

static inline void __DP(command_wr)( __DN(t) * _dev, pci_hdr1_command_t val ) __attribute__ ((always_inline));
static inline void __DP(command_wr)( __DN(t) * _dev, pci_hdr1_command_t val )
{
    pci_hdr1_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    u.val.io_space 	= val.io_space;
    u.val.mem_space 	= val.mem_space;
    u.val.master 	= val.master;
    u.val.special 	= val.special;
    u.val.mem_inval 	= val.mem_inval;
    u.val.vga_snoop 	= val.vga_snoop;
    u.val.parity 	= val.parity;
    u.val.stepping 	= val.stepping;
    u.val.serr 	= val.serr;
    u.val.back2back 	= val.back2back;
    u.val.int_dis 	= val.int_dis;
    mackerel_write_pci_16(_dev->base,(0x4),u.raw);
}

static inline void __DP(command_io_space_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(command_io_space_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    u.val.io_space = val;
    mackerel_write_pci_16(_dev->base,(0x4),u.raw);
}

static inline void __DP(command_mem_space_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(command_mem_space_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    u.val.mem_space = val;
    mackerel_write_pci_16(_dev->base,(0x4),u.raw);
}

static inline void __DP(command_master_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(command_master_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    u.val.master = val;
    mackerel_write_pci_16(_dev->base,(0x4),u.raw);
}

static inline void __DP(command_parity_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(command_parity_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    u.val.parity = val;
    mackerel_write_pci_16(_dev->base,(0x4),u.raw);
}

static inline void __DP(command_serr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(command_serr_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    u.val.serr = val;
    mackerel_write_pci_16(_dev->base,(0x4),u.raw);
}

static inline void __DP(command_int_dis_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(command_int_dis_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    u.val.int_dis = val;
    mackerel_write_pci_16(_dev->base,(0x4),u.raw);
}


static inline int __DP(command_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(command_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr1_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register command (Command):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.io_space;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " io_space =\t0x%"PRIx8" (I/O space enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mem_space;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mem_space =\t0x%"PRIx8" (Memory space enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.master;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " master =\t0x%"PRIx8" (Bus master", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.special;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " special =\t0x%"PRIx8" (Special cycles", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mem_inval;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mem_inval =\t0x%"PRIx8" (Memory write and invalidate enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vga_snoop;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vga_snoop =\t0x%"PRIx8" (VGA palette snoop enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.parity;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " parity =\t0x%"PRIx8" (Parity error response", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.stepping;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " stepping =\t0x%"PRIx8" (IDSEL stepping/wait cycle control", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.serr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " serr =\t0x%"PRIx8" (SERR# enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.back2back;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " back2back =\t0x%"PRIx8" (Fast back-to-back enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.int_dis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " int_dis =\t0x%"PRIx8" (Interrupt disable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register status (Status); type pci_hdr1.statreg (Interface status)
 */

/*
 * Dump of fields for register: status
 *   _anon0 (size 3, offset 0):	 RSVD	  _
 *   intstat (size 1, offset 3):	 RO	  Interrupt status
 *   caplist (size 1, offset 4):	 RO	  Capabilities list
 *   m66 (size 1, offset 5):	 RO	  66MHz capable
 *   udf (size 1, offset 6):	 RO	  UDF supported
 *   back2back (size 1, offset 7):	 RO	  Fast Back-to-Back enable
 *   md_parity (size 1, offset 8):	 RWC	  Master data parity error
 *   devsel (size 2, offset 9):	 RO	  DEVSEL timing
 *   sig_t_abrt (size 1, offset 11):	 RWC	  Signalled target abort
 *   rx_t_abrt (size 1, offset 12):	 RWC	  Received target abort
 *   rx_m_abrt (size 1, offset 13):	 RWC	  Received master abort
 *   system_err (size 1, offset 14):	 RWC	  Signalled system error
 *   parity_err (size 1, offset 15):	 RWC	  Detected parity error
 */

static inline uint16_t __DP(status_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(status_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x6));
}

static inline pci_hdr1_statreg_t __DP(status_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr1_statreg_t __DP(status_rd)( __DN(t) * _dev )
{
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    return u.val;
}

static inline void __DP(status_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(status_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_pci_16(_dev->base,(0x6),val);
}

static inline void __DP(status_wr)( __DN(t) * _dev, pci_hdr1_statreg_t val ) __attribute__ ((always_inline));
static inline void __DP(status_wr)( __DN(t) * _dev, pci_hdr1_statreg_t val )
{
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    u.val.intstat 	= val.intstat;
    u.val.caplist 	= val.caplist;
    u.val.m66 	= val.m66;
    u.val.udf 	= val.udf;
    u.val.back2back 	= val.back2back;
    u.val.md_parity 	= val.md_parity;
    u.val.devsel 	= val.devsel;
    u.val.sig_t_abrt 	= val.sig_t_abrt;
    u.val.rx_t_abrt 	= val.rx_t_abrt;
    u.val.rx_m_abrt 	= val.rx_m_abrt;
    u.val.system_err 	= val.system_err;
    u.val.parity_err 	= val.parity_err;
    mackerel_write_pci_16(_dev->base,(0x6),u.raw);
}

static inline void __DP(status_md_parity_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_md_parity_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    u.val.md_parity = val;
    mackerel_write_pci_16(_dev->base,(0x6),u.raw);
}

static inline void __DP(status_sig_t_abrt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_sig_t_abrt_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    u.val.sig_t_abrt = val;
    mackerel_write_pci_16(_dev->base,(0x6),u.raw);
}

static inline void __DP(status_rx_t_abrt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_rx_t_abrt_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    u.val.rx_t_abrt = val;
    mackerel_write_pci_16(_dev->base,(0x6),u.raw);
}

static inline void __DP(status_rx_m_abrt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_rx_m_abrt_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    u.val.rx_m_abrt = val;
    mackerel_write_pci_16(_dev->base,(0x6),u.raw);
}

static inline void __DP(status_system_err_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_system_err_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    u.val.system_err = val;
    mackerel_write_pci_16(_dev->base,(0x6),u.raw);
}

static inline void __DP(status_parity_err_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_parity_err_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    u.val.parity_err = val;
    mackerel_write_pci_16(_dev->base,(0x6),u.raw);
}


static inline int __DP(status_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(status_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register status (Status):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.intstat;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " intstat =\t0x%"PRIx8" (Interrupt status", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.caplist;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " caplist =\t0x%"PRIx8" (Capabilities list", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.m66;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " m66 =\t0x%"PRIx8" (66MHz capable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.udf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " udf =\t0x%"PRIx8" (UDF supported", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.back2back;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " back2back =\t0x%"PRIx8" (Fast Back-to-Back enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.md_parity;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " md_parity =\t0x%"PRIx8" (Master data parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.devsel;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " devsel =\t0x%"PRIx8" (DEVSEL timing", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sig_t_abrt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sig_t_abrt =\t0x%"PRIx8" (Signalled target abort", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rx_t_abrt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rx_t_abrt =\t0x%"PRIx8" (Received target abort", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rx_m_abrt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rx_m_abrt =\t0x%"PRIx8" (Received master abort", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.system_err;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " system_err =\t0x%"PRIx8" (Signalled system error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.parity_err;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " parity_err =\t0x%"PRIx8" (Detected parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register sec_stat (Secondary status); type pci_hdr1.statreg (Interface status)
 */

/*
 * Dump of fields for register: sec_stat
 *   _anon0 (size 3, offset 0):	 RSVD	  _
 *   intstat (size 1, offset 3):	 RO	  Interrupt status
 *   caplist (size 1, offset 4):	 RO	  Capabilities list
 *   m66 (size 1, offset 5):	 RO	  66MHz capable
 *   udf (size 1, offset 6):	 RO	  UDF supported
 *   back2back (size 1, offset 7):	 RO	  Fast Back-to-Back enable
 *   md_parity (size 1, offset 8):	 RWC	  Master data parity error
 *   devsel (size 2, offset 9):	 RO	  DEVSEL timing
 *   sig_t_abrt (size 1, offset 11):	 RWC	  Signalled target abort
 *   rx_t_abrt (size 1, offset 12):	 RWC	  Received target abort
 *   rx_m_abrt (size 1, offset 13):	 RWC	  Received master abort
 *   system_err (size 1, offset 14):	 RWC	  Signalled system error
 *   parity_err (size 1, offset 15):	 RWC	  Detected parity error
 */

static inline uint16_t __DP(sec_stat_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(sec_stat_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x1e));
}

static inline pci_hdr1_statreg_t __DP(sec_stat_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr1_statreg_t __DP(sec_stat_rd)( __DN(t) * _dev )
{
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x1e));
    return u.val;
}

static inline void __DP(sec_stat_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(sec_stat_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_pci_16(_dev->base,(0x1e),val);
}

static inline void __DP(sec_stat_wr)( __DN(t) * _dev, pci_hdr1_statreg_t val ) __attribute__ ((always_inline));
static inline void __DP(sec_stat_wr)( __DN(t) * _dev, pci_hdr1_statreg_t val )
{
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x1e));
    u.val.intstat 	= val.intstat;
    u.val.caplist 	= val.caplist;
    u.val.m66 	= val.m66;
    u.val.udf 	= val.udf;
    u.val.back2back 	= val.back2back;
    u.val.md_parity 	= val.md_parity;
    u.val.devsel 	= val.devsel;
    u.val.sig_t_abrt 	= val.sig_t_abrt;
    u.val.rx_t_abrt 	= val.rx_t_abrt;
    u.val.rx_m_abrt 	= val.rx_m_abrt;
    u.val.system_err 	= val.system_err;
    u.val.parity_err 	= val.parity_err;
    mackerel_write_pci_16(_dev->base,(0x1e),u.raw);
}

static inline void __DP(sec_stat_md_parity_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(sec_stat_md_parity_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x1e));
    u.val.md_parity = val;
    mackerel_write_pci_16(_dev->base,(0x1e),u.raw);
}

static inline void __DP(sec_stat_sig_t_abrt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(sec_stat_sig_t_abrt_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x1e));
    u.val.sig_t_abrt = val;
    mackerel_write_pci_16(_dev->base,(0x1e),u.raw);
}

static inline void __DP(sec_stat_rx_t_abrt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(sec_stat_rx_t_abrt_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x1e));
    u.val.rx_t_abrt = val;
    mackerel_write_pci_16(_dev->base,(0x1e),u.raw);
}

static inline void __DP(sec_stat_rx_m_abrt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(sec_stat_rx_m_abrt_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x1e));
    u.val.rx_m_abrt = val;
    mackerel_write_pci_16(_dev->base,(0x1e),u.raw);
}

static inline void __DP(sec_stat_system_err_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(sec_stat_system_err_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x1e));
    u.val.system_err = val;
    mackerel_write_pci_16(_dev->base,(0x1e),u.raw);
}

static inline void __DP(sec_stat_parity_err_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(sec_stat_parity_err_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x1e));
    u.val.parity_err = val;
    mackerel_write_pci_16(_dev->base,(0x1e),u.raw);
}


static inline int __DP(sec_stat_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(sec_stat_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr1_statreg_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x1e));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register sec_stat (Secondary status):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.intstat;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " intstat =\t0x%"PRIx8" (Interrupt status", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.caplist;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " caplist =\t0x%"PRIx8" (Capabilities list", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.m66;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " m66 =\t0x%"PRIx8" (66MHz capable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.udf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " udf =\t0x%"PRIx8" (UDF supported", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.back2back;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " back2back =\t0x%"PRIx8" (Fast Back-to-Back enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.md_parity;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " md_parity =\t0x%"PRIx8" (Master data parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.devsel;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " devsel =\t0x%"PRIx8" (DEVSEL timing", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sig_t_abrt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sig_t_abrt =\t0x%"PRIx8" (Signalled target abort", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rx_t_abrt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rx_t_abrt =\t0x%"PRIx8" (Received target abort", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rx_m_abrt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rx_m_abrt =\t0x%"PRIx8" (Received master abort", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.system_err;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " system_err =\t0x%"PRIx8" (Signalled system error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.parity_err;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " parity_err =\t0x%"PRIx8" (Detected parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register rev_id (Revision ID); type pci_hdr1.uint8
 */

static inline uint8_t __DP(rev_id_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(rev_id_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x8));
}

static inline uint8_t __DP(rev_id_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(rev_id_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x8));
}

// Register rev_id is not writeable


static inline int __DP(rev_id_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rev_id_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rev_id (Revision ID):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_pci_8(_dev->base,(0x8)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register class_code (Class code); type pci_hdr1.class_code (Implicit type of Class code register)
 */

/*
 * Dump of fields for register: class_code
 *   _anon0 (size 8, offset 0):	 RSVD	  _
 *   prog_if (size 8, offset 8):	 RO	  Programming intf
 *   subclss (size 8, offset 16):	 RO	  Subclass code
 *   clss (size 8, offset 24):	 RO	  Class code
 */

static inline uint32_t __DP(class_code_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(class_code_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x8));
}

static inline pci_hdr1_class_code_t __DP(class_code_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr1_class_code_t __DP(class_code_rd)( __DN(t) * _dev )
{
    pci_hdr1_class_code_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x8));
    return u.val;
}

// Register class_code is not writeable


static inline int __DP(class_code_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(class_code_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr1_class_code_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x8));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register class_code (Class code):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.prog_if;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " prog_if =\t0x%"PRIx8" (Programming intf", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.subclss;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " subclss =\t0x%"PRIx8" (Subclass code", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.clss;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " clss =\t0x%"PRIx8" (Class code", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = pci_hdr1_classcode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register cache_sz (Cache line size); type pci_hdr1.uint8
 */

static inline uint8_t __DP(cache_sz_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(cache_sz_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0xc));
}

static inline uint8_t __DP(cache_sz_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(cache_sz_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0xc));
}

static inline void __DP(cache_sz_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cache_sz_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_pci_8(_dev->base,(0xc),val);
}

static inline void __DP(cache_sz_wr)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cache_sz_wr)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_pci_8(_dev->base,(0xc),val);
}


static inline int __DP(cache_sz_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cache_sz_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cache_sz (Cache line size):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_pci_8(_dev->base,(0xc)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register latency (Master latency timer); type pci_hdr1.uint8
 */

static inline uint8_t __DP(latency_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(latency_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0xd));
}

static inline uint8_t __DP(latency_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(latency_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0xd));
}

static inline void __DP(latency_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(latency_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_pci_8(_dev->base,(0xd),val);
}

static inline void __DP(latency_wr)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(latency_wr)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_pci_8(_dev->base,(0xd),val);
}


static inline int __DP(latency_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(latency_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register latency (Master latency timer):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_pci_8(_dev->base,(0xd)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register hdr_type (Header type); type pci_hdr1.hdr_type (Implicit type of Header type register)
 */

/*
 * Dump of fields for register: hdr_type
 *   fmt (size 7, offset 0):	 RO	  Configuration header format
 *   multi (size 1, offset 7):	 RO	  Multifunction device
 */

static inline uint8_t __DP(hdr_type_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(hdr_type_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0xe));
}

static inline pci_hdr1_hdr_type_t __DP(hdr_type_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr1_hdr_type_t __DP(hdr_type_rd)( __DN(t) * _dev )
{
    pci_hdr1_hdr_type_un  u;
    u.raw = mackerel_read_pci_8(_dev->base,(0xe));
    return u.val;
}

// Register hdr_type is not writeable


static inline int __DP(hdr_type_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(hdr_type_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr1_hdr_type_un  u;
    u.raw = mackerel_read_pci_8(_dev->base,(0xe));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register hdr_type (Header type):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.fmt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fmt =\t0x%"PRIx8" (Configuration header format", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = pci_hdr1_hdrtype_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.multi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " multi =\t0x%"PRIx8" (Multifunction device", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register bist (Built-in self-test); type pci_hdr1.bist (Implicit type of Built-in self-test register)
 */

/*
 * Dump of fields for register: bist
 *   comp (size 4, offset 0):	 RO	  Completion code
 *   _anon4 (size 2, offset 4):	 RSVD	  _
 *   start (size 1, offset 6):	 RW	  Start BIST
 *   cap (size 1, offset 7):	 RO	  BIST capable
 */

static inline uint8_t __DP(bist_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(bist_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0xf));
}

static inline pci_hdr1_bist_t __DP(bist_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr1_bist_t __DP(bist_rd)( __DN(t) * _dev )
{
    pci_hdr1_bist_un  u;
    u.raw = mackerel_read_pci_8(_dev->base,(0xf));
    return u.val;
}

static inline void __DP(bist_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(bist_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_pci_8(_dev->base,(0xf),val);
}

static inline void __DP(bist_wr)( __DN(t) * _dev, pci_hdr1_bist_t val ) __attribute__ ((always_inline));
static inline void __DP(bist_wr)( __DN(t) * _dev, pci_hdr1_bist_t val )
{
    pci_hdr1_bist_un  u;
    u.raw = mackerel_read_pci_8(_dev->base,(0xf));
    u.val.comp 	= val.comp;
    u.val.start 	= val.start;
    u.val.cap 	= val.cap;
    mackerel_write_pci_8(_dev->base,(0xf),u.raw);
}

static inline void __DP(bist_start_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(bist_start_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_bist_un  u;
    u.raw = mackerel_read_pci_8(_dev->base,(0xf));
    u.val.start = val;
    mackerel_write_pci_8(_dev->base,(0xf),u.raw);
}


static inline int __DP(bist_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(bist_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr1_bist_un  u;
    u.raw = mackerel_read_pci_8(_dev->base,(0xf));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register bist (Built-in self-test):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.comp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " comp =\t0x%"PRIx8" (Completion code", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.start;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " start =\t0x%"PRIx8" (Start BIST", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cap;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cap =\t0x%"PRIx8" (BIST capable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register bar0 (Base address 0); type pci_hdr1.uint32
 */

static inline uint32_t __DP(bar0_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(bar0_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x10));
}

static inline uint32_t __DP(bar0_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(bar0_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x10));
}

static inline void __DP(bar0_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(bar0_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x10),val);
}

static inline void __DP(bar0_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(bar0_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x10),val);
}


static inline int __DP(bar0_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(bar0_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register bar0 (Base address 0):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_pci_32(_dev->base,(0x10)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register bar1 (Base address 1); type pci_hdr1.uint32
 */

static inline uint32_t __DP(bar1_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(bar1_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x14));
}

static inline uint32_t __DP(bar1_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(bar1_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x14));
}

static inline void __DP(bar1_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(bar1_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x14),val);
}

static inline void __DP(bar1_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(bar1_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x14),val);
}


static inline int __DP(bar1_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(bar1_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register bar1 (Base address 1):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_pci_32(_dev->base,(0x14)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register bcfg (Bus configuration register); type pci_hdr1.bcfg (Implicit type of Bus configuration register register)
 */

/*
 * Dump of fields for register: bcfg
 *   pri_bus (size 8, offset 0):	 RW	  Primary bus number
 *   sec_bus (size 8, offset 8):	 RW	  Secondary bus number
 *   sub_bus (size 8, offset 16):	 RW	  Subordinate bus number
 *   sec_lat (size 8, offset 24):	 RW	  Secondary latency timer
 */

static inline uint32_t __DP(bcfg_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(bcfg_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x18));
}

static inline pci_hdr1_bcfg_t __DP(bcfg_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr1_bcfg_t __DP(bcfg_rd)( __DN(t) * _dev )
{
    pci_hdr1_bcfg_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x18));
    return u.val;
}

static inline void __DP(bcfg_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(bcfg_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x18),val);
}

static inline void __DP(bcfg_wr)( __DN(t) * _dev, pci_hdr1_bcfg_t val ) __attribute__ ((always_inline));
static inline void __DP(bcfg_wr)( __DN(t) * _dev, pci_hdr1_bcfg_t val )
{
    pci_hdr1_bcfg_un  u;
    u.val = val;
    mackerel_write_pci_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(bcfg_pri_bus_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(bcfg_pri_bus_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_bcfg_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x18));
    u.val.pri_bus = val;
    mackerel_write_pci_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(bcfg_sec_bus_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(bcfg_sec_bus_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_bcfg_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x18));
    u.val.sec_bus = val;
    mackerel_write_pci_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(bcfg_sub_bus_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(bcfg_sub_bus_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_bcfg_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x18));
    u.val.sub_bus = val;
    mackerel_write_pci_32(_dev->base,(0x18),u.raw);
}

static inline void __DP(bcfg_sec_lat_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(bcfg_sec_lat_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_bcfg_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x18));
    u.val.sec_lat = val;
    mackerel_write_pci_32(_dev->base,(0x18),u.raw);
}


static inline int __DP(bcfg_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(bcfg_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr1_bcfg_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x18));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register bcfg (Bus configuration register):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.pri_bus;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pri_bus =\t0x%"PRIx8" (Primary bus number", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sec_bus;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sec_bus =\t0x%"PRIx8" (Secondary bus number", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sub_bus;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sub_bus =\t0x%"PRIx8" (Subordinate bus number", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sec_lat;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sec_lat =\t0x%"PRIx8" (Secondary latency timer", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register io_base (I/O base); type pci_hdr1.iobl (I/O Base and limit)
 */

/*
 * Dump of fields for register: io_base
 *   tpe (size 4, offset 0):	 RO	  Decode type
 *   val (size 4, offset 4):	 RW	  Low bits of address
 */

static inline uint8_t __DP(io_base_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(io_base_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x1c));
}

static inline pci_hdr1_iobl_t __DP(io_base_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr1_iobl_t __DP(io_base_rd)( __DN(t) * _dev )
{
    pci_hdr1_iobl_un  u;
    u.raw = mackerel_read_pci_8(_dev->base,(0x1c));
    return u.val;
}

static inline void __DP(io_base_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(io_base_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_pci_8(_dev->base,(0x1c),val);
}

static inline void __DP(io_base_wr)( __DN(t) * _dev, pci_hdr1_iobl_t val ) __attribute__ ((always_inline));
static inline void __DP(io_base_wr)( __DN(t) * _dev, pci_hdr1_iobl_t val )
{
    pci_hdr1_iobl_un  u;
    u.val = val;
    mackerel_write_pci_8(_dev->base,(0x1c),u.raw);
}

static inline void __DP(io_base_val_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(io_base_val_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_iobl_un  u;
    u.val.val = val;
    mackerel_write_pci_8(_dev->base,(0x1c),u.raw);
}


static inline int __DP(io_base_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(io_base_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr1_iobl_un  u;
    u.raw = mackerel_read_pci_8(_dev->base,(0x1c));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register io_base (I/O base):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.tpe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tpe =\t0x%"PRIx8" (Decode type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = pci_hdr1_iobl_decode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.val;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " val =\t0x%"PRIx8" (Low bits of address", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register io_limit (I/O limit); type pci_hdr1.iobl (I/O Base and limit)
 */

/*
 * Dump of fields for register: io_limit
 *   tpe (size 4, offset 0):	 RO	  Decode type
 *   val (size 4, offset 4):	 RW	  Low bits of address
 */

static inline uint8_t __DP(io_limit_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(io_limit_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x1d));
}

static inline pci_hdr1_iobl_t __DP(io_limit_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr1_iobl_t __DP(io_limit_rd)( __DN(t) * _dev )
{
    pci_hdr1_iobl_un  u;
    u.raw = mackerel_read_pci_8(_dev->base,(0x1d));
    return u.val;
}

static inline void __DP(io_limit_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(io_limit_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_pci_8(_dev->base,(0x1d),val);
}

static inline void __DP(io_limit_wr)( __DN(t) * _dev, pci_hdr1_iobl_t val ) __attribute__ ((always_inline));
static inline void __DP(io_limit_wr)( __DN(t) * _dev, pci_hdr1_iobl_t val )
{
    pci_hdr1_iobl_un  u;
    u.val = val;
    mackerel_write_pci_8(_dev->base,(0x1d),u.raw);
}

static inline void __DP(io_limit_val_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(io_limit_val_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_iobl_un  u;
    u.val.val = val;
    mackerel_write_pci_8(_dev->base,(0x1d),u.raw);
}


static inline int __DP(io_limit_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(io_limit_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr1_iobl_un  u;
    u.raw = mackerel_read_pci_8(_dev->base,(0x1d));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register io_limit (I/O limit):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.tpe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tpe =\t0x%"PRIx8" (Decode type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = pci_hdr1_iobl_decode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.val;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " val =\t0x%"PRIx8" (Low bits of address", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register io_base_upper (I/O base upper 16b); type pci_hdr1.uint16
 */

static inline uint16_t __DP(io_base_upper_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(io_base_upper_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x30));
}

static inline uint16_t __DP(io_base_upper_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(io_base_upper_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x30));
}

static inline void __DP(io_base_upper_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(io_base_upper_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_pci_16(_dev->base,(0x30),val);
}

static inline void __DP(io_base_upper_wr)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(io_base_upper_wr)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_pci_16(_dev->base,(0x30),val);
}


static inline int __DP(io_base_upper_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(io_base_upper_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register io_base_upper (I/O base upper 16b):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_pci_16(_dev->base,(0x30)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register io_limit_upper (I/O limit upper 16b); type pci_hdr1.uint16
 */

static inline uint16_t __DP(io_limit_upper_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(io_limit_upper_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x32));
}

static inline uint16_t __DP(io_limit_upper_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(io_limit_upper_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x32));
}

static inline void __DP(io_limit_upper_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(io_limit_upper_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_pci_16(_dev->base,(0x32),val);
}

static inline void __DP(io_limit_upper_wr)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(io_limit_upper_wr)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_pci_16(_dev->base,(0x32),val);
}


static inline int __DP(io_limit_upper_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(io_limit_upper_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register io_limit_upper (I/O limit upper 16b):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_pci_16(_dev->base,(0x32)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register membl (Memory base and limit); type pci_hdr1.membl (Implicit type of Memory base and limit register)
 */

/*
 * Dump of fields for register: membl
 *   base (size 16, offset 0):	 RW	  Base
 *   limit (size 16, offset 16):	 RW	  Limit
 */

static inline uint32_t __DP(membl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(membl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x20));
}

static inline pci_hdr1_membl_t __DP(membl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr1_membl_t __DP(membl_rd)( __DN(t) * _dev )
{
    pci_hdr1_membl_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x20));
    return u.val;
}

static inline void __DP(membl_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(membl_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x20),val);
}

static inline void __DP(membl_wr)( __DN(t) * _dev, pci_hdr1_membl_t val ) __attribute__ ((always_inline));
static inline void __DP(membl_wr)( __DN(t) * _dev, pci_hdr1_membl_t val )
{
    pci_hdr1_membl_un  u;
    u.val = val;
    mackerel_write_pci_32(_dev->base,(0x20),u.raw);
}

static inline void __DP(membl_base_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(membl_base_wrf)( __DN(t) * _dev, uint16_t val )
{
    pci_hdr1_membl_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x20));
    u.val.base = val;
    mackerel_write_pci_32(_dev->base,(0x20),u.raw);
}

static inline void __DP(membl_limit_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(membl_limit_wrf)( __DN(t) * _dev, uint16_t val )
{
    pci_hdr1_membl_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x20));
    u.val.limit = val;
    mackerel_write_pci_32(_dev->base,(0x20),u.raw);
}


static inline int __DP(membl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(membl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr1_membl_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x20));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register membl (Memory base and limit):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint16_t pv = (uint16_t)u.val.base;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " base =\t0x%0"PRIx16" (Base", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.limit;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " limit =\t0x%0"PRIx16" (Limit", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register pref_base (Prefetchable memory base); type pci_hdr1.prefbl (Prefetchable memory base and limit)
 */

/*
 * Dump of fields for register: pref_base
 *   tpe (size 4, offset 0):	 RO	  Decode type
 *   val (size 12, offset 4):	 RW	  Low bits of address
 */

static inline uint16_t __DP(pref_base_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(pref_base_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x24));
}

static inline pci_hdr1_prefbl_t __DP(pref_base_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr1_prefbl_t __DP(pref_base_rd)( __DN(t) * _dev )
{
    pci_hdr1_prefbl_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x24));
    return u.val;
}

static inline void __DP(pref_base_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(pref_base_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_pci_16(_dev->base,(0x24),val);
}

static inline void __DP(pref_base_wr)( __DN(t) * _dev, pci_hdr1_prefbl_t val ) __attribute__ ((always_inline));
static inline void __DP(pref_base_wr)( __DN(t) * _dev, pci_hdr1_prefbl_t val )
{
    pci_hdr1_prefbl_un  u;
    u.val = val;
    mackerel_write_pci_16(_dev->base,(0x24),u.raw);
}

static inline void __DP(pref_base_val_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(pref_base_val_wrf)( __DN(t) * _dev, uint16_t val )
{
    pci_hdr1_prefbl_un  u;
    u.val.val = val;
    mackerel_write_pci_16(_dev->base,(0x24),u.raw);
}


static inline int __DP(pref_base_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pref_base_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr1_prefbl_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x24));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register pref_base (Prefetchable memory base):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.tpe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tpe =\t0x%"PRIx8" (Decode type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = pci_hdr1_iobl_decode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.val;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " val =\t0x%0"PRIx16" (Low bits of address", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register pref_limit (Prefetchable memory limit); type pci_hdr1.prefbl (Prefetchable memory base and limit)
 */

/*
 * Dump of fields for register: pref_limit
 *   tpe (size 4, offset 0):	 RO	  Decode type
 *   val (size 12, offset 4):	 RW	  Low bits of address
 */

static inline uint16_t __DP(pref_limit_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(pref_limit_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x26));
}

static inline pci_hdr1_prefbl_t __DP(pref_limit_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr1_prefbl_t __DP(pref_limit_rd)( __DN(t) * _dev )
{
    pci_hdr1_prefbl_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x26));
    return u.val;
}

static inline void __DP(pref_limit_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(pref_limit_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_pci_16(_dev->base,(0x26),val);
}

static inline void __DP(pref_limit_wr)( __DN(t) * _dev, pci_hdr1_prefbl_t val ) __attribute__ ((always_inline));
static inline void __DP(pref_limit_wr)( __DN(t) * _dev, pci_hdr1_prefbl_t val )
{
    pci_hdr1_prefbl_un  u;
    u.val = val;
    mackerel_write_pci_16(_dev->base,(0x26),u.raw);
}

static inline void __DP(pref_limit_val_wrf)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(pref_limit_val_wrf)( __DN(t) * _dev, uint16_t val )
{
    pci_hdr1_prefbl_un  u;
    u.val.val = val;
    mackerel_write_pci_16(_dev->base,(0x26),u.raw);
}


static inline int __DP(pref_limit_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pref_limit_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr1_prefbl_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x26));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register pref_limit (Prefetchable memory limit):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.tpe;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tpe =\t0x%"PRIx8" (Decode type", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = pci_hdr1_iobl_decode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint16_t pv = (uint16_t)u.val.val;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " val =\t0x%0"PRIx16" (Low bits of address", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register pref_base_upper (Prefetch base upper 32b); type pci_hdr1.uint32
 */

static inline uint32_t __DP(pref_base_upper_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(pref_base_upper_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x28));
}

static inline uint32_t __DP(pref_base_upper_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(pref_base_upper_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x28));
}

static inline void __DP(pref_base_upper_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(pref_base_upper_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x28),val);
}

static inline void __DP(pref_base_upper_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(pref_base_upper_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x28),val);
}


static inline int __DP(pref_base_upper_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pref_base_upper_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register pref_base_upper (Prefetch base upper 32b):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_pci_32(_dev->base,(0x28)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register pref_limit_upper (Prefetch limit upper 32b); type pci_hdr1.uint32
 */

static inline uint32_t __DP(pref_limit_upper_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(pref_limit_upper_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x2c));
}

static inline uint32_t __DP(pref_limit_upper_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(pref_limit_upper_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x2c));
}

static inline void __DP(pref_limit_upper_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(pref_limit_upper_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x2c),val);
}

static inline void __DP(pref_limit_upper_wr)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(pref_limit_upper_wr)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x2c),val);
}


static inline int __DP(pref_limit_upper_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pref_limit_upper_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register pref_limit_upper (Prefetch limit upper 32b):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_pci_32(_dev->base,(0x2c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register cap_ptr (Capabilities ptr); type pci_hdr1.uint8
 */

static inline uint8_t __DP(cap_ptr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(cap_ptr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x34));
}

static inline uint8_t __DP(cap_ptr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(cap_ptr_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x34));
}

// Register cap_ptr is not writeable


static inline int __DP(cap_ptr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cap_ptr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cap_ptr (Capabilities ptr):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_pci_8(_dev->base,(0x34)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rom_base (Expansion ROM base addr); type pci_hdr1.rom_base (Implicit type of Expansion ROM base addr register)
 */

/*
 * Dump of fields for register: rom_base
 *   enable (size 1, offset 0):	 RW	  ROM address decoder enable
 *   _anon1 (size 10, offset 1):	 RSVD	  _
 *   base (size 21, offset 11):	 RW	  ROM Base address high bits
 */

static inline uint32_t __DP(rom_base_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rom_base_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x38));
}

static inline pci_hdr1_rom_base_t __DP(rom_base_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr1_rom_base_t __DP(rom_base_rd)( __DN(t) * _dev )
{
    pci_hdr1_rom_base_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x38));
    return u.val;
}

static inline void __DP(rom_base_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rom_base_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x38),val);
}

static inline void __DP(rom_base_wr)( __DN(t) * _dev, pci_hdr1_rom_base_t val ) __attribute__ ((always_inline));
static inline void __DP(rom_base_wr)( __DN(t) * _dev, pci_hdr1_rom_base_t val )
{
    pci_hdr1_rom_base_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x38));
    u.val.enable 	= val.enable;
    u.val.base 	= val.base;
    mackerel_write_pci_32(_dev->base,(0x38),u.raw);
}

static inline void __DP(rom_base_enable_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rom_base_enable_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_rom_base_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x38));
    u.val.enable = val;
    mackerel_write_pci_32(_dev->base,(0x38),u.raw);
}

static inline void __DP(rom_base_base_wrf)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rom_base_base_wrf)( __DN(t) * _dev, uint32_t val )
{
    pci_hdr1_rom_base_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x38));
    u.val.base = val;
    mackerel_write_pci_32(_dev->base,(0x38),u.raw);
}


static inline int __DP(rom_base_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rom_base_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr1_rom_base_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x38));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rom_base (Expansion ROM base addr):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " enable =\t0x%"PRIx8" (ROM address decoder enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint32_t pv = (uint32_t)u.val.base;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " base =\t0x%0"PRIx32" (ROM Base address high bits", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register int_line (Interrupt line); type pci_hdr1.uint8
 */

static inline uint8_t __DP(int_line_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(int_line_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x3c));
}

static inline uint8_t __DP(int_line_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(int_line_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x3c));
}

static inline void __DP(int_line_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(int_line_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_pci_8(_dev->base,(0x3c),val);
}

static inline void __DP(int_line_wr)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(int_line_wr)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_pci_8(_dev->base,(0x3c),val);
}


static inline int __DP(int_line_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(int_line_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register int_line (Interrupt line):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_pci_8(_dev->base,(0x3c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register int_pin (Interrupt ping); type pci_hdr1.uint8
 */

static inline uint8_t __DP(int_pin_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(int_pin_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x3d));
}

static inline uint8_t __DP(int_pin_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(int_pin_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x3d));
}

// Register int_pin is not writeable


static inline int __DP(int_pin_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(int_pin_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register int_pin (Interrupt ping):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_pci_8(_dev->base,(0x3d)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register brdg_ctrl (Bridge control); type pci_hdr1.brdg_ctrl (Implicit type of Bridge control register)
 */

/*
 * Dump of fields for register: brdg_ctrl
 *   parity (size 1, offset 0):	 RW	  Parity error response
 *   serr_en (size 1, offset 1):	 RW	  SERR# enable
 *   isa (size 1, offset 2):	 RW	  ISA enable
 *   vga (size 1, offset 3):	 RW	  VGA enable
 *   _anon4 (size 1, offset 4):	 RSVD	  _
 *   mabort (size 1, offset 5):	 RW	  Master abort mode
 *   sec_reset (size 1, offset 6):	 RW	  Secondary bus reset
 *   back2back (size 1, offset 7):	 RO	  Fast back-to-back enable
 *   pritm_dis (size 1, offset 8):	 RO	  Primary discard timeout
 *   sectm_dis (size 1, offset 9):	 RO	  Secondary discard timeout
 *   tstat_dis (size 1, offset 10):	 RO	  Discard timer status
 *   serr_dis (size 1, offset 11):	 RO	  Discard timer SERR# enable
 *   _anon12 (size 4, offset 12):	 RSVD	  _
 */

static inline uint16_t __DP(brdg_ctrl_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(brdg_ctrl_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x3e));
}

static inline pci_hdr1_brdg_ctrl_t __DP(brdg_ctrl_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr1_brdg_ctrl_t __DP(brdg_ctrl_rd)( __DN(t) * _dev )
{
    pci_hdr1_brdg_ctrl_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x3e));
    return u.val;
}

static inline void __DP(brdg_ctrl_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(brdg_ctrl_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_pci_16(_dev->base,(0x3e),val);
}

static inline void __DP(brdg_ctrl_wr)( __DN(t) * _dev, pci_hdr1_brdg_ctrl_t val ) __attribute__ ((always_inline));
static inline void __DP(brdg_ctrl_wr)( __DN(t) * _dev, pci_hdr1_brdg_ctrl_t val )
{
    pci_hdr1_brdg_ctrl_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x3e));
    u.val.parity 	= val.parity;
    u.val.serr_en 	= val.serr_en;
    u.val.isa 	= val.isa;
    u.val.vga 	= val.vga;
    u.val.mabort 	= val.mabort;
    u.val.sec_reset 	= val.sec_reset;
    u.val.back2back 	= val.back2back;
    u.val.pritm_dis 	= val.pritm_dis;
    u.val.sectm_dis 	= val.sectm_dis;
    u.val.tstat_dis 	= val.tstat_dis;
    u.val.serr_dis 	= val.serr_dis;
    mackerel_write_pci_16(_dev->base,(0x3e),u.raw);
}

static inline void __DP(brdg_ctrl_parity_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(brdg_ctrl_parity_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_brdg_ctrl_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x3e));
    u.val.parity = val;
    mackerel_write_pci_16(_dev->base,(0x3e),u.raw);
}

static inline void __DP(brdg_ctrl_serr_en_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(brdg_ctrl_serr_en_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_brdg_ctrl_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x3e));
    u.val.serr_en = val;
    mackerel_write_pci_16(_dev->base,(0x3e),u.raw);
}

static inline void __DP(brdg_ctrl_isa_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(brdg_ctrl_isa_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_brdg_ctrl_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x3e));
    u.val.isa = val;
    mackerel_write_pci_16(_dev->base,(0x3e),u.raw);
}

static inline void __DP(brdg_ctrl_vga_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(brdg_ctrl_vga_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_brdg_ctrl_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x3e));
    u.val.vga = val;
    mackerel_write_pci_16(_dev->base,(0x3e),u.raw);
}

static inline void __DP(brdg_ctrl_mabort_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(brdg_ctrl_mabort_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_brdg_ctrl_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x3e));
    u.val.mabort = val;
    mackerel_write_pci_16(_dev->base,(0x3e),u.raw);
}

static inline void __DP(brdg_ctrl_sec_reset_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(brdg_ctrl_sec_reset_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr1_brdg_ctrl_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x3e));
    u.val.sec_reset = val;
    mackerel_write_pci_16(_dev->base,(0x3e),u.raw);
}


static inline int __DP(brdg_ctrl_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(brdg_ctrl_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr1_brdg_ctrl_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x3e));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register brdg_ctrl (Bridge control):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.parity;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " parity =\t0x%"PRIx8" (Parity error response", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.serr_en;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " serr_en =\t0x%"PRIx8" (SERR# enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.isa;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " isa =\t0x%"PRIx8" (ISA enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vga;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vga =\t0x%"PRIx8" (VGA enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.mabort;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mabort =\t0x%"PRIx8" (Master abort mode", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sec_reset;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sec_reset =\t0x%"PRIx8" (Secondary bus reset", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.back2back;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " back2back =\t0x%"PRIx8" (Fast back-to-back enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.pritm_dis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " pritm_dis =\t0x%"PRIx8" (Primary discard timeout", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sectm_dis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sectm_dis =\t0x%"PRIx8" (Secondary discard timeout", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.tstat_dis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " tstat_dis =\t0x%"PRIx8" (Discard timer status", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.serr_dis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " serr_dis =\t0x%"PRIx8" (Discard timer SERR# enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}

static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Dump of device pci_hdr1 (PCI Type 1 Configuration):\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(vendor_id_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(device_id_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(command_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(status_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(sec_stat_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rev_id_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(class_code_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cache_sz_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(latency_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(hdr_type_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(bist_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(bar0_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(bar1_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(bcfg_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(io_base_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(io_limit_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(io_base_upper_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(io_limit_upper_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(membl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(pref_base_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(pref_limit_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(pref_base_upper_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(pref_limit_upper_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cap_ptr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rom_base_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(int_line_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(int_pin_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(brdg_ctrl_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "End of dump of device pci_hdr1\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR


#endif // __pci_hdr1_H
