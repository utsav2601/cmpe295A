#ifndef __fat_bpb_DEV_H
#define __fat_bpb_DEV_H 1
/*
 * DEVICE DEFINITION: FAT BIOS Parameter Block (BPB)
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) fat_bpb ## _ ## x
/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t b;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum fat_bpb_initials {
    fat_bpb_bps_initial = 0x0,
    fat_bpb_spc_initial = 0x0,
    fat_bpb_rsvs_initial = 0x0,
    fat_bpb_fatc_initial = 0x0,
    fat_bpb_rtc_initial = 0x0,
    fat_bpb_ssc_initial = 0x0,
    fat_bpb_mdes_initial = 0x0,
    fat_bpb_spf_initial = 0x0,
    fat_bpb_spt_initial = 0x0,
    fat_bpb_heds_initial = 0x0,
    fat_bpb_hids_initial = 0x0,
    fat_bpb_lsc_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void fat_bpb_initialize(__DN(t) *_dev, mackerel_addr_t b) __attribute__ ((always_inline));
static inline void fat_bpb_initialize(__DN(t) *_dev, mackerel_addr_t b)
{
    _dev->b = b;
}

/*
 * Register bps: Bytes per sector (must be 512, 1024, 2048 or 4096)
 * Type: fat_bpb.uint16 (primitive type)
 */
static inline uint16_t fat_bpb_bps_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_bpb_bps_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xb));
}

static inline uint16_t fat_bpb_bps_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_bpb_bps_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xb));
}

static inline void fat_bpb_bps_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_bps_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0xb, _regval);
}

static inline void fat_bpb_bps_wr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_bps_wr(__DN(t) *_dev, uint16_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->b, 0xb, _regval);
}

static inline int fat_bpb_bps_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_bpb_bps_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->b, 0xb);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register bps (Bytes per sector (must be 512, 1024, 2048 or 4096)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register spc: Sectors per cluster, must be power of 2
 * Type: fat_bpb.uint8 (primitive type)
 */
static inline uint8_t fat_bpb_spc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_bpb_spc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0xd));
}

static inline uint8_t fat_bpb_spc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_bpb_spc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0xd));
}

static inline void fat_bpb_spc_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_spc_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->b, 0xd, _regval);
}

static inline void fat_bpb_spc_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_spc_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->b, 0xd, _regval);
}

static inline int fat_bpb_spc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_bpb_spc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->b, 0xd);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register spc (Sectors per cluster, must be power of 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rsvs: Reserved sectors from the start of the volume
 * Type: fat_bpb.uint16 (primitive type)
 */
static inline uint16_t fat_bpb_rsvs_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_bpb_rsvs_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xe));
}

static inline uint16_t fat_bpb_rsvs_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_bpb_rsvs_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0xe));
}

static inline void fat_bpb_rsvs_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_rsvs_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0xe, _regval);
}

static inline void fat_bpb_rsvs_wr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_rsvs_wr(__DN(t) *_dev, uint16_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->b, 0xe, _regval);
}

static inline int fat_bpb_rsvs_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_bpb_rsvs_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->b, 0xe);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rsvs (Reserved sectors from the start of the volume): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register fatc: Number of FAT copies
 * Type: fat_bpb.uint8 (primitive type)
 */
static inline uint8_t fat_bpb_fatc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_bpb_fatc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0x10));
}

static inline uint8_t fat_bpb_fatc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_bpb_fatc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0x10));
}

static inline void fat_bpb_fatc_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_fatc_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->b, 0x10, _regval);
}

static inline void fat_bpb_fatc_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_fatc_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->b, 0x10, _regval);
}

static inline int fat_bpb_fatc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_bpb_fatc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->b, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fatc (Number of FAT copies): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rtc: Maximum number of root entries
 * Type: fat_bpb.uint16 (primitive type)
 */
static inline uint16_t fat_bpb_rtc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_bpb_rtc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x11));
}

static inline uint16_t fat_bpb_rtc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_bpb_rtc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x11));
}

static inline void fat_bpb_rtc_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_rtc_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x11, _regval);
}

static inline void fat_bpb_rtc_wr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_rtc_wr(__DN(t) *_dev, uint16_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->b, 0x11, _regval);
}

static inline int fat_bpb_rtc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_bpb_rtc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->b, 0x11);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rtc (Maximum number of root entries): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ssc: Small sector count, used when volume is smaller than 32 MB
 * Type: fat_bpb.uint16 (primitive type)
 */
static inline uint16_t fat_bpb_ssc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_bpb_ssc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x13));
}

static inline uint16_t fat_bpb_ssc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_bpb_ssc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x13));
}

static inline void fat_bpb_ssc_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_ssc_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x13, _regval);
}

static inline void fat_bpb_ssc_wr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_ssc_wr(__DN(t) *_dev, uint16_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->b, 0x13, _regval);
}

static inline int fat_bpb_ssc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_bpb_ssc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->b, 0x13);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ssc (Small sector count, used when volume is smaller than 32 MB): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register mdes: Media descriptor
 * Type: fat_bpb.uint8 (primitive type)
 */
static inline uint8_t fat_bpb_mdes_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_bpb_mdes_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0x15));
}

static inline uint8_t fat_bpb_mdes_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t fat_bpb_mdes_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->b, 0x15));
}

static inline void fat_bpb_mdes_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_mdes_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->b, 0x15, _regval);
}

static inline void fat_bpb_mdes_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_mdes_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->b, 0x15, _regval);
}

static inline int fat_bpb_mdes_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_bpb_mdes_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->b, 0x15);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mdes (Media descriptor): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register spf: Sectors per FAT
 * Type: fat_bpb.uint16 (primitive type)
 */
static inline uint16_t fat_bpb_spf_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_bpb_spf_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x16));
}

static inline uint16_t fat_bpb_spf_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_bpb_spf_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x16));
}

static inline void fat_bpb_spf_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_spf_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x16, _regval);
}

static inline void fat_bpb_spf_wr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_spf_wr(__DN(t) *_dev, uint16_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->b, 0x16, _regval);
}

static inline int fat_bpb_spf_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_bpb_spf_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->b, 0x16);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register spf (Sectors per FAT): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register spt: Sectors per track
 * Type: fat_bpb.uint16 (primitive type)
 */
static inline uint16_t fat_bpb_spt_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_bpb_spt_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x18));
}

static inline uint16_t fat_bpb_spt_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_bpb_spt_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x18));
}

static inline void fat_bpb_spt_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_spt_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x18, _regval);
}

static inline void fat_bpb_spt_wr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_spt_wr(__DN(t) *_dev, uint16_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->b, 0x18, _regval);
}

static inline int fat_bpb_spt_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_bpb_spt_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->b, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register spt (Sectors per track): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register heds: Number of heads
 * Type: fat_bpb.uint16 (primitive type)
 */
static inline uint16_t fat_bpb_heds_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_bpb_heds_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x1a));
}

static inline uint16_t fat_bpb_heds_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t fat_bpb_heds_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->b, 0x1a));
}

static inline void fat_bpb_heds_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_heds_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    mackerel_write_addr_16(_dev->b, 0x1a, _regval);
}

static inline void fat_bpb_heds_wr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_heds_wr(__DN(t) *_dev, uint16_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->b, 0x1a, _regval);
}

static inline int fat_bpb_heds_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_bpb_heds_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = mackerel_read_addr_16(_dev->b, 0x1a);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register heds (Number of heads): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register hids: Hidden sectors (preceding volume start)
 * Type: fat_bpb.uint32 (primitive type)
 */
static inline uint32_t fat_bpb_hids_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t fat_bpb_hids_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x1c));
}

static inline uint32_t fat_bpb_hids_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t fat_bpb_hids_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x1c));
}

static inline void fat_bpb_hids_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_hids_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x1c, _regval);
}

static inline void fat_bpb_hids_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_hids_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->b, 0x1c, _regval);
}

static inline int fat_bpb_hids_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_bpb_hids_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->b, 0x1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hids (Hidden sectors (preceding volume start)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register lsc: Large sector count, when volume is larger than 32 MB
 * Type: fat_bpb.uint32 (primitive type)
 */
static inline uint32_t fat_bpb_lsc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t fat_bpb_lsc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x20));
}

static inline uint32_t fat_bpb_lsc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t fat_bpb_lsc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->b, 0x20));
}

static inline void fat_bpb_lsc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_lsc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->b, 0x20, _regval);
}

static inline void fat_bpb_lsc_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void fat_bpb_lsc_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->b, 0x20, _regval);
}

static inline int fat_bpb_lsc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_bpb_lsc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->b, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lsc (Large sector count, when volume is larger than 32 MB): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int fat_bpb_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int fat_bpb_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device fat_bpb (FAT BIOS Parameter Block (BPB)):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_bpb_bps_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_bpb_spc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_bpb_rsvs_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_bpb_fatc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_bpb_rtc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_bpb_ssc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_bpb_mdes_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_bpb_spf_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_bpb_spt_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_bpb_heds_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_bpb_hids_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = fat_bpb_lsc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device fat_bpb\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __fat_bpb_DEV_H
