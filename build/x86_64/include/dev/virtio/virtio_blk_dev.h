#ifndef __virtio_blk_DEV_H
#define __virtio_blk_DEV_H 1
/*
 * DEVICE DEFINITION: Virtio Block Device Specification
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) virtio_blk ## _ ## x
/*
 * Constants defn: virtio_blk.req_type (Possible request types for the block device)
 *  - no width specified
 */
typedef uint32_t virtio_blk_req_type_t;
#define virtio_blk_in ((virtio_blk_req_type_t)0x0)
#define virtio_blk_out ((virtio_blk_req_type_t)0x1)
#define virtio_blk_scsi_cmd ((virtio_blk_req_type_t)0x2)
#define virtio_blk_scsi_cmd_out ((virtio_blk_req_type_t)0x3)
#define virtio_blk_flush ((virtio_blk_req_type_t)0x4)
#define virtio_blk_flush_out ((virtio_blk_req_type_t)0x5)
#define virtio_blk_barrier ((virtio_blk_req_type_t)0x80000000)

static inline char *virtio_blk_req_type_describe(virtio_blk_req_type_t _e) __attribute__ ((always_inline));
static inline char *virtio_blk_req_type_describe(virtio_blk_req_type_t _e)
{
    switch (_e) {
    case virtio_blk_in:
        return("in: Request type is an IN operation");
    case virtio_blk_out:
        return("out: Request type is an OUT operation");
    case virtio_blk_scsi_cmd:
        return("scsi_cmd: Request type is an OUT operation");
    case virtio_blk_scsi_cmd_out:
        return("scsi_cmd_out: Request type is an OUT operation");
    case virtio_blk_flush:
        return("flush: Request type is a cache flush");
    case virtio_blk_flush_out:
        return("flush_out: Request type is a cache flush");
    case virtio_blk_barrier:
        return("barrier: IO Barrier (Legacy)");
    default:
        return(NULL);
    }
}

static inline int virtio_blk_req_type_prtval(char *_s, size_t _size, virtio_blk_req_type_t _e) __attribute__ ((always_inline));
static inline int virtio_blk_req_type_prtval(char *_s, size_t _size, virtio_blk_req_type_t _e)
{
    char *d = virtio_blk_req_type_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "virtio_blk_req_type_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: virtio_blk.req_status (The status of the request)
 *  - no width specified
 */
typedef uint8_t virtio_blk_req_status_t;
#define virtio_blk_ok ((virtio_blk_req_status_t)0x0)
#define virtio_blk_ioerror ((virtio_blk_req_status_t)0x1)
#define virtio_blk_unsupp ((virtio_blk_req_status_t)0x2)

static inline char *virtio_blk_req_status_describe(virtio_blk_req_status_t _e) __attribute__ ((always_inline));
static inline char *virtio_blk_req_status_describe(virtio_blk_req_status_t _e)
{
    switch (_e) {
    case virtio_blk_ok:
        return("ok: Everythin ok");
    case virtio_blk_ioerror:
        return("ioerror: IO error occured");
    case virtio_blk_unsupp:
        return("unsupp: The request is not supported");
    default:
        return(NULL);
    }
}

static inline int virtio_blk_req_status_prtval(char *_s, size_t _size, virtio_blk_req_status_t _e) __attribute__ ((always_inline));
static inline int virtio_blk_req_status_prtval(char *_s, size_t _size, virtio_blk_req_status_t _e)
{
    char *d = virtio_blk_req_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "virtio_blk_req_status_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: virtio_blk_capacity_t
 * Description: Implicit type of The capacity in 512byte sectors register
 * Fields:
 *   sectors	(size 64, offset 0, init 0):	RW	Number of 512byte sectors
 */
typedef uint64_t virtio_blk_capacity_t;
#define virtio_blk_capacity_default 0x0
static inline uint64_t virtio_blk_capacity_sectors_extract(virtio_blk_capacity_t _regval) __attribute__ ((always_inline));
static inline uint64_t virtio_blk_capacity_sectors_extract(virtio_blk_capacity_t _regval)
{
    return((uint64_t )((_regval & 0xffffffffffffffff) >> 0));
}

static inline virtio_blk_capacity_t virtio_blk_capacity_sectors_insert(virtio_blk_capacity_t _regval, uint64_t _fieldval) __attribute__ ((always_inline));
static inline virtio_blk_capacity_t virtio_blk_capacity_sectors_insert(virtio_blk_capacity_t _regval, uint64_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffffffffffff & (((virtio_blk_capacity_t )(_fieldval)) << 0)));
}

static inline int virtio_blk_capacity_prtval(char *_s, size_t _size, virtio_blk_capacity_t _regval) __attribute__ ((always_inline));
static inline int virtio_blk_capacity_prtval(char *_s, size_t _size, virtio_blk_capacity_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sectors =\t%" PRIx64 "\t(Number of 512byte sectors)\n", virtio_blk_capacity_sectors_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_blk_seg_size_t
 * Description: Implicit type of The maximum segment size register
 * Fields:
 *   max	(size 32, offset 0, init 0):	RW	Maximum segment size
 */
typedef uint32_t virtio_blk_seg_size_t;
#define virtio_blk_seg_size_default 0x0
static inline uint32_t virtio_blk_seg_size_max_extract(virtio_blk_seg_size_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_blk_seg_size_max_extract(virtio_blk_seg_size_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_blk_seg_size_t virtio_blk_seg_size_max_insert(virtio_blk_seg_size_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_blk_seg_size_t virtio_blk_seg_size_max_insert(virtio_blk_seg_size_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_blk_seg_size_t )(_fieldval)) << 0)));
}

static inline int virtio_blk_seg_size_prtval(char *_s, size_t _size, virtio_blk_seg_size_t _regval) __attribute__ ((always_inline));
static inline int virtio_blk_seg_size_prtval(char *_s, size_t _size, virtio_blk_seg_size_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " max =\t%" PRIx32 "\t(Maximum segment size)\n", virtio_blk_seg_size_max_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_blk_seg_num_t
 * Description: Implicit type of The maximum number of segments register
 * Fields:
 *   max	(size 32, offset 0, init 0):	RW	Maximum number of segments
 */
typedef uint32_t virtio_blk_seg_num_t;
#define virtio_blk_seg_num_default 0x0
static inline uint32_t virtio_blk_seg_num_max_extract(virtio_blk_seg_num_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_blk_seg_num_max_extract(virtio_blk_seg_num_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_blk_seg_num_t virtio_blk_seg_num_max_insert(virtio_blk_seg_num_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_blk_seg_num_t virtio_blk_seg_num_max_insert(virtio_blk_seg_num_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_blk_seg_num_t )(_fieldval)) << 0)));
}

static inline int virtio_blk_seg_num_prtval(char *_s, size_t _size, virtio_blk_seg_num_t _regval) __attribute__ ((always_inline));
static inline int virtio_blk_seg_num_prtval(char *_s, size_t _size, virtio_blk_seg_num_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " max =\t%" PRIx32 "\t(Maximum number of segments)\n", virtio_blk_seg_num_max_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_blk_geometry_t
 * Description: Implicit type of Geometry Information register
 * Fields:
 *   cylinders	(size 16, offset 0, init 0):	RW	Number of cylinders
 *   heads	(size 8, offset 16, init 0):	RW	Number of heads
 *   sectors	(size 8, offset 24, init 0):	RW	Number of sectors
 */
typedef uint32_t virtio_blk_geometry_t;
#define virtio_blk_geometry_default 0x0
static inline uint16_t virtio_blk_geometry_cylinders_extract(virtio_blk_geometry_t _regval) __attribute__ ((always_inline));
static inline uint16_t virtio_blk_geometry_cylinders_extract(virtio_blk_geometry_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline virtio_blk_geometry_t virtio_blk_geometry_cylinders_insert(virtio_blk_geometry_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline virtio_blk_geometry_t virtio_blk_geometry_cylinders_insert(virtio_blk_geometry_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((virtio_blk_geometry_t )(_fieldval)) << 0)));
}

static inline uint8_t virtio_blk_geometry_heads_extract(virtio_blk_geometry_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_geometry_heads_extract(virtio_blk_geometry_t _regval)
{
    return((uint8_t )((_regval & 0xff0000) >> 16));
}

static inline virtio_blk_geometry_t virtio_blk_geometry_heads_insert(virtio_blk_geometry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_blk_geometry_t virtio_blk_geometry_heads_insert(virtio_blk_geometry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((virtio_blk_geometry_t )(_fieldval)) << 16)));
}

static inline uint8_t virtio_blk_geometry_sectors_extract(virtio_blk_geometry_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_geometry_sectors_extract(virtio_blk_geometry_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline virtio_blk_geometry_t virtio_blk_geometry_sectors_insert(virtio_blk_geometry_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_blk_geometry_t virtio_blk_geometry_sectors_insert(virtio_blk_geometry_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((virtio_blk_geometry_t )(_fieldval)) << 24)));
}

static inline int virtio_blk_geometry_prtval(char *_s, size_t _size, virtio_blk_geometry_t _regval) __attribute__ ((always_inline));
static inline int virtio_blk_geometry_prtval(char *_s, size_t _size, virtio_blk_geometry_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cylinders =\t%" PRIx16 "\t(Number of cylinders)\n", virtio_blk_geometry_cylinders_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " heads =\t%" PRIx8 "\t(Number of heads)\n", virtio_blk_geometry_heads_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sectors =\t%" PRIx8 "\t(Number of sectors)\n", virtio_blk_geometry_sectors_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_blk_block_size_t
 * Description: Implicit type of Block Size register
 * Fields:
 *   size	(size 32, offset 0, init 0):	RW	The size of a block
 */
typedef uint32_t virtio_blk_block_size_t;
#define virtio_blk_block_size_default 0x0
static inline uint32_t virtio_blk_block_size_size_extract(virtio_blk_block_size_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_blk_block_size_size_extract(virtio_blk_block_size_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_blk_block_size_t virtio_blk_block_size_size_insert(virtio_blk_block_size_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_blk_block_size_t virtio_blk_block_size_size_insert(virtio_blk_block_size_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_blk_block_size_t )(_fieldval)) << 0)));
}

static inline int virtio_blk_block_size_prtval(char *_s, size_t _size, virtio_blk_block_size_t _regval) __attribute__ ((always_inline));
static inline int virtio_blk_block_size_prtval(char *_s, size_t _size, virtio_blk_block_size_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx32 "\t(The size of a block)\n", virtio_blk_block_size_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_blk_topo_blocks_t
 * Description: Implicit type of Toplogy: Logical Blocks register
 * Fields:
 *   logic_per_phys	(size 8, offset 0, init 0):	RW	Number of logical blocks per physical block
 *   offset_aligned	(size 8, offset 8, init 0):	RW	Offset of first aligned logical block
 */
typedef uint16_t virtio_blk_topo_blocks_t;
#define virtio_blk_topo_blocks_default 0x0
static inline uint8_t virtio_blk_topo_blocks_logic_per_phys_extract(virtio_blk_topo_blocks_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_topo_blocks_logic_per_phys_extract(virtio_blk_topo_blocks_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline virtio_blk_topo_blocks_t virtio_blk_topo_blocks_logic_per_phys_insert(virtio_blk_topo_blocks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_blk_topo_blocks_t virtio_blk_topo_blocks_logic_per_phys_insert(virtio_blk_topo_blocks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff00) | (0xff & (((virtio_blk_topo_blocks_t )(_fieldval)) << 0)));
}

static inline uint8_t virtio_blk_topo_blocks_offset_aligned_extract(virtio_blk_topo_blocks_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_topo_blocks_offset_aligned_extract(virtio_blk_topo_blocks_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline virtio_blk_topo_blocks_t virtio_blk_topo_blocks_offset_aligned_insert(virtio_blk_topo_blocks_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_blk_topo_blocks_t virtio_blk_topo_blocks_offset_aligned_insert(virtio_blk_topo_blocks_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff) | (0xff00 & (((virtio_blk_topo_blocks_t )(_fieldval)) << 8)));
}

static inline int virtio_blk_topo_blocks_prtval(char *_s, size_t _size, virtio_blk_topo_blocks_t _regval) __attribute__ ((always_inline));
static inline int virtio_blk_topo_blocks_prtval(char *_s, size_t _size, virtio_blk_topo_blocks_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " logic_per_phys =\t%" PRIx8 "\t(Number of logical blocks per physical block)\n", virtio_blk_topo_blocks_logic_per_phys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " offset_aligned =\t%" PRIx8 "\t(Offset of first aligned logical block)\n", virtio_blk_topo_blocks_offset_aligned_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_blk_topo_io_size_t
 * Description: Implicit type of Topology: minimum IO Size register
 * Fields:
 *   min	(size 16, offset 0, init 0):	RW	Minimum number of IO size in blocks
 *   opt	(size 16, offset 16, init 0):	RW	Maximum number of IO size in  blocks
 */
typedef uint32_t virtio_blk_topo_io_size_t;
#define virtio_blk_topo_io_size_default 0x0
static inline uint16_t virtio_blk_topo_io_size_min_extract(virtio_blk_topo_io_size_t _regval) __attribute__ ((always_inline));
static inline uint16_t virtio_blk_topo_io_size_min_extract(virtio_blk_topo_io_size_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline virtio_blk_topo_io_size_t virtio_blk_topo_io_size_min_insert(virtio_blk_topo_io_size_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline virtio_blk_topo_io_size_t virtio_blk_topo_io_size_min_insert(virtio_blk_topo_io_size_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((virtio_blk_topo_io_size_t )(_fieldval)) << 0)));
}

static inline uint16_t virtio_blk_topo_io_size_opt_extract(virtio_blk_topo_io_size_t _regval) __attribute__ ((always_inline));
static inline uint16_t virtio_blk_topo_io_size_opt_extract(virtio_blk_topo_io_size_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline virtio_blk_topo_io_size_t virtio_blk_topo_io_size_opt_insert(virtio_blk_topo_io_size_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline virtio_blk_topo_io_size_t virtio_blk_topo_io_size_opt_insert(virtio_blk_topo_io_size_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((virtio_blk_topo_io_size_t )(_fieldval)) << 16)));
}

static inline int virtio_blk_topo_io_size_prtval(char *_s, size_t _size, virtio_blk_topo_io_size_t _regval) __attribute__ ((always_inline));
static inline int virtio_blk_topo_io_size_prtval(char *_s, size_t _size, virtio_blk_topo_io_size_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " min =\t%" PRIx16 "\t(Minimum number of IO size in blocks)\n", virtio_blk_topo_io_size_min_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " opt =\t%" PRIx16 "\t(Maximum number of IO size in  blocks)\n", virtio_blk_topo_io_size_opt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_blk_writeback_t
 * Description: Implicit type of Legacy Writeback Register register
 * Fields:
 *   wb	(size 8, offset 0, init 0):	RW	Write back
 */
typedef uint8_t virtio_blk_writeback_t;
#define virtio_blk_writeback_default 0x0
static inline uint8_t virtio_blk_writeback_wb_extract(virtio_blk_writeback_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_writeback_wb_extract(virtio_blk_writeback_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline virtio_blk_writeback_t virtio_blk_writeback_wb_insert(virtio_blk_writeback_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_blk_writeback_t virtio_blk_writeback_wb_insert(virtio_blk_writeback_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x0) | (0xff & (((virtio_blk_writeback_t )(_fieldval)) << 0)));
}

static inline int virtio_blk_writeback_prtval(char *_s, size_t _size, virtio_blk_writeback_t _regval) __attribute__ ((always_inline));
static inline int virtio_blk_writeback_prtval(char *_s, size_t _size, virtio_blk_writeback_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wb =\t%" PRIx8 "\t(Write back)\n", virtio_blk_writeback_wb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: virtio_blk_features_t
 * Description: Feature bits for block devices
 * Fields:
 *   barrier	(size 1, offset 0, init 0):	RW	Device supports request barriers (Legacy)
 *   size_max	(size 1, offset 1, init 0):	RW	Maximum size of any single segment in size_max
 *   seg_max	(size 1, offset 2, init 0):	RW	Maximum number of segments in a request in seg_max
 *   _anon3	(size 1, offset 3, init 0):	RSVD	_
 *   geometry	(size 1, offset 4, init 0):	RW	Disk-style geometry specified in geometry
 *   read_only	(size 1, offset 5, init 0):	RW	Device is read-only
 *   blk_size	(size 1, offset 6, init 0):	RW	Block size of disk is in blk_size
 *   scsi	(size 1, offset 7, init 0):	RW	Device supports scsi packet commands
 *   _anon8	(size 1, offset 8, init 0):	RSVD	_
 *   flush	(size 1, offset 9, init 0):	RW	Cache flush command support (Legacy)
 *   topology	(size 1, offset 10, init 0):	RW	Device exports information on optimal IO alignment
 *   _anon11	(size 12, offset 11, init 0):	RSVD	_
 *   notify_on_empty	(size 1, offset 23, init 0):	RW	(Legacy) The device MUST issue an interrupt if the device runs out of available descriptors
 *   _anon24	(size 2, offset 24, init 0):	RSVD	_
 *   any_layout	(size 1, offset 26, init 0):	RW	(Legacy) his feature indicates that the device accepts arbitrary descriptor layouts
 *   ring_indirect_desc	(size 1, offset 27, init 0):	RW	river can use descriptors with the VIRTQ_DESC_F_INDIRECT
 *   ring_event_idx	(size 1, offset 28, init 0):	RW	enables the used_event and the avail_event fields
 *   _anon29	(size 2, offset 29, init 0):	RSVD	_
 *   version_1	(size 1, offset 31, init 0):	RW	Distinction Legacy / Version 1 Device
 */
typedef uint8_t *virtio_blk_features_t;
typedef uint8_t virtio_blk_features_array_t[4];
static const size_t virtio_blk_features_size = sizeof(virtio_blk_features_array_t );
static inline uint8_t virtio_blk_features_barrier_extract(virtio_blk_features_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_features_barrier_extract(virtio_blk_features_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x1) >> 0);
}

static inline void virtio_blk_features_barrier_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_features_barrier_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t virtio_blk_features_size_max_extract(virtio_blk_features_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_features_size_max_extract(virtio_blk_features_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x2) >> 1);
}

static inline void virtio_blk_features_size_max_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_features_size_max_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t virtio_blk_features_seg_max_extract(virtio_blk_features_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_features_seg_max_extract(virtio_blk_features_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x4) >> 2);
}

static inline void virtio_blk_features_seg_max_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_features_seg_max_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t virtio_blk_features_geometry_extract(virtio_blk_features_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_features_geometry_extract(virtio_blk_features_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x10) >> 4);
}

static inline void virtio_blk_features_geometry_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_features_geometry_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xef) | (0x10 & (_fieldval << 4)));
}

static inline uint8_t virtio_blk_features_read_only_extract(virtio_blk_features_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_features_read_only_extract(virtio_blk_features_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x20) >> 5);
}

static inline void virtio_blk_features_read_only_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_features_read_only_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xdf) | (0x20 & (_fieldval << 5)));
}

static inline uint8_t virtio_blk_features_blk_size_extract(virtio_blk_features_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_features_blk_size_extract(virtio_blk_features_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x40) >> 6);
}

static inline void virtio_blk_features_blk_size_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_features_blk_size_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t virtio_blk_features_scsi_extract(virtio_blk_features_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_features_scsi_extract(virtio_blk_features_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0x80) >> 7);
}

static inline void virtio_blk_features_scsi_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_features_scsi_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint8_t virtio_blk_features_flush_extract(virtio_blk_features_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_features_flush_extract(virtio_blk_features_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x2) >> 1);
}

static inline void virtio_blk_features_flush_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_features_flush_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t virtio_blk_features_topology_extract(virtio_blk_features_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_features_topology_extract(virtio_blk_features_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x4) >> 2);
}

static inline void virtio_blk_features_topology_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_features_topology_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t virtio_blk_features_notify_on_empty_extract(virtio_blk_features_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_features_notify_on_empty_extract(virtio_blk_features_t _dtptr)
{
    return(((*((uint8_t *)(2 + _dtptr))) & 0x80) >> 7);
}

static inline void virtio_blk_features_notify_on_empty_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_features_notify_on_empty_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(2 + _dtptr)) = (((*((uint8_t *)(2 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint8_t virtio_blk_features_any_layout_extract(virtio_blk_features_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_features_any_layout_extract(virtio_blk_features_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x4) >> 2);
}

static inline void virtio_blk_features_any_layout_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_features_any_layout_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t virtio_blk_features_ring_indirect_desc_extract(virtio_blk_features_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_features_ring_indirect_desc_extract(virtio_blk_features_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x8) >> 3);
}

static inline void virtio_blk_features_ring_indirect_desc_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_features_ring_indirect_desc_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0xf7) | (0x8 & (_fieldval << 3)));
}

static inline uint8_t virtio_blk_features_ring_event_idx_extract(virtio_blk_features_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_features_ring_event_idx_extract(virtio_blk_features_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x10) >> 4);
}

static inline void virtio_blk_features_ring_event_idx_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_features_ring_event_idx_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0xef) | (0x10 & (_fieldval << 4)));
}

static inline uint8_t virtio_blk_features_version_1_extract(virtio_blk_features_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_features_version_1_extract(virtio_blk_features_t _dtptr)
{
    return(((*((uint8_t *)(3 + _dtptr))) & 0x80) >> 7);
}

static inline void virtio_blk_features_version_1_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_features_version_1_insert(virtio_blk_features_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(3 + _dtptr)) = (((*((uint8_t *)(3 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline int virtio_blk_features_prtval(char *_s, size_t _size, virtio_blk_features_t _regval) __attribute__ ((always_inline));
static inline int virtio_blk_features_prtval(char *_s, size_t _size, virtio_blk_features_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " barrier =\t%" PRIx8 "\t(Device supports request barriers (Legacy))\n", virtio_blk_features_barrier_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size_max =\t%" PRIx8 "\t(Maximum size of any single segment in size_max)\n", virtio_blk_features_size_max_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " seg_max =\t%" PRIx8 "\t(Maximum number of segments in a request in seg_max)\n", virtio_blk_features_seg_max_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " geometry =\t%" PRIx8 "\t(Disk-style geometry specified in geometry)\n", virtio_blk_features_geometry_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " read_only =\t%" PRIx8 "\t(Device is read-only)\n", virtio_blk_features_read_only_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " blk_size =\t%" PRIx8 "\t(Block size of disk is in blk_size)\n", virtio_blk_features_blk_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " scsi =\t%" PRIx8 "\t(Device supports scsi packet commands)\n", virtio_blk_features_scsi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flush =\t%" PRIx8 "\t(Cache flush command support (Legacy))\n", virtio_blk_features_flush_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " topology =\t%" PRIx8 "\t(Device exports information on optimal IO alignment)\n", virtio_blk_features_topology_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " notify_on_empty =\t%" PRIx8 "\t((Legacy) The device MUST issue an interrupt if the device runs out of available descriptors)\n", virtio_blk_features_notify_on_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " any_layout =\t%" PRIx8 "\t((Legacy) his feature indicates that the device accepts arbitrary descriptor layouts)\n", virtio_blk_features_any_layout_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ring_indirect_desc =\t%" PRIx8 "\t(river can use descriptors with the VIRTQ_DESC_F_INDIRECT)\n", virtio_blk_features_ring_indirect_desc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ring_event_idx =\t%" PRIx8 "\t(enables the used_event and the avail_event fields)\n", virtio_blk_features_ring_event_idx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " version_1 =\t%" PRIx8 "\t(Distinction Legacy / Version 1 Device)\n", virtio_blk_features_version_1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: virtio_blk_req_t
 * Description: Request header
 * Fields:
 *   rtype	(size 32, offset 0, init 0):	RW	The type of the request
 *   ioprio	(size 32, offset 32, init 0):	RW	The IO prioroty (Legacy)
 *   sector	(size 64, offset 64, init 0):	RW	The sector where to write/read
 */
typedef uint8_t *virtio_blk_req_t;
typedef uint8_t virtio_blk_req_array_t[16];
static const size_t virtio_blk_req_size = sizeof(virtio_blk_req_array_t );
static inline uint32_t virtio_blk_req_rtype_extract(virtio_blk_req_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t virtio_blk_req_rtype_extract(virtio_blk_req_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void virtio_blk_req_rtype_insert(virtio_blk_req_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_req_rtype_insert(virtio_blk_req_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline uint32_t virtio_blk_req_ioprio_extract(virtio_blk_req_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t virtio_blk_req_ioprio_extract(virtio_blk_req_t _dtptr)
{
    return(((*((uint32_t *)(4 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void virtio_blk_req_ioprio_insert(virtio_blk_req_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_req_ioprio_insert(virtio_blk_req_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(4 + _dtptr)) = (((*((uint32_t *)(4 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline uint64_t virtio_blk_req_sector_extract(virtio_blk_req_t _dtptr) __attribute__ ((always_inline));
static inline uint64_t virtio_blk_req_sector_extract(virtio_blk_req_t _dtptr)
{
    return(((*((uint64_t *)(8 + _dtptr))) & 0xffffffffffffffff) >> 0);
}

static inline void virtio_blk_req_sector_insert(virtio_blk_req_t _dtptr, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_req_sector_insert(virtio_blk_req_t _dtptr, uint64_t _fieldval)
{
    *((uint64_t *)(8 + _dtptr)) = (((*((uint64_t *)(8 + _dtptr))) & 0x0) | (0xffffffffffffffff & (_fieldval << 0)));
}

static inline int virtio_blk_req_prtval(char *_s, size_t _size, virtio_blk_req_t _regval) __attribute__ ((always_inline));
static inline int virtio_blk_req_prtval(char *_s, size_t _size, virtio_blk_req_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtype =\t%" PRIx32 "\t(The type of the request)\n", virtio_blk_req_rtype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ioprio =\t%" PRIx32 "\t(The IO prioroty (Legacy))\n", virtio_blk_req_ioprio_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sector =\t%" PRIx64 "\t(The sector where to write/read)\n", virtio_blk_req_sector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: virtio_blk_scsi_req_t
 * Description: SCSI trailer
 * Fields:
 *   errors	(size 32, offset 0, init 0):	RW	Errors that may have occurred
 *   data_len	(size 32, offset 32, init 0):	RW	Deprecated: Should be ignored.
 *   sense_len	(size 32, offset 64, init 0):	RW	The number of bytes in the sense buffer
 *   residual	(size 32, offset 96, init 0):	RW	The residual size: total - transferred
 */
typedef uint8_t *virtio_blk_scsi_req_t;
typedef uint8_t virtio_blk_scsi_req_array_t[16];
static const size_t virtio_blk_scsi_req_size = sizeof(virtio_blk_scsi_req_array_t );
static inline uint32_t virtio_blk_scsi_req_errors_extract(virtio_blk_scsi_req_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t virtio_blk_scsi_req_errors_extract(virtio_blk_scsi_req_t _dtptr)
{
    return(((*((uint32_t *)(0 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void virtio_blk_scsi_req_errors_insert(virtio_blk_scsi_req_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_scsi_req_errors_insert(virtio_blk_scsi_req_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(0 + _dtptr)) = (((*((uint32_t *)(0 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline uint32_t virtio_blk_scsi_req_data_len_extract(virtio_blk_scsi_req_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t virtio_blk_scsi_req_data_len_extract(virtio_blk_scsi_req_t _dtptr)
{
    return(((*((uint32_t *)(4 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void virtio_blk_scsi_req_data_len_insert(virtio_blk_scsi_req_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_scsi_req_data_len_insert(virtio_blk_scsi_req_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(4 + _dtptr)) = (((*((uint32_t *)(4 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline uint32_t virtio_blk_scsi_req_sense_len_extract(virtio_blk_scsi_req_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t virtio_blk_scsi_req_sense_len_extract(virtio_blk_scsi_req_t _dtptr)
{
    return(((*((uint32_t *)(8 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void virtio_blk_scsi_req_sense_len_insert(virtio_blk_scsi_req_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_scsi_req_sense_len_insert(virtio_blk_scsi_req_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(8 + _dtptr)) = (((*((uint32_t *)(8 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline uint32_t virtio_blk_scsi_req_residual_extract(virtio_blk_scsi_req_t _dtptr) __attribute__ ((always_inline));
static inline uint32_t virtio_blk_scsi_req_residual_extract(virtio_blk_scsi_req_t _dtptr)
{
    return(((*((uint32_t *)(12 + _dtptr))) & 0xffffffff) >> 0);
}

static inline void virtio_blk_scsi_req_residual_insert(virtio_blk_scsi_req_t _dtptr, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_scsi_req_residual_insert(virtio_blk_scsi_req_t _dtptr, uint32_t _fieldval)
{
    *((uint32_t *)(12 + _dtptr)) = (((*((uint32_t *)(12 + _dtptr))) & 0x0) | (0xffffffff & (_fieldval << 0)));
}

static inline int virtio_blk_scsi_req_prtval(char *_s, size_t _size, virtio_blk_scsi_req_t _regval) __attribute__ ((always_inline));
static inline int virtio_blk_scsi_req_prtval(char *_s, size_t _size, virtio_blk_scsi_req_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " errors =\t%" PRIx32 "\t(Errors that may have occurred)\n", virtio_blk_scsi_req_errors_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data_len =\t%" PRIx32 "\t(Deprecated: Should be ignored.)\n", virtio_blk_scsi_req_data_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sense_len =\t%" PRIx32 "\t(The number of bytes in the sense buffer)\n", virtio_blk_scsi_req_sense_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " residual =\t%" PRIx32 "\t(The residual size: total - transferred)\n", virtio_blk_scsi_req_residual_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum virtio_blk_initials {
    virtio_blk_capacity_initial = 0x0,
    virtio_blk_seg_size_initial = 0x0,
    virtio_blk_seg_num_initial = 0x0,
    virtio_blk_geometry_initial = 0x0,
    virtio_blk_block_size_initial = 0x0,
    virtio_blk_topo_blocks_initial = 0x0,
    virtio_blk_topo_io_size_initial = 0x0,
    virtio_blk_writeback_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void virtio_blk_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void virtio_blk_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register capacity: The capacity in 512byte sectors
 * Type: virtio_blk.capacity (Implicit type of The capacity in 512byte sectors register)
 *   sectors	(size 64, offset 0, init 0):	RW	Number of 512byte sectors
 */
static inline virtio_blk_capacity_t virtio_blk_capacity_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_blk_capacity_t virtio_blk_capacity_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->base, 0x0));
}

static inline virtio_blk_capacity_t virtio_blk_capacity_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_blk_capacity_t virtio_blk_capacity_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->base, 0x0));
}

static inline void virtio_blk_capacity_rawwr(__DN(t) *_dev, virtio_blk_capacity_t _regval) __attribute__ ((always_inline));
static inline void virtio_blk_capacity_rawwr(__DN(t) *_dev, virtio_blk_capacity_t _regval)
{
    mackerel_write_addr_64(_dev->base, 0x0, _regval);
}

static inline void virtio_blk_capacity_wr(__DN(t) *_dev, virtio_blk_capacity_t _regval) __attribute__ ((always_inline));
static inline void virtio_blk_capacity_wr(__DN(t) *_dev, virtio_blk_capacity_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_64(_dev->base, 0x0, _regval);
}

static inline int virtio_blk_capacity_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_blk_capacity_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_blk_capacity_t _regval = mackerel_read_addr_64(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register capacity (The capacity in 512byte sectors): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sectors =\t%" PRIx64 "\t(Number of 512byte sectors)\n", virtio_blk_capacity_sectors_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint64_t virtio_blk_capacity_sectors_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint64_t virtio_blk_capacity_sectors_rdf(__DN(t) *_dev)
{
    virtio_blk_capacity_t _regval = mackerel_read_addr_64(_dev->base, 0x0);
    return(virtio_blk_capacity_sectors_extract(_regval));
}

static inline void virtio_blk_capacity_sectors_wrf(__DN(t) *_dev, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_capacity_sectors_wrf(__DN(t) *_dev, uint64_t _fieldval)
{
    virtio_blk_capacity_t _regval = 0xffffffffffffffff & (((virtio_blk_capacity_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_64(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register seg_size: The maximum segment size
 * Type: virtio_blk.seg_size (Implicit type of The maximum segment size register)
 *   max	(size 32, offset 0, init 0):	RW	Maximum segment size
 */
static inline virtio_blk_seg_size_t virtio_blk_seg_size_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_blk_seg_size_t virtio_blk_seg_size_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline virtio_blk_seg_size_t virtio_blk_seg_size_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_blk_seg_size_t virtio_blk_seg_size_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void virtio_blk_seg_size_rawwr(__DN(t) *_dev, virtio_blk_seg_size_t _regval) __attribute__ ((always_inline));
static inline void virtio_blk_seg_size_rawwr(__DN(t) *_dev, virtio_blk_seg_size_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline void virtio_blk_seg_size_wr(__DN(t) *_dev, virtio_blk_seg_size_t _regval) __attribute__ ((always_inline));
static inline void virtio_blk_seg_size_wr(__DN(t) *_dev, virtio_blk_seg_size_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline int virtio_blk_seg_size_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_blk_seg_size_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_blk_seg_size_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register seg_size (The maximum segment size): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " max =\t%" PRIx32 "\t(Maximum segment size)\n", virtio_blk_seg_size_max_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_blk_seg_size_max_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_blk_seg_size_max_rdf(__DN(t) *_dev)
{
    virtio_blk_seg_size_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(virtio_blk_seg_size_max_extract(_regval));
}

static inline void virtio_blk_seg_size_max_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_seg_size_max_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_blk_seg_size_t _regval = 0xffffffff & (((virtio_blk_seg_size_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

/*
 * Register seg_num: The maximum number of segments
 * Type: virtio_blk.seg_num (Implicit type of The maximum number of segments register)
 *   max	(size 32, offset 0, init 0):	RW	Maximum number of segments
 */
static inline virtio_blk_seg_num_t virtio_blk_seg_num_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_blk_seg_num_t virtio_blk_seg_num_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline virtio_blk_seg_num_t virtio_blk_seg_num_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_blk_seg_num_t virtio_blk_seg_num_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline void virtio_blk_seg_num_rawwr(__DN(t) *_dev, virtio_blk_seg_num_t _regval) __attribute__ ((always_inline));
static inline void virtio_blk_seg_num_rawwr(__DN(t) *_dev, virtio_blk_seg_num_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline void virtio_blk_seg_num_wr(__DN(t) *_dev, virtio_blk_seg_num_t _regval) __attribute__ ((always_inline));
static inline void virtio_blk_seg_num_wr(__DN(t) *_dev, virtio_blk_seg_num_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline int virtio_blk_seg_num_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_blk_seg_num_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_blk_seg_num_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register seg_num (The maximum number of segments): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " max =\t%" PRIx32 "\t(Maximum number of segments)\n", virtio_blk_seg_num_max_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_blk_seg_num_max_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_blk_seg_num_max_rdf(__DN(t) *_dev)
{
    virtio_blk_seg_num_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(virtio_blk_seg_num_max_extract(_regval));
}

static inline void virtio_blk_seg_num_max_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_seg_num_max_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_blk_seg_num_t _regval = 0xffffffff & (((virtio_blk_seg_num_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

/*
 * Register geometry: Geometry Information
 * Type: virtio_blk.geometry (Implicit type of Geometry Information register)
 *   cylinders	(size 16, offset 0, init 0):	RW	Number of cylinders
 *   heads	(size 8, offset 16, init 0):	RW	Number of heads
 *   sectors	(size 8, offset 24, init 0):	RW	Number of sectors
 */
static inline virtio_blk_geometry_t virtio_blk_geometry_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_blk_geometry_t virtio_blk_geometry_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline virtio_blk_geometry_t virtio_blk_geometry_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_blk_geometry_t virtio_blk_geometry_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void virtio_blk_geometry_rawwr(__DN(t) *_dev, virtio_blk_geometry_t _regval) __attribute__ ((always_inline));
static inline void virtio_blk_geometry_rawwr(__DN(t) *_dev, virtio_blk_geometry_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline void virtio_blk_geometry_wr(__DN(t) *_dev, virtio_blk_geometry_t _regval) __attribute__ ((always_inline));
static inline void virtio_blk_geometry_wr(__DN(t) *_dev, virtio_blk_geometry_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline int virtio_blk_geometry_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_blk_geometry_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_blk_geometry_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register geometry (Geometry Information): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cylinders =\t%" PRIx16 "\t(Number of cylinders)\n", virtio_blk_geometry_cylinders_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " heads =\t%" PRIx8 "\t(Number of heads)\n", virtio_blk_geometry_heads_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sectors =\t%" PRIx8 "\t(Number of sectors)\n", virtio_blk_geometry_sectors_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t virtio_blk_geometry_cylinders_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t virtio_blk_geometry_cylinders_rdf(__DN(t) *_dev)
{
    virtio_blk_geometry_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(virtio_blk_geometry_cylinders_extract(_regval));
}

static inline uint8_t virtio_blk_geometry_heads_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_geometry_heads_rdf(__DN(t) *_dev)
{
    virtio_blk_geometry_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(virtio_blk_geometry_heads_extract(_regval));
}

static inline uint8_t virtio_blk_geometry_sectors_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_geometry_sectors_rdf(__DN(t) *_dev)
{
    virtio_blk_geometry_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(virtio_blk_geometry_sectors_extract(_regval));
}

static inline void virtio_blk_geometry_cylinders_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_geometry_cylinders_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    virtio_blk_geometry_t _regval = 0xffff & (((virtio_blk_geometry_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void virtio_blk_geometry_heads_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_geometry_heads_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_blk_geometry_t _regval = 0xff0000 & (((virtio_blk_geometry_t )(_fieldval)) << 16);
    _regval = (_regval | (0xff00ffff & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void virtio_blk_geometry_sectors_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_geometry_sectors_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_blk_geometry_t _regval = 0xff000000 & (((virtio_blk_geometry_t )(_fieldval)) << 24);
    _regval = (_regval | (0xffffff & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register block_size: Block Size
 * Type: virtio_blk.block_size (Implicit type of Block Size register)
 *   size	(size 32, offset 0, init 0):	RW	The size of a block
 */
static inline virtio_blk_block_size_t virtio_blk_block_size_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_blk_block_size_t virtio_blk_block_size_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline virtio_blk_block_size_t virtio_blk_block_size_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_blk_block_size_t virtio_blk_block_size_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline void virtio_blk_block_size_rawwr(__DN(t) *_dev, virtio_blk_block_size_t _regval) __attribute__ ((always_inline));
static inline void virtio_blk_block_size_rawwr(__DN(t) *_dev, virtio_blk_block_size_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline void virtio_blk_block_size_wr(__DN(t) *_dev, virtio_blk_block_size_t _regval) __attribute__ ((always_inline));
static inline void virtio_blk_block_size_wr(__DN(t) *_dev, virtio_blk_block_size_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline int virtio_blk_block_size_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_blk_block_size_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_blk_block_size_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register block_size (Block Size): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx32 "\t(The size of a block)\n", virtio_blk_block_size_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_blk_block_size_size_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_blk_block_size_size_rdf(__DN(t) *_dev)
{
    virtio_blk_block_size_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(virtio_blk_block_size_size_extract(_regval));
}

static inline void virtio_blk_block_size_size_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_block_size_size_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_blk_block_size_t _regval = 0xffffffff & (((virtio_blk_block_size_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

/*
 * Register topo_blocks: Toplogy: Logical Blocks
 * Type: virtio_blk.topo_blocks (Implicit type of Toplogy: Logical Blocks register)
 *   logic_per_phys	(size 8, offset 0, init 0):	RW	Number of logical blocks per physical block
 *   offset_aligned	(size 8, offset 8, init 0):	RW	Offset of first aligned logical block
 */
static inline virtio_blk_topo_blocks_t virtio_blk_topo_blocks_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_blk_topo_blocks_t virtio_blk_topo_blocks_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->base, 0x18));
}

static inline virtio_blk_topo_blocks_t virtio_blk_topo_blocks_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_blk_topo_blocks_t virtio_blk_topo_blocks_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->base, 0x18));
}

static inline void virtio_blk_topo_blocks_rawwr(__DN(t) *_dev, virtio_blk_topo_blocks_t _regval) __attribute__ ((always_inline));
static inline void virtio_blk_topo_blocks_rawwr(__DN(t) *_dev, virtio_blk_topo_blocks_t _regval)
{
    mackerel_write_addr_16(_dev->base, 0x18, _regval);
}

static inline void virtio_blk_topo_blocks_wr(__DN(t) *_dev, virtio_blk_topo_blocks_t _regval) __attribute__ ((always_inline));
static inline void virtio_blk_topo_blocks_wr(__DN(t) *_dev, virtio_blk_topo_blocks_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->base, 0x18, _regval);
}

static inline int virtio_blk_topo_blocks_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_blk_topo_blocks_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_blk_topo_blocks_t _regval = mackerel_read_addr_16(_dev->base, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register topo_blocks (Toplogy: Logical Blocks): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " logic_per_phys =\t%" PRIx8 "\t(Number of logical blocks per physical block)\n", virtio_blk_topo_blocks_logic_per_phys_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " offset_aligned =\t%" PRIx8 "\t(Offset of first aligned logical block)\n", virtio_blk_topo_blocks_offset_aligned_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t virtio_blk_topo_blocks_logic_per_phys_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_topo_blocks_logic_per_phys_rdf(__DN(t) *_dev)
{
    virtio_blk_topo_blocks_t _regval = mackerel_read_addr_16(_dev->base, 0x18);
    return(virtio_blk_topo_blocks_logic_per_phys_extract(_regval));
}

static inline uint8_t virtio_blk_topo_blocks_offset_aligned_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_topo_blocks_offset_aligned_rdf(__DN(t) *_dev)
{
    virtio_blk_topo_blocks_t _regval = mackerel_read_addr_16(_dev->base, 0x18);
    return(virtio_blk_topo_blocks_offset_aligned_extract(_regval));
}

static inline void virtio_blk_topo_blocks_logic_per_phys_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_topo_blocks_logic_per_phys_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_blk_topo_blocks_t _regval = 0xff & (((virtio_blk_topo_blocks_t )(_fieldval)) << 0);
    _regval = (_regval | (0xff00 & mackerel_read_addr_16(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void virtio_blk_topo_blocks_offset_aligned_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_topo_blocks_offset_aligned_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_blk_topo_blocks_t _regval = 0xff00 & (((virtio_blk_topo_blocks_t )(_fieldval)) << 8);
    _regval = (_regval | (0xff & mackerel_read_addr_16(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

/*
 * Register topo_io_size: Topology: minimum IO Size
 * Type: virtio_blk.topo_io_size (Implicit type of Topology: minimum IO Size register)
 *   min	(size 16, offset 0, init 0):	RW	Minimum number of IO size in blocks
 *   opt	(size 16, offset 16, init 0):	RW	Maximum number of IO size in  blocks
 */
static inline virtio_blk_topo_io_size_t virtio_blk_topo_io_size_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_blk_topo_io_size_t virtio_blk_topo_io_size_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1a));
}

static inline virtio_blk_topo_io_size_t virtio_blk_topo_io_size_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_blk_topo_io_size_t virtio_blk_topo_io_size_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1a));
}

static inline void virtio_blk_topo_io_size_rawwr(__DN(t) *_dev, virtio_blk_topo_io_size_t _regval) __attribute__ ((always_inline));
static inline void virtio_blk_topo_io_size_rawwr(__DN(t) *_dev, virtio_blk_topo_io_size_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1a, _regval);
}

static inline void virtio_blk_topo_io_size_wr(__DN(t) *_dev, virtio_blk_topo_io_size_t _regval) __attribute__ ((always_inline));
static inline void virtio_blk_topo_io_size_wr(__DN(t) *_dev, virtio_blk_topo_io_size_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1a, _regval);
}

static inline int virtio_blk_topo_io_size_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_blk_topo_io_size_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_blk_topo_io_size_t _regval = mackerel_read_addr_32(_dev->base, 0x1a);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register topo_io_size (Topology: minimum IO Size): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " min =\t%" PRIx16 "\t(Minimum number of IO size in blocks)\n", virtio_blk_topo_io_size_min_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " opt =\t%" PRIx16 "\t(Maximum number of IO size in  blocks)\n", virtio_blk_topo_io_size_opt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t virtio_blk_topo_io_size_min_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t virtio_blk_topo_io_size_min_rdf(__DN(t) *_dev)
{
    virtio_blk_topo_io_size_t _regval = mackerel_read_addr_32(_dev->base, 0x1a);
    return(virtio_blk_topo_io_size_min_extract(_regval));
}

static inline uint16_t virtio_blk_topo_io_size_opt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t virtio_blk_topo_io_size_opt_rdf(__DN(t) *_dev)
{
    virtio_blk_topo_io_size_t _regval = mackerel_read_addr_32(_dev->base, 0x1a);
    return(virtio_blk_topo_io_size_opt_extract(_regval));
}

static inline void virtio_blk_topo_io_size_min_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_topo_io_size_min_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    virtio_blk_topo_io_size_t _regval = 0xffff & (((virtio_blk_topo_io_size_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x1a)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1a, _regval);
    // No shadow register to write to
}

static inline void virtio_blk_topo_io_size_opt_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_topo_io_size_opt_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    virtio_blk_topo_io_size_t _regval = 0xffff0000 & (((virtio_blk_topo_io_size_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x1a)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1a, _regval);
    // No shadow register to write to
}

/*
 * Register writeback: Legacy Writeback Register
 * Type: virtio_blk.writeback (Implicit type of Legacy Writeback Register register)
 *   wb	(size 8, offset 0, init 0):	RW	Write back
 */
static inline virtio_blk_writeback_t virtio_blk_writeback_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_blk_writeback_t virtio_blk_writeback_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->base, 0x1e));
}

static inline virtio_blk_writeback_t virtio_blk_writeback_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_blk_writeback_t virtio_blk_writeback_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->base, 0x1e));
}

static inline void virtio_blk_writeback_rawwr(__DN(t) *_dev, virtio_blk_writeback_t _regval) __attribute__ ((always_inline));
static inline void virtio_blk_writeback_rawwr(__DN(t) *_dev, virtio_blk_writeback_t _regval)
{
    mackerel_write_addr_8(_dev->base, 0x1e, _regval);
}

static inline void virtio_blk_writeback_wr(__DN(t) *_dev, virtio_blk_writeback_t _regval) __attribute__ ((always_inline));
static inline void virtio_blk_writeback_wr(__DN(t) *_dev, virtio_blk_writeback_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->base, 0x1e, _regval);
}

static inline int virtio_blk_writeback_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_blk_writeback_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_blk_writeback_t _regval = mackerel_read_addr_8(_dev->base, 0x1e);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register writeback (Legacy Writeback Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wb =\t%" PRIx8 "\t(Write back)\n", virtio_blk_writeback_wb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t virtio_blk_writeback_wb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_blk_writeback_wb_rdf(__DN(t) *_dev)
{
    virtio_blk_writeback_t _regval = mackerel_read_addr_8(_dev->base, 0x1e);
    return(virtio_blk_writeback_wb_extract(_regval));
}

static inline void virtio_blk_writeback_wb_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_blk_writeback_wb_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_blk_writeback_t _regval = 0xff & (((virtio_blk_writeback_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->base, 0x1e, _regval);
    // No shadow register to write to
}

static inline int virtio_blk_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_blk_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device virtio_blk (Virtio Block Device Specification):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_blk_capacity_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_blk_seg_size_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_blk_seg_num_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_blk_geometry_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_blk_block_size_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_blk_topo_blocks_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_blk_topo_io_size_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_blk_writeback_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device virtio_blk\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __virtio_blk_DEV_H
