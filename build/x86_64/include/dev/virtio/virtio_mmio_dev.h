#ifndef __virtio_mmio_DEV_H
#define __virtio_mmio_DEV_H 1
/*
 * DEVICE DEFINITION: Virtio MMIO Transport Specification
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) virtio_mmio ## _ ## x
/*
 * Constants defn: virtio_mmio.virtio_magic (Little Endian equivalent of the 'virt' string)
 *  - width 4 bits
 */
typedef uint8_t virtio_mmio_virtio_magic_t;
#define virtio_mmio_magic_value ((virtio_mmio_virtio_magic_t)0x74726976)

static inline char *virtio_mmio_virtio_magic_describe(virtio_mmio_virtio_magic_t _e) __attribute__ ((always_inline));
static inline char *virtio_mmio_virtio_magic_describe(virtio_mmio_virtio_magic_t _e)
{
    switch (_e) {
    case virtio_mmio_magic_value:
        return("magic_value: Little Endian equivalent of the 'virt' string");
    default:
        return(NULL);
    }
}

static inline int virtio_mmio_virtio_magic_prtval(char *_s, size_t _size, virtio_mmio_virtio_magic_t _e) __attribute__ ((always_inline));
static inline int virtio_mmio_virtio_magic_prtval(char *_s, size_t _size, virtio_mmio_virtio_magic_t _e)
{
    char *d = virtio_mmio_virtio_magic_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "virtio_mmio_virtio_magic_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: virtio_mmio.virtio_version (Virtio MMIO Device Versions)
 *  - width 32 bits
 */
typedef uint32_t virtio_mmio_virtio_version_t;
#define virtio_mmio_version_invalid ((virtio_mmio_virtio_version_t)0x0)
#define virtio_mmio_version_legacy ((virtio_mmio_virtio_version_t)0x1)
#define virtio_mmio_version_virtio10 ((virtio_mmio_virtio_version_t)0x2)

static inline char *virtio_mmio_virtio_version_describe(virtio_mmio_virtio_version_t _e) __attribute__ ((always_inline));
static inline char *virtio_mmio_virtio_version_describe(virtio_mmio_virtio_version_t _e)
{
    switch (_e) {
    case virtio_mmio_version_invalid:
        return("version_invalid: Invalid Version.");
    case virtio_mmio_version_legacy:
        return("version_legacy: The legacy interface is used.");
    case virtio_mmio_version_virtio10:
        return("version_virtio10: Virtio Version 1.0");
    default:
        return(NULL);
    }
}

static inline int virtio_mmio_virtio_version_prtval(char *_s, size_t _size, virtio_mmio_virtio_version_t _e) __attribute__ ((always_inline));
static inline int virtio_mmio_virtio_version_prtval(char *_s, size_t _size, virtio_mmio_virtio_version_t _e)
{
    char *d = virtio_mmio_virtio_version_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "virtio_mmio_virtio_version_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: virtio_mmio.virtio_deviceid (Virtio Device IDs)
 *  - width 32 bits
 */
typedef uint32_t virtio_mmio_virtio_deviceid_t;
#define virtio_mmio_reserved ((virtio_mmio_virtio_deviceid_t)0x0)
#define virtio_mmio_network_card ((virtio_mmio_virtio_deviceid_t)0x1)
#define virtio_mmio_block_device ((virtio_mmio_virtio_deviceid_t)0x2)
#define virtio_mmio_console ((virtio_mmio_virtio_deviceid_t)0x3)
#define virtio_mmio_entropy_source ((virtio_mmio_virtio_deviceid_t)0x4)
#define virtio_mmio_legacy_balloon ((virtio_mmio_virtio_deviceid_t)0x5)
#define virtio_mmio_io_memory ((virtio_mmio_virtio_deviceid_t)0x6)
#define virtio_mmio_rpmsg ((virtio_mmio_virtio_deviceid_t)0x7)
#define virtio_mmio_scsi_host ((virtio_mmio_virtio_deviceid_t)0x8)
#define virtio_mmio_transport_9p ((virtio_mmio_virtio_deviceid_t)0x9)
#define virtio_mmio_mac80211_wlan ((virtio_mmio_virtio_deviceid_t)0xa)
#define virtio_mmio_rproc_serial ((virtio_mmio_virtio_deviceid_t)0xb)
#define virtio_mmio_virtio_caif ((virtio_mmio_virtio_deviceid_t)0xc)
#define virtio_mmio_memory_balloon ((virtio_mmio_virtio_deviceid_t)0xd)
#define virtio_mmio_gpu_device ((virtio_mmio_virtio_deviceid_t)0xe)
#define virtio_mmio_timer_device ((virtio_mmio_virtio_deviceid_t)0xf)

static inline char *virtio_mmio_virtio_deviceid_describe(virtio_mmio_virtio_deviceid_t _e) __attribute__ ((always_inline));
static inline char *virtio_mmio_virtio_deviceid_describe(virtio_mmio_virtio_deviceid_t _e)
{
    switch (_e) {
    case virtio_mmio_reserved:
        return("reserved: Invalid Device ID");
    case virtio_mmio_network_card:
        return("network_card: Network Interface Device");
    case virtio_mmio_block_device:
        return("block_device: Block Device");
    case virtio_mmio_console:
        return("console: Serial Console Device");
    case virtio_mmio_entropy_source:
        return("entropy_source: Entorpy Source Device (Randomness)");
    case virtio_mmio_legacy_balloon:
        return("legacy_balloon: Memory Ballooning Device (legacy)");
    case virtio_mmio_io_memory:
        return("io_memory: IO Memory Device");
    case virtio_mmio_rpmsg:
        return("rpmsg: RPMSG Device");
    case virtio_mmio_scsi_host:
        return("scsi_host: SCSI Host Device");
    case virtio_mmio_transport_9p:
        return("transport_9p: 9P Transport Device");
    case virtio_mmio_mac80211_wlan:
        return("mac80211_wlan: MAC 802.11 WLAN Device");
    case virtio_mmio_rproc_serial:
        return("rproc_serial: RPROC Serial Device");
    case virtio_mmio_virtio_caif:
        return("virtio_caif: Virtio CAIF Device");
    case virtio_mmio_memory_balloon:
        return("memory_balloon: Memory Ballooning Device");
    case virtio_mmio_gpu_device:
        return("gpu_device: GPU Device");
    case virtio_mmio_timer_device:
        return("timer_device: Clock / Timer Device");
    default:
        return(NULL);
    }
}

static inline int virtio_mmio_virtio_deviceid_prtval(char *_s, size_t _size, virtio_mmio_virtio_deviceid_t _e) __attribute__ ((always_inline));
static inline int virtio_mmio_virtio_deviceid_prtval(char *_s, size_t _size, virtio_mmio_virtio_deviceid_t _e)
{
    char *d = virtio_mmio_virtio_deviceid_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "virtio_mmio_virtio_deviceid_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: virtio_mmio.queue (Queue Ready Bit Values)
 *  - width 1 bits
 */
typedef uint8_t virtio_mmio_queue_t;
#define virtio_mmio_ready ((virtio_mmio_queue_t)0x1)
#define virtio_mmio_notready ((virtio_mmio_queue_t)0x0)

static inline char *virtio_mmio_queue_describe(virtio_mmio_queue_t _e) __attribute__ ((always_inline));
static inline char *virtio_mmio_queue_describe(virtio_mmio_queue_t _e)
{
    switch (_e) {
    case virtio_mmio_ready:
        return("ready: The queue is ready to use");
    case virtio_mmio_notready:
        return("notready: The queue is not ready");
    default:
        return(NULL);
    }
}

static inline int virtio_mmio_queue_prtval(char *_s, size_t _size, virtio_mmio_queue_t _e) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_prtval(char *_s, size_t _size, virtio_mmio_queue_t _e)
{
    char *d = virtio_mmio_queue_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "virtio_mmio_queue_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: virtio_mmio.device_status (Reset value)
 *  - width 8 bits
 */
typedef uint8_t virtio_mmio_device_status_t;
#define virtio_mmio_device_reset ((virtio_mmio_device_status_t)0x0)

static inline char *virtio_mmio_device_status_describe(virtio_mmio_device_status_t _e) __attribute__ ((always_inline));
static inline char *virtio_mmio_device_status_describe(virtio_mmio_device_status_t _e)
{
    switch (_e) {
    case virtio_mmio_device_reset:
        return("device_reset: Reset the device");
    default:
        return(NULL);
    }
}

static inline int virtio_mmio_device_status_prtval(char *_s, size_t _size, virtio_mmio_device_status_t _e) __attribute__ ((always_inline));
static inline int virtio_mmio_device_status_prtval(char *_s, size_t _size, virtio_mmio_device_status_t _e)
{
    char *d = virtio_mmio_device_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "virtio_mmio_device_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: virtio_mmio.config_offset (Reset value)
 *  - width 8 bits
 */
typedef uint8_t virtio_mmio_config_offset_t;
#define virtio_mmio_config_offset ((virtio_mmio_config_offset_t)0x100)

static inline char *virtio_mmio_config_offset_describe(virtio_mmio_config_offset_t _e) __attribute__ ((always_inline));
static inline char *virtio_mmio_config_offset_describe(virtio_mmio_config_offset_t _e)
{
    switch (_e) {
    case virtio_mmio_config_offset:
        return("config_offset: Offset of the configuration space");
    default:
        return(NULL);
    }
}

static inline int virtio_mmio_config_offset_prtval(char *_s, size_t _size, virtio_mmio_config_offset_t _e) __attribute__ ((always_inline));
static inline int virtio_mmio_config_offset_prtval(char *_s, size_t _size, virtio_mmio_config_offset_t _e)
{
    char *d = virtio_mmio_config_offset_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "virtio_mmio_config_offset_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: virtio_mmio_magic_value_t
 * Description: Implicit type of Magic value for identifying the Virtio device register
 * Fields:
 *   val	(size 32, offset 0, init 0):	RW	Has to be 0x74726976
 */
typedef uint32_t virtio_mmio_magic_value_t;
#define virtio_mmio_magic_value_default 0x0
static inline uint32_t virtio_mmio_magic_value_val_extract(virtio_mmio_magic_value_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_magic_value_val_extract(virtio_mmio_magic_value_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_mmio_magic_value_t virtio_mmio_magic_value_val_insert(virtio_mmio_magic_value_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_magic_value_t virtio_mmio_magic_value_val_insert(virtio_mmio_magic_value_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_mmio_magic_value_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_magic_value_prtval(char *_s, size_t _size, virtio_mmio_magic_value_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_magic_value_prtval(char *_s, size_t _size, virtio_mmio_magic_value_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx32 "\t(Has to be 0x74726976)\n", virtio_mmio_magic_value_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_version_t
 * Description: Implicit type of Device Version Number register
 * Fields:
 *   version	(size 8, offset 0, init 0):	RW	Virtio device interface version
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t virtio_mmio_version_t;
#define virtio_mmio_version_default 0x0
static inline uint8_t virtio_mmio_version_version_extract(virtio_mmio_version_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_version_version_extract(virtio_mmio_version_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline virtio_mmio_version_t virtio_mmio_version_version_insert(virtio_mmio_version_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_version_t virtio_mmio_version_version_insert(virtio_mmio_version_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((virtio_mmio_version_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_version_prtval(char *_s, size_t _size, virtio_mmio_version_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_version_prtval(char *_s, size_t _size, virtio_mmio_version_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " version =\t%" PRIx8 "\t(Virtio device interface version)\n", virtio_mmio_version_version_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_deviceid_t
 * Description: Implicit type of Virtio Subsystem Device ID register
 * Fields:
 *   id	(size 8, offset 0, init 0):	RW	Device ID
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t virtio_mmio_deviceid_t;
#define virtio_mmio_deviceid_default 0x0
static inline uint8_t virtio_mmio_deviceid_id_extract(virtio_mmio_deviceid_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_deviceid_id_extract(virtio_mmio_deviceid_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline virtio_mmio_deviceid_t virtio_mmio_deviceid_id_insert(virtio_mmio_deviceid_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_deviceid_t virtio_mmio_deviceid_id_insert(virtio_mmio_deviceid_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((virtio_mmio_deviceid_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_deviceid_prtval(char *_s, size_t _size, virtio_mmio_deviceid_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_deviceid_prtval(char *_s, size_t _size, virtio_mmio_deviceid_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " id =\t%" PRIx8 "\t(Device ID)\n", virtio_mmio_deviceid_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_vendorid_t
 * Description: Implicit type of Virtio Subsystem Vendor ID register
 * Fields:
 *   id	(size 32, offset 0, init 0):	RW	Vendor ID
 */
typedef uint32_t virtio_mmio_vendorid_t;
#define virtio_mmio_vendorid_default 0x0
static inline uint32_t virtio_mmio_vendorid_id_extract(virtio_mmio_vendorid_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_vendorid_id_extract(virtio_mmio_vendorid_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_mmio_vendorid_t virtio_mmio_vendorid_id_insert(virtio_mmio_vendorid_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_vendorid_t virtio_mmio_vendorid_id_insert(virtio_mmio_vendorid_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_mmio_vendorid_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_vendorid_prtval(char *_s, size_t _size, virtio_mmio_vendorid_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_vendorid_prtval(char *_s, size_t _size, virtio_mmio_vendorid_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " id =\t%" PRIx32 "\t(Vendor ID)\n", virtio_mmio_vendorid_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_dev_features_t
 * Description: Implicit type of Flags representing features the device supports register
 * Fields:
 *   features	(size 32, offset 0, init 0):	RW	Virtio Features Bits
 */
typedef uint32_t virtio_mmio_dev_features_t;
#define virtio_mmio_dev_features_default 0x0
static inline uint32_t virtio_mmio_dev_features_features_extract(virtio_mmio_dev_features_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_dev_features_features_extract(virtio_mmio_dev_features_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_mmio_dev_features_t virtio_mmio_dev_features_features_insert(virtio_mmio_dev_features_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_dev_features_t virtio_mmio_dev_features_features_insert(virtio_mmio_dev_features_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_mmio_dev_features_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_dev_features_prtval(char *_s, size_t _size, virtio_mmio_dev_features_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_dev_features_prtval(char *_s, size_t _size, virtio_mmio_dev_features_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " features =\t%" PRIx32 "\t(Virtio Features Bits)\n", virtio_mmio_dev_features_features_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_dev_features_sel_t
 * Description: Implicit type of Device (host) features word selection. register
 * Fields:
 *   ready	(size 1, offset 0, init 0):	RW	The host has loaded the dev_features register
 *   _anon1	(size 30, offset 1, init 0):	RSVD	_
 *   selector	(size 1, offset 31, init 0):	RW	Virtio Feature Selector
 */
typedef uint32_t virtio_mmio_dev_features_sel_t;
#define virtio_mmio_dev_features_sel_default 0x0
static inline uint8_t virtio_mmio_dev_features_sel_ready_extract(virtio_mmio_dev_features_sel_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_dev_features_sel_ready_extract(virtio_mmio_dev_features_sel_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline virtio_mmio_dev_features_sel_t virtio_mmio_dev_features_sel_ready_insert(virtio_mmio_dev_features_sel_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_dev_features_sel_t virtio_mmio_dev_features_sel_ready_insert(virtio_mmio_dev_features_sel_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((virtio_mmio_dev_features_sel_t )(_fieldval)) << 0)));
}

static inline uint8_t virtio_mmio_dev_features_sel_selector_extract(virtio_mmio_dev_features_sel_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_dev_features_sel_selector_extract(virtio_mmio_dev_features_sel_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline virtio_mmio_dev_features_sel_t virtio_mmio_dev_features_sel_selector_insert(virtio_mmio_dev_features_sel_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_dev_features_sel_t virtio_mmio_dev_features_sel_selector_insert(virtio_mmio_dev_features_sel_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((virtio_mmio_dev_features_sel_t )(_fieldval)) << 31)));
}

static inline int virtio_mmio_dev_features_sel_prtval(char *_s, size_t _size, virtio_mmio_dev_features_sel_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_dev_features_sel_prtval(char *_s, size_t _size, virtio_mmio_dev_features_sel_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ready =\t%" PRIx8 "\t(The host has loaded the dev_features register)\n", virtio_mmio_dev_features_sel_ready_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " selector =\t%" PRIx8 "\t(Virtio Feature Selector)\n", virtio_mmio_dev_features_sel_selector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_driv_features_t
 * Description: Implicit type of Flags representing device features understood and activated by the driver register
 * Fields:
 *   features	(size 32, offset 0, init 0):	RW	Virtio Features Bits
 */
typedef uint32_t virtio_mmio_driv_features_t;
#define virtio_mmio_driv_features_default 0x0
static inline uint32_t virtio_mmio_driv_features_features_extract(virtio_mmio_driv_features_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_driv_features_features_extract(virtio_mmio_driv_features_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_mmio_driv_features_t virtio_mmio_driv_features_features_insert(virtio_mmio_driv_features_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_driv_features_t virtio_mmio_driv_features_features_insert(virtio_mmio_driv_features_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_mmio_driv_features_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_driv_features_prtval(char *_s, size_t _size, virtio_mmio_driv_features_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_driv_features_prtval(char *_s, size_t _size, virtio_mmio_driv_features_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " features =\t%" PRIx32 "\t(Virtio Features Bits)\n", virtio_mmio_driv_features_features_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_driv_features_sel_t
 * Description: Implicit type of Activated (guest) features word selection register
 * Fields:
 *   selector	(size 1, offset 0, init 0):	RW	Virtio Feature Selector
 *   _anon1	(size 29, offset 1, init 0):	RSVD	_
 *   ready	(size 1, offset 30, init 0):	RW	signal the host that the values are ready
 *   ack	(size 1, offset 31, init 0):	RW	the host has stored the values
 */
typedef uint32_t virtio_mmio_driv_features_sel_t;
#define virtio_mmio_driv_features_sel_default 0x0
static inline uint8_t virtio_mmio_driv_features_sel_selector_extract(virtio_mmio_driv_features_sel_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_driv_features_sel_selector_extract(virtio_mmio_driv_features_sel_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline virtio_mmio_driv_features_sel_t virtio_mmio_driv_features_sel_selector_insert(virtio_mmio_driv_features_sel_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_driv_features_sel_t virtio_mmio_driv_features_sel_selector_insert(virtio_mmio_driv_features_sel_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((virtio_mmio_driv_features_sel_t )(_fieldval)) << 0)));
}

static inline uint8_t virtio_mmio_driv_features_sel_ready_extract(virtio_mmio_driv_features_sel_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_driv_features_sel_ready_extract(virtio_mmio_driv_features_sel_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline virtio_mmio_driv_features_sel_t virtio_mmio_driv_features_sel_ready_insert(virtio_mmio_driv_features_sel_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_driv_features_sel_t virtio_mmio_driv_features_sel_ready_insert(virtio_mmio_driv_features_sel_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((virtio_mmio_driv_features_sel_t )(_fieldval)) << 30)));
}

static inline uint8_t virtio_mmio_driv_features_sel_ack_extract(virtio_mmio_driv_features_sel_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_driv_features_sel_ack_extract(virtio_mmio_driv_features_sel_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline virtio_mmio_driv_features_sel_t virtio_mmio_driv_features_sel_ack_insert(virtio_mmio_driv_features_sel_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_driv_features_sel_t virtio_mmio_driv_features_sel_ack_insert(virtio_mmio_driv_features_sel_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((virtio_mmio_driv_features_sel_t )(_fieldval)) << 31)));
}

static inline int virtio_mmio_driv_features_sel_prtval(char *_s, size_t _size, virtio_mmio_driv_features_sel_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_driv_features_sel_prtval(char *_s, size_t _size, virtio_mmio_driv_features_sel_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " selector =\t%" PRIx8 "\t(Virtio Feature Selector)\n", virtio_mmio_driv_features_sel_selector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ready =\t%" PRIx8 "\t(signal the host that the values are ready)\n", virtio_mmio_driv_features_sel_ready_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack =\t%" PRIx8 "\t(the host has stored the values)\n", virtio_mmio_driv_features_sel_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_queue_sel_t
 * Description: Implicit type of Virtual queue index register
 * Fields:
 *   selector	(size 31, offset 0, init 0):	RW	Virtio Queue Selector
 *   ready	(size 1, offset 31, init 0):	RW	the host has loaded the registers witht the values
 */
typedef uint32_t virtio_mmio_queue_sel_t;
#define virtio_mmio_queue_sel_default 0x0
static inline uint32_t virtio_mmio_queue_sel_selector_extract(virtio_mmio_queue_sel_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_queue_sel_selector_extract(virtio_mmio_queue_sel_t _regval)
{
    return((uint32_t )((_regval & 0x7fffffff) >> 0));
}

static inline virtio_mmio_queue_sel_t virtio_mmio_queue_sel_selector_insert(virtio_mmio_queue_sel_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_queue_sel_t virtio_mmio_queue_sel_selector_insert(virtio_mmio_queue_sel_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x80000000) | (0x7fffffff & (((virtio_mmio_queue_sel_t )(_fieldval)) << 0)));
}

static inline uint8_t virtio_mmio_queue_sel_ready_extract(virtio_mmio_queue_sel_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_queue_sel_ready_extract(virtio_mmio_queue_sel_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline virtio_mmio_queue_sel_t virtio_mmio_queue_sel_ready_insert(virtio_mmio_queue_sel_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_queue_sel_t virtio_mmio_queue_sel_ready_insert(virtio_mmio_queue_sel_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((virtio_mmio_queue_sel_t )(_fieldval)) << 31)));
}

static inline int virtio_mmio_queue_sel_prtval(char *_s, size_t _size, virtio_mmio_queue_sel_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_sel_prtval(char *_s, size_t _size, virtio_mmio_queue_sel_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " selector =\t%" PRIx32 "\t(Virtio Queue Selector)\n", virtio_mmio_queue_sel_selector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ready =\t%" PRIx8 "\t(the host has loaded the registers witht the values)\n", virtio_mmio_queue_sel_ready_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_queue_max_t
 * Description: Implicit type of Maximum virtual queue size register
 * Fields:
 *   size	(size 16, offset 0, init 0):	RW	Number ready to process
 */
typedef uint16_t virtio_mmio_queue_max_t;
#define virtio_mmio_queue_max_default 0x0
static inline uint16_t virtio_mmio_queue_max_size_extract(virtio_mmio_queue_max_t _regval) __attribute__ ((always_inline));
static inline uint16_t virtio_mmio_queue_max_size_extract(virtio_mmio_queue_max_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline virtio_mmio_queue_max_t virtio_mmio_queue_max_size_insert(virtio_mmio_queue_max_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_queue_max_t virtio_mmio_queue_max_size_insert(virtio_mmio_queue_max_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x0) | (0xffff & (((virtio_mmio_queue_max_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_queue_max_prtval(char *_s, size_t _size, virtio_mmio_queue_max_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_max_prtval(char *_s, size_t _size, virtio_mmio_queue_max_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx16 "\t(Number ready to process)\n", virtio_mmio_queue_max_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_queue_num_t
 * Description: Implicit type of Virtual queue size register
 * Fields:
 *   size	(size 16, offset 0, init 0):	RW	Number of elements in queue
 */
typedef uint16_t virtio_mmio_queue_num_t;
#define virtio_mmio_queue_num_default 0x0
static inline uint16_t virtio_mmio_queue_num_size_extract(virtio_mmio_queue_num_t _regval) __attribute__ ((always_inline));
static inline uint16_t virtio_mmio_queue_num_size_extract(virtio_mmio_queue_num_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline virtio_mmio_queue_num_t virtio_mmio_queue_num_size_insert(virtio_mmio_queue_num_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_queue_num_t virtio_mmio_queue_num_size_insert(virtio_mmio_queue_num_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x0) | (0xffff & (((virtio_mmio_queue_num_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_queue_num_prtval(char *_s, size_t _size, virtio_mmio_queue_num_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_num_prtval(char *_s, size_t _size, virtio_mmio_queue_num_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx16 "\t(Number of elements in queue)\n", virtio_mmio_queue_num_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_queue_ready_t
 * Description: Implicit type of Virtual queue ready bit register
 * Fields:
 *   ready	(size 1, offset 0, init 0):	RW	Queue ready bit
 *   _anon1	(size 30, offset 1, init 0):	RSVD	_
 *   signal	(size 1, offset 31, init 0):	RW	signal the host that something has changed
 */
typedef uint32_t virtio_mmio_queue_ready_t;
#define virtio_mmio_queue_ready_default 0x0
static inline uint8_t virtio_mmio_queue_ready_ready_extract(virtio_mmio_queue_ready_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_queue_ready_ready_extract(virtio_mmio_queue_ready_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline virtio_mmio_queue_ready_t virtio_mmio_queue_ready_ready_insert(virtio_mmio_queue_ready_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_queue_ready_t virtio_mmio_queue_ready_ready_insert(virtio_mmio_queue_ready_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((virtio_mmio_queue_ready_t )(_fieldval)) << 0)));
}

static inline uint8_t virtio_mmio_queue_ready_signal_extract(virtio_mmio_queue_ready_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_queue_ready_signal_extract(virtio_mmio_queue_ready_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline virtio_mmio_queue_ready_t virtio_mmio_queue_ready_signal_insert(virtio_mmio_queue_ready_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_queue_ready_t virtio_mmio_queue_ready_signal_insert(virtio_mmio_queue_ready_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((virtio_mmio_queue_ready_t )(_fieldval)) << 31)));
}

static inline int virtio_mmio_queue_ready_prtval(char *_s, size_t _size, virtio_mmio_queue_ready_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_ready_prtval(char *_s, size_t _size, virtio_mmio_queue_ready_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ready =\t%" PRIx8 "\t(Queue ready bit)\n", virtio_mmio_queue_ready_ready_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " signal =\t%" PRIx8 "\t(signal the host that something has changed)\n", virtio_mmio_queue_ready_signal_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_queue_notify_t
 * Description: Implicit type of Queue notifier register
 * Fields:
 *   index	(size 32, offset 0, init 0):	RW	The queue index with new buffers
 */
typedef uint32_t virtio_mmio_queue_notify_t;
#define virtio_mmio_queue_notify_default 0x0
static inline uint32_t virtio_mmio_queue_notify_index_extract(virtio_mmio_queue_notify_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_queue_notify_index_extract(virtio_mmio_queue_notify_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_mmio_queue_notify_t virtio_mmio_queue_notify_index_insert(virtio_mmio_queue_notify_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_queue_notify_t virtio_mmio_queue_notify_index_insert(virtio_mmio_queue_notify_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_mmio_queue_notify_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_queue_notify_prtval(char *_s, size_t _size, virtio_mmio_queue_notify_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_notify_prtval(char *_s, size_t _size, virtio_mmio_queue_notify_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " index =\t%" PRIx32 "\t(The queue index with new buffers)\n", virtio_mmio_queue_notify_index_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_interrupt_status_t
 * Description: Implicit type of Interrupt status register
 * Fields:
 *   ring_update	(size 1, offset 0, init 0):	RW	The device has updated the used ring
 *   config_change	(size 1, offset 1, init 0):	RW	The configuration of the device has changed
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
typedef uint32_t virtio_mmio_interrupt_status_t;
#define virtio_mmio_interrupt_status_default 0x0
static inline uint8_t virtio_mmio_interrupt_status_ring_update_extract(virtio_mmio_interrupt_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_interrupt_status_ring_update_extract(virtio_mmio_interrupt_status_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline virtio_mmio_interrupt_status_t virtio_mmio_interrupt_status_ring_update_insert(virtio_mmio_interrupt_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_interrupt_status_t virtio_mmio_interrupt_status_ring_update_insert(virtio_mmio_interrupt_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((virtio_mmio_interrupt_status_t )(_fieldval)) << 0)));
}

static inline uint8_t virtio_mmio_interrupt_status_config_change_extract(virtio_mmio_interrupt_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_interrupt_status_config_change_extract(virtio_mmio_interrupt_status_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline virtio_mmio_interrupt_status_t virtio_mmio_interrupt_status_config_change_insert(virtio_mmio_interrupt_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_interrupt_status_t virtio_mmio_interrupt_status_config_change_insert(virtio_mmio_interrupt_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((virtio_mmio_interrupt_status_t )(_fieldval)) << 1)));
}

static inline int virtio_mmio_interrupt_status_prtval(char *_s, size_t _size, virtio_mmio_interrupt_status_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_interrupt_status_prtval(char *_s, size_t _size, virtio_mmio_interrupt_status_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ring_update =\t%" PRIx8 "\t(The device has updated the used ring)\n", virtio_mmio_interrupt_status_ring_update_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " config_change =\t%" PRIx8 "\t(The configuration of the device has changed)\n", virtio_mmio_interrupt_status_config_change_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_interrupt_ack_t
 * Description: Implicit type of Interrupt acknowledge register
 * Fields:
 *   ring_update	(size 1, offset 0, init 0):	RW	The device has updated the used ring
 *   config_change	(size 1, offset 1, init 0):	RW	The configuration of the device has changed
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
typedef uint32_t virtio_mmio_interrupt_ack_t;
#define virtio_mmio_interrupt_ack_default 0x0
static inline uint8_t virtio_mmio_interrupt_ack_ring_update_extract(virtio_mmio_interrupt_ack_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_interrupt_ack_ring_update_extract(virtio_mmio_interrupt_ack_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline virtio_mmio_interrupt_ack_t virtio_mmio_interrupt_ack_ring_update_insert(virtio_mmio_interrupt_ack_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_interrupt_ack_t virtio_mmio_interrupt_ack_ring_update_insert(virtio_mmio_interrupt_ack_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((virtio_mmio_interrupt_ack_t )(_fieldval)) << 0)));
}

static inline uint8_t virtio_mmio_interrupt_ack_config_change_extract(virtio_mmio_interrupt_ack_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_interrupt_ack_config_change_extract(virtio_mmio_interrupt_ack_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline virtio_mmio_interrupt_ack_t virtio_mmio_interrupt_ack_config_change_insert(virtio_mmio_interrupt_ack_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_interrupt_ack_t virtio_mmio_interrupt_ack_config_change_insert(virtio_mmio_interrupt_ack_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((virtio_mmio_interrupt_ack_t )(_fieldval)) << 1)));
}

static inline int virtio_mmio_interrupt_ack_prtval(char *_s, size_t _size, virtio_mmio_interrupt_ack_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_interrupt_ack_prtval(char *_s, size_t _size, virtio_mmio_interrupt_ack_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ring_update =\t%" PRIx8 "\t(The device has updated the used ring)\n", virtio_mmio_interrupt_ack_ring_update_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " config_change =\t%" PRIx8 "\t(The configuration of the device has changed)\n", virtio_mmio_interrupt_ack_config_change_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_status_t
 * Description: Implicit type of status register
 * Fields:
 *   acknowledge	(size 1, offset 0, init 0):	RW	Guest has found the device
 *   driver	(size 1, offset 1, init 0):	RW	Guest knows how to drive the device
 *   driver_ok	(size 1, offset 2, init 0):	RW	Driver setup and ready to drive the device
 *   features_ok	(size 1, offset 3, init 0):	RW	Driver has acknowledged all the features it understands
 *   _anon4	(size 3, offset 4, init 0):	RSVD	_
 *   failed	(size 1, offset 7, init 0):	RW	Something went wrong
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t virtio_mmio_status_t;
#define virtio_mmio_status_default 0x0
static inline uint8_t virtio_mmio_status_acknowledge_extract(virtio_mmio_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_status_acknowledge_extract(virtio_mmio_status_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline virtio_mmio_status_t virtio_mmio_status_acknowledge_insert(virtio_mmio_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_status_t virtio_mmio_status_acknowledge_insert(virtio_mmio_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((virtio_mmio_status_t )(_fieldval)) << 0)));
}

static inline uint8_t virtio_mmio_status_driver_extract(virtio_mmio_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_status_driver_extract(virtio_mmio_status_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline virtio_mmio_status_t virtio_mmio_status_driver_insert(virtio_mmio_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_status_t virtio_mmio_status_driver_insert(virtio_mmio_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((virtio_mmio_status_t )(_fieldval)) << 1)));
}

static inline uint8_t virtio_mmio_status_driver_ok_extract(virtio_mmio_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_status_driver_ok_extract(virtio_mmio_status_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline virtio_mmio_status_t virtio_mmio_status_driver_ok_insert(virtio_mmio_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_status_t virtio_mmio_status_driver_ok_insert(virtio_mmio_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((virtio_mmio_status_t )(_fieldval)) << 2)));
}

static inline uint8_t virtio_mmio_status_features_ok_extract(virtio_mmio_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_status_features_ok_extract(virtio_mmio_status_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline virtio_mmio_status_t virtio_mmio_status_features_ok_insert(virtio_mmio_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_status_t virtio_mmio_status_features_ok_insert(virtio_mmio_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((virtio_mmio_status_t )(_fieldval)) << 3)));
}

static inline uint8_t virtio_mmio_status_failed_extract(virtio_mmio_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_status_failed_extract(virtio_mmio_status_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline virtio_mmio_status_t virtio_mmio_status_failed_insert(virtio_mmio_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_status_t virtio_mmio_status_failed_insert(virtio_mmio_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((virtio_mmio_status_t )(_fieldval)) << 7)));
}

static inline int virtio_mmio_status_prtval(char *_s, size_t _size, virtio_mmio_status_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_status_prtval(char *_s, size_t _size, virtio_mmio_status_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " acknowledge =\t%" PRIx8 "\t(Guest has found the device)\n", virtio_mmio_status_acknowledge_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " driver =\t%" PRIx8 "\t(Guest knows how to drive the device)\n", virtio_mmio_status_driver_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " driver_ok =\t%" PRIx8 "\t(Driver setup and ready to drive the device)\n", virtio_mmio_status_driver_ok_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " features_ok =\t%" PRIx8 "\t(Driver has acknowledged all the features it understands)\n", virtio_mmio_status_features_ok_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " failed =\t%" PRIx8 "\t(Something went wrong)\n", virtio_mmio_status_failed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_reset_t
 * Description: Implicit type of reset register
 * Fields:
 *   reset	(size 8, offset 0, init 0):	RW	Reset the device
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t virtio_mmio_reset_t;
#define virtio_mmio_reset_default 0x0
static inline uint8_t virtio_mmio_reset_reset_extract(virtio_mmio_reset_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_reset_reset_extract(virtio_mmio_reset_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline virtio_mmio_reset_t virtio_mmio_reset_reset_insert(virtio_mmio_reset_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_reset_t virtio_mmio_reset_reset_insert(virtio_mmio_reset_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((virtio_mmio_reset_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_reset_prtval(char *_s, size_t _size, virtio_mmio_reset_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_reset_prtval(char *_s, size_t _size, virtio_mmio_reset_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reset =\t%" PRIx8 "\t(Reset the device)\n", virtio_mmio_reset_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_queue_desc_lo_t
 * Description: Implicit type of Virtual queue Descriptor Table 64 bit long physical address register
 * Fields:
 *   addr	(size 32, offset 0, init 0):	RW	Address of Queue Descriptor Table
 */
typedef uint32_t virtio_mmio_queue_desc_lo_t;
#define virtio_mmio_queue_desc_lo_default 0x0
static inline uint32_t virtio_mmio_queue_desc_lo_addr_extract(virtio_mmio_queue_desc_lo_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_queue_desc_lo_addr_extract(virtio_mmio_queue_desc_lo_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_mmio_queue_desc_lo_t virtio_mmio_queue_desc_lo_addr_insert(virtio_mmio_queue_desc_lo_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_queue_desc_lo_t virtio_mmio_queue_desc_lo_addr_insert(virtio_mmio_queue_desc_lo_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_mmio_queue_desc_lo_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_queue_desc_lo_prtval(char *_s, size_t _size, virtio_mmio_queue_desc_lo_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_desc_lo_prtval(char *_s, size_t _size, virtio_mmio_queue_desc_lo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address of Queue Descriptor Table)\n", virtio_mmio_queue_desc_lo_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_queue_desc_hi_t
 * Description: Implicit type of Virtual queue Descriptor Table 64 bit long physical address register
 * Fields:
 *   addr	(size 32, offset 0, init 0):	RW	Address of Queue Descriptor Table
 */
typedef uint32_t virtio_mmio_queue_desc_hi_t;
#define virtio_mmio_queue_desc_hi_default 0x0
static inline uint32_t virtio_mmio_queue_desc_hi_addr_extract(virtio_mmio_queue_desc_hi_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_queue_desc_hi_addr_extract(virtio_mmio_queue_desc_hi_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_mmio_queue_desc_hi_t virtio_mmio_queue_desc_hi_addr_insert(virtio_mmio_queue_desc_hi_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_queue_desc_hi_t virtio_mmio_queue_desc_hi_addr_insert(virtio_mmio_queue_desc_hi_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_mmio_queue_desc_hi_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_queue_desc_hi_prtval(char *_s, size_t _size, virtio_mmio_queue_desc_hi_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_desc_hi_prtval(char *_s, size_t _size, virtio_mmio_queue_desc_hi_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address of Queue Descriptor Table)\n", virtio_mmio_queue_desc_hi_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_queue_avail_lo_t
 * Description: Implicit type of Virtual queue Available Ring 64 bit long physical address register
 * Fields:
 *   addr	(size 32, offset 0, init 0):	RW	Address of available ring
 */
typedef uint32_t virtio_mmio_queue_avail_lo_t;
#define virtio_mmio_queue_avail_lo_default 0x0
static inline uint32_t virtio_mmio_queue_avail_lo_addr_extract(virtio_mmio_queue_avail_lo_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_queue_avail_lo_addr_extract(virtio_mmio_queue_avail_lo_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_mmio_queue_avail_lo_t virtio_mmio_queue_avail_lo_addr_insert(virtio_mmio_queue_avail_lo_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_queue_avail_lo_t virtio_mmio_queue_avail_lo_addr_insert(virtio_mmio_queue_avail_lo_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_mmio_queue_avail_lo_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_queue_avail_lo_prtval(char *_s, size_t _size, virtio_mmio_queue_avail_lo_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_avail_lo_prtval(char *_s, size_t _size, virtio_mmio_queue_avail_lo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address of available ring)\n", virtio_mmio_queue_avail_lo_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_queue_avail_hi_t
 * Description: Implicit type of Virtual queue Available Ring 64 bit long physical address register
 * Fields:
 *   addr	(size 32, offset 0, init 0):	RW	Address of available ring
 */
typedef uint32_t virtio_mmio_queue_avail_hi_t;
#define virtio_mmio_queue_avail_hi_default 0x0
static inline uint32_t virtio_mmio_queue_avail_hi_addr_extract(virtio_mmio_queue_avail_hi_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_queue_avail_hi_addr_extract(virtio_mmio_queue_avail_hi_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_mmio_queue_avail_hi_t virtio_mmio_queue_avail_hi_addr_insert(virtio_mmio_queue_avail_hi_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_queue_avail_hi_t virtio_mmio_queue_avail_hi_addr_insert(virtio_mmio_queue_avail_hi_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_mmio_queue_avail_hi_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_queue_avail_hi_prtval(char *_s, size_t _size, virtio_mmio_queue_avail_hi_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_avail_hi_prtval(char *_s, size_t _size, virtio_mmio_queue_avail_hi_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address of available ring)\n", virtio_mmio_queue_avail_hi_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_queue_used_lo_t
 * Description: Implicit type of Virtual queue Used Ring 64 bit long physical address register
 * Fields:
 *   addr	(size 32, offset 0, init 0):	RW	Address of used ring
 */
typedef uint32_t virtio_mmio_queue_used_lo_t;
#define virtio_mmio_queue_used_lo_default 0x0
static inline uint32_t virtio_mmio_queue_used_lo_addr_extract(virtio_mmio_queue_used_lo_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_queue_used_lo_addr_extract(virtio_mmio_queue_used_lo_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_mmio_queue_used_lo_t virtio_mmio_queue_used_lo_addr_insert(virtio_mmio_queue_used_lo_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_queue_used_lo_t virtio_mmio_queue_used_lo_addr_insert(virtio_mmio_queue_used_lo_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_mmio_queue_used_lo_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_queue_used_lo_prtval(char *_s, size_t _size, virtio_mmio_queue_used_lo_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_used_lo_prtval(char *_s, size_t _size, virtio_mmio_queue_used_lo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address of used ring)\n", virtio_mmio_queue_used_lo_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_queue_used_hi_t
 * Description: Implicit type of Virtual queue Used Ring 64 bit long physical address register
 * Fields:
 *   addr	(size 32, offset 0, init 0):	RW	Address of used ring
 */
typedef uint32_t virtio_mmio_queue_used_hi_t;
#define virtio_mmio_queue_used_hi_default 0x0
static inline uint32_t virtio_mmio_queue_used_hi_addr_extract(virtio_mmio_queue_used_hi_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_queue_used_hi_addr_extract(virtio_mmio_queue_used_hi_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_mmio_queue_used_hi_t virtio_mmio_queue_used_hi_addr_insert(virtio_mmio_queue_used_hi_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_queue_used_hi_t virtio_mmio_queue_used_hi_addr_insert(virtio_mmio_queue_used_hi_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_mmio_queue_used_hi_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_queue_used_hi_prtval(char *_s, size_t _size, virtio_mmio_queue_used_hi_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_used_hi_prtval(char *_s, size_t _size, virtio_mmio_queue_used_hi_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address of used ring)\n", virtio_mmio_queue_used_hi_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_mmio_config_gen_t
 * Description: Implicit type of Configuration atomicity value register
 * Fields:
 *   value	(size 32, offset 0, init 0):	RW	Value
 */
typedef uint32_t virtio_mmio_config_gen_t;
#define virtio_mmio_config_gen_default 0x0
static inline uint32_t virtio_mmio_config_gen_value_extract(virtio_mmio_config_gen_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_config_gen_value_extract(virtio_mmio_config_gen_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_mmio_config_gen_t virtio_mmio_config_gen_value_insert(virtio_mmio_config_gen_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_mmio_config_gen_t virtio_mmio_config_gen_value_insert(virtio_mmio_config_gen_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_mmio_config_gen_t )(_fieldval)) << 0)));
}

static inline int virtio_mmio_config_gen_prtval(char *_s, size_t _size, virtio_mmio_config_gen_t _regval) __attribute__ ((always_inline));
static inline int virtio_mmio_config_gen_prtval(char *_s, size_t _size, virtio_mmio_config_gen_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " value =\t%" PRIx32 "\t(Value)\n", virtio_mmio_config_gen_value_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum virtio_mmio_initials {
    virtio_mmio_magic_value_initial = 0x0,
    virtio_mmio_version_initial = 0x0,
    virtio_mmio_deviceid_initial = 0x0,
    virtio_mmio_vendorid_initial = 0x0,
    virtio_mmio_dev_features_initial = 0x0,
    virtio_mmio_dev_features_sel_initial = 0x0,
    virtio_mmio_driv_features_initial = 0x0,
    virtio_mmio_driv_features_sel_initial = 0x0,
    virtio_mmio_queue_sel_initial = 0x0,
    virtio_mmio_queue_max_initial = 0x0,
    virtio_mmio_queue_num_initial = 0x0,
    virtio_mmio_queue_ready_initial = 0x0,
    virtio_mmio_queue_notify_initial = 0x0,
    virtio_mmio_interrupt_status_initial = 0x0,
    virtio_mmio_interrupt_ack_initial = 0x0,
    virtio_mmio_status_initial = 0x0,
    virtio_mmio_reset_initial = 0x0,
    virtio_mmio_queue_desc_lo_initial = 0x0,
    virtio_mmio_queue_desc_hi_initial = 0x0,
    virtio_mmio_queue_avail_lo_initial = 0x0,
    virtio_mmio_queue_avail_hi_initial = 0x0,
    virtio_mmio_queue_used_lo_initial = 0x0,
    virtio_mmio_queue_used_hi_initial = 0x0,
    virtio_mmio_config_gen_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void virtio_mmio_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void virtio_mmio_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register magic_value: Magic value for identifying the Virtio device
 * Type: virtio_mmio.magic_value (Implicit type of Magic value for identifying the Virtio device register)
 *   val	(size 32, offset 0, init 0):	RW	Has to be 0x74726976
 */
static inline virtio_mmio_magic_value_t virtio_mmio_magic_value_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_magic_value_t virtio_mmio_magic_value_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline virtio_mmio_magic_value_t virtio_mmio_magic_value_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_magic_value_t virtio_mmio_magic_value_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void virtio_mmio_magic_value_rawwr(__DN(t) *_dev, virtio_mmio_magic_value_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_magic_value_rawwr(__DN(t) *_dev, virtio_mmio_magic_value_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline void virtio_mmio_magic_value_wr(__DN(t) *_dev, virtio_mmio_magic_value_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_magic_value_wr(__DN(t) *_dev, virtio_mmio_magic_value_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline int virtio_mmio_magic_value_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_magic_value_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_magic_value_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register magic_value (Magic value for identifying the Virtio device): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx32 "\t(Has to be 0x74726976)\n", virtio_mmio_magic_value_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_mmio_magic_value_val_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_magic_value_val_rdf(__DN(t) *_dev)
{
    virtio_mmio_magic_value_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(virtio_mmio_magic_value_val_extract(_regval));
}

static inline void virtio_mmio_magic_value_val_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_magic_value_val_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_mmio_magic_value_t _regval = 0xffffffff & (((virtio_mmio_magic_value_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register version: Device Version Number
 * Type: virtio_mmio.version (Implicit type of Device Version Number register)
 *   version	(size 8, offset 0, init 0):	RW	Virtio device interface version
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline virtio_mmio_version_t virtio_mmio_version_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_version_t virtio_mmio_version_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline virtio_mmio_version_t virtio_mmio_version_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_version_t virtio_mmio_version_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline void virtio_mmio_version_rawwr(__DN(t) *_dev, virtio_mmio_version_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_version_rawwr(__DN(t) *_dev, virtio_mmio_version_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline void virtio_mmio_version_wr(__DN(t) *_dev, virtio_mmio_version_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_version_wr(__DN(t) *_dev, virtio_mmio_version_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x4)));
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline int virtio_mmio_version_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_version_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_version_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register version (Device Version Number): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " version =\t%" PRIx8 "\t(Virtio device interface version)\n", virtio_mmio_version_version_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t virtio_mmio_version_version_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_version_version_rdf(__DN(t) *_dev)
{
    virtio_mmio_version_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(virtio_mmio_version_version_extract(_regval));
}

static inline void virtio_mmio_version_version_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_version_version_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_version_t _regval = 0xff & (((virtio_mmio_version_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

/*
 * Register deviceid: Virtio Subsystem Device ID
 * Type: virtio_mmio.deviceid (Implicit type of Virtio Subsystem Device ID register)
 *   id	(size 8, offset 0, init 0):	RW	Device ID
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline virtio_mmio_deviceid_t virtio_mmio_deviceid_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_deviceid_t virtio_mmio_deviceid_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline virtio_mmio_deviceid_t virtio_mmio_deviceid_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_deviceid_t virtio_mmio_deviceid_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void virtio_mmio_deviceid_rawwr(__DN(t) *_dev, virtio_mmio_deviceid_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_deviceid_rawwr(__DN(t) *_dev, virtio_mmio_deviceid_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline void virtio_mmio_deviceid_wr(__DN(t) *_dev, virtio_mmio_deviceid_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_deviceid_wr(__DN(t) *_dev, virtio_mmio_deviceid_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x8)));
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline int virtio_mmio_deviceid_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_deviceid_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_deviceid_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register deviceid (Virtio Subsystem Device ID): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " id =\t%" PRIx8 "\t(Device ID)\n", virtio_mmio_deviceid_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t virtio_mmio_deviceid_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_deviceid_id_rdf(__DN(t) *_dev)
{
    virtio_mmio_deviceid_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(virtio_mmio_deviceid_id_extract(_regval));
}

static inline void virtio_mmio_deviceid_id_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_deviceid_id_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_deviceid_t _regval = 0xff & (((virtio_mmio_deviceid_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

/*
 * Register vendorid: Virtio Subsystem Vendor ID
 * Type: virtio_mmio.vendorid (Implicit type of Virtio Subsystem Vendor ID register)
 *   id	(size 32, offset 0, init 0):	RW	Vendor ID
 */
static inline virtio_mmio_vendorid_t virtio_mmio_vendorid_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_vendorid_t virtio_mmio_vendorid_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline virtio_mmio_vendorid_t virtio_mmio_vendorid_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_vendorid_t virtio_mmio_vendorid_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline void virtio_mmio_vendorid_rawwr(__DN(t) *_dev, virtio_mmio_vendorid_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_vendorid_rawwr(__DN(t) *_dev, virtio_mmio_vendorid_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline void virtio_mmio_vendorid_wr(__DN(t) *_dev, virtio_mmio_vendorid_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_vendorid_wr(__DN(t) *_dev, virtio_mmio_vendorid_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline int virtio_mmio_vendorid_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_vendorid_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_vendorid_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vendorid (Virtio Subsystem Vendor ID): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " id =\t%" PRIx32 "\t(Vendor ID)\n", virtio_mmio_vendorid_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_mmio_vendorid_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_vendorid_id_rdf(__DN(t) *_dev)
{
    virtio_mmio_vendorid_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(virtio_mmio_vendorid_id_extract(_regval));
}

static inline void virtio_mmio_vendorid_id_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_vendorid_id_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_mmio_vendorid_t _regval = 0xffffffff & (((virtio_mmio_vendorid_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

/*
 * Register dev_features: Flags representing features the device supports
 * Type: virtio_mmio.dev_features (Implicit type of Flags representing features the device supports register)
 *   features	(size 32, offset 0, init 0):	RW	Virtio Features Bits
 */
static inline virtio_mmio_dev_features_t virtio_mmio_dev_features_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_dev_features_t virtio_mmio_dev_features_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline virtio_mmio_dev_features_t virtio_mmio_dev_features_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_dev_features_t virtio_mmio_dev_features_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void virtio_mmio_dev_features_rawwr(__DN(t) *_dev, virtio_mmio_dev_features_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_dev_features_rawwr(__DN(t) *_dev, virtio_mmio_dev_features_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline void virtio_mmio_dev_features_wr(__DN(t) *_dev, virtio_mmio_dev_features_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_dev_features_wr(__DN(t) *_dev, virtio_mmio_dev_features_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline int virtio_mmio_dev_features_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_dev_features_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_dev_features_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dev_features (Flags representing features the device supports): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " features =\t%" PRIx32 "\t(Virtio Features Bits)\n", virtio_mmio_dev_features_features_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_mmio_dev_features_features_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_dev_features_features_rdf(__DN(t) *_dev)
{
    virtio_mmio_dev_features_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(virtio_mmio_dev_features_features_extract(_regval));
}

static inline void virtio_mmio_dev_features_features_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_dev_features_features_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_mmio_dev_features_t _regval = 0xffffffff & (((virtio_mmio_dev_features_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register dev_features_sel: Device (host) features word selection.
 * Type: virtio_mmio.dev_features_sel (Implicit type of Device (host) features word selection. register)
 *   ready	(size 1, offset 0, init 0):	RW	The host has loaded the dev_features register
 *   _anon1	(size 30, offset 1, init 0):	RSVD	_
 *   selector	(size 1, offset 31, init 0):	RW	Virtio Feature Selector
 */
static inline virtio_mmio_dev_features_sel_t virtio_mmio_dev_features_sel_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_dev_features_sel_t virtio_mmio_dev_features_sel_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline virtio_mmio_dev_features_sel_t virtio_mmio_dev_features_sel_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_dev_features_sel_t virtio_mmio_dev_features_sel_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline void virtio_mmio_dev_features_sel_rawwr(__DN(t) *_dev, virtio_mmio_dev_features_sel_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_dev_features_sel_rawwr(__DN(t) *_dev, virtio_mmio_dev_features_sel_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline void virtio_mmio_dev_features_sel_wr(__DN(t) *_dev, virtio_mmio_dev_features_sel_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_dev_features_sel_wr(__DN(t) *_dev, virtio_mmio_dev_features_sel_t _regval)
{
    _regval = (_regval & 0x80000001);
    // No MB1 fields present
    _regval = (_regval | (0x7ffffffe & mackerel_read_addr_32(_dev->base, 0x14)));
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline int virtio_mmio_dev_features_sel_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_dev_features_sel_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_dev_features_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dev_features_sel (Device (host) features word selection.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ready =\t%" PRIx8 "\t(The host has loaded the dev_features register)\n", virtio_mmio_dev_features_sel_ready_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " selector =\t%" PRIx8 "\t(Virtio Feature Selector)\n", virtio_mmio_dev_features_sel_selector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t virtio_mmio_dev_features_sel_ready_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_dev_features_sel_ready_rdf(__DN(t) *_dev)
{
    virtio_mmio_dev_features_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(virtio_mmio_dev_features_sel_ready_extract(_regval));
}

static inline uint8_t virtio_mmio_dev_features_sel_selector_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_dev_features_sel_selector_rdf(__DN(t) *_dev)
{
    virtio_mmio_dev_features_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(virtio_mmio_dev_features_sel_selector_extract(_regval));
}

static inline void virtio_mmio_dev_features_sel_ready_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_dev_features_sel_ready_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_dev_features_sel_t _regval = 0x1 & (((virtio_mmio_dev_features_sel_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void virtio_mmio_dev_features_sel_selector_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_dev_features_sel_selector_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_dev_features_sel_t _regval = 0x80000000 & (((virtio_mmio_dev_features_sel_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

/*
 * Register driv_features: Flags representing device features understood and activated by the driver
 * Type: virtio_mmio.driv_features (Implicit type of Flags representing device features understood and activated by the driver register)
 *   features	(size 32, offset 0, init 0):	RW	Virtio Features Bits
 */
static inline virtio_mmio_driv_features_t virtio_mmio_driv_features_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_driv_features_t virtio_mmio_driv_features_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline virtio_mmio_driv_features_t virtio_mmio_driv_features_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_driv_features_t virtio_mmio_driv_features_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline void virtio_mmio_driv_features_rawwr(__DN(t) *_dev, virtio_mmio_driv_features_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_driv_features_rawwr(__DN(t) *_dev, virtio_mmio_driv_features_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline void virtio_mmio_driv_features_wr(__DN(t) *_dev, virtio_mmio_driv_features_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_driv_features_wr(__DN(t) *_dev, virtio_mmio_driv_features_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline int virtio_mmio_driv_features_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_driv_features_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_driv_features_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register driv_features (Flags representing device features understood and activated by the driver): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " features =\t%" PRIx32 "\t(Virtio Features Bits)\n", virtio_mmio_driv_features_features_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_mmio_driv_features_features_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_driv_features_features_rdf(__DN(t) *_dev)
{
    virtio_mmio_driv_features_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(virtio_mmio_driv_features_features_extract(_regval));
}

static inline void virtio_mmio_driv_features_features_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_driv_features_features_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_mmio_driv_features_t _regval = 0xffffffff & (((virtio_mmio_driv_features_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

/*
 * Register driv_features_sel: Activated (guest) features word selection
 * Type: virtio_mmio.driv_features_sel (Implicit type of Activated (guest) features word selection register)
 *   selector	(size 1, offset 0, init 0):	RW	Virtio Feature Selector
 *   _anon1	(size 29, offset 1, init 0):	RSVD	_
 *   ready	(size 1, offset 30, init 0):	RW	signal the host that the values are ready
 *   ack	(size 1, offset 31, init 0):	RW	the host has stored the values
 */
static inline virtio_mmio_driv_features_sel_t virtio_mmio_driv_features_sel_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_driv_features_sel_t virtio_mmio_driv_features_sel_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline virtio_mmio_driv_features_sel_t virtio_mmio_driv_features_sel_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_driv_features_sel_t virtio_mmio_driv_features_sel_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline void virtio_mmio_driv_features_sel_rawwr(__DN(t) *_dev, virtio_mmio_driv_features_sel_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_driv_features_sel_rawwr(__DN(t) *_dev, virtio_mmio_driv_features_sel_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline void virtio_mmio_driv_features_sel_wr(__DN(t) *_dev, virtio_mmio_driv_features_sel_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_driv_features_sel_wr(__DN(t) *_dev, virtio_mmio_driv_features_sel_t _regval)
{
    _regval = (_regval & 0xc0000001);
    // No MB1 fields present
    _regval = (_regval | (0x3ffffffe & mackerel_read_addr_32(_dev->base, 0x24)));
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline int virtio_mmio_driv_features_sel_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_driv_features_sel_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_driv_features_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register driv_features_sel (Activated (guest) features word selection): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " selector =\t%" PRIx8 "\t(Virtio Feature Selector)\n", virtio_mmio_driv_features_sel_selector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ready =\t%" PRIx8 "\t(signal the host that the values are ready)\n", virtio_mmio_driv_features_sel_ready_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack =\t%" PRIx8 "\t(the host has stored the values)\n", virtio_mmio_driv_features_sel_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t virtio_mmio_driv_features_sel_selector_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_driv_features_sel_selector_rdf(__DN(t) *_dev)
{
    virtio_mmio_driv_features_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(virtio_mmio_driv_features_sel_selector_extract(_regval));
}

static inline uint8_t virtio_mmio_driv_features_sel_ready_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_driv_features_sel_ready_rdf(__DN(t) *_dev)
{
    virtio_mmio_driv_features_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(virtio_mmio_driv_features_sel_ready_extract(_regval));
}

static inline uint8_t virtio_mmio_driv_features_sel_ack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_driv_features_sel_ack_rdf(__DN(t) *_dev)
{
    virtio_mmio_driv_features_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(virtio_mmio_driv_features_sel_ack_extract(_regval));
}

static inline void virtio_mmio_driv_features_sel_selector_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_driv_features_sel_selector_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_driv_features_sel_t _regval = 0x1 & (((virtio_mmio_driv_features_sel_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

static inline void virtio_mmio_driv_features_sel_ready_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_driv_features_sel_ready_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_driv_features_sel_t _regval = 0x40000000 & (((virtio_mmio_driv_features_sel_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

static inline void virtio_mmio_driv_features_sel_ack_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_driv_features_sel_ack_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_driv_features_sel_t _regval = 0x80000000 & (((virtio_mmio_driv_features_sel_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

/*
 * Register queue_sel: Virtual queue index
 * Type: virtio_mmio.queue_sel (Implicit type of Virtual queue index register)
 *   selector	(size 31, offset 0, init 0):	RW	Virtio Queue Selector
 *   ready	(size 1, offset 31, init 0):	RW	the host has loaded the registers witht the values
 */
static inline virtio_mmio_queue_sel_t virtio_mmio_queue_sel_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_sel_t virtio_mmio_queue_sel_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline virtio_mmio_queue_sel_t virtio_mmio_queue_sel_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_sel_t virtio_mmio_queue_sel_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline void virtio_mmio_queue_sel_rawwr(__DN(t) *_dev, virtio_mmio_queue_sel_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_sel_rawwr(__DN(t) *_dev, virtio_mmio_queue_sel_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline void virtio_mmio_queue_sel_wr(__DN(t) *_dev, virtio_mmio_queue_sel_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_sel_wr(__DN(t) *_dev, virtio_mmio_queue_sel_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline int virtio_mmio_queue_sel_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_sel_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_queue_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_sel (Virtual queue index): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " selector =\t%" PRIx32 "\t(Virtio Queue Selector)\n", virtio_mmio_queue_sel_selector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ready =\t%" PRIx8 "\t(the host has loaded the registers witht the values)\n", virtio_mmio_queue_sel_ready_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_mmio_queue_sel_selector_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_queue_sel_selector_rdf(__DN(t) *_dev)
{
    virtio_mmio_queue_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(virtio_mmio_queue_sel_selector_extract(_regval));
}

static inline uint8_t virtio_mmio_queue_sel_ready_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_queue_sel_ready_rdf(__DN(t) *_dev)
{
    virtio_mmio_queue_sel_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(virtio_mmio_queue_sel_ready_extract(_regval));
}

static inline void virtio_mmio_queue_sel_selector_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_sel_selector_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_mmio_queue_sel_t _regval = 0x7fffffff & (((virtio_mmio_queue_sel_t )(_fieldval)) << 0);
    _regval = (_regval | (0x80000000 & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

static inline void virtio_mmio_queue_sel_ready_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_sel_ready_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_queue_sel_t _regval = 0x80000000 & (((virtio_mmio_queue_sel_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
    // No shadow register to write to
}

/*
 * Register queue_max: Maximum virtual queue size
 * Type: virtio_mmio.queue_max (Implicit type of Maximum virtual queue size register)
 *   size	(size 16, offset 0, init 0):	RW	Number ready to process
 */
static inline virtio_mmio_queue_max_t virtio_mmio_queue_max_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_max_t virtio_mmio_queue_max_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->base, 0x34));
}

static inline virtio_mmio_queue_max_t virtio_mmio_queue_max_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_max_t virtio_mmio_queue_max_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->base, 0x34));
}

static inline void virtio_mmio_queue_max_rawwr(__DN(t) *_dev, virtio_mmio_queue_max_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_max_rawwr(__DN(t) *_dev, virtio_mmio_queue_max_t _regval)
{
    mackerel_write_addr_16(_dev->base, 0x34, _regval);
}

static inline void virtio_mmio_queue_max_wr(__DN(t) *_dev, virtio_mmio_queue_max_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_max_wr(__DN(t) *_dev, virtio_mmio_queue_max_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->base, 0x34, _regval);
}

static inline int virtio_mmio_queue_max_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_max_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_queue_max_t _regval = mackerel_read_addr_16(_dev->base, 0x34);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_max (Maximum virtual queue size): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx16 "\t(Number ready to process)\n", virtio_mmio_queue_max_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t virtio_mmio_queue_max_size_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t virtio_mmio_queue_max_size_rdf(__DN(t) *_dev)
{
    virtio_mmio_queue_max_t _regval = mackerel_read_addr_16(_dev->base, 0x34);
    return(virtio_mmio_queue_max_size_extract(_regval));
}

static inline void virtio_mmio_queue_max_size_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_max_size_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    virtio_mmio_queue_max_t _regval = 0xffff & (((virtio_mmio_queue_max_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

/*
 * Register queue_num: Virtual queue size
 * Type: virtio_mmio.queue_num (Implicit type of Virtual queue size register)
 *   size	(size 16, offset 0, init 0):	RW	Number of elements in queue
 */
static inline virtio_mmio_queue_num_t virtio_mmio_queue_num_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_num_t virtio_mmio_queue_num_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->base, 0x38));
}

static inline virtio_mmio_queue_num_t virtio_mmio_queue_num_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_num_t virtio_mmio_queue_num_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->base, 0x38));
}

static inline void virtio_mmio_queue_num_rawwr(__DN(t) *_dev, virtio_mmio_queue_num_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_num_rawwr(__DN(t) *_dev, virtio_mmio_queue_num_t _regval)
{
    mackerel_write_addr_16(_dev->base, 0x38, _regval);
}

static inline void virtio_mmio_queue_num_wr(__DN(t) *_dev, virtio_mmio_queue_num_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_num_wr(__DN(t) *_dev, virtio_mmio_queue_num_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->base, 0x38, _regval);
}

static inline int virtio_mmio_queue_num_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_num_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_queue_num_t _regval = mackerel_read_addr_16(_dev->base, 0x38);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_num (Virtual queue size): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx16 "\t(Number of elements in queue)\n", virtio_mmio_queue_num_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t virtio_mmio_queue_num_size_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t virtio_mmio_queue_num_size_rdf(__DN(t) *_dev)
{
    virtio_mmio_queue_num_t _regval = mackerel_read_addr_16(_dev->base, 0x38);
    return(virtio_mmio_queue_num_size_extract(_regval));
}

static inline void virtio_mmio_queue_num_size_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_num_size_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    virtio_mmio_queue_num_t _regval = 0xffff & (((virtio_mmio_queue_num_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->base, 0x38, _regval);
    // No shadow register to write to
}

/*
 * Register queue_ready: Virtual queue ready bit
 * Type: virtio_mmio.queue_ready (Implicit type of Virtual queue ready bit register)
 *   ready	(size 1, offset 0, init 0):	RW	Queue ready bit
 *   _anon1	(size 30, offset 1, init 0):	RSVD	_
 *   signal	(size 1, offset 31, init 0):	RW	signal the host that something has changed
 */
static inline virtio_mmio_queue_ready_t virtio_mmio_queue_ready_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_ready_t virtio_mmio_queue_ready_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline virtio_mmio_queue_ready_t virtio_mmio_queue_ready_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_ready_t virtio_mmio_queue_ready_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline void virtio_mmio_queue_ready_rawwr(__DN(t) *_dev, virtio_mmio_queue_ready_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_ready_rawwr(__DN(t) *_dev, virtio_mmio_queue_ready_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline void virtio_mmio_queue_ready_wr(__DN(t) *_dev, virtio_mmio_queue_ready_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_ready_wr(__DN(t) *_dev, virtio_mmio_queue_ready_t _regval)
{
    _regval = (_regval & 0x80000001);
    // No MB1 fields present
    _regval = (_regval | (0x7ffffffe & mackerel_read_addr_32(_dev->base, 0x44)));
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline int virtio_mmio_queue_ready_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_ready_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_queue_ready_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_ready (Virtual queue ready bit): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ready =\t%" PRIx8 "\t(Queue ready bit)\n", virtio_mmio_queue_ready_ready_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " signal =\t%" PRIx8 "\t(signal the host that something has changed)\n", virtio_mmio_queue_ready_signal_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t virtio_mmio_queue_ready_ready_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_queue_ready_ready_rdf(__DN(t) *_dev)
{
    virtio_mmio_queue_ready_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(virtio_mmio_queue_ready_ready_extract(_regval));
}

static inline uint8_t virtio_mmio_queue_ready_signal_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_queue_ready_signal_rdf(__DN(t) *_dev)
{
    virtio_mmio_queue_ready_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(virtio_mmio_queue_ready_signal_extract(_regval));
}

static inline void virtio_mmio_queue_ready_ready_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_ready_ready_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_queue_ready_t _regval = 0x1 & (((virtio_mmio_queue_ready_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

static inline void virtio_mmio_queue_ready_signal_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_ready_signal_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_queue_ready_t _regval = 0x80000000 & (((virtio_mmio_queue_ready_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

/*
 * Register queue_notify: Queue notifier
 * Type: virtio_mmio.queue_notify (Implicit type of Queue notifier register)
 *   index	(size 32, offset 0, init 0):	RW	The queue index with new buffers
 */
static inline virtio_mmio_queue_notify_t virtio_mmio_queue_notify_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_notify_t virtio_mmio_queue_notify_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50));
}

static inline virtio_mmio_queue_notify_t virtio_mmio_queue_notify_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_notify_t virtio_mmio_queue_notify_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50));
}

static inline void virtio_mmio_queue_notify_rawwr(__DN(t) *_dev, virtio_mmio_queue_notify_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_notify_rawwr(__DN(t) *_dev, virtio_mmio_queue_notify_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
}

static inline void virtio_mmio_queue_notify_wr(__DN(t) *_dev, virtio_mmio_queue_notify_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_notify_wr(__DN(t) *_dev, virtio_mmio_queue_notify_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
}

static inline int virtio_mmio_queue_notify_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_notify_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_queue_notify_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_notify (Queue notifier): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " index =\t%" PRIx32 "\t(The queue index with new buffers)\n", virtio_mmio_queue_notify_index_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_mmio_queue_notify_index_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_queue_notify_index_rdf(__DN(t) *_dev)
{
    virtio_mmio_queue_notify_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(virtio_mmio_queue_notify_index_extract(_regval));
}

static inline void virtio_mmio_queue_notify_index_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_notify_index_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_mmio_queue_notify_t _regval = 0xffffffff & (((virtio_mmio_queue_notify_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    // No shadow register to write to
}

/*
 * Register interrupt_status: Interrupt status
 * Type: virtio_mmio.interrupt_status (Implicit type of Interrupt status register)
 *   ring_update	(size 1, offset 0, init 0):	RW	The device has updated the used ring
 *   config_change	(size 1, offset 1, init 0):	RW	The configuration of the device has changed
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
static inline virtio_mmio_interrupt_status_t virtio_mmio_interrupt_status_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_interrupt_status_t virtio_mmio_interrupt_status_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x60));
}

static inline virtio_mmio_interrupt_status_t virtio_mmio_interrupt_status_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_interrupt_status_t virtio_mmio_interrupt_status_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x60));
}

static inline void virtio_mmio_interrupt_status_rawwr(__DN(t) *_dev, virtio_mmio_interrupt_status_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_interrupt_status_rawwr(__DN(t) *_dev, virtio_mmio_interrupt_status_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
}

static inline void virtio_mmio_interrupt_status_wr(__DN(t) *_dev, virtio_mmio_interrupt_status_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_interrupt_status_wr(__DN(t) *_dev, virtio_mmio_interrupt_status_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0x60)));
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
}

static inline int virtio_mmio_interrupt_status_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_interrupt_status_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_interrupt_status_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register interrupt_status (Interrupt status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ring_update =\t%" PRIx8 "\t(The device has updated the used ring)\n", virtio_mmio_interrupt_status_ring_update_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " config_change =\t%" PRIx8 "\t(The configuration of the device has changed)\n", virtio_mmio_interrupt_status_config_change_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline uint8_t virtio_mmio_interrupt_status_ring_update_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_interrupt_status_ring_update_rdf(__DN(t) *_dev)
{
    virtio_mmio_interrupt_status_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(virtio_mmio_interrupt_status_ring_update_extract(_regval));
}

static inline uint8_t virtio_mmio_interrupt_status_config_change_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_interrupt_status_config_change_rdf(__DN(t) *_dev)
{
    virtio_mmio_interrupt_status_t _regval = mackerel_read_addr_32(_dev->base, 0x60);
    return(virtio_mmio_interrupt_status_config_change_extract(_regval));
}

static inline void virtio_mmio_interrupt_status_ring_update_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_interrupt_status_ring_update_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_interrupt_status_t _regval = 0x1 & (((virtio_mmio_interrupt_status_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x60)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
    // No shadow register to write to
}

static inline void virtio_mmio_interrupt_status_config_change_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_interrupt_status_config_change_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_interrupt_status_t _regval = 0x2 & (((virtio_mmio_interrupt_status_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x60)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x60, _regval);
    // No shadow register to write to
}

/*
 * Register interrupt_ack: Interrupt acknowledge
 * Type: virtio_mmio.interrupt_ack (Implicit type of Interrupt acknowledge register)
 *   ring_update	(size 1, offset 0, init 0):	RW	The device has updated the used ring
 *   config_change	(size 1, offset 1, init 0):	RW	The configuration of the device has changed
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
static inline virtio_mmio_interrupt_ack_t virtio_mmio_interrupt_ack_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_interrupt_ack_t virtio_mmio_interrupt_ack_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x64));
}

static inline virtio_mmio_interrupt_ack_t virtio_mmio_interrupt_ack_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_interrupt_ack_t virtio_mmio_interrupt_ack_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x64));
}

static inline void virtio_mmio_interrupt_ack_rawwr(__DN(t) *_dev, virtio_mmio_interrupt_ack_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_interrupt_ack_rawwr(__DN(t) *_dev, virtio_mmio_interrupt_ack_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
}

static inline void virtio_mmio_interrupt_ack_wr(__DN(t) *_dev, virtio_mmio_interrupt_ack_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_interrupt_ack_wr(__DN(t) *_dev, virtio_mmio_interrupt_ack_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0x64)));
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
}

static inline int virtio_mmio_interrupt_ack_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_interrupt_ack_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_interrupt_ack_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register interrupt_ack (Interrupt acknowledge): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ring_update =\t%" PRIx8 "\t(The device has updated the used ring)\n", virtio_mmio_interrupt_ack_ring_update_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " config_change =\t%" PRIx8 "\t(The configuration of the device has changed)\n", virtio_mmio_interrupt_ack_config_change_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline uint8_t virtio_mmio_interrupt_ack_ring_update_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_interrupt_ack_ring_update_rdf(__DN(t) *_dev)
{
    virtio_mmio_interrupt_ack_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    return(virtio_mmio_interrupt_ack_ring_update_extract(_regval));
}

static inline uint8_t virtio_mmio_interrupt_ack_config_change_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_interrupt_ack_config_change_rdf(__DN(t) *_dev)
{
    virtio_mmio_interrupt_ack_t _regval = mackerel_read_addr_32(_dev->base, 0x64);
    return(virtio_mmio_interrupt_ack_config_change_extract(_regval));
}

static inline void virtio_mmio_interrupt_ack_ring_update_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_interrupt_ack_ring_update_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_interrupt_ack_t _regval = 0x1 & (((virtio_mmio_interrupt_ack_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x64)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
    // No shadow register to write to
}

static inline void virtio_mmio_interrupt_ack_config_change_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_interrupt_ack_config_change_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_interrupt_ack_t _regval = 0x2 & (((virtio_mmio_interrupt_ack_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x64)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x64, _regval);
    // No shadow register to write to
}

/*
 * Register status: status
 * Type: virtio_mmio.status (Implicit type of status register)
 *   acknowledge	(size 1, offset 0, init 0):	RW	Guest has found the device
 *   driver	(size 1, offset 1, init 0):	RW	Guest knows how to drive the device
 *   driver_ok	(size 1, offset 2, init 0):	RW	Driver setup and ready to drive the device
 *   features_ok	(size 1, offset 3, init 0):	RW	Driver has acknowledged all the features it understands
 *   _anon4	(size 3, offset 4, init 0):	RSVD	_
 *   failed	(size 1, offset 7, init 0):	RW	Something went wrong
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline virtio_mmio_status_t virtio_mmio_status_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_status_t virtio_mmio_status_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x70));
}

static inline virtio_mmio_status_t virtio_mmio_status_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_status_t virtio_mmio_status_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x70));
}

static inline void virtio_mmio_status_rawwr(__DN(t) *_dev, virtio_mmio_status_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_status_rawwr(__DN(t) *_dev, virtio_mmio_status_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
}

static inline void virtio_mmio_status_wr(__DN(t) *_dev, virtio_mmio_status_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_status_wr(__DN(t) *_dev, virtio_mmio_status_t _regval)
{
    _regval = (_regval & 0x8f);
    // No MB1 fields present
    _regval = (_regval | (0xffffff70 & mackerel_read_addr_32(_dev->base, 0x70)));
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
}

static inline int virtio_mmio_status_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_status_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_status_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register status (status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " acknowledge =\t%" PRIx8 "\t(Guest has found the device)\n", virtio_mmio_status_acknowledge_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " driver =\t%" PRIx8 "\t(Guest knows how to drive the device)\n", virtio_mmio_status_driver_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " driver_ok =\t%" PRIx8 "\t(Driver setup and ready to drive the device)\n", virtio_mmio_status_driver_ok_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " features_ok =\t%" PRIx8 "\t(Driver has acknowledged all the features it understands)\n", virtio_mmio_status_features_ok_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " failed =\t%" PRIx8 "\t(Something went wrong)\n", virtio_mmio_status_failed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t virtio_mmio_status_acknowledge_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_status_acknowledge_rdf(__DN(t) *_dev)
{
    virtio_mmio_status_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(virtio_mmio_status_acknowledge_extract(_regval));
}

static inline uint8_t virtio_mmio_status_driver_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_status_driver_rdf(__DN(t) *_dev)
{
    virtio_mmio_status_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(virtio_mmio_status_driver_extract(_regval));
}

static inline uint8_t virtio_mmio_status_driver_ok_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_status_driver_ok_rdf(__DN(t) *_dev)
{
    virtio_mmio_status_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(virtio_mmio_status_driver_ok_extract(_regval));
}

static inline uint8_t virtio_mmio_status_features_ok_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_status_features_ok_rdf(__DN(t) *_dev)
{
    virtio_mmio_status_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(virtio_mmio_status_features_ok_extract(_regval));
}

static inline uint8_t virtio_mmio_status_failed_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_status_failed_rdf(__DN(t) *_dev)
{
    virtio_mmio_status_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(virtio_mmio_status_failed_extract(_regval));
}

static inline void virtio_mmio_status_acknowledge_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_status_acknowledge_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_status_t _regval = 0x1 & (((virtio_mmio_status_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

static inline void virtio_mmio_status_driver_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_status_driver_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_status_t _regval = 0x2 & (((virtio_mmio_status_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

static inline void virtio_mmio_status_driver_ok_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_status_driver_ok_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_status_t _regval = 0x4 & (((virtio_mmio_status_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

static inline void virtio_mmio_status_features_ok_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_status_features_ok_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_status_t _regval = 0x8 & (((virtio_mmio_status_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

static inline void virtio_mmio_status_failed_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_status_failed_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_status_t _regval = 0x80 & (((virtio_mmio_status_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

/*
 * Register reset: reset
 * Type: virtio_mmio.reset (Implicit type of reset register)
 *   reset	(size 8, offset 0, init 0):	RW	Reset the device
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline virtio_mmio_reset_t virtio_mmio_reset_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_reset_t virtio_mmio_reset_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x70));
}

static inline virtio_mmio_reset_t virtio_mmio_reset_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_reset_t virtio_mmio_reset_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x70));
}

static inline void virtio_mmio_reset_rawwr(__DN(t) *_dev, virtio_mmio_reset_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_reset_rawwr(__DN(t) *_dev, virtio_mmio_reset_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
}

static inline void virtio_mmio_reset_wr(__DN(t) *_dev, virtio_mmio_reset_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_reset_wr(__DN(t) *_dev, virtio_mmio_reset_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x70)));
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
}

static inline int virtio_mmio_reset_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_reset_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_reset_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register reset (reset): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reset =\t%" PRIx8 "\t(Reset the device)\n", virtio_mmio_reset_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t virtio_mmio_reset_reset_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_mmio_reset_reset_rdf(__DN(t) *_dev)
{
    virtio_mmio_reset_t _regval = mackerel_read_addr_32(_dev->base, 0x70);
    return(virtio_mmio_reset_reset_extract(_regval));
}

static inline void virtio_mmio_reset_reset_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_reset_reset_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_mmio_reset_t _regval = 0xff & (((virtio_mmio_reset_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x70, _regval);
    // No shadow register to write to
}

/*
 * Register queue_desc_lo: Virtual queue Descriptor Table 64 bit long physical address
 * Type: virtio_mmio.queue_desc_lo (Implicit type of Virtual queue Descriptor Table 64 bit long physical address register)
 *   addr	(size 32, offset 0, init 0):	RW	Address of Queue Descriptor Table
 */
static inline virtio_mmio_queue_desc_lo_t virtio_mmio_queue_desc_lo_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_desc_lo_t virtio_mmio_queue_desc_lo_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x80));
}

static inline virtio_mmio_queue_desc_lo_t virtio_mmio_queue_desc_lo_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_desc_lo_t virtio_mmio_queue_desc_lo_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x80));
}

static inline void virtio_mmio_queue_desc_lo_rawwr(__DN(t) *_dev, virtio_mmio_queue_desc_lo_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_desc_lo_rawwr(__DN(t) *_dev, virtio_mmio_queue_desc_lo_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
}

static inline void virtio_mmio_queue_desc_lo_wr(__DN(t) *_dev, virtio_mmio_queue_desc_lo_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_desc_lo_wr(__DN(t) *_dev, virtio_mmio_queue_desc_lo_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
}

static inline int virtio_mmio_queue_desc_lo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_desc_lo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_queue_desc_lo_t _regval = mackerel_read_addr_32(_dev->base, 0x80);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_desc_lo (Virtual queue Descriptor Table 64 bit long physical address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address of Queue Descriptor Table)\n", virtio_mmio_queue_desc_lo_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_mmio_queue_desc_lo_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_queue_desc_lo_addr_rdf(__DN(t) *_dev)
{
    virtio_mmio_queue_desc_lo_t _regval = mackerel_read_addr_32(_dev->base, 0x80);
    return(virtio_mmio_queue_desc_lo_addr_extract(_regval));
}

static inline void virtio_mmio_queue_desc_lo_addr_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_desc_lo_addr_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_mmio_queue_desc_lo_t _regval = 0xffffffff & (((virtio_mmio_queue_desc_lo_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
    // No shadow register to write to
}

/*
 * Register queue_desc_hi: Virtual queue Descriptor Table 64 bit long physical address
 * Type: virtio_mmio.queue_desc_hi (Implicit type of Virtual queue Descriptor Table 64 bit long physical address register)
 *   addr	(size 32, offset 0, init 0):	RW	Address of Queue Descriptor Table
 */
static inline virtio_mmio_queue_desc_hi_t virtio_mmio_queue_desc_hi_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_desc_hi_t virtio_mmio_queue_desc_hi_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x84));
}

static inline virtio_mmio_queue_desc_hi_t virtio_mmio_queue_desc_hi_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_desc_hi_t virtio_mmio_queue_desc_hi_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x84));
}

static inline void virtio_mmio_queue_desc_hi_rawwr(__DN(t) *_dev, virtio_mmio_queue_desc_hi_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_desc_hi_rawwr(__DN(t) *_dev, virtio_mmio_queue_desc_hi_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x84, _regval);
}

static inline void virtio_mmio_queue_desc_hi_wr(__DN(t) *_dev, virtio_mmio_queue_desc_hi_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_desc_hi_wr(__DN(t) *_dev, virtio_mmio_queue_desc_hi_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x84, _regval);
}

static inline int virtio_mmio_queue_desc_hi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_desc_hi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_queue_desc_hi_t _regval = mackerel_read_addr_32(_dev->base, 0x84);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_desc_hi (Virtual queue Descriptor Table 64 bit long physical address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address of Queue Descriptor Table)\n", virtio_mmio_queue_desc_hi_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_mmio_queue_desc_hi_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_queue_desc_hi_addr_rdf(__DN(t) *_dev)
{
    virtio_mmio_queue_desc_hi_t _regval = mackerel_read_addr_32(_dev->base, 0x84);
    return(virtio_mmio_queue_desc_hi_addr_extract(_regval));
}

static inline void virtio_mmio_queue_desc_hi_addr_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_desc_hi_addr_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_mmio_queue_desc_hi_t _regval = 0xffffffff & (((virtio_mmio_queue_desc_hi_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x84, _regval);
    // No shadow register to write to
}

/*
 * Register queue_avail_lo: Virtual queue Available Ring 64 bit long physical address
 * Type: virtio_mmio.queue_avail_lo (Implicit type of Virtual queue Available Ring 64 bit long physical address register)
 *   addr	(size 32, offset 0, init 0):	RW	Address of available ring
 */
static inline virtio_mmio_queue_avail_lo_t virtio_mmio_queue_avail_lo_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_avail_lo_t virtio_mmio_queue_avail_lo_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x90));
}

static inline virtio_mmio_queue_avail_lo_t virtio_mmio_queue_avail_lo_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_avail_lo_t virtio_mmio_queue_avail_lo_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x90));
}

static inline void virtio_mmio_queue_avail_lo_rawwr(__DN(t) *_dev, virtio_mmio_queue_avail_lo_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_avail_lo_rawwr(__DN(t) *_dev, virtio_mmio_queue_avail_lo_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x90, _regval);
}

static inline void virtio_mmio_queue_avail_lo_wr(__DN(t) *_dev, virtio_mmio_queue_avail_lo_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_avail_lo_wr(__DN(t) *_dev, virtio_mmio_queue_avail_lo_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x90, _regval);
}

static inline int virtio_mmio_queue_avail_lo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_avail_lo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_queue_avail_lo_t _regval = mackerel_read_addr_32(_dev->base, 0x90);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_avail_lo (Virtual queue Available Ring 64 bit long physical address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address of available ring)\n", virtio_mmio_queue_avail_lo_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_mmio_queue_avail_lo_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_queue_avail_lo_addr_rdf(__DN(t) *_dev)
{
    virtio_mmio_queue_avail_lo_t _regval = mackerel_read_addr_32(_dev->base, 0x90);
    return(virtio_mmio_queue_avail_lo_addr_extract(_regval));
}

static inline void virtio_mmio_queue_avail_lo_addr_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_avail_lo_addr_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_mmio_queue_avail_lo_t _regval = 0xffffffff & (((virtio_mmio_queue_avail_lo_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x90, _regval);
    // No shadow register to write to
}

/*
 * Register queue_avail_hi: Virtual queue Available Ring 64 bit long physical address
 * Type: virtio_mmio.queue_avail_hi (Implicit type of Virtual queue Available Ring 64 bit long physical address register)
 *   addr	(size 32, offset 0, init 0):	RW	Address of available ring
 */
static inline virtio_mmio_queue_avail_hi_t virtio_mmio_queue_avail_hi_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_avail_hi_t virtio_mmio_queue_avail_hi_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x94));
}

static inline virtio_mmio_queue_avail_hi_t virtio_mmio_queue_avail_hi_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_avail_hi_t virtio_mmio_queue_avail_hi_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x94));
}

static inline void virtio_mmio_queue_avail_hi_rawwr(__DN(t) *_dev, virtio_mmio_queue_avail_hi_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_avail_hi_rawwr(__DN(t) *_dev, virtio_mmio_queue_avail_hi_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x94, _regval);
}

static inline void virtio_mmio_queue_avail_hi_wr(__DN(t) *_dev, virtio_mmio_queue_avail_hi_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_avail_hi_wr(__DN(t) *_dev, virtio_mmio_queue_avail_hi_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x94, _regval);
}

static inline int virtio_mmio_queue_avail_hi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_avail_hi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_queue_avail_hi_t _regval = mackerel_read_addr_32(_dev->base, 0x94);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_avail_hi (Virtual queue Available Ring 64 bit long physical address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address of available ring)\n", virtio_mmio_queue_avail_hi_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_mmio_queue_avail_hi_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_queue_avail_hi_addr_rdf(__DN(t) *_dev)
{
    virtio_mmio_queue_avail_hi_t _regval = mackerel_read_addr_32(_dev->base, 0x94);
    return(virtio_mmio_queue_avail_hi_addr_extract(_regval));
}

static inline void virtio_mmio_queue_avail_hi_addr_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_avail_hi_addr_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_mmio_queue_avail_hi_t _regval = 0xffffffff & (((virtio_mmio_queue_avail_hi_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x94, _regval);
    // No shadow register to write to
}

/*
 * Register queue_used_lo: Virtual queue Used Ring 64 bit long physical address
 * Type: virtio_mmio.queue_used_lo (Implicit type of Virtual queue Used Ring 64 bit long physical address register)
 *   addr	(size 32, offset 0, init 0):	RW	Address of used ring
 */
static inline virtio_mmio_queue_used_lo_t virtio_mmio_queue_used_lo_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_used_lo_t virtio_mmio_queue_used_lo_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa0));
}

static inline virtio_mmio_queue_used_lo_t virtio_mmio_queue_used_lo_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_used_lo_t virtio_mmio_queue_used_lo_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa0));
}

static inline void virtio_mmio_queue_used_lo_rawwr(__DN(t) *_dev, virtio_mmio_queue_used_lo_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_used_lo_rawwr(__DN(t) *_dev, virtio_mmio_queue_used_lo_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
}

static inline void virtio_mmio_queue_used_lo_wr(__DN(t) *_dev, virtio_mmio_queue_used_lo_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_used_lo_wr(__DN(t) *_dev, virtio_mmio_queue_used_lo_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
}

static inline int virtio_mmio_queue_used_lo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_used_lo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_queue_used_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_used_lo (Virtual queue Used Ring 64 bit long physical address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address of used ring)\n", virtio_mmio_queue_used_lo_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_mmio_queue_used_lo_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_queue_used_lo_addr_rdf(__DN(t) *_dev)
{
    virtio_mmio_queue_used_lo_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    return(virtio_mmio_queue_used_lo_addr_extract(_regval));
}

static inline void virtio_mmio_queue_used_lo_addr_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_used_lo_addr_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_mmio_queue_used_lo_t _regval = 0xffffffff & (((virtio_mmio_queue_used_lo_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
    // No shadow register to write to
}

/*
 * Register queue_used_hi: Virtual queue Used Ring 64 bit long physical address
 * Type: virtio_mmio.queue_used_hi (Implicit type of Virtual queue Used Ring 64 bit long physical address register)
 *   addr	(size 32, offset 0, init 0):	RW	Address of used ring
 */
static inline virtio_mmio_queue_used_hi_t virtio_mmio_queue_used_hi_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_used_hi_t virtio_mmio_queue_used_hi_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa4));
}

static inline virtio_mmio_queue_used_hi_t virtio_mmio_queue_used_hi_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_queue_used_hi_t virtio_mmio_queue_used_hi_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa4));
}

static inline void virtio_mmio_queue_used_hi_rawwr(__DN(t) *_dev, virtio_mmio_queue_used_hi_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_used_hi_rawwr(__DN(t) *_dev, virtio_mmio_queue_used_hi_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa4, _regval);
}

static inline void virtio_mmio_queue_used_hi_wr(__DN(t) *_dev, virtio_mmio_queue_used_hi_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_used_hi_wr(__DN(t) *_dev, virtio_mmio_queue_used_hi_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa4, _regval);
}

static inline int virtio_mmio_queue_used_hi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_queue_used_hi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_queue_used_hi_t _regval = mackerel_read_addr_32(_dev->base, 0xa4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_used_hi (Virtual queue Used Ring 64 bit long physical address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address of used ring)\n", virtio_mmio_queue_used_hi_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_mmio_queue_used_hi_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_queue_used_hi_addr_rdf(__DN(t) *_dev)
{
    virtio_mmio_queue_used_hi_t _regval = mackerel_read_addr_32(_dev->base, 0xa4);
    return(virtio_mmio_queue_used_hi_addr_extract(_regval));
}

static inline void virtio_mmio_queue_used_hi_addr_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_queue_used_hi_addr_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_mmio_queue_used_hi_t _regval = 0xffffffff & (((virtio_mmio_queue_used_hi_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa4, _regval);
    // No shadow register to write to
}

/*
 * Register config_gen: Configuration atomicity value
 * Type: virtio_mmio.config_gen (Implicit type of Configuration atomicity value register)
 *   value	(size 32, offset 0, init 0):	RW	Value
 */
static inline virtio_mmio_config_gen_t virtio_mmio_config_gen_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_config_gen_t virtio_mmio_config_gen_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xfc));
}

static inline virtio_mmio_config_gen_t virtio_mmio_config_gen_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_mmio_config_gen_t virtio_mmio_config_gen_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xfc));
}

static inline void virtio_mmio_config_gen_rawwr(__DN(t) *_dev, virtio_mmio_config_gen_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_config_gen_rawwr(__DN(t) *_dev, virtio_mmio_config_gen_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xfc, _regval);
}

static inline void virtio_mmio_config_gen_wr(__DN(t) *_dev, virtio_mmio_config_gen_t _regval) __attribute__ ((always_inline));
static inline void virtio_mmio_config_gen_wr(__DN(t) *_dev, virtio_mmio_config_gen_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xfc, _regval);
}

static inline int virtio_mmio_config_gen_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_config_gen_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_mmio_config_gen_t _regval = mackerel_read_addr_32(_dev->base, 0xfc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register config_gen (Configuration atomicity value): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " value =\t%" PRIx32 "\t(Value)\n", virtio_mmio_config_gen_value_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_mmio_config_gen_value_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_mmio_config_gen_value_rdf(__DN(t) *_dev)
{
    virtio_mmio_config_gen_t _regval = mackerel_read_addr_32(_dev->base, 0xfc);
    return(virtio_mmio_config_gen_value_extract(_regval));
}

static inline void virtio_mmio_config_gen_value_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_mmio_config_gen_value_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_mmio_config_gen_t _regval = 0xffffffff & (((virtio_mmio_config_gen_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xfc, _regval);
    // No shadow register to write to
}

static inline int virtio_mmio_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_mmio_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device virtio_mmio (Virtio MMIO Transport Specification):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_magic_value_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_version_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_deviceid_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_vendorid_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_dev_features_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_dev_features_sel_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_driv_features_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_driv_features_sel_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_queue_sel_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_queue_max_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_queue_num_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_queue_ready_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_queue_notify_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_interrupt_status_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_interrupt_ack_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_status_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_reset_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_queue_desc_lo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_queue_desc_hi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_queue_avail_lo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_queue_avail_hi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_queue_used_lo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_queue_used_hi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_mmio_config_gen_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device virtio_mmio\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __virtio_mmio_DEV_H
