#ifndef __virtio_pci_DEV_H
#define __virtio_pci_DEV_H 1
/*
 * DEVICE DEFINITION: Virtio PCI Device Specification
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) virtio_pci ## _ ## x
/*
 * Constants defn: virtio_pci.vendor_id (VirtIO PCI vendor)
 *  - width 4 bits
 */
typedef uint8_t virtio_pci_vendor_id_t;
#define virtio_pci_virtio_vendor ((virtio_pci_vendor_id_t)0x1af4)

static inline char *virtio_pci_vendor_id_describe(virtio_pci_vendor_id_t _e) __attribute__ ((always_inline));
static inline char *virtio_pci_vendor_id_describe(virtio_pci_vendor_id_t _e)
{
    switch (_e) {
    case virtio_pci_virtio_vendor:
        return("virtio_vendor: virtio_vendor");
    default:
        return(NULL);
    }
}

static inline int virtio_pci_vendor_id_prtval(char *_s, size_t _size, virtio_pci_vendor_id_t _e) __attribute__ ((always_inline));
static inline int virtio_pci_vendor_id_prtval(char *_s, size_t _size, virtio_pci_vendor_id_t _e)
{
    char *d = virtio_pci_vendor_id_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "virtio_pci_vendor_id_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: virtio_pci.config_type (Configuration types)
 *  - width 8 bits
 */
typedef uint8_t virtio_pci_config_type_t;
#define virtio_pci_common ((virtio_pci_config_type_t)0x1)
#define virtio_pci_notify ((virtio_pci_config_type_t)0x2)
#define virtio_pci_isr ((virtio_pci_config_type_t)0x3)
#define virtio_pci_devspec ((virtio_pci_config_type_t)0x4)
#define virtio_pci_pci_cfg ((virtio_pci_config_type_t)0x5)

static inline char *virtio_pci_config_type_describe(virtio_pci_config_type_t _e) __attribute__ ((always_inline));
static inline char *virtio_pci_config_type_describe(virtio_pci_config_type_t _e)
{
    switch (_e) {
    case virtio_pci_common:
        return("common: Common configuration");
    case virtio_pci_notify:
        return("notify: Notifications");
    case virtio_pci_isr:
        return("isr: ISR Status");
    case virtio_pci_devspec:
        return("devspec: Device specific configuration");
    case virtio_pci_pci_cfg:
        return("pci_cfg: PCI configuration access");
    default:
        return(NULL);
    }
}

static inline int virtio_pci_config_type_prtval(char *_s, size_t _size, virtio_pci_config_type_t _e) __attribute__ ((always_inline));
static inline int virtio_pci_config_type_prtval(char *_s, size_t _size, virtio_pci_config_type_t _e)
{
    char *d = virtio_pci_config_type_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "virtio_pci_config_type_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: virtio_pci_vendor_t
 * Description: Implicit type of Identifies a vendor-specific capability. register
 * Fields:
 *   vndr	(size 8, offset 0, init 0):	RW	Vendor ID
 */
typedef uint8_t virtio_pci_vendor_t;
#define virtio_pci_vendor_default 0x0
static inline uint8_t virtio_pci_vendor_vndr_extract(virtio_pci_vendor_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_pci_vendor_vndr_extract(virtio_pci_vendor_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline virtio_pci_vendor_t virtio_pci_vendor_vndr_insert(virtio_pci_vendor_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_vendor_t virtio_pci_vendor_vndr_insert(virtio_pci_vendor_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x0) | (0xff & (((virtio_pci_vendor_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_vendor_prtval(char *_s, size_t _size, virtio_pci_vendor_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_vendor_prtval(char *_s, size_t _size, virtio_pci_vendor_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vndr =\t%" PRIx8 "\t(Vendor ID)\n", virtio_pci_vendor_vndr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_next_t
 * Description: Implicit type of Next Pointer register
 * Fields:
 *   next	(size 8, offset 0, init 0):	RW	Link to next capability in the capability list.
 */
typedef uint8_t virtio_pci_next_t;
#define virtio_pci_next_default 0x0
static inline uint8_t virtio_pci_next_next_extract(virtio_pci_next_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_pci_next_next_extract(virtio_pci_next_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline virtio_pci_next_t virtio_pci_next_next_insert(virtio_pci_next_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_next_t virtio_pci_next_next_insert(virtio_pci_next_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x0) | (0xff & (((virtio_pci_next_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_next_prtval(char *_s, size_t _size, virtio_pci_next_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_next_prtval(char *_s, size_t _size, virtio_pci_next_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " next =\t%" PRIx8 "\t(Link to next capability in the capability list.)\n", virtio_pci_next_next_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_length_t
 * Description: Implicit type of Length of this capability structure register
 * Fields:
 *   len	(size 8, offset 0, init 0):	RW	Length
 */
typedef uint8_t virtio_pci_length_t;
#define virtio_pci_length_default 0x0
static inline uint8_t virtio_pci_length_len_extract(virtio_pci_length_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_pci_length_len_extract(virtio_pci_length_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline virtio_pci_length_t virtio_pci_length_len_insert(virtio_pci_length_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_length_t virtio_pci_length_len_insert(virtio_pci_length_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x0) | (0xff & (((virtio_pci_length_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_length_prtval(char *_s, size_t _size, virtio_pci_length_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_length_prtval(char *_s, size_t _size, virtio_pci_length_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " len =\t%" PRIx8 "\t(Length)\n", virtio_pci_length_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_config_t
 * Description: Implicit type of identifies the structure register
 * Fields:
 *   cfg_type	(size 8, offset 0, init 0):	RW	configuration type
 */
typedef uint8_t virtio_pci_config_t;
#define virtio_pci_config_default 0x0
static inline uint8_t virtio_pci_config_cfg_type_extract(virtio_pci_config_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_pci_config_cfg_type_extract(virtio_pci_config_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline virtio_pci_config_t virtio_pci_config_cfg_type_insert(virtio_pci_config_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_config_t virtio_pci_config_cfg_type_insert(virtio_pci_config_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x0) | (0xff & (((virtio_pci_config_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_config_prtval(char *_s, size_t _size, virtio_pci_config_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_config_prtval(char *_s, size_t _size, virtio_pci_config_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfg_type =\t%" PRIx8 "\t(configuration type)\n", virtio_pci_config_cfg_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_bar_t
 * Description: Implicit type of Base Address register (BAR) belonging to the function located beginning register
 * Fields:
 *   bar	(size 8, offset 0, init 0):	RW	Base Address register (BAR)
 */
typedef uint8_t virtio_pci_bar_t;
#define virtio_pci_bar_default 0x0
static inline uint8_t virtio_pci_bar_bar_extract(virtio_pci_bar_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_pci_bar_bar_extract(virtio_pci_bar_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline virtio_pci_bar_t virtio_pci_bar_bar_insert(virtio_pci_bar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_bar_t virtio_pci_bar_bar_insert(virtio_pci_bar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x0) | (0xff & (((virtio_pci_bar_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_bar_prtval(char *_s, size_t _size, virtio_pci_bar_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_bar_prtval(char *_s, size_t _size, virtio_pci_bar_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bar =\t%" PRIx8 "\t(Base Address register (BAR))\n", virtio_pci_bar_bar_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_offset_t
 * Description: Implicit type of beginning of the structure relative to the base address register
 * Fields:
 *   off	(size 32, offset 0, init 0):	RW	Offset
 */
typedef uint32_t virtio_pci_offset_t;
#define virtio_pci_offset_default 0x0
static inline uint32_t virtio_pci_offset_off_extract(virtio_pci_offset_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_pci_offset_off_extract(virtio_pci_offset_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_pci_offset_t virtio_pci_offset_off_insert(virtio_pci_offset_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_offset_t virtio_pci_offset_off_insert(virtio_pci_offset_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_pci_offset_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_offset_prtval(char *_s, size_t _size, virtio_pci_offset_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_offset_prtval(char *_s, size_t _size, virtio_pci_offset_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " off =\t%" PRIx32 "\t(Offset)\n", virtio_pci_offset_off_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_length2_t
 * Description: Implicit type of indicates the length of the structure. register
 * Fields:
 *   len	(size 32, offset 0, init 0):	RW	Length
 */
typedef uint32_t virtio_pci_length2_t;
#define virtio_pci_length2_default 0x0
static inline uint32_t virtio_pci_length2_len_extract(virtio_pci_length2_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_pci_length2_len_extract(virtio_pci_length2_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_pci_length2_t virtio_pci_length2_len_insert(virtio_pci_length2_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_length2_t virtio_pci_length2_len_insert(virtio_pci_length2_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_pci_length2_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_length2_prtval(char *_s, size_t _size, virtio_pci_length2_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_length2_prtval(char *_s, size_t _size, virtio_pci_length2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " len =\t%" PRIx32 "\t(Length)\n", virtio_pci_length2_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_device_feature_select_t
 * Description: Implicit type of  register
 * Fields:
 *   reg	(size 32, offset 0, init 0):	RW	todo
 */
typedef uint32_t virtio_pci_device_feature_select_t;
#define virtio_pci_device_feature_select_default 0x0
static inline uint32_t virtio_pci_device_feature_select_reg_extract(virtio_pci_device_feature_select_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_pci_device_feature_select_reg_extract(virtio_pci_device_feature_select_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_pci_device_feature_select_t virtio_pci_device_feature_select_reg_insert(virtio_pci_device_feature_select_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_device_feature_select_t virtio_pci_device_feature_select_reg_insert(virtio_pci_device_feature_select_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_pci_device_feature_select_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_device_feature_select_prtval(char *_s, size_t _size, virtio_pci_device_feature_select_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_device_feature_select_prtval(char *_s, size_t _size, virtio_pci_device_feature_select_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(todo)\n", virtio_pci_device_feature_select_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_device_feature_t
 * Description: Implicit type of  register
 * Fields:
 *   reg	(size 32, offset 0, init 0):	RW	todo
 */
typedef uint32_t virtio_pci_device_feature_t;
#define virtio_pci_device_feature_default 0x0
static inline uint32_t virtio_pci_device_feature_reg_extract(virtio_pci_device_feature_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_pci_device_feature_reg_extract(virtio_pci_device_feature_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_pci_device_feature_t virtio_pci_device_feature_reg_insert(virtio_pci_device_feature_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_device_feature_t virtio_pci_device_feature_reg_insert(virtio_pci_device_feature_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_pci_device_feature_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_device_feature_prtval(char *_s, size_t _size, virtio_pci_device_feature_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_device_feature_prtval(char *_s, size_t _size, virtio_pci_device_feature_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(todo)\n", virtio_pci_device_feature_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_driver_feature_select_t
 * Description: Implicit type of  register
 * Fields:
 *   reg	(size 32, offset 0, init 0):	RW	todo
 */
typedef uint32_t virtio_pci_driver_feature_select_t;
#define virtio_pci_driver_feature_select_default 0x0
static inline uint32_t virtio_pci_driver_feature_select_reg_extract(virtio_pci_driver_feature_select_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_pci_driver_feature_select_reg_extract(virtio_pci_driver_feature_select_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_pci_driver_feature_select_t virtio_pci_driver_feature_select_reg_insert(virtio_pci_driver_feature_select_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_driver_feature_select_t virtio_pci_driver_feature_select_reg_insert(virtio_pci_driver_feature_select_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_pci_driver_feature_select_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_driver_feature_select_prtval(char *_s, size_t _size, virtio_pci_driver_feature_select_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_driver_feature_select_prtval(char *_s, size_t _size, virtio_pci_driver_feature_select_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(todo)\n", virtio_pci_driver_feature_select_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_driver_t
 * Description: Implicit type of  register
 * Fields:
 *   reg	(size 32, offset 0, init 0):	RW	todo
 */
typedef uint32_t virtio_pci_driver_t;
#define virtio_pci_driver_default 0x0
static inline uint32_t virtio_pci_driver_reg_extract(virtio_pci_driver_t _regval) __attribute__ ((always_inline));
static inline uint32_t virtio_pci_driver_reg_extract(virtio_pci_driver_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline virtio_pci_driver_t virtio_pci_driver_reg_insert(virtio_pci_driver_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_driver_t virtio_pci_driver_reg_insert(virtio_pci_driver_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((virtio_pci_driver_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_driver_prtval(char *_s, size_t _size, virtio_pci_driver_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_driver_prtval(char *_s, size_t _size, virtio_pci_driver_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(todo)\n", virtio_pci_driver_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_msix_config_t
 * Description: Implicit type of msix_config register
 * Fields:
 *   reg	(size 16, offset 0, init 0):	RW	todo
 */
typedef uint16_t virtio_pci_msix_config_t;
#define virtio_pci_msix_config_default 0x0
static inline uint16_t virtio_pci_msix_config_reg_extract(virtio_pci_msix_config_t _regval) __attribute__ ((always_inline));
static inline uint16_t virtio_pci_msix_config_reg_extract(virtio_pci_msix_config_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline virtio_pci_msix_config_t virtio_pci_msix_config_reg_insert(virtio_pci_msix_config_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_msix_config_t virtio_pci_msix_config_reg_insert(virtio_pci_msix_config_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x0) | (0xffff & (((virtio_pci_msix_config_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_msix_config_prtval(char *_s, size_t _size, virtio_pci_msix_config_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_msix_config_prtval(char *_s, size_t _size, virtio_pci_msix_config_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx16 "\t(todo)\n", virtio_pci_msix_config_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_num_queues_t
 * Description: Implicit type of num_queues register
 * Fields:
 *   reg	(size 16, offset 0, init 0):	RW	todo
 */
typedef uint16_t virtio_pci_num_queues_t;
#define virtio_pci_num_queues_default 0x0
static inline uint16_t virtio_pci_num_queues_reg_extract(virtio_pci_num_queues_t _regval) __attribute__ ((always_inline));
static inline uint16_t virtio_pci_num_queues_reg_extract(virtio_pci_num_queues_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline virtio_pci_num_queues_t virtio_pci_num_queues_reg_insert(virtio_pci_num_queues_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_num_queues_t virtio_pci_num_queues_reg_insert(virtio_pci_num_queues_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x0) | (0xffff & (((virtio_pci_num_queues_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_num_queues_prtval(char *_s, size_t _size, virtio_pci_num_queues_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_num_queues_prtval(char *_s, size_t _size, virtio_pci_num_queues_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx16 "\t(todo)\n", virtio_pci_num_queues_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_device_status_t
 * Description: Implicit type of device_status register
 * Fields:
 *   reg	(size 8, offset 0, init 0):	RW	todo
 */
typedef uint8_t virtio_pci_device_status_t;
#define virtio_pci_device_status_default 0x0
static inline uint8_t virtio_pci_device_status_reg_extract(virtio_pci_device_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_pci_device_status_reg_extract(virtio_pci_device_status_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline virtio_pci_device_status_t virtio_pci_device_status_reg_insert(virtio_pci_device_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_device_status_t virtio_pci_device_status_reg_insert(virtio_pci_device_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x0) | (0xff & (((virtio_pci_device_status_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_device_status_prtval(char *_s, size_t _size, virtio_pci_device_status_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_device_status_prtval(char *_s, size_t _size, virtio_pci_device_status_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx8 "\t(todo)\n", virtio_pci_device_status_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_config_generation_t
 * Description: Implicit type of config_generation register
 * Fields:
 *   reg	(size 8, offset 0, init 0):	RW	todo
 */
typedef uint8_t virtio_pci_config_generation_t;
#define virtio_pci_config_generation_default 0x0
static inline uint8_t virtio_pci_config_generation_reg_extract(virtio_pci_config_generation_t _regval) __attribute__ ((always_inline));
static inline uint8_t virtio_pci_config_generation_reg_extract(virtio_pci_config_generation_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline virtio_pci_config_generation_t virtio_pci_config_generation_reg_insert(virtio_pci_config_generation_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_config_generation_t virtio_pci_config_generation_reg_insert(virtio_pci_config_generation_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x0) | (0xff & (((virtio_pci_config_generation_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_config_generation_prtval(char *_s, size_t _size, virtio_pci_config_generation_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_config_generation_prtval(char *_s, size_t _size, virtio_pci_config_generation_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx8 "\t(todo)\n", virtio_pci_config_generation_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_queue_select_t
 * Description: Implicit type of queue_select register
 * Fields:
 *   val	(size 16, offset 0, init 0):	RW	
 */
typedef uint16_t virtio_pci_queue_select_t;
#define virtio_pci_queue_select_default 0x0
static inline uint16_t virtio_pci_queue_select_val_extract(virtio_pci_queue_select_t _regval) __attribute__ ((always_inline));
static inline uint16_t virtio_pci_queue_select_val_extract(virtio_pci_queue_select_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline virtio_pci_queue_select_t virtio_pci_queue_select_val_insert(virtio_pci_queue_select_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_queue_select_t virtio_pci_queue_select_val_insert(virtio_pci_queue_select_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x0) | (0xffff & (((virtio_pci_queue_select_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_queue_select_prtval(char *_s, size_t _size, virtio_pci_queue_select_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_queue_select_prtval(char *_s, size_t _size, virtio_pci_queue_select_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx16 "\t()\n", virtio_pci_queue_select_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_queue_size_t
 * Description: Implicit type of queue_size register
 * Fields:
 *   val	(size 16, offset 0, init 0):	RW	
 */
typedef uint16_t virtio_pci_queue_size_t;
#define virtio_pci_queue_size_default 0x0
static inline uint16_t virtio_pci_queue_size_val_extract(virtio_pci_queue_size_t _regval) __attribute__ ((always_inline));
static inline uint16_t virtio_pci_queue_size_val_extract(virtio_pci_queue_size_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline virtio_pci_queue_size_t virtio_pci_queue_size_val_insert(virtio_pci_queue_size_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_queue_size_t virtio_pci_queue_size_val_insert(virtio_pci_queue_size_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x0) | (0xffff & (((virtio_pci_queue_size_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_queue_size_prtval(char *_s, size_t _size, virtio_pci_queue_size_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_queue_size_prtval(char *_s, size_t _size, virtio_pci_queue_size_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx16 "\t()\n", virtio_pci_queue_size_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_queue_msix_vector_t
 * Description: Implicit type of queue_msix_vector register
 * Fields:
 *   val	(size 16, offset 0, init 0):	RW	
 */
typedef uint16_t virtio_pci_queue_msix_vector_t;
#define virtio_pci_queue_msix_vector_default 0x0
static inline uint16_t virtio_pci_queue_msix_vector_val_extract(virtio_pci_queue_msix_vector_t _regval) __attribute__ ((always_inline));
static inline uint16_t virtio_pci_queue_msix_vector_val_extract(virtio_pci_queue_msix_vector_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline virtio_pci_queue_msix_vector_t virtio_pci_queue_msix_vector_val_insert(virtio_pci_queue_msix_vector_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_queue_msix_vector_t virtio_pci_queue_msix_vector_val_insert(virtio_pci_queue_msix_vector_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x0) | (0xffff & (((virtio_pci_queue_msix_vector_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_queue_msix_vector_prtval(char *_s, size_t _size, virtio_pci_queue_msix_vector_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_queue_msix_vector_prtval(char *_s, size_t _size, virtio_pci_queue_msix_vector_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx16 "\t()\n", virtio_pci_queue_msix_vector_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_queue_enable_t
 * Description: Implicit type of queue_enable register
 * Fields:
 *   val	(size 16, offset 0, init 0):	RW	
 */
typedef uint16_t virtio_pci_queue_enable_t;
#define virtio_pci_queue_enable_default 0x0
static inline uint16_t virtio_pci_queue_enable_val_extract(virtio_pci_queue_enable_t _regval) __attribute__ ((always_inline));
static inline uint16_t virtio_pci_queue_enable_val_extract(virtio_pci_queue_enable_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline virtio_pci_queue_enable_t virtio_pci_queue_enable_val_insert(virtio_pci_queue_enable_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_queue_enable_t virtio_pci_queue_enable_val_insert(virtio_pci_queue_enable_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x0) | (0xffff & (((virtio_pci_queue_enable_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_queue_enable_prtval(char *_s, size_t _size, virtio_pci_queue_enable_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_queue_enable_prtval(char *_s, size_t _size, virtio_pci_queue_enable_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx16 "\t()\n", virtio_pci_queue_enable_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_queue_notify_off_t
 * Description: Implicit type of queue_notify_off register
 * Fields:
 *   val	(size 16, offset 0, init 0):	RW	
 */
typedef uint16_t virtio_pci_queue_notify_off_t;
#define virtio_pci_queue_notify_off_default 0x0
static inline uint16_t virtio_pci_queue_notify_off_val_extract(virtio_pci_queue_notify_off_t _regval) __attribute__ ((always_inline));
static inline uint16_t virtio_pci_queue_notify_off_val_extract(virtio_pci_queue_notify_off_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline virtio_pci_queue_notify_off_t virtio_pci_queue_notify_off_val_insert(virtio_pci_queue_notify_off_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_queue_notify_off_t virtio_pci_queue_notify_off_val_insert(virtio_pci_queue_notify_off_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x0) | (0xffff & (((virtio_pci_queue_notify_off_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_queue_notify_off_prtval(char *_s, size_t _size, virtio_pci_queue_notify_off_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_queue_notify_off_prtval(char *_s, size_t _size, virtio_pci_queue_notify_off_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx16 "\t()\n", virtio_pci_queue_notify_off_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_queue_desc_t
 * Description: Implicit type of queue_desc register
 * Fields:
 *   val	(size 64, offset 0, init 0):	RW	
 */
typedef uint64_t virtio_pci_queue_desc_t;
#define virtio_pci_queue_desc_default 0x0
static inline uint64_t virtio_pci_queue_desc_val_extract(virtio_pci_queue_desc_t _regval) __attribute__ ((always_inline));
static inline uint64_t virtio_pci_queue_desc_val_extract(virtio_pci_queue_desc_t _regval)
{
    return((uint64_t )((_regval & 0xffffffffffffffff) >> 0));
}

static inline virtio_pci_queue_desc_t virtio_pci_queue_desc_val_insert(virtio_pci_queue_desc_t _regval, uint64_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_queue_desc_t virtio_pci_queue_desc_val_insert(virtio_pci_queue_desc_t _regval, uint64_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffffffffffff & (((virtio_pci_queue_desc_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_queue_desc_prtval(char *_s, size_t _size, virtio_pci_queue_desc_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_queue_desc_prtval(char *_s, size_t _size, virtio_pci_queue_desc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx64 "\t()\n", virtio_pci_queue_desc_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_queue_avail_t
 * Description: Implicit type of queue_avail register
 * Fields:
 *   val	(size 64, offset 0, init 0):	RW	
 */
typedef uint64_t virtio_pci_queue_avail_t;
#define virtio_pci_queue_avail_default 0x0
static inline uint64_t virtio_pci_queue_avail_val_extract(virtio_pci_queue_avail_t _regval) __attribute__ ((always_inline));
static inline uint64_t virtio_pci_queue_avail_val_extract(virtio_pci_queue_avail_t _regval)
{
    return((uint64_t )((_regval & 0xffffffffffffffff) >> 0));
}

static inline virtio_pci_queue_avail_t virtio_pci_queue_avail_val_insert(virtio_pci_queue_avail_t _regval, uint64_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_queue_avail_t virtio_pci_queue_avail_val_insert(virtio_pci_queue_avail_t _regval, uint64_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffffffffffff & (((virtio_pci_queue_avail_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_queue_avail_prtval(char *_s, size_t _size, virtio_pci_queue_avail_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_queue_avail_prtval(char *_s, size_t _size, virtio_pci_queue_avail_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx64 "\t()\n", virtio_pci_queue_avail_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: virtio_pci_queue_used_t
 * Description: Implicit type of queue_used register
 * Fields:
 *   val	(size 64, offset 0, init 0):	RW	
 */
typedef uint64_t virtio_pci_queue_used_t;
#define virtio_pci_queue_used_default 0x0
static inline uint64_t virtio_pci_queue_used_val_extract(virtio_pci_queue_used_t _regval) __attribute__ ((always_inline));
static inline uint64_t virtio_pci_queue_used_val_extract(virtio_pci_queue_used_t _regval)
{
    return((uint64_t )((_regval & 0xffffffffffffffff) >> 0));
}

static inline virtio_pci_queue_used_t virtio_pci_queue_used_val_insert(virtio_pci_queue_used_t _regval, uint64_t _fieldval) __attribute__ ((always_inline));
static inline virtio_pci_queue_used_t virtio_pci_queue_used_val_insert(virtio_pci_queue_used_t _regval, uint64_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffffffffffff & (((virtio_pci_queue_used_t )(_fieldval)) << 0)));
}

static inline int virtio_pci_queue_used_prtval(char *_s, size_t _size, virtio_pci_queue_used_t _regval) __attribute__ ((always_inline));
static inline int virtio_pci_queue_used_prtval(char *_s, size_t _size, virtio_pci_queue_used_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx64 "\t()\n", virtio_pci_queue_used_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
    mackerel_addr_t common;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum virtio_pci_initials {
    virtio_pci_vendor_initial = 0x0,
    virtio_pci_next_initial = 0x0,
    virtio_pci_length_initial = 0x0,
    virtio_pci_config_initial = 0x0,
    virtio_pci_bar_initial = 0x0,
    virtio_pci_offset_initial = 0x0,
    virtio_pci_length2_initial = 0x0,
    virtio_pci_device_feature_select_initial = 0x0,
    virtio_pci_device_feature_initial = 0x0,
    virtio_pci_driver_feature_select_initial = 0x0,
    virtio_pci_driver_initial = 0x0,
    virtio_pci_msix_config_initial = 0x0,
    virtio_pci_num_queues_initial = 0x0,
    virtio_pci_device_status_initial = 0x0,
    virtio_pci_config_generation_initial = 0x0,
    virtio_pci_queue_select_initial = 0x0,
    virtio_pci_queue_size_initial = 0x0,
    virtio_pci_queue_msix_vector_initial = 0x0,
    virtio_pci_queue_enable_initial = 0x0,
    virtio_pci_queue_notify_off_initial = 0x0,
    virtio_pci_queue_desc_initial = 0x0,
    virtio_pci_queue_avail_initial = 0x0,
    virtio_pci_queue_used_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void virtio_pci_initialize(__DN(t) *_dev, mackerel_addr_t base, mackerel_addr_t common) __attribute__ ((always_inline));
static inline void virtio_pci_initialize(__DN(t) *_dev, mackerel_addr_t base, mackerel_addr_t common)
{
    _dev->base = base;
    _dev->common = common;
}

/*
 * Register vendor: Identifies a vendor-specific capability.
 * Type: virtio_pci.vendor (Implicit type of Identifies a vendor-specific capability. register)
 *   vndr	(size 8, offset 0, init 0):	RW	Vendor ID
 */
static inline virtio_pci_vendor_t virtio_pci_vendor_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_vendor_t virtio_pci_vendor_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->base, 0x0));
}

static inline virtio_pci_vendor_t virtio_pci_vendor_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_vendor_t virtio_pci_vendor_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->base, 0x0));
}

static inline void virtio_pci_vendor_rawwr(__DN(t) *_dev, virtio_pci_vendor_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_vendor_rawwr(__DN(t) *_dev, virtio_pci_vendor_t _regval)
{
    mackerel_write_addr_8(_dev->base, 0x0, _regval);
}

static inline void virtio_pci_vendor_wr(__DN(t) *_dev, virtio_pci_vendor_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_vendor_wr(__DN(t) *_dev, virtio_pci_vendor_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->base, 0x0, _regval);
}

static inline int virtio_pci_vendor_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_vendor_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_vendor_t _regval = mackerel_read_addr_8(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vendor (Identifies a vendor-specific capability.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vndr =\t%" PRIx8 "\t(Vendor ID)\n", virtio_pci_vendor_vndr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t virtio_pci_vendor_vndr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_pci_vendor_vndr_rdf(__DN(t) *_dev)
{
    virtio_pci_vendor_t _regval = mackerel_read_addr_8(_dev->base, 0x0);
    return(virtio_pci_vendor_vndr_extract(_regval));
}

static inline void virtio_pci_vendor_vndr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_vendor_vndr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_pci_vendor_t _regval = 0xff & (((virtio_pci_vendor_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register next: Next Pointer
 * Type: virtio_pci.next (Implicit type of Next Pointer register)
 *   next	(size 8, offset 0, init 0):	RW	Link to next capability in the capability list.
 */
static inline virtio_pci_next_t virtio_pci_next_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_next_t virtio_pci_next_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->base, 0x1));
}

static inline virtio_pci_next_t virtio_pci_next_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_next_t virtio_pci_next_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->base, 0x1));
}

static inline void virtio_pci_next_rawwr(__DN(t) *_dev, virtio_pci_next_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_next_rawwr(__DN(t) *_dev, virtio_pci_next_t _regval)
{
    mackerel_write_addr_8(_dev->base, 0x1, _regval);
}

static inline void virtio_pci_next_wr(__DN(t) *_dev, virtio_pci_next_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_next_wr(__DN(t) *_dev, virtio_pci_next_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->base, 0x1, _regval);
}

static inline int virtio_pci_next_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_next_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_next_t _regval = mackerel_read_addr_8(_dev->base, 0x1);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register next (Next Pointer): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " next =\t%" PRIx8 "\t(Link to next capability in the capability list.)\n", virtio_pci_next_next_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t virtio_pci_next_next_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_pci_next_next_rdf(__DN(t) *_dev)
{
    virtio_pci_next_t _regval = mackerel_read_addr_8(_dev->base, 0x1);
    return(virtio_pci_next_next_extract(_regval));
}

static inline void virtio_pci_next_next_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_next_next_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_pci_next_t _regval = 0xff & (((virtio_pci_next_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->base, 0x1, _regval);
    // No shadow register to write to
}

/*
 * Register length: Length of this capability structure
 * Type: virtio_pci.length (Implicit type of Length of this capability structure register)
 *   len	(size 8, offset 0, init 0):	RW	Length
 */
static inline virtio_pci_length_t virtio_pci_length_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_length_t virtio_pci_length_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->base, 0x2));
}

static inline virtio_pci_length_t virtio_pci_length_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_length_t virtio_pci_length_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->base, 0x2));
}

static inline void virtio_pci_length_rawwr(__DN(t) *_dev, virtio_pci_length_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_length_rawwr(__DN(t) *_dev, virtio_pci_length_t _regval)
{
    mackerel_write_addr_8(_dev->base, 0x2, _regval);
}

static inline void virtio_pci_length_wr(__DN(t) *_dev, virtio_pci_length_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_length_wr(__DN(t) *_dev, virtio_pci_length_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->base, 0x2, _regval);
}

static inline int virtio_pci_length_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_length_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_length_t _regval = mackerel_read_addr_8(_dev->base, 0x2);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register length (Length of this capability structure): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " len =\t%" PRIx8 "\t(Length)\n", virtio_pci_length_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t virtio_pci_length_len_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_pci_length_len_rdf(__DN(t) *_dev)
{
    virtio_pci_length_t _regval = mackerel_read_addr_8(_dev->base, 0x2);
    return(virtio_pci_length_len_extract(_regval));
}

static inline void virtio_pci_length_len_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_length_len_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_pci_length_t _regval = 0xff & (((virtio_pci_length_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->base, 0x2, _regval);
    // No shadow register to write to
}

/*
 * Register config: identifies the structure
 * Type: virtio_pci.config (Implicit type of identifies the structure register)
 *   cfg_type	(size 8, offset 0, init 0):	RW	configuration type
 */
static inline virtio_pci_config_t virtio_pci_config_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_config_t virtio_pci_config_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->base, 0x3));
}

static inline virtio_pci_config_t virtio_pci_config_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_config_t virtio_pci_config_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->base, 0x3));
}

static inline void virtio_pci_config_rawwr(__DN(t) *_dev, virtio_pci_config_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_config_rawwr(__DN(t) *_dev, virtio_pci_config_t _regval)
{
    mackerel_write_addr_8(_dev->base, 0x3, _regval);
}

static inline void virtio_pci_config_wr(__DN(t) *_dev, virtio_pci_config_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_config_wr(__DN(t) *_dev, virtio_pci_config_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->base, 0x3, _regval);
}

static inline int virtio_pci_config_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_config_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_config_t _regval = mackerel_read_addr_8(_dev->base, 0x3);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register config (identifies the structure): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfg_type =\t%" PRIx8 "\t(configuration type)\n", virtio_pci_config_cfg_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t virtio_pci_config_cfg_type_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_pci_config_cfg_type_rdf(__DN(t) *_dev)
{
    virtio_pci_config_t _regval = mackerel_read_addr_8(_dev->base, 0x3);
    return(virtio_pci_config_cfg_type_extract(_regval));
}

static inline void virtio_pci_config_cfg_type_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_config_cfg_type_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_pci_config_t _regval = 0xff & (((virtio_pci_config_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->base, 0x3, _regval);
    // No shadow register to write to
}

/*
 * Register bar: Base Address register (BAR) belonging to the function located beginning
 * Type: virtio_pci.bar (Implicit type of Base Address register (BAR) belonging to the function located beginning register)
 *   bar	(size 8, offset 0, init 0):	RW	Base Address register (BAR)
 */
static inline virtio_pci_bar_t virtio_pci_bar_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_bar_t virtio_pci_bar_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->base, 0x4));
}

static inline virtio_pci_bar_t virtio_pci_bar_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_bar_t virtio_pci_bar_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->base, 0x4));
}

static inline void virtio_pci_bar_rawwr(__DN(t) *_dev, virtio_pci_bar_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_bar_rawwr(__DN(t) *_dev, virtio_pci_bar_t _regval)
{
    mackerel_write_addr_8(_dev->base, 0x4, _regval);
}

static inline void virtio_pci_bar_wr(__DN(t) *_dev, virtio_pci_bar_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_bar_wr(__DN(t) *_dev, virtio_pci_bar_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->base, 0x4, _regval);
}

static inline int virtio_pci_bar_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_bar_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_bar_t _regval = mackerel_read_addr_8(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register bar (Base Address register (BAR) belonging to the function located beginning): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bar =\t%" PRIx8 "\t(Base Address register (BAR))\n", virtio_pci_bar_bar_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t virtio_pci_bar_bar_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_pci_bar_bar_rdf(__DN(t) *_dev)
{
    virtio_pci_bar_t _regval = mackerel_read_addr_8(_dev->base, 0x4);
    return(virtio_pci_bar_bar_extract(_regval));
}

static inline void virtio_pci_bar_bar_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_bar_bar_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_pci_bar_t _regval = 0xff & (((virtio_pci_bar_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

/*
 * Register offset: beginning of the structure relative to the base address
 * Type: virtio_pci.offset (Implicit type of beginning of the structure relative to the base address register)
 *   off	(size 32, offset 0, init 0):	RW	Offset
 */
static inline virtio_pci_offset_t virtio_pci_offset_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_offset_t virtio_pci_offset_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline virtio_pci_offset_t virtio_pci_offset_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_offset_t virtio_pci_offset_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void virtio_pci_offset_rawwr(__DN(t) *_dev, virtio_pci_offset_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_offset_rawwr(__DN(t) *_dev, virtio_pci_offset_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline void virtio_pci_offset_wr(__DN(t) *_dev, virtio_pci_offset_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_offset_wr(__DN(t) *_dev, virtio_pci_offset_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline int virtio_pci_offset_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_offset_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_offset_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register offset (beginning of the structure relative to the base address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " off =\t%" PRIx32 "\t(Offset)\n", virtio_pci_offset_off_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_pci_offset_off_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_pci_offset_off_rdf(__DN(t) *_dev)
{
    virtio_pci_offset_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(virtio_pci_offset_off_extract(_regval));
}

static inline void virtio_pci_offset_off_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_offset_off_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_pci_offset_t _regval = 0xffffffff & (((virtio_pci_offset_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

/*
 * Register length2: indicates the length of the structure.
 * Type: virtio_pci.length2 (Implicit type of indicates the length of the structure. register)
 *   len	(size 32, offset 0, init 0):	RW	Length
 */
static inline virtio_pci_length2_t virtio_pci_length2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_length2_t virtio_pci_length2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline virtio_pci_length2_t virtio_pci_length2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_length2_t virtio_pci_length2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline void virtio_pci_length2_rawwr(__DN(t) *_dev, virtio_pci_length2_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_length2_rawwr(__DN(t) *_dev, virtio_pci_length2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline void virtio_pci_length2_wr(__DN(t) *_dev, virtio_pci_length2_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_length2_wr(__DN(t) *_dev, virtio_pci_length2_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline int virtio_pci_length2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_length2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_length2_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register length2 (indicates the length of the structure.): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " len =\t%" PRIx32 "\t(Length)\n", virtio_pci_length2_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_pci_length2_len_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_pci_length2_len_rdf(__DN(t) *_dev)
{
    virtio_pci_length2_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(virtio_pci_length2_len_extract(_regval));
}

static inline void virtio_pci_length2_len_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_length2_len_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_pci_length2_t _regval = 0xffffffff & (((virtio_pci_length2_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

/*
 * Register device_feature_select: 
 * Type: virtio_pci.device_feature_select (Implicit type of  register)
 *   reg	(size 32, offset 0, init 0):	RW	todo
 */
static inline virtio_pci_device_feature_select_t virtio_pci_device_feature_select_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_device_feature_select_t virtio_pci_device_feature_select_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->common, 0x0));
}

static inline virtio_pci_device_feature_select_t virtio_pci_device_feature_select_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_device_feature_select_t virtio_pci_device_feature_select_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->common, 0x0));
}

static inline void virtio_pci_device_feature_select_rawwr(__DN(t) *_dev, virtio_pci_device_feature_select_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_device_feature_select_rawwr(__DN(t) *_dev, virtio_pci_device_feature_select_t _regval)
{
    mackerel_write_addr_32(_dev->common, 0x0, _regval);
}

static inline void virtio_pci_device_feature_select_wr(__DN(t) *_dev, virtio_pci_device_feature_select_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_device_feature_select_wr(__DN(t) *_dev, virtio_pci_device_feature_select_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->common, 0x0, _regval);
}

static inline int virtio_pci_device_feature_select_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_device_feature_select_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_device_feature_select_t _regval = mackerel_read_addr_32(_dev->common, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register device_feature_select (): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(todo)\n", virtio_pci_device_feature_select_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_pci_device_feature_select_reg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_pci_device_feature_select_reg_rdf(__DN(t) *_dev)
{
    virtio_pci_device_feature_select_t _regval = mackerel_read_addr_32(_dev->common, 0x0);
    return(virtio_pci_device_feature_select_reg_extract(_regval));
}

static inline void virtio_pci_device_feature_select_reg_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_device_feature_select_reg_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_pci_device_feature_select_t _regval = 0xffffffff & (((virtio_pci_device_feature_select_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->common, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register device_feature: 
 * Type: virtio_pci.device_feature (Implicit type of  register)
 *   reg	(size 32, offset 0, init 0):	RW	todo
 */
static inline virtio_pci_device_feature_t virtio_pci_device_feature_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_device_feature_t virtio_pci_device_feature_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->common, 0x4));
}

static inline virtio_pci_device_feature_t virtio_pci_device_feature_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_device_feature_t virtio_pci_device_feature_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->common, 0x4));
}

static inline void virtio_pci_device_feature_rawwr(__DN(t) *_dev, virtio_pci_device_feature_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_device_feature_rawwr(__DN(t) *_dev, virtio_pci_device_feature_t _regval)
{
    mackerel_write_addr_32(_dev->common, 0x4, _regval);
}

static inline void virtio_pci_device_feature_wr(__DN(t) *_dev, virtio_pci_device_feature_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_device_feature_wr(__DN(t) *_dev, virtio_pci_device_feature_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->common, 0x4, _regval);
}

static inline int virtio_pci_device_feature_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_device_feature_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_device_feature_t _regval = mackerel_read_addr_32(_dev->common, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register device_feature (): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(todo)\n", virtio_pci_device_feature_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_pci_device_feature_reg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_pci_device_feature_reg_rdf(__DN(t) *_dev)
{
    virtio_pci_device_feature_t _regval = mackerel_read_addr_32(_dev->common, 0x4);
    return(virtio_pci_device_feature_reg_extract(_regval));
}

static inline void virtio_pci_device_feature_reg_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_device_feature_reg_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_pci_device_feature_t _regval = 0xffffffff & (((virtio_pci_device_feature_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->common, 0x4, _regval);
    // No shadow register to write to
}

/*
 * Register driver_feature_select: 
 * Type: virtio_pci.driver_feature_select (Implicit type of  register)
 *   reg	(size 32, offset 0, init 0):	RW	todo
 */
static inline virtio_pci_driver_feature_select_t virtio_pci_driver_feature_select_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_driver_feature_select_t virtio_pci_driver_feature_select_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->common, 0x8));
}

static inline virtio_pci_driver_feature_select_t virtio_pci_driver_feature_select_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_driver_feature_select_t virtio_pci_driver_feature_select_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->common, 0x8));
}

static inline void virtio_pci_driver_feature_select_rawwr(__DN(t) *_dev, virtio_pci_driver_feature_select_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_driver_feature_select_rawwr(__DN(t) *_dev, virtio_pci_driver_feature_select_t _regval)
{
    mackerel_write_addr_32(_dev->common, 0x8, _regval);
}

static inline void virtio_pci_driver_feature_select_wr(__DN(t) *_dev, virtio_pci_driver_feature_select_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_driver_feature_select_wr(__DN(t) *_dev, virtio_pci_driver_feature_select_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->common, 0x8, _regval);
}

static inline int virtio_pci_driver_feature_select_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_driver_feature_select_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_driver_feature_select_t _regval = mackerel_read_addr_32(_dev->common, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register driver_feature_select (): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(todo)\n", virtio_pci_driver_feature_select_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_pci_driver_feature_select_reg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_pci_driver_feature_select_reg_rdf(__DN(t) *_dev)
{
    virtio_pci_driver_feature_select_t _regval = mackerel_read_addr_32(_dev->common, 0x8);
    return(virtio_pci_driver_feature_select_reg_extract(_regval));
}

static inline void virtio_pci_driver_feature_select_reg_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_driver_feature_select_reg_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_pci_driver_feature_select_t _regval = 0xffffffff & (((virtio_pci_driver_feature_select_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->common, 0x8, _regval);
    // No shadow register to write to
}

/*
 * Register driver: 
 * Type: virtio_pci.driver (Implicit type of  register)
 *   reg	(size 32, offset 0, init 0):	RW	todo
 */
static inline virtio_pci_driver_t virtio_pci_driver_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_driver_t virtio_pci_driver_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->common, 0xc));
}

static inline virtio_pci_driver_t virtio_pci_driver_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_driver_t virtio_pci_driver_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->common, 0xc));
}

static inline void virtio_pci_driver_rawwr(__DN(t) *_dev, virtio_pci_driver_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_driver_rawwr(__DN(t) *_dev, virtio_pci_driver_t _regval)
{
    mackerel_write_addr_32(_dev->common, 0xc, _regval);
}

static inline void virtio_pci_driver_wr(__DN(t) *_dev, virtio_pci_driver_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_driver_wr(__DN(t) *_dev, virtio_pci_driver_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->common, 0xc, _regval);
}

static inline int virtio_pci_driver_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_driver_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_driver_t _regval = mackerel_read_addr_32(_dev->common, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register driver (): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx32 "\t(todo)\n", virtio_pci_driver_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t virtio_pci_driver_reg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t virtio_pci_driver_reg_rdf(__DN(t) *_dev)
{
    virtio_pci_driver_t _regval = mackerel_read_addr_32(_dev->common, 0xc);
    return(virtio_pci_driver_reg_extract(_regval));
}

static inline void virtio_pci_driver_reg_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_driver_reg_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    virtio_pci_driver_t _regval = 0xffffffff & (((virtio_pci_driver_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->common, 0xc, _regval);
    // No shadow register to write to
}

/*
 * Register msix_config: msix_config
 * Type: virtio_pci.msix_config (Implicit type of msix_config register)
 *   reg	(size 16, offset 0, init 0):	RW	todo
 */
static inline virtio_pci_msix_config_t virtio_pci_msix_config_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_msix_config_t virtio_pci_msix_config_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->common, 0x10));
}

static inline virtio_pci_msix_config_t virtio_pci_msix_config_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_msix_config_t virtio_pci_msix_config_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->common, 0x10));
}

static inline void virtio_pci_msix_config_rawwr(__DN(t) *_dev, virtio_pci_msix_config_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_msix_config_rawwr(__DN(t) *_dev, virtio_pci_msix_config_t _regval)
{
    mackerel_write_addr_16(_dev->common, 0x10, _regval);
}

static inline void virtio_pci_msix_config_wr(__DN(t) *_dev, virtio_pci_msix_config_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_msix_config_wr(__DN(t) *_dev, virtio_pci_msix_config_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->common, 0x10, _regval);
}

static inline int virtio_pci_msix_config_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_msix_config_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_msix_config_t _regval = mackerel_read_addr_16(_dev->common, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register msix_config (msix_config): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx16 "\t(todo)\n", virtio_pci_msix_config_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t virtio_pci_msix_config_reg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t virtio_pci_msix_config_reg_rdf(__DN(t) *_dev)
{
    virtio_pci_msix_config_t _regval = mackerel_read_addr_16(_dev->common, 0x10);
    return(virtio_pci_msix_config_reg_extract(_regval));
}

static inline void virtio_pci_msix_config_reg_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_msix_config_reg_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    virtio_pci_msix_config_t _regval = 0xffff & (((virtio_pci_msix_config_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->common, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register num_queues: num_queues
 * Type: virtio_pci.num_queues (Implicit type of num_queues register)
 *   reg	(size 16, offset 0, init 0):	RW	todo
 */
static inline virtio_pci_num_queues_t virtio_pci_num_queues_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_num_queues_t virtio_pci_num_queues_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->common, 0x12));
}

static inline virtio_pci_num_queues_t virtio_pci_num_queues_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_num_queues_t virtio_pci_num_queues_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->common, 0x12));
}

static inline void virtio_pci_num_queues_rawwr(__DN(t) *_dev, virtio_pci_num_queues_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_num_queues_rawwr(__DN(t) *_dev, virtio_pci_num_queues_t _regval)
{
    mackerel_write_addr_16(_dev->common, 0x12, _regval);
}

static inline void virtio_pci_num_queues_wr(__DN(t) *_dev, virtio_pci_num_queues_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_num_queues_wr(__DN(t) *_dev, virtio_pci_num_queues_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->common, 0x12, _regval);
}

static inline int virtio_pci_num_queues_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_num_queues_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_num_queues_t _regval = mackerel_read_addr_16(_dev->common, 0x12);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register num_queues (num_queues): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx16 "\t(todo)\n", virtio_pci_num_queues_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t virtio_pci_num_queues_reg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t virtio_pci_num_queues_reg_rdf(__DN(t) *_dev)
{
    virtio_pci_num_queues_t _regval = mackerel_read_addr_16(_dev->common, 0x12);
    return(virtio_pci_num_queues_reg_extract(_regval));
}

static inline void virtio_pci_num_queues_reg_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_num_queues_reg_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    virtio_pci_num_queues_t _regval = 0xffff & (((virtio_pci_num_queues_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->common, 0x12, _regval);
    // No shadow register to write to
}

/*
 * Register device_status: device_status
 * Type: virtio_pci.device_status (Implicit type of device_status register)
 *   reg	(size 8, offset 0, init 0):	RW	todo
 */
static inline virtio_pci_device_status_t virtio_pci_device_status_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_device_status_t virtio_pci_device_status_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->common, 0x14));
}

static inline virtio_pci_device_status_t virtio_pci_device_status_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_device_status_t virtio_pci_device_status_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->common, 0x14));
}

static inline void virtio_pci_device_status_rawwr(__DN(t) *_dev, virtio_pci_device_status_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_device_status_rawwr(__DN(t) *_dev, virtio_pci_device_status_t _regval)
{
    mackerel_write_addr_8(_dev->common, 0x14, _regval);
}

static inline void virtio_pci_device_status_wr(__DN(t) *_dev, virtio_pci_device_status_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_device_status_wr(__DN(t) *_dev, virtio_pci_device_status_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->common, 0x14, _regval);
}

static inline int virtio_pci_device_status_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_device_status_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_device_status_t _regval = mackerel_read_addr_8(_dev->common, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register device_status (device_status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx8 "\t(todo)\n", virtio_pci_device_status_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t virtio_pci_device_status_reg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_pci_device_status_reg_rdf(__DN(t) *_dev)
{
    virtio_pci_device_status_t _regval = mackerel_read_addr_8(_dev->common, 0x14);
    return(virtio_pci_device_status_reg_extract(_regval));
}

static inline void virtio_pci_device_status_reg_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_device_status_reg_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_pci_device_status_t _regval = 0xff & (((virtio_pci_device_status_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->common, 0x14, _regval);
    // No shadow register to write to
}

/*
 * Register config_generation: config_generation
 * Type: virtio_pci.config_generation (Implicit type of config_generation register)
 *   reg	(size 8, offset 0, init 0):	RW	todo
 */
static inline virtio_pci_config_generation_t virtio_pci_config_generation_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_config_generation_t virtio_pci_config_generation_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->common, 0x15));
}

static inline virtio_pci_config_generation_t virtio_pci_config_generation_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_config_generation_t virtio_pci_config_generation_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_8(_dev->common, 0x15));
}

static inline void virtio_pci_config_generation_rawwr(__DN(t) *_dev, virtio_pci_config_generation_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_config_generation_rawwr(__DN(t) *_dev, virtio_pci_config_generation_t _regval)
{
    mackerel_write_addr_8(_dev->common, 0x15, _regval);
}

static inline void virtio_pci_config_generation_wr(__DN(t) *_dev, virtio_pci_config_generation_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_config_generation_wr(__DN(t) *_dev, virtio_pci_config_generation_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->common, 0x15, _regval);
}

static inline int virtio_pci_config_generation_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_config_generation_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_config_generation_t _regval = mackerel_read_addr_8(_dev->common, 0x15);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register config_generation (config_generation): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reg =\t%" PRIx8 "\t(todo)\n", virtio_pci_config_generation_reg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t virtio_pci_config_generation_reg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t virtio_pci_config_generation_reg_rdf(__DN(t) *_dev)
{
    virtio_pci_config_generation_t _regval = mackerel_read_addr_8(_dev->common, 0x15);
    return(virtio_pci_config_generation_reg_extract(_regval));
}

static inline void virtio_pci_config_generation_reg_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_config_generation_reg_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    virtio_pci_config_generation_t _regval = 0xff & (((virtio_pci_config_generation_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_8(_dev->common, 0x15, _regval);
    // No shadow register to write to
}

/*
 * Register queue_select: queue_select
 * Type: virtio_pci.queue_select (Implicit type of queue_select register)
 *   val	(size 16, offset 0, init 0):	RW	
 */
static inline virtio_pci_queue_select_t virtio_pci_queue_select_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_queue_select_t virtio_pci_queue_select_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->common, 0x16));
}

static inline virtio_pci_queue_select_t virtio_pci_queue_select_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_queue_select_t virtio_pci_queue_select_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->common, 0x16));
}

static inline void virtio_pci_queue_select_rawwr(__DN(t) *_dev, virtio_pci_queue_select_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_select_rawwr(__DN(t) *_dev, virtio_pci_queue_select_t _regval)
{
    mackerel_write_addr_16(_dev->common, 0x16, _regval);
}

static inline void virtio_pci_queue_select_wr(__DN(t) *_dev, virtio_pci_queue_select_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_select_wr(__DN(t) *_dev, virtio_pci_queue_select_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->common, 0x16, _regval);
}

static inline int virtio_pci_queue_select_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_queue_select_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_queue_select_t _regval = mackerel_read_addr_16(_dev->common, 0x16);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_select (queue_select): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx16 "\t()\n", virtio_pci_queue_select_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t virtio_pci_queue_select_val_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t virtio_pci_queue_select_val_rdf(__DN(t) *_dev)
{
    virtio_pci_queue_select_t _regval = mackerel_read_addr_16(_dev->common, 0x16);
    return(virtio_pci_queue_select_val_extract(_regval));
}

static inline void virtio_pci_queue_select_val_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_select_val_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    virtio_pci_queue_select_t _regval = 0xffff & (((virtio_pci_queue_select_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->common, 0x16, _regval);
    // No shadow register to write to
}

/*
 * Register queue_size: queue_size
 * Type: virtio_pci.queue_size (Implicit type of queue_size register)
 *   val	(size 16, offset 0, init 0):	RW	
 */
static inline virtio_pci_queue_size_t virtio_pci_queue_size_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_queue_size_t virtio_pci_queue_size_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->common, 0x18));
}

static inline virtio_pci_queue_size_t virtio_pci_queue_size_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_queue_size_t virtio_pci_queue_size_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->common, 0x18));
}

static inline void virtio_pci_queue_size_rawwr(__DN(t) *_dev, virtio_pci_queue_size_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_size_rawwr(__DN(t) *_dev, virtio_pci_queue_size_t _regval)
{
    mackerel_write_addr_16(_dev->common, 0x18, _regval);
}

static inline void virtio_pci_queue_size_wr(__DN(t) *_dev, virtio_pci_queue_size_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_size_wr(__DN(t) *_dev, virtio_pci_queue_size_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->common, 0x18, _regval);
}

static inline int virtio_pci_queue_size_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_queue_size_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_queue_size_t _regval = mackerel_read_addr_16(_dev->common, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_size (queue_size): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx16 "\t()\n", virtio_pci_queue_size_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t virtio_pci_queue_size_val_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t virtio_pci_queue_size_val_rdf(__DN(t) *_dev)
{
    virtio_pci_queue_size_t _regval = mackerel_read_addr_16(_dev->common, 0x18);
    return(virtio_pci_queue_size_val_extract(_regval));
}

static inline void virtio_pci_queue_size_val_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_size_val_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    virtio_pci_queue_size_t _regval = 0xffff & (((virtio_pci_queue_size_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->common, 0x18, _regval);
    // No shadow register to write to
}

/*
 * Register queue_msix_vector: queue_msix_vector
 * Type: virtio_pci.queue_msix_vector (Implicit type of queue_msix_vector register)
 *   val	(size 16, offset 0, init 0):	RW	
 */
static inline virtio_pci_queue_msix_vector_t virtio_pci_queue_msix_vector_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_queue_msix_vector_t virtio_pci_queue_msix_vector_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->common, 0x1a));
}

static inline virtio_pci_queue_msix_vector_t virtio_pci_queue_msix_vector_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_queue_msix_vector_t virtio_pci_queue_msix_vector_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->common, 0x1a));
}

static inline void virtio_pci_queue_msix_vector_rawwr(__DN(t) *_dev, virtio_pci_queue_msix_vector_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_msix_vector_rawwr(__DN(t) *_dev, virtio_pci_queue_msix_vector_t _regval)
{
    mackerel_write_addr_16(_dev->common, 0x1a, _regval);
}

static inline void virtio_pci_queue_msix_vector_wr(__DN(t) *_dev, virtio_pci_queue_msix_vector_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_msix_vector_wr(__DN(t) *_dev, virtio_pci_queue_msix_vector_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->common, 0x1a, _regval);
}

static inline int virtio_pci_queue_msix_vector_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_queue_msix_vector_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_queue_msix_vector_t _regval = mackerel_read_addr_16(_dev->common, 0x1a);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_msix_vector (queue_msix_vector): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx16 "\t()\n", virtio_pci_queue_msix_vector_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t virtio_pci_queue_msix_vector_val_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t virtio_pci_queue_msix_vector_val_rdf(__DN(t) *_dev)
{
    virtio_pci_queue_msix_vector_t _regval = mackerel_read_addr_16(_dev->common, 0x1a);
    return(virtio_pci_queue_msix_vector_val_extract(_regval));
}

static inline void virtio_pci_queue_msix_vector_val_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_msix_vector_val_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    virtio_pci_queue_msix_vector_t _regval = 0xffff & (((virtio_pci_queue_msix_vector_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->common, 0x1a, _regval);
    // No shadow register to write to
}

/*
 * Register queue_enable: queue_enable
 * Type: virtio_pci.queue_enable (Implicit type of queue_enable register)
 *   val	(size 16, offset 0, init 0):	RW	
 */
static inline virtio_pci_queue_enable_t virtio_pci_queue_enable_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_queue_enable_t virtio_pci_queue_enable_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->common, 0x1c));
}

static inline virtio_pci_queue_enable_t virtio_pci_queue_enable_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_queue_enable_t virtio_pci_queue_enable_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->common, 0x1c));
}

static inline void virtio_pci_queue_enable_rawwr(__DN(t) *_dev, virtio_pci_queue_enable_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_enable_rawwr(__DN(t) *_dev, virtio_pci_queue_enable_t _regval)
{
    mackerel_write_addr_16(_dev->common, 0x1c, _regval);
}

static inline void virtio_pci_queue_enable_wr(__DN(t) *_dev, virtio_pci_queue_enable_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_enable_wr(__DN(t) *_dev, virtio_pci_queue_enable_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->common, 0x1c, _regval);
}

static inline int virtio_pci_queue_enable_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_queue_enable_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_queue_enable_t _regval = mackerel_read_addr_16(_dev->common, 0x1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_enable (queue_enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx16 "\t()\n", virtio_pci_queue_enable_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t virtio_pci_queue_enable_val_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t virtio_pci_queue_enable_val_rdf(__DN(t) *_dev)
{
    virtio_pci_queue_enable_t _regval = mackerel_read_addr_16(_dev->common, 0x1c);
    return(virtio_pci_queue_enable_val_extract(_regval));
}

static inline void virtio_pci_queue_enable_val_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_enable_val_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    virtio_pci_queue_enable_t _regval = 0xffff & (((virtio_pci_queue_enable_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->common, 0x1c, _regval);
    // No shadow register to write to
}

/*
 * Register queue_notify_off: queue_notify_off
 * Type: virtio_pci.queue_notify_off (Implicit type of queue_notify_off register)
 *   val	(size 16, offset 0, init 0):	RW	
 */
static inline virtio_pci_queue_notify_off_t virtio_pci_queue_notify_off_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_queue_notify_off_t virtio_pci_queue_notify_off_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->common, 0x1e));
}

static inline virtio_pci_queue_notify_off_t virtio_pci_queue_notify_off_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_queue_notify_off_t virtio_pci_queue_notify_off_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_16(_dev->common, 0x1e));
}

static inline void virtio_pci_queue_notify_off_rawwr(__DN(t) *_dev, virtio_pci_queue_notify_off_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_notify_off_rawwr(__DN(t) *_dev, virtio_pci_queue_notify_off_t _regval)
{
    mackerel_write_addr_16(_dev->common, 0x1e, _regval);
}

static inline void virtio_pci_queue_notify_off_wr(__DN(t) *_dev, virtio_pci_queue_notify_off_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_notify_off_wr(__DN(t) *_dev, virtio_pci_queue_notify_off_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_16(_dev->common, 0x1e, _regval);
}

static inline int virtio_pci_queue_notify_off_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_queue_notify_off_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_queue_notify_off_t _regval = mackerel_read_addr_16(_dev->common, 0x1e);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_notify_off (queue_notify_off): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx16 "\t()\n", virtio_pci_queue_notify_off_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t virtio_pci_queue_notify_off_val_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t virtio_pci_queue_notify_off_val_rdf(__DN(t) *_dev)
{
    virtio_pci_queue_notify_off_t _regval = mackerel_read_addr_16(_dev->common, 0x1e);
    return(virtio_pci_queue_notify_off_val_extract(_regval));
}

static inline void virtio_pci_queue_notify_off_val_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_notify_off_val_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    virtio_pci_queue_notify_off_t _regval = 0xffff & (((virtio_pci_queue_notify_off_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_16(_dev->common, 0x1e, _regval);
    // No shadow register to write to
}

/*
 * Register queue_desc: queue_desc
 * Type: virtio_pci.queue_desc (Implicit type of queue_desc register)
 *   val	(size 64, offset 0, init 0):	RW	
 */
static inline virtio_pci_queue_desc_t virtio_pci_queue_desc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_queue_desc_t virtio_pci_queue_desc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->common, 0x20));
}

static inline virtio_pci_queue_desc_t virtio_pci_queue_desc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_queue_desc_t virtio_pci_queue_desc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->common, 0x20));
}

static inline void virtio_pci_queue_desc_rawwr(__DN(t) *_dev, virtio_pci_queue_desc_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_desc_rawwr(__DN(t) *_dev, virtio_pci_queue_desc_t _regval)
{
    mackerel_write_addr_64(_dev->common, 0x20, _regval);
}

static inline void virtio_pci_queue_desc_wr(__DN(t) *_dev, virtio_pci_queue_desc_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_desc_wr(__DN(t) *_dev, virtio_pci_queue_desc_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_64(_dev->common, 0x20, _regval);
}

static inline int virtio_pci_queue_desc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_queue_desc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_queue_desc_t _regval = mackerel_read_addr_64(_dev->common, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_desc (queue_desc): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx64 "\t()\n", virtio_pci_queue_desc_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint64_t virtio_pci_queue_desc_val_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint64_t virtio_pci_queue_desc_val_rdf(__DN(t) *_dev)
{
    virtio_pci_queue_desc_t _regval = mackerel_read_addr_64(_dev->common, 0x20);
    return(virtio_pci_queue_desc_val_extract(_regval));
}

static inline void virtio_pci_queue_desc_val_wrf(__DN(t) *_dev, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_desc_val_wrf(__DN(t) *_dev, uint64_t _fieldval)
{
    virtio_pci_queue_desc_t _regval = 0xffffffffffffffff & (((virtio_pci_queue_desc_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_64(_dev->common, 0x20, _regval);
    // No shadow register to write to
}

/*
 * Register queue_avail: queue_avail
 * Type: virtio_pci.queue_avail (Implicit type of queue_avail register)
 *   val	(size 64, offset 0, init 0):	RW	
 */
static inline virtio_pci_queue_avail_t virtio_pci_queue_avail_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_queue_avail_t virtio_pci_queue_avail_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->common, 0x28));
}

static inline virtio_pci_queue_avail_t virtio_pci_queue_avail_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_queue_avail_t virtio_pci_queue_avail_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->common, 0x28));
}

static inline void virtio_pci_queue_avail_rawwr(__DN(t) *_dev, virtio_pci_queue_avail_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_avail_rawwr(__DN(t) *_dev, virtio_pci_queue_avail_t _regval)
{
    mackerel_write_addr_64(_dev->common, 0x28, _regval);
}

static inline void virtio_pci_queue_avail_wr(__DN(t) *_dev, virtio_pci_queue_avail_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_avail_wr(__DN(t) *_dev, virtio_pci_queue_avail_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_64(_dev->common, 0x28, _regval);
}

static inline int virtio_pci_queue_avail_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_queue_avail_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_queue_avail_t _regval = mackerel_read_addr_64(_dev->common, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_avail (queue_avail): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx64 "\t()\n", virtio_pci_queue_avail_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint64_t virtio_pci_queue_avail_val_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint64_t virtio_pci_queue_avail_val_rdf(__DN(t) *_dev)
{
    virtio_pci_queue_avail_t _regval = mackerel_read_addr_64(_dev->common, 0x28);
    return(virtio_pci_queue_avail_val_extract(_regval));
}

static inline void virtio_pci_queue_avail_val_wrf(__DN(t) *_dev, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_avail_val_wrf(__DN(t) *_dev, uint64_t _fieldval)
{
    virtio_pci_queue_avail_t _regval = 0xffffffffffffffff & (((virtio_pci_queue_avail_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_64(_dev->common, 0x28, _regval);
    // No shadow register to write to
}

/*
 * Register queue_used: queue_used
 * Type: virtio_pci.queue_used (Implicit type of queue_used register)
 *   val	(size 64, offset 0, init 0):	RW	
 */
static inline virtio_pci_queue_used_t virtio_pci_queue_used_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_queue_used_t virtio_pci_queue_used_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->common, 0x30));
}

static inline virtio_pci_queue_used_t virtio_pci_queue_used_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline virtio_pci_queue_used_t virtio_pci_queue_used_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_64(_dev->common, 0x30));
}

static inline void virtio_pci_queue_used_rawwr(__DN(t) *_dev, virtio_pci_queue_used_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_used_rawwr(__DN(t) *_dev, virtio_pci_queue_used_t _regval)
{
    mackerel_write_addr_64(_dev->common, 0x30, _regval);
}

static inline void virtio_pci_queue_used_wr(__DN(t) *_dev, virtio_pci_queue_used_t _regval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_used_wr(__DN(t) *_dev, virtio_pci_queue_used_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_64(_dev->common, 0x30, _regval);
}

static inline int virtio_pci_queue_used_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_queue_used_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    virtio_pci_queue_used_t _regval = mackerel_read_addr_64(_dev->common, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register queue_used (queue_used): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx64 "\t()\n", virtio_pci_queue_used_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint64_t virtio_pci_queue_used_val_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint64_t virtio_pci_queue_used_val_rdf(__DN(t) *_dev)
{
    virtio_pci_queue_used_t _regval = mackerel_read_addr_64(_dev->common, 0x30);
    return(virtio_pci_queue_used_val_extract(_regval));
}

static inline void virtio_pci_queue_used_val_wrf(__DN(t) *_dev, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void virtio_pci_queue_used_val_wrf(__DN(t) *_dev, uint64_t _fieldval)
{
    virtio_pci_queue_used_t _regval = 0xffffffffffffffff & (((virtio_pci_queue_used_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_64(_dev->common, 0x30, _regval);
    // No shadow register to write to
}

static inline int virtio_pci_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int virtio_pci_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device virtio_pci (Virtio PCI Device Specification):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_vendor_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_next_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_length_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_config_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_bar_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_offset_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_length2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_device_feature_select_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_device_feature_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_driver_feature_select_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_driver_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_msix_config_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_num_queues_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_device_status_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_config_generation_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_queue_select_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_queue_size_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_queue_msix_vector_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_queue_enable_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_queue_notify_off_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_queue_desc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_queue_avail_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = virtio_pci_queue_used_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device virtio_pci\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __virtio_pci_DEV_H
