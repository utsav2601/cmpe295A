/*
 * DEVICE DEFINITION: PCI Type 0 Configuration
 * 
 * Copyright (c) 2007, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich.
 *  Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED: DO NOT EDIT!
 */

#ifndef __pci_hdr0_H
#define __pci_hdr0_H

#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR
#define __DN(x) pci_hdr0 ## _ ## x
#ifdef pci_hdr0_PREFIX
#define __DP(x) __DP1(x,pci_hdr0_PREFIX)
#define __DP1(x1,x2) __DP2(x1,x2)
#define __DP2(x1,x2) x2 ## x1
#else
#define __DP(x) pci_hdr0##_ ##x
#endif
#define __STR(x) #x
#define __XTR(x) __STR(x)

/*
 * Constant definition: pci_hdr0.classcode (Class code)
 */
typedef enum pci_hdr0_classcode_t {
    __DP(old) = (0x0),
    __DP(mass) = (0x1),
    __DP(network) = (0x2),
    __DP(display) = (0x3),
    __DP(multimedia) = (0x4),
    __DP(memory) = (0x5),
    __DP(bridge) = (0x6),
    __DP(simple) = (0x7),
    __DP(base) = (0x8),
    __DP(input) = (0x9),
    __DP(docking) = (0xa),
    __DP(processor) = (0xb),
    __DP(serial) = (0xc),
    __DP(wireless) = (0xd),
    __DP(intelligent) = (0xe),
    __DP(satellite) = (0xf),
    __DP(crypt) = (0x10),
    __DP(acquisition) = (0x11),
    __DP(misc) = (0xff),
} pci_hdr0_classcode_t;

static inline int pci_hdr0_classcode_prt( char * s, size_t sz, pci_hdr0_classcode_t e ) __attribute__ ((always_inline));
static inline int pci_hdr0_classcode_prt( char * s, size_t sz, pci_hdr0_classcode_t e )
{
    switch (e) {
        case __DP(old):
        return snprintf(s, sz, "%s", "Pre-2.0 PCI device");
        case __DP(mass):
        return snprintf(s, sz, "%s", "Mass storage controller");
        case __DP(network):
        return snprintf(s, sz, "%s", "Network controller");
        case __DP(display):
        return snprintf(s, sz, "%s", "Display controller");
        case __DP(multimedia):
        return snprintf(s, sz, "%s", "Multimedia device");
        case __DP(memory):
        return snprintf(s, sz, "%s", "Memory controller");
        case __DP(bridge):
        return snprintf(s, sz, "%s", "Bridge device");
        case __DP(simple):
        return snprintf(s, sz, "%s", "Simple communications controller");
        case __DP(base):
        return snprintf(s, sz, "%s", "Base system peripherals");
        case __DP(input):
        return snprintf(s, sz, "%s", "Input device");
        case __DP(docking):
        return snprintf(s, sz, "%s", "Docking station");
        case __DP(processor):
        return snprintf(s, sz, "%s", "Processor");
        case __DP(serial):
        return snprintf(s, sz, "%s", "Serial bus controller");
        case __DP(wireless):
        return snprintf(s, sz, "%s", "Wireless controller");
        case __DP(intelligent):
        return snprintf(s, sz, "%s", "Intelligent I/O controller");
        case __DP(satellite):
        return snprintf(s, sz, "%s", "Satellite communications controller");
        case __DP(crypt):
        return snprintf(s, sz, "%s", "Encryption/decryption device");
        case __DP(acquisition):
        return snprintf(s, sz, "%s", "Data acquisition controller");
        case __DP(misc):
        return snprintf(s, sz, "%s", "Miscellaneous");
        default:
        return snprintf(s, sz, "Unknown " __XTR(pci_hdr0_classcode_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int pci_hdr0_classcode_chk( pci_hdr0_classcode_t e ) __attribute__ ((always_inline));
static inline int pci_hdr0_classcode_chk( pci_hdr0_classcode_t e )
{
    switch (e) {
        case __DP(old):
        return 1;
        case __DP(mass):
        return 1;
        case __DP(network):
        return 1;
        case __DP(display):
        return 1;
        case __DP(multimedia):
        return 1;
        case __DP(memory):
        return 1;
        case __DP(bridge):
        return 1;
        case __DP(simple):
        return 1;
        case __DP(base):
        return 1;
        case __DP(input):
        return 1;
        case __DP(docking):
        return 1;
        case __DP(processor):
        return 1;
        case __DP(serial):
        return 1;
        case __DP(wireless):
        return 1;
        case __DP(intelligent):
        return 1;
        case __DP(satellite):
        return 1;
        case __DP(crypt):
        return 1;
        case __DP(acquisition):
        return 1;
        case __DP(misc):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: pci_hdr0.hdrtype (Configuration header types)
 */
typedef enum pci_hdr0_hdrtype_t {
    __DP(nonbridge) = (0x0),
    __DP(pci2pci) = (0x1),
    __DP(cardbus) = (0x2),
} pci_hdr0_hdrtype_t;

static inline int pci_hdr0_hdrtype_prt( char * s, size_t sz, pci_hdr0_hdrtype_t e ) __attribute__ ((always_inline));
static inline int pci_hdr0_hdrtype_prt( char * s, size_t sz, pci_hdr0_hdrtype_t e )
{
    switch (e) {
        case __DP(nonbridge):
        return snprintf(s, sz, "%s", "non-bridge function");
        case __DP(pci2pci):
        return snprintf(s, sz, "%s", "PCI-to-PCI bridge");
        case __DP(cardbus):
        return snprintf(s, sz, "%s", "CardBus bridge");
        default:
        return snprintf(s, sz, "Unknown " __XTR(pci_hdr0_hdrtype_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int pci_hdr0_hdrtype_chk( pci_hdr0_hdrtype_t e ) __attribute__ ((always_inline));
static inline int pci_hdr0_hdrtype_chk( pci_hdr0_hdrtype_t e )
{
    switch (e) {
        case __DP(nonbridge):
        return 1;
        case __DP(pci2pci):
        return 1;
        case __DP(cardbus):
        return 1;
        default:
        return 0;
    }
}


/*
 * Constant definition: pci_hdr0.bardecoder (BAR decoder type)
 */
typedef enum pci_hdr0_bardecoder_t {
    __DP(bar_32bit) = (0x0),
    __DP(bar_64bit) = (0x2),
} pci_hdr0_bardecoder_t;

static inline int pci_hdr0_bardecoder_prt( char * s, size_t sz, pci_hdr0_bardecoder_t e ) __attribute__ ((always_inline));
static inline int pci_hdr0_bardecoder_prt( char * s, size_t sz, pci_hdr0_bardecoder_t e )
{
    switch (e) {
        case __DP(bar_32bit):
        return snprintf(s, sz, "%s", "32-bit decoder");
        case __DP(bar_64bit):
        return snprintf(s, sz, "%s", "64-bit decoder");
        default:
        return snprintf(s, sz, "Unknown " __XTR(pci_hdr0_bardecoder_t) " value 0x%" PRIxPTR, (uintptr_t)e);
    }
}

static inline int pci_hdr0_bardecoder_chk( pci_hdr0_bardecoder_t e ) __attribute__ ((always_inline));
static inline int pci_hdr0_bardecoder_chk( pci_hdr0_bardecoder_t e )
{
    switch (e) {
        case __DP(bar_32bit):
        return 1;
        case __DP(bar_64bit):
        return 1;
        default:
        return 0;
    }
}


/*
 * Register type: Implicit type of Command register
 */

/*
 * Dump of fields for register type: pci_hdr0_command_t
 *   io_space (size 1, offset 0):	 RW	  I/O space enable
 *   mem_space (size 1, offset 1):	 RW	  Memory space enable
 *   master (size 1, offset 2):	 RW	  Bus master
 *   special (size 1, offset 3):	 RO	  Special cycles
 *   mem_inval (size 1, offset 4):	 RO	  Memory write and invalidate enable
 *   vga_snoop (size 1, offset 5):	 RO	  VGA palette snoop enable
 *   parity (size 1, offset 6):	 RW	  Parity error response
 *   stepping (size 1, offset 7):	 RO	  IDSEL stepping/wait cycle control
 *   serr (size 1, offset 8):	 RW	  SERR# enable
 *   back2back (size 1, offset 9):	 RO	  Fast back-to-back enable
 *   int_dis (size 1, offset 10):	 RW	  Interrupt disable
 *   _anon11 (size 5, offset 11):	 RSVD	  _
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr0_command_t {
    uint8_t	io_space	:1;
    uint8_t	mem_space	:1;
    uint8_t	master	:1;
    uint8_t	special	:1;
    uint8_t	mem_inval	:1;
    uint8_t	vga_snoop	:1;
    uint8_t	parity	:1;
    uint8_t	stepping	:1;
    uint8_t	serr	:1;
    uint8_t	back2back	:1;
    uint8_t	int_dis	:1;
    uint8_t	_anon11	:5;
} __attribute__ ((packed))
 pci_hdr0_command_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr0_command_t, sizeof(uint16_t));

typedef union pci_hdr0_command_un {
    pci_hdr0_command_t	val;
    uint16_t	raw;
}
 pci_hdr0_command_un;
static inline int pci_hdr0_command_prtval( char * s, size_t sz, pci_hdr0_command_t v ) __attribute__ ((always_inline));
static inline int pci_hdr0_command_prtval( char * s, size_t sz, pci_hdr0_command_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " io_space=0x%"PRIx8" (I/O space enable)\n", (uint8_t)(v.io_space));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mem_space=0x%"PRIx8" (Memory space enable)\n", (uint8_t)(v.mem_space));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " master=0x%"PRIx8" (Bus master)\n", (uint8_t)(v.master));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " special=0x%"PRIx8" (Special cycles)\n", (uint8_t)(v.special));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " mem_inval=0x%"PRIx8" (Memory write and invalidate enable)\n", (uint8_t)(v.mem_inval));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " vga_snoop=0x%"PRIx8" (VGA palette snoop enable)\n", (uint8_t)(v.vga_snoop));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " parity=0x%"PRIx8" (Parity error response)\n", (uint8_t)(v.parity));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " stepping=0x%"PRIx8" (IDSEL stepping/wait cycle control)\n", (uint8_t)(v.stepping));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " serr=0x%"PRIx8" (SERR# enable)\n", (uint8_t)(v.serr));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " back2back=0x%"PRIx8" (Fast back-to-back enable)\n", (uint8_t)(v.back2back));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " int_dis=0x%"PRIx8" (Interrupt disable)\n", (uint8_t)(v.int_dis));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Status register
 */

/*
 * Dump of fields for register type: pci_hdr0_status_t
 *   _anon0 (size 3, offset 0):	 RSVD	  _
 *   intstat (size 1, offset 3):	 RO	  Interrupt status
 *   caplist (size 1, offset 4):	 RO	  Capabilities list
 *   m66 (size 1, offset 5):	 RO	  66MHz capable
 *   udf (size 1, offset 6):	 RO	  UDF supported
 *   back2back (size 1, offset 7):	 RO	  Fast Back-to-Back enable
 *   md_parity (size 1, offset 8):	 RWC	  Master data parity error
 *   devsel (size 2, offset 9):	 RO	  DEVSEL timing
 *   sig_t_abrt (size 1, offset 11):	 RWC	  Signalled target abort
 *   rx_t_abrt (size 1, offset 12):	 RWC	  Received target abort
 *   rx_m_abrt (size 1, offset 13):	 RWC	  Received master abort
 *   system_err (size 1, offset 14):	 RWC	  Signalled system error
 *   parity_err (size 1, offset 15):	 RWC	  Detected parity error
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr0_status_t {
    uint8_t	_anon0	:3;
    uint8_t	intstat	:1;
    uint8_t	caplist	:1;
    uint8_t	m66	:1;
    uint8_t	udf	:1;
    uint8_t	back2back	:1;
    uint8_t	md_parity	:1;
    uint8_t	devsel	:2;
    uint8_t	sig_t_abrt	:1;
    uint8_t	rx_t_abrt	:1;
    uint8_t	rx_m_abrt	:1;
    uint8_t	system_err	:1;
    uint8_t	parity_err	:1;
} __attribute__ ((packed))
 pci_hdr0_status_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr0_status_t, sizeof(uint16_t));

typedef union pci_hdr0_status_un {
    pci_hdr0_status_t	val;
    uint16_t	raw;
}
 pci_hdr0_status_un;
static inline int pci_hdr0_status_prtval( char * s, size_t sz, pci_hdr0_status_t v ) __attribute__ ((always_inline));
static inline int pci_hdr0_status_prtval( char * s, size_t sz, pci_hdr0_status_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " intstat=0x%"PRIx8" (Interrupt status)\n", (uint8_t)(v.intstat));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " caplist=0x%"PRIx8" (Capabilities list)\n", (uint8_t)(v.caplist));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " m66=0x%"PRIx8" (66MHz capable)\n", (uint8_t)(v.m66));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " udf=0x%"PRIx8" (UDF supported)\n", (uint8_t)(v.udf));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " back2back=0x%"PRIx8" (Fast Back-to-Back enable)\n", (uint8_t)(v.back2back));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " md_parity=0x%"PRIx8" (Master data parity error)\n", (uint8_t)(v.md_parity));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " devsel=0x%"PRIx8" (DEVSEL timing)\n", (uint8_t)(v.devsel));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " sig_t_abrt=0x%"PRIx8" (Signalled target abort)\n", (uint8_t)(v.sig_t_abrt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rx_t_abrt=0x%"PRIx8" (Received target abort)\n", (uint8_t)(v.rx_t_abrt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " rx_m_abrt=0x%"PRIx8" (Received master abort)\n", (uint8_t)(v.rx_m_abrt));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " system_err=0x%"PRIx8" (Signalled system error)\n", (uint8_t)(v.system_err));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " parity_err=0x%"PRIx8" (Detected parity error)\n", (uint8_t)(v.parity_err));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Class code register
 */

/*
 * Dump of fields for register type: pci_hdr0_class_code_t
 *   _anon0 (size 8, offset 0):	 RSVD	  _
 *   prog_if (size 8, offset 8):	 RO	  Programming intf
 *   subclss (size 8, offset 16):	 RO	  Subclass code
 *   clss (size 8, offset 24):	 RO	  Class code
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr0_class_code_t {
    uint8_t	_anon0	:8;
    uint8_t	prog_if	:8;
    uint8_t	subclss	:8;
    pci_hdr0_classcode_t	clss	:8;
} __attribute__ ((packed))
 pci_hdr0_class_code_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr0_class_code_t, sizeof(uint32_t));

typedef union pci_hdr0_class_code_un {
    pci_hdr0_class_code_t	val;
    uint32_t	raw;
}
 pci_hdr0_class_code_un;
static inline int pci_hdr0_class_code_prtval( char * s, size_t sz, pci_hdr0_class_code_t v ) __attribute__ ((always_inline));
static inline int pci_hdr0_class_code_prtval( char * s, size_t sz, pci_hdr0_class_code_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " prog_if=0x%"PRIx8" (Programming intf)\n", (uint8_t)(v.prog_if));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " subclss=0x%"PRIx8" (Subclass code)\n", (uint8_t)(v.subclss));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " clss=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = pci_hdr0_classcode_prt(s+r, _avail, v.clss);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Class code)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Header type register
 */

/*
 * Dump of fields for register type: pci_hdr0_hdr_type_t
 *   fmt (size 7, offset 0):	 RO	  Configuration header format
 *   multi (size 1, offset 7):	 RO	  Multifunction device
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr0_hdr_type_t {
    pci_hdr0_hdrtype_t	fmt	:7;
    uint8_t	multi	:1;
} __attribute__ ((packed))
 pci_hdr0_hdr_type_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr0_hdr_type_t, sizeof(uint8_t));

typedef union pci_hdr0_hdr_type_un {
    pci_hdr0_hdr_type_t	val;
    uint8_t	raw;
}
 pci_hdr0_hdr_type_un;
static inline int pci_hdr0_hdr_type_prtval( char * s, size_t sz, pci_hdr0_hdr_type_t v ) __attribute__ ((always_inline));
static inline int pci_hdr0_hdr_type_prtval( char * s, size_t sz, pci_hdr0_hdr_type_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " fmt=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = pci_hdr0_hdrtype_prt(s+r, _avail, v.fmt);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Configuration header format)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " multi=0x%"PRIx8" (Multifunction device)\n", (uint8_t)(v.multi));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Built-in self-test register
 */

/*
 * Dump of fields for register type: pci_hdr0_bist_t
 *   comp (size 4, offset 0):	 RO	  Completion code
 *   _anon4 (size 2, offset 4):	 RSVD	  _
 *   start (size 1, offset 6):	 RW	  Start BIST
 *   cap (size 1, offset 7):	 RO	  BIST capable
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr0_bist_t {
    uint8_t	comp	:4;
    uint8_t	_anon4	:2;
    uint8_t	start	:1;
    uint8_t	cap	:1;
} __attribute__ ((packed))
 pci_hdr0_bist_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr0_bist_t, sizeof(uint8_t));

typedef union pci_hdr0_bist_un {
    pci_hdr0_bist_t	val;
    uint8_t	raw;
}
 pci_hdr0_bist_un;
static inline int pci_hdr0_bist_prtval( char * s, size_t sz, pci_hdr0_bist_t v ) __attribute__ ((always_inline));
static inline int pci_hdr0_bist_prtval( char * s, size_t sz, pci_hdr0_bist_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " comp=0x%"PRIx8" (Completion code)\n", (uint8_t)(v.comp));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " start=0x%"PRIx8" (Start BIST)\n", (uint8_t)(v.start));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " cap=0x%"PRIx8" (BIST capable)\n", (uint8_t)(v.cap));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: 32-bit memory base address
 */

/*
 * Dump of fields for register type: pci_hdr0_bar32_t
 *   space (size 1, offset 0):	 RO	  Memory space indicator
 *   tpe (size 2, offset 1):	 RO	  Memory decoder type
 *   prefetch (size 1, offset 3):	 RO	  Prefetchable
 *   _anon4 (size 3, offset 4):	 RSVD	  _
 *   base (size 25, offset 7):	 RW	  Base address
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr0_bar32_t {
    uint8_t	space	:1;
    pci_hdr0_bardecoder_t	tpe	:2;
    uint8_t	prefetch	:1;
    uint8_t	_anon4	:3;
    uint32_t	base	:25;
} __attribute__ ((packed))
 pci_hdr0_bar32_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr0_bar32_t, sizeof(uint32_t));

typedef union pci_hdr0_bar32_un {
    pci_hdr0_bar32_t	val;
    uint32_t	raw;
}
 pci_hdr0_bar32_un;
static inline int pci_hdr0_bar32_prtval( char * s, size_t sz, pci_hdr0_bar32_t v ) __attribute__ ((always_inline));
static inline int pci_hdr0_bar32_prtval( char * s, size_t sz, pci_hdr0_bar32_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " space=0x%"PRIx8" (Memory space indicator)\n", (uint8_t)(v.space));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " tpe=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = pci_hdr0_bardecoder_prt(s+r, _avail, v.tpe);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Memory decoder type)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " prefetch=0x%"PRIx8" (Prefetchable)\n", (uint8_t)(v.prefetch));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " base=0x%0"PRIx32" (Base address)\n", (uint32_t)(v.base));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: 64-bit memory base address
 */

/*
 * Dump of fields for register type: pci_hdr0_bar64_t
 *   space (size 1, offset 0):	 RO	  Memory space indicator
 *   tpe (size 2, offset 1):	 RO	  Memory decoder type
 *   prefetch (size 1, offset 3):	 RO	  Prefetchable
 *   _anon4 (size 3, offset 4):	 RSVD	  _
 *   base (size 57, offset 7):	 RW	  Base address
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr0_bar64_t {
    uint8_t	space	:1;
    pci_hdr0_bardecoder_t	tpe	:2;
    uint8_t	prefetch	:1;
    uint8_t	_anon4	:3;
    uint64_t	base	:57;
} __attribute__ ((packed))
 pci_hdr0_bar64_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr0_bar64_t, sizeof(uint64_t));

typedef union pci_hdr0_bar64_un {
    pci_hdr0_bar64_t	val;
    uint64_t	raw;
}
 pci_hdr0_bar64_un;
static inline int pci_hdr0_bar64_prtval( char * s, size_t sz, pci_hdr0_bar64_t v ) __attribute__ ((always_inline));
static inline int pci_hdr0_bar64_prtval( char * s, size_t sz, pci_hdr0_bar64_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " space=0x%"PRIx8" (Memory space indicator)\n", (uint8_t)(v.space));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " tpe=");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = pci_hdr0_bardecoder_prt(s+r, _avail, v.tpe);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", " (Memory decoder type)\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " prefetch=0x%"PRIx8" (Prefetchable)\n", (uint8_t)(v.prefetch));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " base=0x%0"PRIx64" (Base address)\n", (uint64_t)(v.base));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: I/O space base address
 */

/*
 * Dump of fields for register type: pci_hdr0_bario_t
 *   space (size 1, offset 0):	 RO	  I/O space indicator
 *   _anon1 (size 1, offset 1):	 RSVD	  _
 *   base (size 30, offset 2):	 RW	  Base address
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr0_bario_t {
    uint8_t	space	:1;
    uint8_t	_anon1	:1;
    uint32_t	base	:30;
} __attribute__ ((packed))
 pci_hdr0_bario_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr0_bario_t, sizeof(uint32_t));

typedef union pci_hdr0_bario_un {
    pci_hdr0_bario_t	val;
    uint32_t	raw;
}
 pci_hdr0_bario_un;
static inline int pci_hdr0_bario_prtval( char * s, size_t sz, pci_hdr0_bario_t v ) __attribute__ ((always_inline));
static inline int pci_hdr0_bario_prtval( char * s, size_t sz, pci_hdr0_bario_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " space=0x%"PRIx8" (I/O space indicator)\n", (uint8_t)(v.space));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " base=0x%0"PRIx32" (Base address)\n", (uint32_t)(v.base));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register type: Implicit type of Expansion ROM base addr register
 */

/*
 * Dump of fields for register type: pci_hdr0_rom_base_t
 *   enable (size 1, offset 0):	 RW	  ROM address decoder enable
 *   _anon1 (size 10, offset 1):	 RSVD	  _
 *   base (size 21, offset 11):	 RW	  ROM Base address high bits
 */
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(push,1)
#endif
typedef struct pci_hdr0_rom_base_t {
    uint8_t	enable	:1;
    uint16_t	_anon1	:10;
    uint32_t	base	:21;
} __attribute__ ((packed))
 pci_hdr0_rom_base_t;
#if defined(__GNUC__) && (defined(__amd64) || defined(__i386)) && (__GNUC__ <= 4 && __GNUC_MINOR__ <= 3)
#pragma pack(pop)
#endif

STATIC_ASSERT_SIZEOF(pci_hdr0_rom_base_t, sizeof(uint32_t));

typedef union pci_hdr0_rom_base_un {
    pci_hdr0_rom_base_t	val;
    uint32_t	raw;
}
 pci_hdr0_rom_base_un;
static inline int pci_hdr0_rom_base_prtval( char * s, size_t sz, pci_hdr0_rom_base_t v ) __attribute__ ((always_inline));
static inline int pci_hdr0_rom_base_prtval( char * s, size_t sz, pci_hdr0_rom_base_t v )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " enable=0x%"PRIx8" (ROM address decoder enable)\n", (uint8_t)(v.enable));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, " base=0x%0"PRIx32" (ROM Base address high bits)\n", (uint32_t)(v.base));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Device representation structure
 */
typedef struct __DN(t) {
    // Device arguments
    mackerel_pci_t	base;
    // Shadow registers
}
 __DN(t);

/*
 * Device Initialization function
 */
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_pci_t base ) __attribute__ ((always_inline));
static inline void __DN(initialize)( __DN(t) * _dev, mackerel_pci_t base )
{
    /* Setting up device arguments*/
    _dev->base = base;
    /* Setting up shadow registers*/
}

// No user-defined spaces

/*
 * Register vendor_id (Vendor ID); type pci_hdr0.uint16
 */

static inline uint16_t __DP(vendor_id_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(vendor_id_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x0));
}

static inline uint16_t __DP(vendor_id_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(vendor_id_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x0));
}

// Register vendor_id is not writeable


static inline int __DP(vendor_id_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(vendor_id_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register vendor_id (Vendor ID):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_pci_16(_dev->base,(0x0)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register device_id (Device ID); type pci_hdr0.uint16
 */

static inline uint16_t __DP(device_id_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(device_id_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x2));
}

static inline uint16_t __DP(device_id_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(device_id_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x2));
}

// Register device_id is not writeable


static inline int __DP(device_id_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(device_id_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register device_id (Device ID):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_pci_16(_dev->base,(0x2)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register command (Command); type pci_hdr0.command (Implicit type of Command register)
 */

/*
 * Dump of fields for register: command
 *   io_space (size 1, offset 0):	 RW	  I/O space enable
 *   mem_space (size 1, offset 1):	 RW	  Memory space enable
 *   master (size 1, offset 2):	 RW	  Bus master
 *   special (size 1, offset 3):	 RO	  Special cycles
 *   mem_inval (size 1, offset 4):	 RO	  Memory write and invalidate enable
 *   vga_snoop (size 1, offset 5):	 RO	  VGA palette snoop enable
 *   parity (size 1, offset 6):	 RW	  Parity error response
 *   stepping (size 1, offset 7):	 RO	  IDSEL stepping/wait cycle control
 *   serr (size 1, offset 8):	 RW	  SERR# enable
 *   back2back (size 1, offset 9):	 RO	  Fast back-to-back enable
 *   int_dis (size 1, offset 10):	 RW	  Interrupt disable
 *   _anon11 (size 5, offset 11):	 RSVD	  _
 */

static inline uint16_t __DP(command_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(command_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x4));
}

static inline pci_hdr0_command_t __DP(command_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr0_command_t __DP(command_rd)( __DN(t) * _dev )
{
    pci_hdr0_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    return u.val;
}

static inline void __DP(command_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(command_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_pci_16(_dev->base,(0x4),val);
}

static inline void __DP(command_wr)( __DN(t) * _dev, pci_hdr0_command_t val ) __attribute__ ((always_inline));
static inline void __DP(command_wr)( __DN(t) * _dev, pci_hdr0_command_t val )
{
    pci_hdr0_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    u.val.io_space 	= val.io_space;
    u.val.mem_space 	= val.mem_space;
    u.val.master 	= val.master;
    u.val.special 	= val.special;
    u.val.mem_inval 	= val.mem_inval;
    u.val.vga_snoop 	= val.vga_snoop;
    u.val.parity 	= val.parity;
    u.val.stepping 	= val.stepping;
    u.val.serr 	= val.serr;
    u.val.back2back 	= val.back2back;
    u.val.int_dis 	= val.int_dis;
    mackerel_write_pci_16(_dev->base,(0x4),u.raw);
}

static inline void __DP(command_io_space_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(command_io_space_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr0_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    u.val.io_space = val;
    mackerel_write_pci_16(_dev->base,(0x4),u.raw);
}

static inline void __DP(command_mem_space_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(command_mem_space_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr0_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    u.val.mem_space = val;
    mackerel_write_pci_16(_dev->base,(0x4),u.raw);
}

static inline void __DP(command_master_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(command_master_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr0_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    u.val.master = val;
    mackerel_write_pci_16(_dev->base,(0x4),u.raw);
}

static inline void __DP(command_parity_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(command_parity_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr0_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    u.val.parity = val;
    mackerel_write_pci_16(_dev->base,(0x4),u.raw);
}

static inline void __DP(command_serr_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(command_serr_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr0_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    u.val.serr = val;
    mackerel_write_pci_16(_dev->base,(0x4),u.raw);
}

static inline void __DP(command_int_dis_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(command_int_dis_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr0_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    u.val.int_dis = val;
    mackerel_write_pci_16(_dev->base,(0x4),u.raw);
}


static inline int __DP(command_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(command_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr0_command_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x4));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register command (Command):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.io_space;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " io_space =\t0x%"PRIx8" (I/O space enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mem_space;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mem_space =\t0x%"PRIx8" (Memory space enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.master;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " master =\t0x%"PRIx8" (Bus master", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.special;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " special =\t0x%"PRIx8" (Special cycles", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.mem_inval;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " mem_inval =\t0x%"PRIx8" (Memory write and invalidate enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.vga_snoop;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " vga_snoop =\t0x%"PRIx8" (VGA palette snoop enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.parity;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " parity =\t0x%"PRIx8" (Parity error response", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.stepping;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " stepping =\t0x%"PRIx8" (IDSEL stepping/wait cycle control", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.serr;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " serr =\t0x%"PRIx8" (SERR# enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.back2back;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " back2back =\t0x%"PRIx8" (Fast back-to-back enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.int_dis;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " int_dis =\t0x%"PRIx8" (Interrupt disable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    return r;
}


/*
 * Register status (Status); type pci_hdr0.status (Implicit type of Status register)
 */

/*
 * Dump of fields for register: status
 *   _anon0 (size 3, offset 0):	 RSVD	  _
 *   intstat (size 1, offset 3):	 RO	  Interrupt status
 *   caplist (size 1, offset 4):	 RO	  Capabilities list
 *   m66 (size 1, offset 5):	 RO	  66MHz capable
 *   udf (size 1, offset 6):	 RO	  UDF supported
 *   back2back (size 1, offset 7):	 RO	  Fast Back-to-Back enable
 *   md_parity (size 1, offset 8):	 RWC	  Master data parity error
 *   devsel (size 2, offset 9):	 RO	  DEVSEL timing
 *   sig_t_abrt (size 1, offset 11):	 RWC	  Signalled target abort
 *   rx_t_abrt (size 1, offset 12):	 RWC	  Received target abort
 *   rx_m_abrt (size 1, offset 13):	 RWC	  Received master abort
 *   system_err (size 1, offset 14):	 RWC	  Signalled system error
 *   parity_err (size 1, offset 15):	 RWC	  Detected parity error
 */

static inline uint16_t __DP(status_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(status_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x6));
}

static inline pci_hdr0_status_t __DP(status_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr0_status_t __DP(status_rd)( __DN(t) * _dev )
{
    pci_hdr0_status_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    return u.val;
}

static inline void __DP(status_wr_raw)( __DN(t) * _dev, uint16_t val ) __attribute__ ((always_inline));
static inline void __DP(status_wr_raw)( __DN(t) * _dev, uint16_t val )
{
    mackerel_write_pci_16(_dev->base,(0x6),val);
}

static inline void __DP(status_wr)( __DN(t) * _dev, pci_hdr0_status_t val ) __attribute__ ((always_inline));
static inline void __DP(status_wr)( __DN(t) * _dev, pci_hdr0_status_t val )
{
    pci_hdr0_status_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    u.val.intstat 	= val.intstat;
    u.val.caplist 	= val.caplist;
    u.val.m66 	= val.m66;
    u.val.udf 	= val.udf;
    u.val.back2back 	= val.back2back;
    u.val.md_parity 	= val.md_parity;
    u.val.devsel 	= val.devsel;
    u.val.sig_t_abrt 	= val.sig_t_abrt;
    u.val.rx_t_abrt 	= val.rx_t_abrt;
    u.val.rx_m_abrt 	= val.rx_m_abrt;
    u.val.system_err 	= val.system_err;
    u.val.parity_err 	= val.parity_err;
    mackerel_write_pci_16(_dev->base,(0x6),u.raw);
}

static inline void __DP(status_md_parity_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_md_parity_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr0_status_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    u.val.md_parity = val;
    mackerel_write_pci_16(_dev->base,(0x6),u.raw);
}

static inline void __DP(status_sig_t_abrt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_sig_t_abrt_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr0_status_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    u.val.sig_t_abrt = val;
    mackerel_write_pci_16(_dev->base,(0x6),u.raw);
}

static inline void __DP(status_rx_t_abrt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_rx_t_abrt_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr0_status_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    u.val.rx_t_abrt = val;
    mackerel_write_pci_16(_dev->base,(0x6),u.raw);
}

static inline void __DP(status_rx_m_abrt_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_rx_m_abrt_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr0_status_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    u.val.rx_m_abrt = val;
    mackerel_write_pci_16(_dev->base,(0x6),u.raw);
}

static inline void __DP(status_system_err_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_system_err_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr0_status_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    u.val.system_err = val;
    mackerel_write_pci_16(_dev->base,(0x6),u.raw);
}

static inline void __DP(status_parity_err_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(status_parity_err_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr0_status_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    u.val.parity_err = val;
    mackerel_write_pci_16(_dev->base,(0x6),u.raw);
}


static inline int __DP(status_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(status_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr0_status_un  u;
    u.raw = mackerel_read_pci_16(_dev->base,(0x6));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register status (Status):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.intstat;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " intstat =\t0x%"PRIx8" (Interrupt status", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.caplist;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " caplist =\t0x%"PRIx8" (Capabilities list", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.m66;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " m66 =\t0x%"PRIx8" (66MHz capable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.udf;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " udf =\t0x%"PRIx8" (UDF supported", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.back2back;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " back2back =\t0x%"PRIx8" (Fast Back-to-Back enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.md_parity;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " md_parity =\t0x%"PRIx8" (Master data parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.devsel;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " devsel =\t0x%"PRIx8" (DEVSEL timing", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.sig_t_abrt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " sig_t_abrt =\t0x%"PRIx8" (Signalled target abort", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rx_t_abrt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rx_t_abrt =\t0x%"PRIx8" (Received target abort", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.rx_m_abrt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " rx_m_abrt =\t0x%"PRIx8" (Received master abort", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.system_err;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " system_err =\t0x%"PRIx8" (Signalled system error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.parity_err;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " parity_err =\t0x%"PRIx8" (Detected parity error", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register rev_id (Revision ID); type pci_hdr0.uint8
 */

static inline uint8_t __DP(rev_id_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(rev_id_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x8));
}

static inline uint8_t __DP(rev_id_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(rev_id_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x8));
}

// Register rev_id is not writeable


static inline int __DP(rev_id_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rev_id_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rev_id (Revision ID):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_pci_8(_dev->base,(0x8)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register class_code (Class code); type pci_hdr0.class_code (Implicit type of Class code register)
 */

/*
 * Dump of fields for register: class_code
 *   _anon0 (size 8, offset 0):	 RSVD	  _
 *   prog_if (size 8, offset 8):	 RO	  Programming intf
 *   subclss (size 8, offset 16):	 RO	  Subclass code
 *   clss (size 8, offset 24):	 RO	  Class code
 */

static inline uint32_t __DP(class_code_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(class_code_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x8));
}

static inline pci_hdr0_class_code_t __DP(class_code_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr0_class_code_t __DP(class_code_rd)( __DN(t) * _dev )
{
    pci_hdr0_class_code_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x8));
    return u.val;
}

// Register class_code is not writeable


static inline int __DP(class_code_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(class_code_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr0_class_code_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x8));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register class_code (Class code):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.prog_if;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " prog_if =\t0x%"PRIx8" (Programming intf", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.subclss;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " subclss =\t0x%"PRIx8" (Subclass code", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.clss;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " clss =\t0x%"PRIx8" (Class code", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = pci_hdr0_classcode_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register cache_sz (Cache line size); type pci_hdr0.uint8
 */

static inline uint8_t __DP(cache_sz_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(cache_sz_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0xc));
}

static inline uint8_t __DP(cache_sz_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(cache_sz_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0xc));
}

static inline void __DP(cache_sz_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cache_sz_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_pci_8(_dev->base,(0xc),val);
}

static inline void __DP(cache_sz_wr)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(cache_sz_wr)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_pci_8(_dev->base,(0xc),val);
}


static inline int __DP(cache_sz_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cache_sz_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cache_sz (Cache line size):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_pci_8(_dev->base,(0xc)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register latency (Master latency timer); type pci_hdr0.uint8
 */

static inline uint8_t __DP(latency_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(latency_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0xd));
}

static inline uint8_t __DP(latency_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(latency_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0xd));
}

static inline void __DP(latency_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(latency_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_pci_8(_dev->base,(0xd),val);
}

static inline void __DP(latency_wr)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(latency_wr)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_pci_8(_dev->base,(0xd),val);
}


static inline int __DP(latency_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(latency_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register latency (Master latency timer):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_pci_8(_dev->base,(0xd)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register hdr_type (Header type); type pci_hdr0.hdr_type (Implicit type of Header type register)
 */

/*
 * Dump of fields for register: hdr_type
 *   fmt (size 7, offset 0):	 RO	  Configuration header format
 *   multi (size 1, offset 7):	 RO	  Multifunction device
 */

static inline uint8_t __DP(hdr_type_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(hdr_type_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0xe));
}

static inline pci_hdr0_hdr_type_t __DP(hdr_type_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr0_hdr_type_t __DP(hdr_type_rd)( __DN(t) * _dev )
{
    pci_hdr0_hdr_type_un  u;
    u.raw = mackerel_read_pci_8(_dev->base,(0xe));
    return u.val;
}

// Register hdr_type is not writeable


static inline int __DP(hdr_type_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(hdr_type_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr0_hdr_type_un  u;
    u.raw = mackerel_read_pci_8(_dev->base,(0xe));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register hdr_type (Header type):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.fmt;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " fmt =\t0x%"PRIx8" (Configuration header format", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ": ");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = pci_hdr0_hdrtype_prt(s+r, _avail, pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.multi;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " multi =\t0x%"PRIx8" (Multifunction device", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register bist (Built-in self-test); type pci_hdr0.bist (Implicit type of Built-in self-test register)
 */

/*
 * Dump of fields for register: bist
 *   comp (size 4, offset 0):	 RO	  Completion code
 *   _anon4 (size 2, offset 4):	 RSVD	  _
 *   start (size 1, offset 6):	 RW	  Start BIST
 *   cap (size 1, offset 7):	 RO	  BIST capable
 */

static inline uint8_t __DP(bist_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(bist_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0xf));
}

static inline pci_hdr0_bist_t __DP(bist_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr0_bist_t __DP(bist_rd)( __DN(t) * _dev )
{
    pci_hdr0_bist_un  u;
    u.raw = mackerel_read_pci_8(_dev->base,(0xf));
    return u.val;
}

static inline void __DP(bist_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(bist_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_pci_8(_dev->base,(0xf),val);
}

static inline void __DP(bist_wr)( __DN(t) * _dev, pci_hdr0_bist_t val ) __attribute__ ((always_inline));
static inline void __DP(bist_wr)( __DN(t) * _dev, pci_hdr0_bist_t val )
{
    pci_hdr0_bist_un  u;
    u.raw = mackerel_read_pci_8(_dev->base,(0xf));
    u.val.comp 	= val.comp;
    u.val.start 	= val.start;
    u.val.cap 	= val.cap;
    mackerel_write_pci_8(_dev->base,(0xf),u.raw);
}

static inline void __DP(bist_start_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(bist_start_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr0_bist_un  u;
    u.raw = mackerel_read_pci_8(_dev->base,(0xf));
    u.val.start = val;
    mackerel_write_pci_8(_dev->base,(0xf),u.raw);
}


static inline int __DP(bist_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(bist_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr0_bist_un  u;
    u.raw = mackerel_read_pci_8(_dev->base,(0xf));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register bist (Built-in self-test):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.comp;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " comp =\t0x%"PRIx8" (Completion code", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint8_t pv = (uint8_t)u.val.start;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " start =\t0x%"PRIx8" (Start BIST", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    {
        uint8_t pv = (uint8_t)u.val.cap;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " cap =\t0x%"PRIx8" (BIST capable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register bars (Base address registers); type pci_hdr0.uint32
 */
static const int __DP(bars_length) = 0x5;
static inline uint32_t __DP(bars_rd_raw)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(bars_rd_raw)( __DN(t) * _dev, int _i )
{
    return mackerel_read_pci_32(_dev->base,(0x10) + (_i *(32/8)));
}

static inline uint32_t __DP(bars_rd)( __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline uint32_t __DP(bars_rd)( __DN(t) * _dev, int _i )
{
    return mackerel_read_pci_32(_dev->base,(0x10) + (_i *(32/8)));
}

static inline void __DP(bars_wr_raw)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(bars_wr_raw)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x10) + (_i *(32/8)),val);
}

static inline void __DP(bars_wr)( __DN(t) * _dev, int _i, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(bars_wr)( __DN(t) * _dev, int _i, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x10) + (_i *(32/8)),val);
}


static inline int __DP(bars_pri)( char * s, size_t sz, __DN(t) * _dev, int _i ) __attribute__ ((always_inline));
static inline int __DP(bars_pri)( char * s, size_t sz, __DN(t) * _dev, int _i )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "Register bars[%d] (Base address registers):", _i);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_pci_32(_dev->base,(0x10) + (_i *(32/8))));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}
static inline int __DP(bars_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(bars_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    for( int _i=0; _i < 0x5; _i++ ) {
        _avail = (r > sz) ? 0 : sz-r;
        _rc = __DP(bars_pri)(s+r, _avail, _dev, _i);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register cardbus (CardBus CIS ptr); type pci_hdr0.uint32
 */

static inline uint32_t __DP(cardbus_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(cardbus_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x28));
}

static inline uint32_t __DP(cardbus_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(cardbus_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x28));
}

// Register cardbus is not writeable


static inline int __DP(cardbus_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cardbus_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cardbus (CardBus CIS ptr):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx32"\n", mackerel_read_pci_32(_dev->base,(0x28)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register subsys_vid (Subsystem vendor ID); type pci_hdr0.uint16
 */

static inline uint16_t __DP(subsys_vid_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(subsys_vid_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x2c));
}

static inline uint16_t __DP(subsys_vid_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(subsys_vid_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x2c));
}

// Register subsys_vid is not writeable


static inline int __DP(subsys_vid_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(subsys_vid_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register subsys_vid (Subsystem vendor ID):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_pci_16(_dev->base,(0x2c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register subsys_id (Subsystem ID); type pci_hdr0.uint16
 */

static inline uint16_t __DP(subsys_id_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(subsys_id_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x2e));
}

static inline uint16_t __DP(subsys_id_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint16_t __DP(subsys_id_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_16(_dev->base,(0x2e));
}

// Register subsys_id is not writeable


static inline int __DP(subsys_id_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(subsys_id_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register subsys_id (Subsystem ID):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%0"PRIx16"\n", mackerel_read_pci_16(_dev->base,(0x2e)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register rom_base (Expansion ROM base addr); type pci_hdr0.rom_base (Implicit type of Expansion ROM base addr register)
 */

/*
 * Dump of fields for register: rom_base
 *   enable (size 1, offset 0):	 RW	  ROM address decoder enable
 *   _anon1 (size 10, offset 1):	 RSVD	  _
 *   base (size 21, offset 11):	 RW	  ROM Base address high bits
 */

static inline uint32_t __DP(rom_base_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint32_t __DP(rom_base_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_32(_dev->base,(0x30));
}

static inline pci_hdr0_rom_base_t __DP(rom_base_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline pci_hdr0_rom_base_t __DP(rom_base_rd)( __DN(t) * _dev )
{
    pci_hdr0_rom_base_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x30));
    return u.val;
}

static inline void __DP(rom_base_wr_raw)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rom_base_wr_raw)( __DN(t) * _dev, uint32_t val )
{
    mackerel_write_pci_32(_dev->base,(0x30),val);
}

static inline void __DP(rom_base_wr)( __DN(t) * _dev, pci_hdr0_rom_base_t val ) __attribute__ ((always_inline));
static inline void __DP(rom_base_wr)( __DN(t) * _dev, pci_hdr0_rom_base_t val )
{
    pci_hdr0_rom_base_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x30));
    u.val.enable 	= val.enable;
    u.val.base 	= val.base;
    mackerel_write_pci_32(_dev->base,(0x30),u.raw);
}

static inline void __DP(rom_base_enable_wrf)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(rom_base_enable_wrf)( __DN(t) * _dev, uint8_t val )
{
    pci_hdr0_rom_base_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x30));
    u.val.enable = val;
    mackerel_write_pci_32(_dev->base,(0x30),u.raw);
}

static inline void __DP(rom_base_base_wrf)( __DN(t) * _dev, uint32_t val ) __attribute__ ((always_inline));
static inline void __DP(rom_base_base_wrf)( __DN(t) * _dev, uint32_t val )
{
    pci_hdr0_rom_base_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x30));
    u.val.base = val;
    mackerel_write_pci_32(_dev->base,(0x30),u.raw);
}


static inline int __DP(rom_base_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(rom_base_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    pci_hdr0_rom_base_un  u;
    u.raw = mackerel_read_pci_32(_dev->base,(0x30));
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register rom_base (Expansion ROM base addr):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    {
        uint8_t pv = (uint8_t)u.val.enable;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " enable =\t0x%"PRIx8" (ROM address decoder enable", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    // skipping anonymous field
    {
        uint32_t pv = (uint32_t)u.val.base;
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, " base =\t0x%0"PRIx32" (ROM Base address high bits", pv);
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
        _avail = (r > sz) ? 0 : sz-r;
        _rc = snprintf(s+r, _avail, "%s", ")\n");
        if ( _rc > 0 && _rc < _avail) { r += _rc; }
    }
    return r;
}


/*
 * Register cap_ptr (Capabilities ptr); type pci_hdr0.uint8
 */

static inline uint8_t __DP(cap_ptr_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(cap_ptr_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x34));
}

static inline uint8_t __DP(cap_ptr_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(cap_ptr_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x34));
}

// Register cap_ptr is not writeable


static inline int __DP(cap_ptr_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(cap_ptr_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register cap_ptr (Capabilities ptr):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_pci_8(_dev->base,(0x34)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register int_line (Interrupt line); type pci_hdr0.uint8
 */

static inline uint8_t __DP(int_line_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(int_line_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x3c));
}

static inline uint8_t __DP(int_line_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(int_line_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x3c));
}

static inline void __DP(int_line_wr_raw)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(int_line_wr_raw)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_pci_8(_dev->base,(0x3c),val);
}

static inline void __DP(int_line_wr)( __DN(t) * _dev, uint8_t val ) __attribute__ ((always_inline));
static inline void __DP(int_line_wr)( __DN(t) * _dev, uint8_t val )
{
    mackerel_write_pci_8(_dev->base,(0x3c),val);
}


static inline int __DP(int_line_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(int_line_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register int_line (Interrupt line):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_pci_8(_dev->base,(0x3c)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register int_pin (Interrupt pin); type pci_hdr0.uint8
 */

static inline uint8_t __DP(int_pin_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(int_pin_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x3d));
}

static inline uint8_t __DP(int_pin_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(int_pin_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x3d));
}

// Register int_pin is not writeable


static inline int __DP(int_pin_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(int_pin_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register int_pin (Interrupt pin):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_pci_8(_dev->base,(0x3d)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register min_gnt (Min Gnt); type pci_hdr0.uint8
 */

static inline uint8_t __DP(min_gnt_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(min_gnt_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x3e));
}

static inline uint8_t __DP(min_gnt_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(min_gnt_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x3e));
}

// Register min_gnt is not writeable


static inline int __DP(min_gnt_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(min_gnt_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register min_gnt (Min Gnt):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_pci_8(_dev->base,(0x3e)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}


/*
 * Register max_lat (Max Lat); type pci_hdr0.uint8
 */

static inline uint8_t __DP(max_lat_rd_raw)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(max_lat_rd_raw)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x3f));
}

static inline uint8_t __DP(max_lat_rd)( __DN(t) * _dev ) __attribute__ ((always_inline));
static inline uint8_t __DP(max_lat_rd)( __DN(t) * _dev )
{
    return mackerel_read_pci_8(_dev->base,(0x3f));
}

// Register max_lat is not writeable


static inline int __DP(max_lat_pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(max_lat_pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    // register is primitive type
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Register max_lat (Max Lat):");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "\t0x%"PRIx8"\n", mackerel_read_pci_8(_dev->base,(0x3f)));
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev ) __attribute__ ((always_inline));
static inline int __DP(pr)( char * s, size_t sz, __DN(t) * _dev )
{
    int r=0;
    int _avail, _rc;
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "Dump of device pci_hdr0 (PCI Type 0 Configuration):\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(vendor_id_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(device_id_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(command_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(status_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rev_id_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(class_code_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cache_sz_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(latency_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(hdr_type_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(bist_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(bars_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cardbus_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(subsys_vid_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(subsys_id_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(rom_base_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(cap_ptr_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(int_line_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(int_pin_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(min_gnt_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = __DP(max_lat_pr)(s+r, _avail, _dev);
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "End of dump of device pci_hdr0\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    _avail = (r > sz) ? 0 : sz-r;
    _rc = snprintf(s+r, _avail, "%s", "-------------------------\n");
    if ( _rc > 0 && _rc < _avail) { r += _rc; }
    return r;
}

#undef __DN
#undef __DP
#undef __DP1
#undef __DP2
#undef __STR
#undef __XTR


#endif // __pci_hdr0_H
