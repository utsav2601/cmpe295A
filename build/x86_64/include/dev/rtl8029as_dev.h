#ifndef __rtl8029as_DEV_H
#define __rtl8029as_DEV_H 1
/*
 * DEVICE DEFINITION: RTL8029AS Ethernet Controller
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) rtl8029as ## _ ## x
/*
 * Constants defn: rtl8029as.rd (Remote read/write)
 *  - no width specified
 */
typedef uint8_t rtl8029as_rd_t;
#define rtl8029as_notallowed ((rtl8029as_rd_t)0x0)
#define rtl8029as_rrd ((rtl8029as_rd_t)0x1)
#define rtl8029as_rwr ((rtl8029as_rd_t)0x2)
#define rtl8029as_sp ((rtl8029as_rd_t)0x3)
#define rtl8029as_acrdma ((rtl8029as_rd_t)0x4)

static inline char *rtl8029as_rd_describe(rtl8029as_rd_t _e) __attribute__ ((always_inline));
static inline char *rtl8029as_rd_describe(rtl8029as_rd_t _e)
{
    switch (_e) {
    case rtl8029as_notallowed:
        return("notallowed: Not allowed");
    case rtl8029as_rrd:
        return("rrd: Remote read");
    case rtl8029as_rwr:
        return("rwr: Remote write");
    case rtl8029as_sp:
        return("sp: Send packet");
    case rtl8029as_acrdma:
        return("acrdma: Abort/Complete remote DMA");
    default:
        return(NULL);
    }
}

static inline int rtl8029as_rd_prtval(char *_s, size_t _size, rtl8029as_rd_t _e) __attribute__ ((always_inline));
static inline int rtl8029as_rd_prtval(char *_s, size_t _size, rtl8029as_rd_t _e)
{
    char *d = rtl8029as_rd_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "rtl8029as_rd_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: rtl8029as.ps (Page identification)
 *  - no width specified
 */
typedef uint8_t rtl8029as_ps_t;
#define rtl8029as_ne2000p0 ((rtl8029as_ps_t)0x0)
#define rtl8029as_ne2000p1 ((rtl8029as_ps_t)0x1)
#define rtl8029as_ne2000p2 ((rtl8029as_ps_t)0x2)
#define rtl8029as_rtl8029as ((rtl8029as_ps_t)0x3)

static inline char *rtl8029as_ps_describe(rtl8029as_ps_t _e) __attribute__ ((always_inline));
static inline char *rtl8029as_ps_describe(rtl8029as_ps_t _e)
{
    switch (_e) {
    case rtl8029as_ne2000p0:
        return("ne2000p0: NE2000 compatible page 0");
    case rtl8029as_ne2000p1:
        return("ne2000p1: NE2000 compatible page 1");
    case rtl8029as_ne2000p2:
        return("ne2000p2: NE2000 compatible page 2");
    case rtl8029as_rtl8029as:
        return("rtl8029as: RTL8029AS configuration page 3");
    default:
        return(NULL);
    }
}

static inline int rtl8029as_ps_prtval(char *_s, size_t _size, rtl8029as_ps_t _e) __attribute__ ((always_inline));
static inline int rtl8029as_ps_prtval(char *_s, size_t _size, rtl8029as_ps_t _e)
{
    char *d = rtl8029as_ps_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "rtl8029as_ps_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: rtl8029as.lpconf (Loopback configuration)
 *  - no width specified
 */
typedef uint8_t rtl8029as_lpconf_t;
#define rtl8029as_normal ((rtl8029as_lpconf_t)0x0)
#define rtl8029as_internal ((rtl8029as_lpconf_t)0x1)
#define rtl8029as_external ((rtl8029as_lpconf_t)0x2)
#define rtl8029as_external1 ((rtl8029as_lpconf_t)0x3)

static inline char *rtl8029as_lpconf_describe(rtl8029as_lpconf_t _e) __attribute__ ((always_inline));
static inline char *rtl8029as_lpconf_describe(rtl8029as_lpconf_t _e)
{
    switch (_e) {
    case rtl8029as_normal:
        return("normal: Normal operation");
    case rtl8029as_internal:
        return("internal: Internal loopback");
    case rtl8029as_external:
        return("external: External loopback");
    case rtl8029as_external1:
        return("external1: External loopback");
    default:
        return(NULL);
    }
}

static inline int rtl8029as_lpconf_prtval(char *_s, size_t _size, rtl8029as_lpconf_t _e) __attribute__ ((always_inline));
static inline int rtl8029as_lpconf_prtval(char *_s, size_t _size, rtl8029as_lpconf_t _e)
{
    char *d = rtl8029as_lpconf_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "rtl8029as_lpconf_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: rtl8029as.mode (RTL8029AS operating mode)
 *  - no width specified
 */
typedef uint8_t rtl8029as_mode_t;
#define rtl8029as_opnormal ((rtl8029as_mode_t)0x0)
#define rtl8029as_autoload ((rtl8029as_mode_t)0x1)
#define rtl8029as_programming ((rtl8029as_mode_t)0x2)
#define rtl8029as_configwrite ((rtl8029as_mode_t)0x3)

static inline char *rtl8029as_mode_describe(rtl8029as_mode_t _e) __attribute__ ((always_inline));
static inline char *rtl8029as_mode_describe(rtl8029as_mode_t _e)
{
    switch (_e) {
    case rtl8029as_opnormal:
        return("opnormal: Normal (DP8390 compatible)");
    case rtl8029as_autoload:
        return("autoload: Auto-load 9346");
    case rtl8029as_programming:
        return("programming: 9346 programming");
    case rtl8029as_configwrite:
        return("configwrite: Config register write enable");
    default:
        return(NULL);
    }
}

static inline int rtl8029as_mode_prtval(char *_s, size_t _size, rtl8029as_mode_t _e) __attribute__ ((always_inline));
static inline int rtl8029as_mode_prtval(char *_s, size_t _size, rtl8029as_mode_t _e)
{
    char *d = rtl8029as_mode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "rtl8029as_mode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: rtl8029as.bromsize (Boot ROM Size)
 *  - no width specified
 */
typedef uint8_t rtl8029as_bromsize_t;
#define rtl8029as_nobrom ((rtl8029as_bromsize_t)0x0)
#define rtl8029as_size8k ((rtl8029as_bromsize_t)0x1)
#define rtl8029as_size16k ((rtl8029as_bromsize_t)0x2)
#define rtl8029as_size32k ((rtl8029as_bromsize_t)0x3)

static inline char *rtl8029as_bromsize_describe(rtl8029as_bromsize_t _e) __attribute__ ((always_inline));
static inline char *rtl8029as_bromsize_describe(rtl8029as_bromsize_t _e)
{
    switch (_e) {
    case rtl8029as_nobrom:
        return("nobrom: No Boot ROM");
    case rtl8029as_size8k:
        return("size8k: 8K Boot ROM");
    case rtl8029as_size16k:
        return("size16k: 16K Boot ROM");
    case rtl8029as_size32k:
        return("size32k: 32K Boot ROM");
    default:
        return(NULL);
    }
}

static inline int rtl8029as_bromsize_prtval(char *_s, size_t _size, rtl8029as_bromsize_t _e) __attribute__ ((always_inline));
static inline int rtl8029as_bromsize_prtval(char *_s, size_t _size, rtl8029as_bromsize_t _e)
{
    char *d = rtl8029as_bromsize_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "rtl8029as_bromsize_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: rtl8029as.medium (Network Medium)
 *  - no width specified
 */
typedef uint8_t rtl8029as_medium_t;
#define rtl8029as_auto ((rtl8029as_medium_t)0x0)
#define rtl8029as_tenbaset ((rtl8029as_medium_t)0x1)
#define rtl8029as_tenbase5 ((rtl8029as_medium_t)0x2)
#define rtl8029as_tenbase2 ((rtl8029as_medium_t)0x3)

static inline char *rtl8029as_medium_describe(rtl8029as_medium_t _e) __attribute__ ((always_inline));
static inline char *rtl8029as_medium_describe(rtl8029as_medium_t _e)
{
    switch (_e) {
    case rtl8029as_auto:
        return("auto: TP/CX auto-detect");
    case rtl8029as_tenbaset:
        return("tenbaset: 10BaseT");
    case rtl8029as_tenbase5:
        return("tenbase5: 10Base5");
    case rtl8029as_tenbase2:
        return("tenbase2: 10Base2");
    default:
        return(NULL);
    }
}

static inline int rtl8029as_medium_prtval(char *_s, size_t _size, rtl8029as_medium_t _e) __attribute__ ((always_inline));
static inline int rtl8029as_medium_prtval(char *_s, size_t _size, rtl8029as_medium_t _e)
{
    char *d = rtl8029as_medium_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "rtl8029as_medium_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: rtl8029as.leds (LED Control)
 *  - no width specified
 */
typedef uint8_t rtl8029as_leds_t;
#define rtl8029as_rxcol ((rtl8029as_leds_t)0x0)
#define rtl8029as_rxlink ((rtl8029as_leds_t)0x1)
#define rtl8029as_crscol ((rtl8029as_leds_t)0x2)
#define rtl8029as_crslink ((rtl8029as_leds_t)0x3)

static inline char *rtl8029as_leds_describe(rtl8029as_leds_t _e) __attribute__ ((always_inline));
static inline char *rtl8029as_leds_describe(rtl8029as_leds_t _e)
{
    switch (_e) {
    case rtl8029as_rxcol:
        return("rxcol: RX and COL");
    case rtl8029as_rxlink:
        return("rxlink: RX and LINK");
    case rtl8029as_crscol:
        return("crscol: CRS and COL");
    case rtl8029as_crslink:
        return("crslink: CRS and LINK");
    default:
        return(NULL);
    }
}

static inline int rtl8029as_leds_prtval(char *_s, size_t _size, rtl8029as_leds_t _e) __attribute__ ((always_inline));
static inline int rtl8029as_leds_prtval(char *_s, size_t _size, rtl8029as_leds_t _e)
{
    char *d = rtl8029as_leds_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "rtl8029as_leds_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: rtl8029as.clock (Halt Clock Mode)
 *  - no width specified
 */
typedef uint8_t rtl8029as_clock_t;
#define rtl8029as_running ((rtl8029as_clock_t)0x52)
#define rtl8029as_halted ((rtl8029as_clock_t)0x48)

static inline char *rtl8029as_clock_describe(rtl8029as_clock_t _e) __attribute__ ((always_inline));
static inline char *rtl8029as_clock_describe(rtl8029as_clock_t _e)
{
    switch (_e) {
    case rtl8029as_running:
        return("running: Running");
    case rtl8029as_halted:
        return("halted: Halted");
    default:
        return(NULL);
    }
}

static inline int rtl8029as_clock_prtval(char *_s, size_t _size, rtl8029as_clock_t _e) __attribute__ ((always_inline));
static inline int rtl8029as_clock_prtval(char *_s, size_t _size, rtl8029as_clock_t _e)
{
    char *d = rtl8029as_clock_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "rtl8029as_clock_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: rtl8029as_irq_t
 * Description: Interrupts
 * Fields:
 *   prx	(size 1, offset 0, init 0):	NOATTR	Packet received correctly
 *   ptx	(size 1, offset 1, init 0):	NOATTR	Packet transmitted correctly
 *   rxe	(size 1, offset 2, init 0):	NOATTR	Packet receive error
 *   txe	(size 1, offset 3, init 0):	NOATTR	Packet sent aborted (excessive collisions)
 *   ovw	(size 1, offset 4, init 0):	NOATTR	Receive buffer exhausted
 *   cnt	(size 1, offset 5, init 0):	NOATTR	MSB of one or more network tally counters is set
 *   rdc	(size 1, offset 6, init 0):	NOATTR	Remote DMA operation completed
 *   rst	(size 1, offset 7, init 0):	NOATTR	Reset state / Receive buffer overflow
 */
typedef uint8_t rtl8029as_irq_t;
#define rtl8029as_irq_default 0x0
static inline uint8_t rtl8029as_irq_prx_extract(rtl8029as_irq_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_irq_prx_extract(rtl8029as_irq_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline rtl8029as_irq_t rtl8029as_irq_prx_insert(rtl8029as_irq_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_irq_t rtl8029as_irq_prx_insert(rtl8029as_irq_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((rtl8029as_irq_t )(_fieldval)) << 0)));
}

static inline uint8_t rtl8029as_irq_ptx_extract(rtl8029as_irq_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_irq_ptx_extract(rtl8029as_irq_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline rtl8029as_irq_t rtl8029as_irq_ptx_insert(rtl8029as_irq_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_irq_t rtl8029as_irq_ptx_insert(rtl8029as_irq_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((rtl8029as_irq_t )(_fieldval)) << 1)));
}

static inline uint8_t rtl8029as_irq_rxe_extract(rtl8029as_irq_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_irq_rxe_extract(rtl8029as_irq_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline rtl8029as_irq_t rtl8029as_irq_rxe_insert(rtl8029as_irq_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_irq_t rtl8029as_irq_rxe_insert(rtl8029as_irq_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((rtl8029as_irq_t )(_fieldval)) << 2)));
}

static inline uint8_t rtl8029as_irq_txe_extract(rtl8029as_irq_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_irq_txe_extract(rtl8029as_irq_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline rtl8029as_irq_t rtl8029as_irq_txe_insert(rtl8029as_irq_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_irq_t rtl8029as_irq_txe_insert(rtl8029as_irq_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((rtl8029as_irq_t )(_fieldval)) << 3)));
}

static inline uint8_t rtl8029as_irq_ovw_extract(rtl8029as_irq_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_irq_ovw_extract(rtl8029as_irq_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline rtl8029as_irq_t rtl8029as_irq_ovw_insert(rtl8029as_irq_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_irq_t rtl8029as_irq_ovw_insert(rtl8029as_irq_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((rtl8029as_irq_t )(_fieldval)) << 4)));
}

static inline uint8_t rtl8029as_irq_cnt_extract(rtl8029as_irq_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_irq_cnt_extract(rtl8029as_irq_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline rtl8029as_irq_t rtl8029as_irq_cnt_insert(rtl8029as_irq_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_irq_t rtl8029as_irq_cnt_insert(rtl8029as_irq_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdf) | (0x20 & (((rtl8029as_irq_t )(_fieldval)) << 5)));
}

static inline uint8_t rtl8029as_irq_rdc_extract(rtl8029as_irq_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_irq_rdc_extract(rtl8029as_irq_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline rtl8029as_irq_t rtl8029as_irq_rdc_insert(rtl8029as_irq_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_irq_t rtl8029as_irq_rdc_insert(rtl8029as_irq_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbf) | (0x40 & (((rtl8029as_irq_t )(_fieldval)) << 6)));
}

static inline uint8_t rtl8029as_irq_rst_extract(rtl8029as_irq_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_irq_rst_extract(rtl8029as_irq_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline rtl8029as_irq_t rtl8029as_irq_rst_insert(rtl8029as_irq_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_irq_t rtl8029as_irq_rst_insert(rtl8029as_irq_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7f) | (0x80 & (((rtl8029as_irq_t )(_fieldval)) << 7)));
}

static inline int rtl8029as_irq_prtval(char *_s, size_t _size, rtl8029as_irq_t _regval) __attribute__ ((always_inline));
static inline int rtl8029as_irq_prtval(char *_s, size_t _size, rtl8029as_irq_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prx =\t%" PRIx8 "\t(Packet received correctly)\n", rtl8029as_irq_prx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ptx =\t%" PRIx8 "\t(Packet transmitted correctly)\n", rtl8029as_irq_ptx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxe =\t%" PRIx8 "\t(Packet receive error)\n", rtl8029as_irq_rxe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txe =\t%" PRIx8 "\t(Packet sent aborted (excessive collisions))\n", rtl8029as_irq_txe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ovw =\t%" PRIx8 "\t(Receive buffer exhausted)\n", rtl8029as_irq_ovw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cnt =\t%" PRIx8 "\t(MSB of one or more network tally counters is set)\n", rtl8029as_irq_cnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rdc =\t%" PRIx8 "\t(Remote DMA operation completed)\n", rtl8029as_irq_rdc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rst =\t%" PRIx8 "\t(Reset state / Receive buffer overflow)\n", rtl8029as_irq_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: rtl8029as_cr_t
 * Description: Implicit type of Command register
 * Fields:
 *   stp	(size 1, offset 0, init 0):	RW	Stop command
 *   sta	(size 1, offset 1, init 0):	RW	Start command
 *   txp	(size 1, offset 2, init 0):	RW	Transmit packet
 *   rd	(size 3, offset 3, init 0):	RW	Remote read/write
 *   ps	(size 2, offset 6, init 0):	RW	Page identification
 */
typedef uint8_t rtl8029as_cr_t;
#define rtl8029as_cr_default 0x0
static inline uint8_t rtl8029as_cr_stp_extract(rtl8029as_cr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cr_stp_extract(rtl8029as_cr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline rtl8029as_cr_t rtl8029as_cr_stp_insert(rtl8029as_cr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_cr_t rtl8029as_cr_stp_insert(rtl8029as_cr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((rtl8029as_cr_t )(_fieldval)) << 0)));
}

static inline uint8_t rtl8029as_cr_sta_extract(rtl8029as_cr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cr_sta_extract(rtl8029as_cr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline rtl8029as_cr_t rtl8029as_cr_sta_insert(rtl8029as_cr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_cr_t rtl8029as_cr_sta_insert(rtl8029as_cr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((rtl8029as_cr_t )(_fieldval)) << 1)));
}

static inline uint8_t rtl8029as_cr_txp_extract(rtl8029as_cr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cr_txp_extract(rtl8029as_cr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline rtl8029as_cr_t rtl8029as_cr_txp_insert(rtl8029as_cr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_cr_t rtl8029as_cr_txp_insert(rtl8029as_cr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((rtl8029as_cr_t )(_fieldval)) << 2)));
}

static inline rtl8029as_rd_t rtl8029as_cr_rd_extract(rtl8029as_cr_t _regval) __attribute__ ((always_inline));
static inline rtl8029as_rd_t rtl8029as_cr_rd_extract(rtl8029as_cr_t _regval)
{
    return((rtl8029as_rd_t )((_regval & 0x38) >> 3));
}

static inline rtl8029as_cr_t rtl8029as_cr_rd_insert(rtl8029as_cr_t _regval, rtl8029as_rd_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_cr_t rtl8029as_cr_rd_insert(rtl8029as_cr_t _regval, rtl8029as_rd_t _fieldval)
{
    return((_regval & 0xc7) | (0x38 & (((rtl8029as_cr_t )(_fieldval)) << 3)));
}

static inline rtl8029as_ps_t rtl8029as_cr_ps_extract(rtl8029as_cr_t _regval) __attribute__ ((always_inline));
static inline rtl8029as_ps_t rtl8029as_cr_ps_extract(rtl8029as_cr_t _regval)
{
    return((rtl8029as_ps_t )((_regval & 0xc0) >> 6));
}

static inline rtl8029as_cr_t rtl8029as_cr_ps_insert(rtl8029as_cr_t _regval, rtl8029as_ps_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_cr_t rtl8029as_cr_ps_insert(rtl8029as_cr_t _regval, rtl8029as_ps_t _fieldval)
{
    return((_regval & 0x3f) | (0xc0 & (((rtl8029as_cr_t )(_fieldval)) << 6)));
}

static inline int rtl8029as_cr_prtval(char *_s, size_t _size, rtl8029as_cr_t _regval) __attribute__ ((always_inline));
static inline int rtl8029as_cr_prtval(char *_s, size_t _size, rtl8029as_cr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stp =\t%" PRIx8 "\t(Stop command)\n", rtl8029as_cr_stp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sta =\t%" PRIx8 "\t(Start command)\n", rtl8029as_cr_sta_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txp =\t%" PRIx8 "\t(Transmit packet)\n", rtl8029as_cr_txp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rd =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_rd_prtval(_s + _r, _avail, rtl8029as_cr_rd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Remote read/write)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ps =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_ps_prtval(_s + _r, _avail, rtl8029as_cr_ps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Page identification)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: rtl8029as_dcr_t
 * Description: Implicit type of Data Configuration register
 * Fields:
 *   wts	(size 1, offset 0, init 0):	RW	Word transfer select
 *   bos	(size 1, offset 1, init 0):	RW	Byte order select
 *   _anon2	(size 1, offset 2, init 0):	MBZ	_
 *   ls	(size 1, offset 3, init 0):	RW	Loopback select
 *   arm	(size 1, offset 4, init 0):	RW	Auto-Initialize remote
 *   ft	(size 2, offset 5, init 0):	RW	FIFO threshold select
 *   _anon7	(size 1, offset 7, init 1):	MB1	_
 */
typedef uint8_t rtl8029as_dcr_t;
#define rtl8029as_dcr_default 0x80
static inline uint8_t rtl8029as_dcr_wts_extract(rtl8029as_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_dcr_wts_extract(rtl8029as_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline rtl8029as_dcr_t rtl8029as_dcr_wts_insert(rtl8029as_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_dcr_t rtl8029as_dcr_wts_insert(rtl8029as_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((rtl8029as_dcr_t )(_fieldval)) << 0)));
}

static inline uint8_t rtl8029as_dcr_bos_extract(rtl8029as_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_dcr_bos_extract(rtl8029as_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline rtl8029as_dcr_t rtl8029as_dcr_bos_insert(rtl8029as_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_dcr_t rtl8029as_dcr_bos_insert(rtl8029as_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((rtl8029as_dcr_t )(_fieldval)) << 1)));
}

static inline uint8_t rtl8029as_dcr_ls_extract(rtl8029as_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_dcr_ls_extract(rtl8029as_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline rtl8029as_dcr_t rtl8029as_dcr_ls_insert(rtl8029as_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_dcr_t rtl8029as_dcr_ls_insert(rtl8029as_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((rtl8029as_dcr_t )(_fieldval)) << 3)));
}

static inline uint8_t rtl8029as_dcr_arm_extract(rtl8029as_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_dcr_arm_extract(rtl8029as_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline rtl8029as_dcr_t rtl8029as_dcr_arm_insert(rtl8029as_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_dcr_t rtl8029as_dcr_arm_insert(rtl8029as_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((rtl8029as_dcr_t )(_fieldval)) << 4)));
}

static inline uint8_t rtl8029as_dcr_ft_extract(rtl8029as_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_dcr_ft_extract(rtl8029as_dcr_t _regval)
{
    return((uint8_t )((_regval & 0x60) >> 5));
}

static inline rtl8029as_dcr_t rtl8029as_dcr_ft_insert(rtl8029as_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_dcr_t rtl8029as_dcr_ft_insert(rtl8029as_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x9f) | (0x60 & (((rtl8029as_dcr_t )(_fieldval)) << 5)));
}

static inline int rtl8029as_dcr_prtval(char *_s, size_t _size, rtl8029as_dcr_t _regval) __attribute__ ((always_inline));
static inline int rtl8029as_dcr_prtval(char *_s, size_t _size, rtl8029as_dcr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wts =\t%" PRIx8 "\t(Word transfer select)\n", rtl8029as_dcr_wts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bos =\t%" PRIx8 "\t(Byte order select)\n", rtl8029as_dcr_bos_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ls =\t%" PRIx8 "\t(Loopback select)\n", rtl8029as_dcr_ls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arm =\t%" PRIx8 "\t(Auto-Initialize remote)\n", rtl8029as_dcr_arm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ft =\t%" PRIx8 "\t(FIFO threshold select)\n", rtl8029as_dcr_ft_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: rtl8029as_tcr_t
 * Description: Implicit type of Transmit Configuration register
 * Fields:
 *   crc	(size 1, offset 0, init 0):	RW	Inhibit CRC generation
 *   lb	(size 2, offset 1, init 0):	RW	Loopback configuration
 *   atd	(size 1, offset 3, init 0):	RW	Auto transmit disable
 *   ofst	(size 1, offset 4, init 0):	RW	Collision offset enable
 *   _anon5	(size 3, offset 5, init 7):	MB1	_
 */
typedef uint8_t rtl8029as_tcr_t;
#define rtl8029as_tcr_default 0xe0
static inline uint8_t rtl8029as_tcr_crc_extract(rtl8029as_tcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tcr_crc_extract(rtl8029as_tcr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline rtl8029as_tcr_t rtl8029as_tcr_crc_insert(rtl8029as_tcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_tcr_t rtl8029as_tcr_crc_insert(rtl8029as_tcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((rtl8029as_tcr_t )(_fieldval)) << 0)));
}

static inline rtl8029as_lpconf_t rtl8029as_tcr_lb_extract(rtl8029as_tcr_t _regval) __attribute__ ((always_inline));
static inline rtl8029as_lpconf_t rtl8029as_tcr_lb_extract(rtl8029as_tcr_t _regval)
{
    return((rtl8029as_lpconf_t )((_regval & 0x6) >> 1));
}

static inline rtl8029as_tcr_t rtl8029as_tcr_lb_insert(rtl8029as_tcr_t _regval, rtl8029as_lpconf_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_tcr_t rtl8029as_tcr_lb_insert(rtl8029as_tcr_t _regval, rtl8029as_lpconf_t _fieldval)
{
    return((_regval & 0xf9) | (0x6 & (((rtl8029as_tcr_t )(_fieldval)) << 1)));
}

static inline uint8_t rtl8029as_tcr_atd_extract(rtl8029as_tcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tcr_atd_extract(rtl8029as_tcr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline rtl8029as_tcr_t rtl8029as_tcr_atd_insert(rtl8029as_tcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_tcr_t rtl8029as_tcr_atd_insert(rtl8029as_tcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((rtl8029as_tcr_t )(_fieldval)) << 3)));
}

static inline uint8_t rtl8029as_tcr_ofst_extract(rtl8029as_tcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tcr_ofst_extract(rtl8029as_tcr_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline rtl8029as_tcr_t rtl8029as_tcr_ofst_insert(rtl8029as_tcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_tcr_t rtl8029as_tcr_ofst_insert(rtl8029as_tcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((rtl8029as_tcr_t )(_fieldval)) << 4)));
}

static inline int rtl8029as_tcr_prtval(char *_s, size_t _size, rtl8029as_tcr_t _regval) __attribute__ ((always_inline));
static inline int rtl8029as_tcr_prtval(char *_s, size_t _size, rtl8029as_tcr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crc =\t%" PRIx8 "\t(Inhibit CRC generation)\n", rtl8029as_tcr_crc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lb =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_lpconf_prtval(_s + _r, _avail, rtl8029as_tcr_lb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Loopback configuration)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " atd =\t%" PRIx8 "\t(Auto transmit disable)\n", rtl8029as_tcr_atd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ofst =\t%" PRIx8 "\t(Collision offset enable)\n", rtl8029as_tcr_ofst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: rtl8029as_tsr_t
 * Description: Implicit type of Transmit Status register
 * Fields:
 *   ptx	(size 1, offset 0, init 0):	RO	Transmission completed
 *   _anon1	(size 1, offset 1, init 1):	MB1	_
 *   col	(size 1, offset 2, init 0):	RO	Collision
 *   abt	(size 1, offset 3, init 0):	RO	Aborted (excessive collisions)
 *   crs	(size 1, offset 4, init 0):	RO	Carrier lost
 *   _anon5	(size 1, offset 5, init 0):	MBZ	_
 *   cdh	(size 1, offset 6, init 0):	RO	CD Heartbeat failed
 *   owc	(size 1, offset 7, init 0):	RO	Out of Window collision
 */
typedef uint8_t rtl8029as_tsr_t;
#define rtl8029as_tsr_default 0x2
static inline uint8_t rtl8029as_tsr_ptx_extract(rtl8029as_tsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tsr_ptx_extract(rtl8029as_tsr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline rtl8029as_tsr_t rtl8029as_tsr_ptx_insert(rtl8029as_tsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_tsr_t rtl8029as_tsr_ptx_insert(rtl8029as_tsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((rtl8029as_tsr_t )(_fieldval)) << 0)));
}

static inline uint8_t rtl8029as_tsr_col_extract(rtl8029as_tsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tsr_col_extract(rtl8029as_tsr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline rtl8029as_tsr_t rtl8029as_tsr_col_insert(rtl8029as_tsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_tsr_t rtl8029as_tsr_col_insert(rtl8029as_tsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((rtl8029as_tsr_t )(_fieldval)) << 2)));
}

static inline uint8_t rtl8029as_tsr_abt_extract(rtl8029as_tsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tsr_abt_extract(rtl8029as_tsr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline rtl8029as_tsr_t rtl8029as_tsr_abt_insert(rtl8029as_tsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_tsr_t rtl8029as_tsr_abt_insert(rtl8029as_tsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((rtl8029as_tsr_t )(_fieldval)) << 3)));
}

static inline uint8_t rtl8029as_tsr_crs_extract(rtl8029as_tsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tsr_crs_extract(rtl8029as_tsr_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline rtl8029as_tsr_t rtl8029as_tsr_crs_insert(rtl8029as_tsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_tsr_t rtl8029as_tsr_crs_insert(rtl8029as_tsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((rtl8029as_tsr_t )(_fieldval)) << 4)));
}

static inline uint8_t rtl8029as_tsr_cdh_extract(rtl8029as_tsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tsr_cdh_extract(rtl8029as_tsr_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline rtl8029as_tsr_t rtl8029as_tsr_cdh_insert(rtl8029as_tsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_tsr_t rtl8029as_tsr_cdh_insert(rtl8029as_tsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbf) | (0x40 & (((rtl8029as_tsr_t )(_fieldval)) << 6)));
}

static inline uint8_t rtl8029as_tsr_owc_extract(rtl8029as_tsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tsr_owc_extract(rtl8029as_tsr_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline rtl8029as_tsr_t rtl8029as_tsr_owc_insert(rtl8029as_tsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_tsr_t rtl8029as_tsr_owc_insert(rtl8029as_tsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7f) | (0x80 & (((rtl8029as_tsr_t )(_fieldval)) << 7)));
}

static inline int rtl8029as_tsr_prtval(char *_s, size_t _size, rtl8029as_tsr_t _regval) __attribute__ ((always_inline));
static inline int rtl8029as_tsr_prtval(char *_s, size_t _size, rtl8029as_tsr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ptx =\t%" PRIx8 "\t(Transmission completed)\n", rtl8029as_tsr_ptx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " col =\t%" PRIx8 "\t(Collision)\n", rtl8029as_tsr_col_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " abt =\t%" PRIx8 "\t(Aborted (excessive collisions))\n", rtl8029as_tsr_abt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crs =\t%" PRIx8 "\t(Carrier lost)\n", rtl8029as_tsr_crs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cdh =\t%" PRIx8 "\t(CD Heartbeat failed)\n", rtl8029as_tsr_cdh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " owc =\t%" PRIx8 "\t(Out of Window collision)\n", rtl8029as_tsr_owc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: rtl8029as_rcr_t
 * Description: Implicit type of Receive Configuration register
 * Fields:
 *   sep	(size 1, offset 0, init 0):	RW	Accept packets with receive errors
 *   ar	(size 1, offset 1, init 0):	RW	Accept length < 64 bytes
 *   ab	(size 1, offset 2, init 0):	RW	Accept broadcast destination address
 *   am	(size 1, offset 3, init 0):	RW	Accept multicast destination address
 *   pro	(size 1, offset 4, init 0):	RW	Promiscuous mode
 *   mon	(size 1, offset 5, init 0):	RW	Monitor mode
 *   _anon6	(size 2, offset 6, init 3):	MB1	_
 */
typedef uint8_t rtl8029as_rcr_t;
#define rtl8029as_rcr_default 0xc0
static inline uint8_t rtl8029as_rcr_sep_extract(rtl8029as_rcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rcr_sep_extract(rtl8029as_rcr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline rtl8029as_rcr_t rtl8029as_rcr_sep_insert(rtl8029as_rcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_rcr_t rtl8029as_rcr_sep_insert(rtl8029as_rcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((rtl8029as_rcr_t )(_fieldval)) << 0)));
}

static inline uint8_t rtl8029as_rcr_ar_extract(rtl8029as_rcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rcr_ar_extract(rtl8029as_rcr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline rtl8029as_rcr_t rtl8029as_rcr_ar_insert(rtl8029as_rcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_rcr_t rtl8029as_rcr_ar_insert(rtl8029as_rcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((rtl8029as_rcr_t )(_fieldval)) << 1)));
}

static inline uint8_t rtl8029as_rcr_ab_extract(rtl8029as_rcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rcr_ab_extract(rtl8029as_rcr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline rtl8029as_rcr_t rtl8029as_rcr_ab_insert(rtl8029as_rcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_rcr_t rtl8029as_rcr_ab_insert(rtl8029as_rcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((rtl8029as_rcr_t )(_fieldval)) << 2)));
}

static inline uint8_t rtl8029as_rcr_am_extract(rtl8029as_rcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rcr_am_extract(rtl8029as_rcr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline rtl8029as_rcr_t rtl8029as_rcr_am_insert(rtl8029as_rcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_rcr_t rtl8029as_rcr_am_insert(rtl8029as_rcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((rtl8029as_rcr_t )(_fieldval)) << 3)));
}

static inline uint8_t rtl8029as_rcr_pro_extract(rtl8029as_rcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rcr_pro_extract(rtl8029as_rcr_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline rtl8029as_rcr_t rtl8029as_rcr_pro_insert(rtl8029as_rcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_rcr_t rtl8029as_rcr_pro_insert(rtl8029as_rcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((rtl8029as_rcr_t )(_fieldval)) << 4)));
}

static inline uint8_t rtl8029as_rcr_mon_extract(rtl8029as_rcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rcr_mon_extract(rtl8029as_rcr_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline rtl8029as_rcr_t rtl8029as_rcr_mon_insert(rtl8029as_rcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_rcr_t rtl8029as_rcr_mon_insert(rtl8029as_rcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdf) | (0x20 & (((rtl8029as_rcr_t )(_fieldval)) << 5)));
}

static inline int rtl8029as_rcr_prtval(char *_s, size_t _size, rtl8029as_rcr_t _regval) __attribute__ ((always_inline));
static inline int rtl8029as_rcr_prtval(char *_s, size_t _size, rtl8029as_rcr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sep =\t%" PRIx8 "\t(Accept packets with receive errors)\n", rtl8029as_rcr_sep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ar =\t%" PRIx8 "\t(Accept length < 64 bytes)\n", rtl8029as_rcr_ar_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ab =\t%" PRIx8 "\t(Accept broadcast destination address)\n", rtl8029as_rcr_ab_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " am =\t%" PRIx8 "\t(Accept multicast destination address)\n", rtl8029as_rcr_am_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pro =\t%" PRIx8 "\t(Promiscuous mode)\n", rtl8029as_rcr_pro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mon =\t%" PRIx8 "\t(Monitor mode)\n", rtl8029as_rcr_mon_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: rtl8029as_rsr_t
 * Description: Implicit type of Receive Status register
 * Fields:
 *   prx	(size 1, offset 0, init 0):	RO	Packet received correctly
 *   crc	(size 1, offset 1, init 0):	RO	CRC mismatch
 *   fae	(size 1, offset 2, init 0):	RO	Frame alignment error
 *   _anon3	(size 1, offset 3, init 0):	MBZ	_
 *   mpa	(size 1, offset 4, init 0):	RO	Missed packet
 *   phy	(size 1, offset 5, init 0):	RO	Physical destination error
 *   dis	(size 1, offset 6, init 0):	RO	Receiver disabled
 *   dfr	(size 1, offset 7, init 0):	RO	Deferring
 */
typedef uint8_t rtl8029as_rsr_t;
#define rtl8029as_rsr_default 0x0
static inline uint8_t rtl8029as_rsr_prx_extract(rtl8029as_rsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rsr_prx_extract(rtl8029as_rsr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline rtl8029as_rsr_t rtl8029as_rsr_prx_insert(rtl8029as_rsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_rsr_t rtl8029as_rsr_prx_insert(rtl8029as_rsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((rtl8029as_rsr_t )(_fieldval)) << 0)));
}

static inline uint8_t rtl8029as_rsr_crc_extract(rtl8029as_rsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rsr_crc_extract(rtl8029as_rsr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline rtl8029as_rsr_t rtl8029as_rsr_crc_insert(rtl8029as_rsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_rsr_t rtl8029as_rsr_crc_insert(rtl8029as_rsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((rtl8029as_rsr_t )(_fieldval)) << 1)));
}

static inline uint8_t rtl8029as_rsr_fae_extract(rtl8029as_rsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rsr_fae_extract(rtl8029as_rsr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline rtl8029as_rsr_t rtl8029as_rsr_fae_insert(rtl8029as_rsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_rsr_t rtl8029as_rsr_fae_insert(rtl8029as_rsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((rtl8029as_rsr_t )(_fieldval)) << 2)));
}

static inline uint8_t rtl8029as_rsr_mpa_extract(rtl8029as_rsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rsr_mpa_extract(rtl8029as_rsr_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline rtl8029as_rsr_t rtl8029as_rsr_mpa_insert(rtl8029as_rsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_rsr_t rtl8029as_rsr_mpa_insert(rtl8029as_rsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((rtl8029as_rsr_t )(_fieldval)) << 4)));
}

static inline uint8_t rtl8029as_rsr_phy_extract(rtl8029as_rsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rsr_phy_extract(rtl8029as_rsr_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline rtl8029as_rsr_t rtl8029as_rsr_phy_insert(rtl8029as_rsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_rsr_t rtl8029as_rsr_phy_insert(rtl8029as_rsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdf) | (0x20 & (((rtl8029as_rsr_t )(_fieldval)) << 5)));
}

static inline uint8_t rtl8029as_rsr_dis_extract(rtl8029as_rsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rsr_dis_extract(rtl8029as_rsr_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline rtl8029as_rsr_t rtl8029as_rsr_dis_insert(rtl8029as_rsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_rsr_t rtl8029as_rsr_dis_insert(rtl8029as_rsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbf) | (0x40 & (((rtl8029as_rsr_t )(_fieldval)) << 6)));
}

static inline uint8_t rtl8029as_rsr_dfr_extract(rtl8029as_rsr_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rsr_dfr_extract(rtl8029as_rsr_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline rtl8029as_rsr_t rtl8029as_rsr_dfr_insert(rtl8029as_rsr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_rsr_t rtl8029as_rsr_dfr_insert(rtl8029as_rsr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7f) | (0x80 & (((rtl8029as_rsr_t )(_fieldval)) << 7)));
}

static inline int rtl8029as_rsr_prtval(char *_s, size_t _size, rtl8029as_rsr_t _regval) __attribute__ ((always_inline));
static inline int rtl8029as_rsr_prtval(char *_s, size_t _size, rtl8029as_rsr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prx =\t%" PRIx8 "\t(Packet received correctly)\n", rtl8029as_rsr_prx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crc =\t%" PRIx8 "\t(CRC mismatch)\n", rtl8029as_rsr_crc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fae =\t%" PRIx8 "\t(Frame alignment error)\n", rtl8029as_rsr_fae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mpa =\t%" PRIx8 "\t(Missed packet)\n", rtl8029as_rsr_mpa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phy =\t%" PRIx8 "\t(Physical destination error)\n", rtl8029as_rsr_phy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dis =\t%" PRIx8 "\t(Receiver disabled)\n", rtl8029as_rsr_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dfr =\t%" PRIx8 "\t(Deferring)\n", rtl8029as_rsr_dfr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: rtl8029as_cr9346_t
 * Description: Implicit type of 9346 Command register
 * Fields:
 *   eedo	(size 1, offset 0, init 0):	RW	eedo
 *   eedi	(size 1, offset 1, init 0):	RW	eedi
 *   eesk	(size 1, offset 2, init 0):	RW	eesk
 *   eecs	(size 1, offset 3, init 0):	RW	eecs
 *   _anon4	(size 2, offset 4, init 0):	RSVD	_
 *   eem	(size 2, offset 6, init 0):	RW	RTL8029AS operating mode
 */
typedef uint8_t rtl8029as_cr9346_t;
#define rtl8029as_cr9346_default 0x0
static inline uint8_t rtl8029as_cr9346_eedo_extract(rtl8029as_cr9346_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cr9346_eedo_extract(rtl8029as_cr9346_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline rtl8029as_cr9346_t rtl8029as_cr9346_eedo_insert(rtl8029as_cr9346_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_cr9346_t rtl8029as_cr9346_eedo_insert(rtl8029as_cr9346_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe) | (0x1 & (((rtl8029as_cr9346_t )(_fieldval)) << 0)));
}

static inline uint8_t rtl8029as_cr9346_eedi_extract(rtl8029as_cr9346_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cr9346_eedi_extract(rtl8029as_cr9346_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline rtl8029as_cr9346_t rtl8029as_cr9346_eedi_insert(rtl8029as_cr9346_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_cr9346_t rtl8029as_cr9346_eedi_insert(rtl8029as_cr9346_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((rtl8029as_cr9346_t )(_fieldval)) << 1)));
}

static inline uint8_t rtl8029as_cr9346_eesk_extract(rtl8029as_cr9346_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cr9346_eesk_extract(rtl8029as_cr9346_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline rtl8029as_cr9346_t rtl8029as_cr9346_eesk_insert(rtl8029as_cr9346_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_cr9346_t rtl8029as_cr9346_eesk_insert(rtl8029as_cr9346_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((rtl8029as_cr9346_t )(_fieldval)) << 2)));
}

static inline uint8_t rtl8029as_cr9346_eecs_extract(rtl8029as_cr9346_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cr9346_eecs_extract(rtl8029as_cr9346_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline rtl8029as_cr9346_t rtl8029as_cr9346_eecs_insert(rtl8029as_cr9346_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_cr9346_t rtl8029as_cr9346_eecs_insert(rtl8029as_cr9346_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7) | (0x8 & (((rtl8029as_cr9346_t )(_fieldval)) << 3)));
}

static inline rtl8029as_mode_t rtl8029as_cr9346_eem_extract(rtl8029as_cr9346_t _regval) __attribute__ ((always_inline));
static inline rtl8029as_mode_t rtl8029as_cr9346_eem_extract(rtl8029as_cr9346_t _regval)
{
    return((rtl8029as_mode_t )((_regval & 0xc0) >> 6));
}

static inline rtl8029as_cr9346_t rtl8029as_cr9346_eem_insert(rtl8029as_cr9346_t _regval, rtl8029as_mode_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_cr9346_t rtl8029as_cr9346_eem_insert(rtl8029as_cr9346_t _regval, rtl8029as_mode_t _fieldval)
{
    return((_regval & 0x3f) | (0xc0 & (((rtl8029as_cr9346_t )(_fieldval)) << 6)));
}

static inline int rtl8029as_cr9346_prtval(char *_s, size_t _size, rtl8029as_cr9346_t _regval) __attribute__ ((always_inline));
static inline int rtl8029as_cr9346_prtval(char *_s, size_t _size, rtl8029as_cr9346_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eedo =\t%" PRIx8 "\t(eedo)\n", rtl8029as_cr9346_eedo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eedi =\t%" PRIx8 "\t(eedi)\n", rtl8029as_cr9346_eedi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eesk =\t%" PRIx8 "\t(eesk)\n", rtl8029as_cr9346_eesk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eecs =\t%" PRIx8 "\t(eecs)\n", rtl8029as_cr9346_eecs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eem =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_mode_prtval(_s + _r, _avail, rtl8029as_cr9346_eem_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(RTL8029AS operating mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: rtl8029as_config0_t
 * Description: Implicit type of RTL8029AS Configuration 0 register
 * Fields:
 *   _anon0	(size 2, offset 0, init 0):	MBZ	_
 *   bnc	(size 1, offset 2, init 0):	RO	10Base2 thin cable connected
 *   _anon3	(size 5, offset 3, init 0):	RSVD	_
 */
typedef uint8_t rtl8029as_config0_t;
#define rtl8029as_config0_default 0x0
static inline uint8_t rtl8029as_config0_bnc_extract(rtl8029as_config0_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_config0_bnc_extract(rtl8029as_config0_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline rtl8029as_config0_t rtl8029as_config0_bnc_insert(rtl8029as_config0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_config0_t rtl8029as_config0_bnc_insert(rtl8029as_config0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((rtl8029as_config0_t )(_fieldval)) << 2)));
}

static inline int rtl8029as_config0_prtval(char *_s, size_t _size, rtl8029as_config0_t _regval) __attribute__ ((always_inline));
static inline int rtl8029as_config0_prtval(char *_s, size_t _size, rtl8029as_config0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bnc =\t%" PRIx8 "\t(10Base2 thin cable connected)\n", rtl8029as_config0_bnc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: rtl8029as_config2_t
 * Description: Implicit type of RTL8029AS Configuration 2 register
 * Fields:
 *   bs	(size 2, offset 0, init 0):	RO	Boot ROM size
 *   _anon2	(size 2, offset 2, init 0):	RSVD	_
 *   pf	(size 1, offset 4, init 0):	RO	Pause flag
 *   fce	(size 1, offset 5, init 0):	RW	Flow control enable
 *   pl	(size 2, offset 6, init 0):	RW	Network medium select
 */
typedef uint8_t rtl8029as_config2_t;
#define rtl8029as_config2_default 0x0
static inline rtl8029as_bromsize_t rtl8029as_config2_bs_extract(rtl8029as_config2_t _regval) __attribute__ ((always_inline));
static inline rtl8029as_bromsize_t rtl8029as_config2_bs_extract(rtl8029as_config2_t _regval)
{
    return((rtl8029as_bromsize_t )((_regval & 0x3) >> 0));
}

static inline rtl8029as_config2_t rtl8029as_config2_bs_insert(rtl8029as_config2_t _regval, rtl8029as_bromsize_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_config2_t rtl8029as_config2_bs_insert(rtl8029as_config2_t _regval, rtl8029as_bromsize_t _fieldval)
{
    return((_regval & 0xfc) | (0x3 & (((rtl8029as_config2_t )(_fieldval)) << 0)));
}

static inline uint8_t rtl8029as_config2_pf_extract(rtl8029as_config2_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_config2_pf_extract(rtl8029as_config2_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline rtl8029as_config2_t rtl8029as_config2_pf_insert(rtl8029as_config2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_config2_t rtl8029as_config2_pf_insert(rtl8029as_config2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xef) | (0x10 & (((rtl8029as_config2_t )(_fieldval)) << 4)));
}

static inline uint8_t rtl8029as_config2_fce_extract(rtl8029as_config2_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_config2_fce_extract(rtl8029as_config2_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline rtl8029as_config2_t rtl8029as_config2_fce_insert(rtl8029as_config2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_config2_t rtl8029as_config2_fce_insert(rtl8029as_config2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdf) | (0x20 & (((rtl8029as_config2_t )(_fieldval)) << 5)));
}

static inline rtl8029as_medium_t rtl8029as_config2_pl_extract(rtl8029as_config2_t _regval) __attribute__ ((always_inline));
static inline rtl8029as_medium_t rtl8029as_config2_pl_extract(rtl8029as_config2_t _regval)
{
    return((rtl8029as_medium_t )((_regval & 0xc0) >> 6));
}

static inline rtl8029as_config2_t rtl8029as_config2_pl_insert(rtl8029as_config2_t _regval, rtl8029as_medium_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_config2_t rtl8029as_config2_pl_insert(rtl8029as_config2_t _regval, rtl8029as_medium_t _fieldval)
{
    return((_regval & 0x3f) | (0xc0 & (((rtl8029as_config2_t )(_fieldval)) << 6)));
}

static inline int rtl8029as_config2_prtval(char *_s, size_t _size, rtl8029as_config2_t _regval) __attribute__ ((always_inline));
static inline int rtl8029as_config2_prtval(char *_s, size_t _size, rtl8029as_config2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bs =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_bromsize_prtval(_s + _r, _avail, rtl8029as_config2_bs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Boot ROM size)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pf =\t%" PRIx8 "\t(Pause flag)\n", rtl8029as_config2_pf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fce =\t%" PRIx8 "\t(Flow control enable)\n", rtl8029as_config2_fce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_medium_prtval(_s + _r, _avail, rtl8029as_config2_pl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Network medium select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: rtl8029as_config3_t
 * Description: Implicit type of RTL8029AS Configuration 3 register
 * Fields:
 *   _anon0	(size 1, offset 0, init 0):	RSVD	_
 *   pwrdn	(size 1, offset 1, init 0):	RW	Power down mode
 *   sleep	(size 1, offset 2, init 0):	RW	Sleep mode
 *   _anon3	(size 1, offset 3, init 0):	MBZ	_
 *   leds	(size 2, offset 4, init 0):	RW	LED control
 *   fudup	(size 1, offset 6, init 0):	RW	Full-duplex mode
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 */
typedef uint8_t rtl8029as_config3_t;
#define rtl8029as_config3_default 0x0
static inline uint8_t rtl8029as_config3_pwrdn_extract(rtl8029as_config3_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_config3_pwrdn_extract(rtl8029as_config3_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline rtl8029as_config3_t rtl8029as_config3_pwrdn_insert(rtl8029as_config3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_config3_t rtl8029as_config3_pwrdn_insert(rtl8029as_config3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfd) | (0x2 & (((rtl8029as_config3_t )(_fieldval)) << 1)));
}

static inline uint8_t rtl8029as_config3_sleep_extract(rtl8029as_config3_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_config3_sleep_extract(rtl8029as_config3_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline rtl8029as_config3_t rtl8029as_config3_sleep_insert(rtl8029as_config3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_config3_t rtl8029as_config3_sleep_insert(rtl8029as_config3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfb) | (0x4 & (((rtl8029as_config3_t )(_fieldval)) << 2)));
}

static inline rtl8029as_leds_t rtl8029as_config3_leds_extract(rtl8029as_config3_t _regval) __attribute__ ((always_inline));
static inline rtl8029as_leds_t rtl8029as_config3_leds_extract(rtl8029as_config3_t _regval)
{
    return((rtl8029as_leds_t )((_regval & 0x30) >> 4));
}

static inline rtl8029as_config3_t rtl8029as_config3_leds_insert(rtl8029as_config3_t _regval, rtl8029as_leds_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_config3_t rtl8029as_config3_leds_insert(rtl8029as_config3_t _regval, rtl8029as_leds_t _fieldval)
{
    return((_regval & 0xcf) | (0x30 & (((rtl8029as_config3_t )(_fieldval)) << 4)));
}

static inline uint8_t rtl8029as_config3_fudup_extract(rtl8029as_config3_t _regval) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_config3_fudup_extract(rtl8029as_config3_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline rtl8029as_config3_t rtl8029as_config3_fudup_insert(rtl8029as_config3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline rtl8029as_config3_t rtl8029as_config3_fudup_insert(rtl8029as_config3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbf) | (0x40 & (((rtl8029as_config3_t )(_fieldval)) << 6)));
}

static inline int rtl8029as_config3_prtval(char *_s, size_t _size, rtl8029as_config3_t _regval) __attribute__ ((always_inline));
static inline int rtl8029as_config3_prtval(char *_s, size_t _size, rtl8029as_config3_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pwrdn =\t%" PRIx8 "\t(Power down mode)\n", rtl8029as_config3_pwrdn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sleep =\t%" PRIx8 "\t(Sleep mode)\n", rtl8029as_config3_sleep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " leds =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_leds_prtval(_s + _r, _avail, rtl8029as_config3_leds_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fudup =\t%" PRIx8 "\t(Full-duplex mode)\n", rtl8029as_config3_fudup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_io_t base;
    uint8_t tpsr_shadow;
    uint16_t tbcr_shadow;
    uint16_t rsar_shadow;
    uint16_t rbcr_shadow;
    uint8_t hltclk_shadow;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum rtl8029as_initials {
    rtl8029as_cr_initial = 0x0,
    rtl8029as_isr_initial = 0x0,
    rtl8029as_imr_initial = 0x0,
    rtl8029as_dcr_initial = 0x0,
    rtl8029as_tcr_initial = 0x0,
    rtl8029as_tsr_initial = 0x0,
    rtl8029as_rcr_initial = 0x0,
    rtl8029as_rsr_initial = 0x0,
    rtl8029as_clda_initial = 0x0,
    rtl8029as_pstart_initial = 0x0,
    rtl8029as_pstop_initial = 0x0,
    rtl8029as_bnry_initial = 0x0,
    rtl8029as_tpsr_initial = 0x0,
    rtl8029as_tbcr_initial = 0x0,
    rtl8029as_ncr_initial = 0x0,
    rtl8029as_fifo_initial = 0x0,
    rtl8029as_crda_initial = 0x0,
    rtl8029as_rsar_initial = 0x0,
    rtl8029as_rbcr_initial = 0x0,
    rtl8029as_cntr0_initial = 0x0,
    rtl8029as_cntr1_initial = 0x0,
    rtl8029as_cntr2_initial = 0x0,
    rtl8029as_par_initial = 0x0,
    rtl8029as_curr_initial = 0x0,
    rtl8029as_mar_initial = 0x0,
    rtl8029as_chipid_initial = 0x0,
    rtl8029as_cr9346_initial = 0x0,
    rtl8029as_config0_initial = 0x0,
    rtl8029as_config2_initial = 0x0,
    rtl8029as_config3_initial = 0x0,
    rtl8029as_hltclk_initial = 0x0,
    rtl8029as_asid_initial = 0x0,
    rtl8029as_rdma32_initial = 0x0,
    rtl8029as_rdma16_initial = 0x0,
    rtl8029as_rdma8_initial = 0x0,
    rtl8029as_reset_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void rtl8029as_initialize(__DN(t) *_dev, mackerel_io_t base) __attribute__ ((always_inline));
static inline void rtl8029as_initialize(__DN(t) *_dev, mackerel_io_t base)
{
    _dev->base = base;
}

/*
 * Register cr: Command
 * Type: rtl8029as.cr (Implicit type of Command register)
 *   stp	(size 1, offset 0, init 0):	RW	Stop command
 *   sta	(size 1, offset 1, init 0):	RW	Start command
 *   txp	(size 1, offset 2, init 0):	RW	Transmit packet
 *   rd	(size 3, offset 3, init 0):	RW	Remote read/write
 *   ps	(size 2, offset 6, init 0):	RW	Page identification
 */
static inline rtl8029as_cr_t rtl8029as_cr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_cr_t rtl8029as_cr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x0));
}

static inline rtl8029as_cr_t rtl8029as_cr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_cr_t rtl8029as_cr_rd(__DN(t) *_dev)
{
    return(mackerel_read_io_8(_dev->base, 0x0));
}

static inline void rtl8029as_cr_rawwr(__DN(t) *_dev, rtl8029as_cr_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_cr_rawwr(__DN(t) *_dev, rtl8029as_cr_t _regval)
{
    mackerel_write_io_8(_dev->base, 0x0, _regval);
}

static inline void rtl8029as_cr_wr(__DN(t) *_dev, rtl8029as_cr_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_cr_wr(__DN(t) *_dev, rtl8029as_cr_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_io_8(_dev->base, 0x0, _regval);
}

static inline int rtl8029as_cr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_cr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    rtl8029as_cr_t _regval = mackerel_read_io_8(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cr (Command): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stp =\t%" PRIx8 "\t(Stop command)\n", rtl8029as_cr_stp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sta =\t%" PRIx8 "\t(Start command)\n", rtl8029as_cr_sta_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txp =\t%" PRIx8 "\t(Transmit packet)\n", rtl8029as_cr_txp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rd =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_rd_prtval(_s + _r, _avail, rtl8029as_cr_rd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Remote read/write)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ps =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_ps_prtval(_s + _r, _avail, rtl8029as_cr_ps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Page identification)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t rtl8029as_cr_stp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cr_stp_rdf(__DN(t) *_dev)
{
    rtl8029as_cr_t _regval = mackerel_read_io_8(_dev->base, 0x0);
    return(rtl8029as_cr_stp_extract(_regval));
}

static inline uint8_t rtl8029as_cr_sta_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cr_sta_rdf(__DN(t) *_dev)
{
    rtl8029as_cr_t _regval = mackerel_read_io_8(_dev->base, 0x0);
    return(rtl8029as_cr_sta_extract(_regval));
}

static inline uint8_t rtl8029as_cr_txp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cr_txp_rdf(__DN(t) *_dev)
{
    rtl8029as_cr_t _regval = mackerel_read_io_8(_dev->base, 0x0);
    return(rtl8029as_cr_txp_extract(_regval));
}

static inline rtl8029as_rd_t rtl8029as_cr_rd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_rd_t rtl8029as_cr_rd_rdf(__DN(t) *_dev)
{
    rtl8029as_cr_t _regval = mackerel_read_io_8(_dev->base, 0x0);
    return(rtl8029as_cr_rd_extract(_regval));
}

static inline rtl8029as_ps_t rtl8029as_cr_ps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_ps_t rtl8029as_cr_ps_rdf(__DN(t) *_dev)
{
    rtl8029as_cr_t _regval = mackerel_read_io_8(_dev->base, 0x0);
    return(rtl8029as_cr_ps_extract(_regval));
}

static inline void rtl8029as_cr_stp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_cr_stp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_cr_t _regval = 0x1 & (((rtl8029as_cr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfe & mackerel_read_io_8(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_cr_sta_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_cr_sta_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_cr_t _regval = 0x2 & (((rtl8029as_cr_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfd & mackerel_read_io_8(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_cr_txp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_cr_txp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_cr_t _regval = 0x4 & (((rtl8029as_cr_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfb & mackerel_read_io_8(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_cr_rd_wrf(__DN(t) *_dev, rtl8029as_rd_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_cr_rd_wrf(__DN(t) *_dev, rtl8029as_rd_t _fieldval)
{
    rtl8029as_cr_t _regval = 0x38 & (((rtl8029as_cr_t )(_fieldval)) << 3);
    _regval = (_regval | (0xc7 & mackerel_read_io_8(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_cr_ps_wrf(__DN(t) *_dev, rtl8029as_ps_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_cr_ps_wrf(__DN(t) *_dev, rtl8029as_ps_t _fieldval)
{
    rtl8029as_cr_t _regval = 0xc0 & (((rtl8029as_cr_t )(_fieldval)) << 6);
    _regval = (_regval | (0x3f & mackerel_read_io_8(_dev->base, 0x0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_io_8(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register isr: Interrupt Status
 * Type: rtl8029as.irq (Interrupts)
 *   prx	(size 1, offset 0, init 0):	RW	Packet received correctly
 *   ptx	(size 1, offset 1, init 0):	RW	Packet transmitted correctly
 *   rxe	(size 1, offset 2, init 0):	RW	Packet receive error
 *   txe	(size 1, offset 3, init 0):	RW	Packet sent aborted (excessive collisions)
 *   ovw	(size 1, offset 4, init 0):	RW	Receive buffer exhausted
 *   cnt	(size 1, offset 5, init 0):	RW	MSB of one or more network tally counters is set
 *   rdc	(size 1, offset 6, init 0):	RW	Remote DMA operation completed
 *   rst	(size 1, offset 7, init 0):	RW	Reset state / Receive buffer overflow
 */
static inline rtl8029as_irq_t rtl8029as_isr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_irq_t rtl8029as_isr_rawrd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0x7));
}

static inline rtl8029as_irq_t rtl8029as_isr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_irq_t rtl8029as_isr_rd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0x7));
}

static inline void rtl8029as_isr_rawwr(__DN(t) *_dev, rtl8029as_irq_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_isr_rawwr(__DN(t) *_dev, rtl8029as_irq_t _regval)
{
    __DN(page0_write_8)(_dev, 0x7, _regval);
}

static inline void rtl8029as_isr_wr(__DN(t) *_dev, rtl8029as_irq_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_isr_wr(__DN(t) *_dev, rtl8029as_irq_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(page0_write_8)(_dev, 0x7, _regval);
}

static inline int rtl8029as_isr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_isr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    rtl8029as_irq_t _regval = __DN(page0_read_8)(_dev, 0x7);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register isr (Interrupt Status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prx =\t%" PRIx8 "\t(Packet received correctly)\n", rtl8029as_irq_prx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ptx =\t%" PRIx8 "\t(Packet transmitted correctly)\n", rtl8029as_irq_ptx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxe =\t%" PRIx8 "\t(Packet receive error)\n", rtl8029as_irq_rxe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txe =\t%" PRIx8 "\t(Packet sent aborted (excessive collisions))\n", rtl8029as_irq_txe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ovw =\t%" PRIx8 "\t(Receive buffer exhausted)\n", rtl8029as_irq_ovw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cnt =\t%" PRIx8 "\t(MSB of one or more network tally counters is set)\n", rtl8029as_irq_cnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rdc =\t%" PRIx8 "\t(Remote DMA operation completed)\n", rtl8029as_irq_rdc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rst =\t%" PRIx8 "\t(Reset state / Receive buffer overflow)\n", rtl8029as_irq_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t rtl8029as_isr_prx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_isr_prx_rdf(__DN(t) *_dev)
{
    rtl8029as_irq_t _regval = __DN(page0_read_8)(_dev, 0x7);
    return(rtl8029as_irq_prx_extract(_regval));
}

static inline uint8_t rtl8029as_isr_ptx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_isr_ptx_rdf(__DN(t) *_dev)
{
    rtl8029as_irq_t _regval = __DN(page0_read_8)(_dev, 0x7);
    return(rtl8029as_irq_ptx_extract(_regval));
}

static inline uint8_t rtl8029as_isr_rxe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_isr_rxe_rdf(__DN(t) *_dev)
{
    rtl8029as_irq_t _regval = __DN(page0_read_8)(_dev, 0x7);
    return(rtl8029as_irq_rxe_extract(_regval));
}

static inline uint8_t rtl8029as_isr_txe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_isr_txe_rdf(__DN(t) *_dev)
{
    rtl8029as_irq_t _regval = __DN(page0_read_8)(_dev, 0x7);
    return(rtl8029as_irq_txe_extract(_regval));
}

static inline uint8_t rtl8029as_isr_ovw_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_isr_ovw_rdf(__DN(t) *_dev)
{
    rtl8029as_irq_t _regval = __DN(page0_read_8)(_dev, 0x7);
    return(rtl8029as_irq_ovw_extract(_regval));
}

static inline uint8_t rtl8029as_isr_cnt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_isr_cnt_rdf(__DN(t) *_dev)
{
    rtl8029as_irq_t _regval = __DN(page0_read_8)(_dev, 0x7);
    return(rtl8029as_irq_cnt_extract(_regval));
}

static inline uint8_t rtl8029as_isr_rdc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_isr_rdc_rdf(__DN(t) *_dev)
{
    rtl8029as_irq_t _regval = __DN(page0_read_8)(_dev, 0x7);
    return(rtl8029as_irq_rdc_extract(_regval));
}

static inline uint8_t rtl8029as_isr_rst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_isr_rst_rdf(__DN(t) *_dev)
{
    rtl8029as_irq_t _regval = __DN(page0_read_8)(_dev, 0x7);
    return(rtl8029as_irq_rst_extract(_regval));
}

static inline void rtl8029as_isr_prx_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_isr_prx_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_irq_t _regval = 0x1 & (((rtl8029as_irq_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfe & __DN(page0_read_8)(_dev, 0x7)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(page0_write_8)(_dev, 0x7, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_isr_ptx_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_isr_ptx_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_irq_t _regval = 0x2 & (((rtl8029as_irq_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfd & __DN(page0_read_8)(_dev, 0x7)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(page0_write_8)(_dev, 0x7, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_isr_rxe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_isr_rxe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_irq_t _regval = 0x4 & (((rtl8029as_irq_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfb & __DN(page0_read_8)(_dev, 0x7)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(page0_write_8)(_dev, 0x7, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_isr_txe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_isr_txe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_irq_t _regval = 0x8 & (((rtl8029as_irq_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf7 & __DN(page0_read_8)(_dev, 0x7)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(page0_write_8)(_dev, 0x7, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_isr_ovw_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_isr_ovw_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_irq_t _regval = 0x10 & (((rtl8029as_irq_t )(_fieldval)) << 4);
    _regval = (_regval | (0xef & __DN(page0_read_8)(_dev, 0x7)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(page0_write_8)(_dev, 0x7, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_isr_cnt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_isr_cnt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_irq_t _regval = 0x20 & (((rtl8029as_irq_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdf & __DN(page0_read_8)(_dev, 0x7)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(page0_write_8)(_dev, 0x7, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_isr_rdc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_isr_rdc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_irq_t _regval = 0x40 & (((rtl8029as_irq_t )(_fieldval)) << 6);
    _regval = (_regval | (0xbf & __DN(page0_read_8)(_dev, 0x7)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(page0_write_8)(_dev, 0x7, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_isr_rst_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_isr_rst_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_irq_t _regval = 0x80 & (((rtl8029as_irq_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7f & __DN(page0_read_8)(_dev, 0x7)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(page0_write_8)(_dev, 0x7, _regval);
    // No shadow register to write to
}

/*
 * Register imr: Interrupt Mask
 * Type: rtl8029as.irq (Interrupts)
 *   prx	(size 1, offset 0, init 0):	RW	Packet received correctly
 *   ptx	(size 1, offset 1, init 0):	RW	Packet transmitted correctly
 *   rxe	(size 1, offset 2, init 0):	RW	Packet receive error
 *   txe	(size 1, offset 3, init 0):	RW	Packet sent aborted (excessive collisions)
 *   ovw	(size 1, offset 4, init 0):	RW	Receive buffer exhausted
 *   cnt	(size 1, offset 5, init 0):	RW	MSB of one or more network tally counters is set
 *   rdc	(size 1, offset 6, init 0):	RW	Remote DMA operation completed
 *   rst	(size 1, offset 7, init 0):	RW	Reset state / Receive buffer overflow
 */
static inline rtl8029as_irq_t rtl8029as_imr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_irq_t rtl8029as_imr_rawrd(__DN(t) *_dev)
{
    return(__DN(p2p0_read_8)(_dev, 0xf));
}

static inline rtl8029as_irq_t rtl8029as_imr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_irq_t rtl8029as_imr_rd(__DN(t) *_dev)
{
    return(__DN(p2p0_read_8)(_dev, 0xf));
}

static inline void rtl8029as_imr_rawwr(__DN(t) *_dev, rtl8029as_irq_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_imr_rawwr(__DN(t) *_dev, rtl8029as_irq_t _regval)
{
    __DN(p2p0_write_8)(_dev, 0xf, _regval);
}

static inline void rtl8029as_imr_wr(__DN(t) *_dev, rtl8029as_irq_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_imr_wr(__DN(t) *_dev, rtl8029as_irq_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(p2p0_write_8)(_dev, 0xf, _regval);
}

static inline int rtl8029as_imr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_imr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    rtl8029as_irq_t _regval = __DN(p2p0_read_8)(_dev, 0xf);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register imr (Interrupt Mask): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prx =\t%" PRIx8 "\t(Packet received correctly)\n", rtl8029as_irq_prx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ptx =\t%" PRIx8 "\t(Packet transmitted correctly)\n", rtl8029as_irq_ptx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxe =\t%" PRIx8 "\t(Packet receive error)\n", rtl8029as_irq_rxe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txe =\t%" PRIx8 "\t(Packet sent aborted (excessive collisions))\n", rtl8029as_irq_txe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ovw =\t%" PRIx8 "\t(Receive buffer exhausted)\n", rtl8029as_irq_ovw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cnt =\t%" PRIx8 "\t(MSB of one or more network tally counters is set)\n", rtl8029as_irq_cnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rdc =\t%" PRIx8 "\t(Remote DMA operation completed)\n", rtl8029as_irq_rdc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rst =\t%" PRIx8 "\t(Reset state / Receive buffer overflow)\n", rtl8029as_irq_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t rtl8029as_imr_prx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_imr_prx_rdf(__DN(t) *_dev)
{
    rtl8029as_irq_t _regval = __DN(p2p0_read_8)(_dev, 0xf);
    return(rtl8029as_irq_prx_extract(_regval));
}

static inline uint8_t rtl8029as_imr_ptx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_imr_ptx_rdf(__DN(t) *_dev)
{
    rtl8029as_irq_t _regval = __DN(p2p0_read_8)(_dev, 0xf);
    return(rtl8029as_irq_ptx_extract(_regval));
}

static inline uint8_t rtl8029as_imr_rxe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_imr_rxe_rdf(__DN(t) *_dev)
{
    rtl8029as_irq_t _regval = __DN(p2p0_read_8)(_dev, 0xf);
    return(rtl8029as_irq_rxe_extract(_regval));
}

static inline uint8_t rtl8029as_imr_txe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_imr_txe_rdf(__DN(t) *_dev)
{
    rtl8029as_irq_t _regval = __DN(p2p0_read_8)(_dev, 0xf);
    return(rtl8029as_irq_txe_extract(_regval));
}

static inline uint8_t rtl8029as_imr_ovw_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_imr_ovw_rdf(__DN(t) *_dev)
{
    rtl8029as_irq_t _regval = __DN(p2p0_read_8)(_dev, 0xf);
    return(rtl8029as_irq_ovw_extract(_regval));
}

static inline uint8_t rtl8029as_imr_cnt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_imr_cnt_rdf(__DN(t) *_dev)
{
    rtl8029as_irq_t _regval = __DN(p2p0_read_8)(_dev, 0xf);
    return(rtl8029as_irq_cnt_extract(_regval));
}

static inline uint8_t rtl8029as_imr_rdc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_imr_rdc_rdf(__DN(t) *_dev)
{
    rtl8029as_irq_t _regval = __DN(p2p0_read_8)(_dev, 0xf);
    return(rtl8029as_irq_rdc_extract(_regval));
}

static inline uint8_t rtl8029as_imr_rst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_imr_rst_rdf(__DN(t) *_dev)
{
    rtl8029as_irq_t _regval = __DN(p2p0_read_8)(_dev, 0xf);
    return(rtl8029as_irq_rst_extract(_regval));
}

static inline void rtl8029as_imr_prx_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_imr_prx_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_irq_t _regval = 0x1 & (((rtl8029as_irq_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfe & __DN(p2p0_read_8)(_dev, 0xf)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(p2p0_write_8)(_dev, 0xf, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_imr_ptx_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_imr_ptx_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_irq_t _regval = 0x2 & (((rtl8029as_irq_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfd & __DN(p2p0_read_8)(_dev, 0xf)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(p2p0_write_8)(_dev, 0xf, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_imr_rxe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_imr_rxe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_irq_t _regval = 0x4 & (((rtl8029as_irq_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfb & __DN(p2p0_read_8)(_dev, 0xf)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(p2p0_write_8)(_dev, 0xf, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_imr_txe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_imr_txe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_irq_t _regval = 0x8 & (((rtl8029as_irq_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf7 & __DN(p2p0_read_8)(_dev, 0xf)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(p2p0_write_8)(_dev, 0xf, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_imr_ovw_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_imr_ovw_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_irq_t _regval = 0x10 & (((rtl8029as_irq_t )(_fieldval)) << 4);
    _regval = (_regval | (0xef & __DN(p2p0_read_8)(_dev, 0xf)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(p2p0_write_8)(_dev, 0xf, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_imr_cnt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_imr_cnt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_irq_t _regval = 0x20 & (((rtl8029as_irq_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdf & __DN(p2p0_read_8)(_dev, 0xf)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(p2p0_write_8)(_dev, 0xf, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_imr_rdc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_imr_rdc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_irq_t _regval = 0x40 & (((rtl8029as_irq_t )(_fieldval)) << 6);
    _regval = (_regval | (0xbf & __DN(p2p0_read_8)(_dev, 0xf)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(p2p0_write_8)(_dev, 0xf, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_imr_rst_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_imr_rst_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_irq_t _regval = 0x80 & (((rtl8029as_irq_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7f & __DN(p2p0_read_8)(_dev, 0xf)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(p2p0_write_8)(_dev, 0xf, _regval);
    // No shadow register to write to
}

/*
 * Register dcr: Data Configuration
 * Type: rtl8029as.dcr (Implicit type of Data Configuration register)
 *   wts	(size 1, offset 0, init 0):	RW	Word transfer select
 *   bos	(size 1, offset 1, init 0):	RW	Byte order select
 *   _anon2	(size 1, offset 2, init 0):	MBZ	_
 *   ls	(size 1, offset 3, init 0):	RW	Loopback select
 *   arm	(size 1, offset 4, init 0):	RW	Auto-Initialize remote
 *   ft	(size 2, offset 5, init 0):	RW	FIFO threshold select
 *   _anon7	(size 1, offset 7, init 1):	MB1	_
 */
static inline rtl8029as_dcr_t rtl8029as_dcr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_dcr_t rtl8029as_dcr_rawrd(__DN(t) *_dev)
{
    return(__DN(p2p0_read_8)(_dev, 0xe));
}

static inline rtl8029as_dcr_t rtl8029as_dcr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_dcr_t rtl8029as_dcr_rd(__DN(t) *_dev)
{
    return(__DN(p2p0_read_8)(_dev, 0xe));
}

static inline void rtl8029as_dcr_rawwr(__DN(t) *_dev, rtl8029as_dcr_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_dcr_rawwr(__DN(t) *_dev, rtl8029as_dcr_t _regval)
{
    __DN(p2p0_write_8)(_dev, 0xe, _regval);
}

static inline void rtl8029as_dcr_wr(__DN(t) *_dev, rtl8029as_dcr_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_dcr_wr(__DN(t) *_dev, rtl8029as_dcr_t _regval)
{
    _regval = (_regval & 0xfb);
    _regval = (_regval | 0x80);
    // No pre-read of register required
    __DN(p2p0_write_8)(_dev, 0xe, _regval);
}

static inline int rtl8029as_dcr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_dcr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    rtl8029as_dcr_t _regval = __DN(p2p0_read_8)(_dev, 0xe);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dcr (Data Configuration): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wts =\t%" PRIx8 "\t(Word transfer select)\n", rtl8029as_dcr_wts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bos =\t%" PRIx8 "\t(Byte order select)\n", rtl8029as_dcr_bos_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ls =\t%" PRIx8 "\t(Loopback select)\n", rtl8029as_dcr_ls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arm =\t%" PRIx8 "\t(Auto-Initialize remote)\n", rtl8029as_dcr_arm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ft =\t%" PRIx8 "\t(FIFO threshold select)\n", rtl8029as_dcr_ft_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    return(_r);
}

static inline uint8_t rtl8029as_dcr_wts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_dcr_wts_rdf(__DN(t) *_dev)
{
    rtl8029as_dcr_t _regval = __DN(p2p0_read_8)(_dev, 0xe);
    return(rtl8029as_dcr_wts_extract(_regval));
}

static inline uint8_t rtl8029as_dcr_bos_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_dcr_bos_rdf(__DN(t) *_dev)
{
    rtl8029as_dcr_t _regval = __DN(p2p0_read_8)(_dev, 0xe);
    return(rtl8029as_dcr_bos_extract(_regval));
}

static inline uint8_t rtl8029as_dcr_ls_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_dcr_ls_rdf(__DN(t) *_dev)
{
    rtl8029as_dcr_t _regval = __DN(p2p0_read_8)(_dev, 0xe);
    return(rtl8029as_dcr_ls_extract(_regval));
}

static inline uint8_t rtl8029as_dcr_arm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_dcr_arm_rdf(__DN(t) *_dev)
{
    rtl8029as_dcr_t _regval = __DN(p2p0_read_8)(_dev, 0xe);
    return(rtl8029as_dcr_arm_extract(_regval));
}

static inline uint8_t rtl8029as_dcr_ft_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_dcr_ft_rdf(__DN(t) *_dev)
{
    rtl8029as_dcr_t _regval = __DN(p2p0_read_8)(_dev, 0xe);
    return(rtl8029as_dcr_ft_extract(_regval));
}

static inline void rtl8029as_dcr_wts_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_dcr_wts_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_dcr_t _regval = 0x1 & (((rtl8029as_dcr_t )(_fieldval)) << 0);
    _regval = (_regval | (0x7a & __DN(p2p0_read_8)(_dev, 0xe)));
    // No read of register shadow required
    _regval = (_regval & 0xfb);
    _regval = (_regval | 0x80);
    __DN(p2p0_write_8)(_dev, 0xe, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_dcr_bos_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_dcr_bos_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_dcr_t _regval = 0x2 & (((rtl8029as_dcr_t )(_fieldval)) << 1);
    _regval = (_regval | (0x79 & __DN(p2p0_read_8)(_dev, 0xe)));
    // No read of register shadow required
    _regval = (_regval & 0xfb);
    _regval = (_regval | 0x80);
    __DN(p2p0_write_8)(_dev, 0xe, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_dcr_ls_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_dcr_ls_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_dcr_t _regval = 0x8 & (((rtl8029as_dcr_t )(_fieldval)) << 3);
    _regval = (_regval | (0x73 & __DN(p2p0_read_8)(_dev, 0xe)));
    // No read of register shadow required
    _regval = (_regval & 0xfb);
    _regval = (_regval | 0x80);
    __DN(p2p0_write_8)(_dev, 0xe, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_dcr_arm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_dcr_arm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_dcr_t _regval = 0x10 & (((rtl8029as_dcr_t )(_fieldval)) << 4);
    _regval = (_regval | (0x6b & __DN(p2p0_read_8)(_dev, 0xe)));
    // No read of register shadow required
    _regval = (_regval & 0xfb);
    _regval = (_regval | 0x80);
    __DN(p2p0_write_8)(_dev, 0xe, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_dcr_ft_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_dcr_ft_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_dcr_t _regval = 0x60 & (((rtl8029as_dcr_t )(_fieldval)) << 5);
    _regval = (_regval | (0x1b & __DN(p2p0_read_8)(_dev, 0xe)));
    // No read of register shadow required
    _regval = (_regval & 0xfb);
    _regval = (_regval | 0x80);
    __DN(p2p0_write_8)(_dev, 0xe, _regval);
    // No shadow register to write to
}

/*
 * Register tcr: Transmit Configuration
 * Type: rtl8029as.tcr (Implicit type of Transmit Configuration register)
 *   crc	(size 1, offset 0, init 0):	RW	Inhibit CRC generation
 *   lb	(size 2, offset 1, init 0):	RW	Loopback configuration
 *   atd	(size 1, offset 3, init 0):	RW	Auto transmit disable
 *   ofst	(size 1, offset 4, init 0):	RW	Collision offset enable
 *   _anon5	(size 3, offset 5, init 7):	MB1	_
 */
static inline rtl8029as_tcr_t rtl8029as_tcr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_tcr_t rtl8029as_tcr_rawrd(__DN(t) *_dev)
{
    return(__DN(p2p0_read_8)(_dev, 0xd));
}

static inline rtl8029as_tcr_t rtl8029as_tcr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_tcr_t rtl8029as_tcr_rd(__DN(t) *_dev)
{
    return(__DN(p2p0_read_8)(_dev, 0xd));
}

static inline void rtl8029as_tcr_rawwr(__DN(t) *_dev, rtl8029as_tcr_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_tcr_rawwr(__DN(t) *_dev, rtl8029as_tcr_t _regval)
{
    __DN(p2p0_write_8)(_dev, 0xd, _regval);
}

static inline void rtl8029as_tcr_wr(__DN(t) *_dev, rtl8029as_tcr_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_tcr_wr(__DN(t) *_dev, rtl8029as_tcr_t _regval)
{
    // No MB0 or RSVD fields present
    _regval = (_regval | 0xe0);
    // No pre-read of register required
    __DN(p2p0_write_8)(_dev, 0xd, _regval);
}

static inline int rtl8029as_tcr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_tcr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    rtl8029as_tcr_t _regval = __DN(p2p0_read_8)(_dev, 0xd);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tcr (Transmit Configuration): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crc =\t%" PRIx8 "\t(Inhibit CRC generation)\n", rtl8029as_tcr_crc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lb =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_lpconf_prtval(_s + _r, _avail, rtl8029as_tcr_lb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Loopback configuration)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " atd =\t%" PRIx8 "\t(Auto transmit disable)\n", rtl8029as_tcr_atd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ofst =\t%" PRIx8 "\t(Collision offset enable)\n", rtl8029as_tcr_ofst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline uint8_t rtl8029as_tcr_crc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tcr_crc_rdf(__DN(t) *_dev)
{
    rtl8029as_tcr_t _regval = __DN(p2p0_read_8)(_dev, 0xd);
    return(rtl8029as_tcr_crc_extract(_regval));
}

static inline rtl8029as_lpconf_t rtl8029as_tcr_lb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_lpconf_t rtl8029as_tcr_lb_rdf(__DN(t) *_dev)
{
    rtl8029as_tcr_t _regval = __DN(p2p0_read_8)(_dev, 0xd);
    return(rtl8029as_tcr_lb_extract(_regval));
}

static inline uint8_t rtl8029as_tcr_atd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tcr_atd_rdf(__DN(t) *_dev)
{
    rtl8029as_tcr_t _regval = __DN(p2p0_read_8)(_dev, 0xd);
    return(rtl8029as_tcr_atd_extract(_regval));
}

static inline uint8_t rtl8029as_tcr_ofst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tcr_ofst_rdf(__DN(t) *_dev)
{
    rtl8029as_tcr_t _regval = __DN(p2p0_read_8)(_dev, 0xd);
    return(rtl8029as_tcr_ofst_extract(_regval));
}

static inline void rtl8029as_tcr_crc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_tcr_crc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_tcr_t _regval = 0x1 & (((rtl8029as_tcr_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1e & __DN(p2p0_read_8)(_dev, 0xd)));
    // No read of register shadow required
    // No MB0 fields present
    _regval = (_regval | 0xe0);
    __DN(p2p0_write_8)(_dev, 0xd, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_tcr_lb_wrf(__DN(t) *_dev, rtl8029as_lpconf_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_tcr_lb_wrf(__DN(t) *_dev, rtl8029as_lpconf_t _fieldval)
{
    rtl8029as_tcr_t _regval = 0x6 & (((rtl8029as_tcr_t )(_fieldval)) << 1);
    _regval = (_regval | (0x19 & __DN(p2p0_read_8)(_dev, 0xd)));
    // No read of register shadow required
    // No MB0 fields present
    _regval = (_regval | 0xe0);
    __DN(p2p0_write_8)(_dev, 0xd, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_tcr_atd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_tcr_atd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_tcr_t _regval = 0x8 & (((rtl8029as_tcr_t )(_fieldval)) << 3);
    _regval = (_regval | (0x17 & __DN(p2p0_read_8)(_dev, 0xd)));
    // No read of register shadow required
    // No MB0 fields present
    _regval = (_regval | 0xe0);
    __DN(p2p0_write_8)(_dev, 0xd, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_tcr_ofst_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_tcr_ofst_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_tcr_t _regval = 0x10 & (((rtl8029as_tcr_t )(_fieldval)) << 4);
    _regval = (_regval | (0xf & __DN(p2p0_read_8)(_dev, 0xd)));
    // No read of register shadow required
    // No MB0 fields present
    _regval = (_regval | 0xe0);
    __DN(p2p0_write_8)(_dev, 0xd, _regval);
    // No shadow register to write to
}

/*
 * Register tsr: Transmit Status
 * Type: rtl8029as.tsr (Implicit type of Transmit Status register)
 *   ptx	(size 1, offset 0, init 0):	RO	Transmission completed
 *   _anon1	(size 1, offset 1, init 1):	MB1	_
 *   col	(size 1, offset 2, init 0):	RO	Collision
 *   abt	(size 1, offset 3, init 0):	RO	Aborted (excessive collisions)
 *   crs	(size 1, offset 4, init 0):	RO	Carrier lost
 *   _anon5	(size 1, offset 5, init 0):	MBZ	_
 *   cdh	(size 1, offset 6, init 0):	RO	CD Heartbeat failed
 *   owc	(size 1, offset 7, init 0):	RO	Out of Window collision
 */
static inline rtl8029as_tsr_t rtl8029as_tsr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_tsr_t rtl8029as_tsr_rawrd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0x4));
}

static inline rtl8029as_tsr_t rtl8029as_tsr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_tsr_t rtl8029as_tsr_rd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0x4));
}

static inline void rtl8029as_tsr_rawwr(__DN(t) *_dev, rtl8029as_tsr_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_tsr_rawwr(__DN(t) *_dev, rtl8029as_tsr_t _regval)
{
    __DN(page0_write_8)(_dev, 0x4, _regval);
}

// Register tsr is not writeable
static inline int rtl8029as_tsr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_tsr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    rtl8029as_tsr_t _regval = __DN(page0_read_8)(_dev, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tsr (Transmit Status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ptx =\t%" PRIx8 "\t(Transmission completed)\n", rtl8029as_tsr_ptx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " col =\t%" PRIx8 "\t(Collision)\n", rtl8029as_tsr_col_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " abt =\t%" PRIx8 "\t(Aborted (excessive collisions))\n", rtl8029as_tsr_abt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crs =\t%" PRIx8 "\t(Carrier lost)\n", rtl8029as_tsr_crs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cdh =\t%" PRIx8 "\t(CD Heartbeat failed)\n", rtl8029as_tsr_cdh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " owc =\t%" PRIx8 "\t(Out of Window collision)\n", rtl8029as_tsr_owc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t rtl8029as_tsr_ptx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tsr_ptx_rdf(__DN(t) *_dev)
{
    rtl8029as_tsr_t _regval = __DN(page0_read_8)(_dev, 0x4);
    return(rtl8029as_tsr_ptx_extract(_regval));
}

static inline uint8_t rtl8029as_tsr_col_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tsr_col_rdf(__DN(t) *_dev)
{
    rtl8029as_tsr_t _regval = __DN(page0_read_8)(_dev, 0x4);
    return(rtl8029as_tsr_col_extract(_regval));
}

static inline uint8_t rtl8029as_tsr_abt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tsr_abt_rdf(__DN(t) *_dev)
{
    rtl8029as_tsr_t _regval = __DN(page0_read_8)(_dev, 0x4);
    return(rtl8029as_tsr_abt_extract(_regval));
}

static inline uint8_t rtl8029as_tsr_crs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tsr_crs_rdf(__DN(t) *_dev)
{
    rtl8029as_tsr_t _regval = __DN(page0_read_8)(_dev, 0x4);
    return(rtl8029as_tsr_crs_extract(_regval));
}

static inline uint8_t rtl8029as_tsr_cdh_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tsr_cdh_rdf(__DN(t) *_dev)
{
    rtl8029as_tsr_t _regval = __DN(page0_read_8)(_dev, 0x4);
    return(rtl8029as_tsr_cdh_extract(_regval));
}

static inline uint8_t rtl8029as_tsr_owc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tsr_owc_rdf(__DN(t) *_dev)
{
    rtl8029as_tsr_t _regval = __DN(page0_read_8)(_dev, 0x4);
    return(rtl8029as_tsr_owc_extract(_regval));
}

/*
 * Register rcr: Receive Configuration
 * Type: rtl8029as.rcr (Implicit type of Receive Configuration register)
 *   sep	(size 1, offset 0, init 0):	RW	Accept packets with receive errors
 *   ar	(size 1, offset 1, init 0):	RW	Accept length < 64 bytes
 *   ab	(size 1, offset 2, init 0):	RW	Accept broadcast destination address
 *   am	(size 1, offset 3, init 0):	RW	Accept multicast destination address
 *   pro	(size 1, offset 4, init 0):	RW	Promiscuous mode
 *   mon	(size 1, offset 5, init 0):	RW	Monitor mode
 *   _anon6	(size 2, offset 6, init 3):	MB1	_
 */
static inline rtl8029as_rcr_t rtl8029as_rcr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_rcr_t rtl8029as_rcr_rawrd(__DN(t) *_dev)
{
    return(__DN(p2p0_read_8)(_dev, 0xc));
}

static inline rtl8029as_rcr_t rtl8029as_rcr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_rcr_t rtl8029as_rcr_rd(__DN(t) *_dev)
{
    return(__DN(p2p0_read_8)(_dev, 0xc));
}

static inline void rtl8029as_rcr_rawwr(__DN(t) *_dev, rtl8029as_rcr_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_rcr_rawwr(__DN(t) *_dev, rtl8029as_rcr_t _regval)
{
    __DN(p2p0_write_8)(_dev, 0xc, _regval);
}

static inline void rtl8029as_rcr_wr(__DN(t) *_dev, rtl8029as_rcr_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_rcr_wr(__DN(t) *_dev, rtl8029as_rcr_t _regval)
{
    // No MB0 or RSVD fields present
    _regval = (_regval | 0xc0);
    // No pre-read of register required
    __DN(p2p0_write_8)(_dev, 0xc, _regval);
}

static inline int rtl8029as_rcr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_rcr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    rtl8029as_rcr_t _regval = __DN(p2p0_read_8)(_dev, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rcr (Receive Configuration): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sep =\t%" PRIx8 "\t(Accept packets with receive errors)\n", rtl8029as_rcr_sep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ar =\t%" PRIx8 "\t(Accept length < 64 bytes)\n", rtl8029as_rcr_ar_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ab =\t%" PRIx8 "\t(Accept broadcast destination address)\n", rtl8029as_rcr_ab_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " am =\t%" PRIx8 "\t(Accept multicast destination address)\n", rtl8029as_rcr_am_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pro =\t%" PRIx8 "\t(Promiscuous mode)\n", rtl8029as_rcr_pro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mon =\t%" PRIx8 "\t(Monitor mode)\n", rtl8029as_rcr_mon_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    return(_r);
}

static inline uint8_t rtl8029as_rcr_sep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rcr_sep_rdf(__DN(t) *_dev)
{
    rtl8029as_rcr_t _regval = __DN(p2p0_read_8)(_dev, 0xc);
    return(rtl8029as_rcr_sep_extract(_regval));
}

static inline uint8_t rtl8029as_rcr_ar_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rcr_ar_rdf(__DN(t) *_dev)
{
    rtl8029as_rcr_t _regval = __DN(p2p0_read_8)(_dev, 0xc);
    return(rtl8029as_rcr_ar_extract(_regval));
}

static inline uint8_t rtl8029as_rcr_ab_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rcr_ab_rdf(__DN(t) *_dev)
{
    rtl8029as_rcr_t _regval = __DN(p2p0_read_8)(_dev, 0xc);
    return(rtl8029as_rcr_ab_extract(_regval));
}

static inline uint8_t rtl8029as_rcr_am_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rcr_am_rdf(__DN(t) *_dev)
{
    rtl8029as_rcr_t _regval = __DN(p2p0_read_8)(_dev, 0xc);
    return(rtl8029as_rcr_am_extract(_regval));
}

static inline uint8_t rtl8029as_rcr_pro_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rcr_pro_rdf(__DN(t) *_dev)
{
    rtl8029as_rcr_t _regval = __DN(p2p0_read_8)(_dev, 0xc);
    return(rtl8029as_rcr_pro_extract(_regval));
}

static inline uint8_t rtl8029as_rcr_mon_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rcr_mon_rdf(__DN(t) *_dev)
{
    rtl8029as_rcr_t _regval = __DN(p2p0_read_8)(_dev, 0xc);
    return(rtl8029as_rcr_mon_extract(_regval));
}

static inline void rtl8029as_rcr_sep_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_rcr_sep_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_rcr_t _regval = 0x1 & (((rtl8029as_rcr_t )(_fieldval)) << 0);
    _regval = (_regval | (0x3e & __DN(p2p0_read_8)(_dev, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    _regval = (_regval | 0xc0);
    __DN(p2p0_write_8)(_dev, 0xc, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_rcr_ar_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_rcr_ar_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_rcr_t _regval = 0x2 & (((rtl8029as_rcr_t )(_fieldval)) << 1);
    _regval = (_regval | (0x3d & __DN(p2p0_read_8)(_dev, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    _regval = (_regval | 0xc0);
    __DN(p2p0_write_8)(_dev, 0xc, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_rcr_ab_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_rcr_ab_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_rcr_t _regval = 0x4 & (((rtl8029as_rcr_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3b & __DN(p2p0_read_8)(_dev, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    _regval = (_regval | 0xc0);
    __DN(p2p0_write_8)(_dev, 0xc, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_rcr_am_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_rcr_am_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_rcr_t _regval = 0x8 & (((rtl8029as_rcr_t )(_fieldval)) << 3);
    _regval = (_regval | (0x37 & __DN(p2p0_read_8)(_dev, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    _regval = (_regval | 0xc0);
    __DN(p2p0_write_8)(_dev, 0xc, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_rcr_pro_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_rcr_pro_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_rcr_t _regval = 0x10 & (((rtl8029as_rcr_t )(_fieldval)) << 4);
    _regval = (_regval | (0x2f & __DN(p2p0_read_8)(_dev, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    _regval = (_regval | 0xc0);
    __DN(p2p0_write_8)(_dev, 0xc, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_rcr_mon_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_rcr_mon_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_rcr_t _regval = 0x20 & (((rtl8029as_rcr_t )(_fieldval)) << 5);
    _regval = (_regval | (0x1f & __DN(p2p0_read_8)(_dev, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    _regval = (_regval | 0xc0);
    __DN(p2p0_write_8)(_dev, 0xc, _regval);
    // No shadow register to write to
}

/*
 * Register rsr: Receive Status
 * Type: rtl8029as.rsr (Implicit type of Receive Status register)
 *   prx	(size 1, offset 0, init 0):	RO	Packet received correctly
 *   crc	(size 1, offset 1, init 0):	RO	CRC mismatch
 *   fae	(size 1, offset 2, init 0):	RO	Frame alignment error
 *   _anon3	(size 1, offset 3, init 0):	MBZ	_
 *   mpa	(size 1, offset 4, init 0):	RO	Missed packet
 *   phy	(size 1, offset 5, init 0):	RO	Physical destination error
 *   dis	(size 1, offset 6, init 0):	RO	Receiver disabled
 *   dfr	(size 1, offset 7, init 0):	RO	Deferring
 */
static inline rtl8029as_rsr_t rtl8029as_rsr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_rsr_t rtl8029as_rsr_rawrd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0xc));
}

static inline rtl8029as_rsr_t rtl8029as_rsr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_rsr_t rtl8029as_rsr_rd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0xc));
}

static inline void rtl8029as_rsr_rawwr(__DN(t) *_dev, rtl8029as_rsr_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_rsr_rawwr(__DN(t) *_dev, rtl8029as_rsr_t _regval)
{
    __DN(page0_write_8)(_dev, 0xc, _regval);
}

// Register rsr is not writeable
static inline int rtl8029as_rsr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_rsr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    rtl8029as_rsr_t _regval = __DN(page0_read_8)(_dev, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rsr (Receive Status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prx =\t%" PRIx8 "\t(Packet received correctly)\n", rtl8029as_rsr_prx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crc =\t%" PRIx8 "\t(CRC mismatch)\n", rtl8029as_rsr_crc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fae =\t%" PRIx8 "\t(Frame alignment error)\n", rtl8029as_rsr_fae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mpa =\t%" PRIx8 "\t(Missed packet)\n", rtl8029as_rsr_mpa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phy =\t%" PRIx8 "\t(Physical destination error)\n", rtl8029as_rsr_phy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dis =\t%" PRIx8 "\t(Receiver disabled)\n", rtl8029as_rsr_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dfr =\t%" PRIx8 "\t(Deferring)\n", rtl8029as_rsr_dfr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t rtl8029as_rsr_prx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rsr_prx_rdf(__DN(t) *_dev)
{
    rtl8029as_rsr_t _regval = __DN(page0_read_8)(_dev, 0xc);
    return(rtl8029as_rsr_prx_extract(_regval));
}

static inline uint8_t rtl8029as_rsr_crc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rsr_crc_rdf(__DN(t) *_dev)
{
    rtl8029as_rsr_t _regval = __DN(page0_read_8)(_dev, 0xc);
    return(rtl8029as_rsr_crc_extract(_regval));
}

static inline uint8_t rtl8029as_rsr_fae_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rsr_fae_rdf(__DN(t) *_dev)
{
    rtl8029as_rsr_t _regval = __DN(page0_read_8)(_dev, 0xc);
    return(rtl8029as_rsr_fae_extract(_regval));
}

static inline uint8_t rtl8029as_rsr_mpa_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rsr_mpa_rdf(__DN(t) *_dev)
{
    rtl8029as_rsr_t _regval = __DN(page0_read_8)(_dev, 0xc);
    return(rtl8029as_rsr_mpa_extract(_regval));
}

static inline uint8_t rtl8029as_rsr_phy_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rsr_phy_rdf(__DN(t) *_dev)
{
    rtl8029as_rsr_t _regval = __DN(page0_read_8)(_dev, 0xc);
    return(rtl8029as_rsr_phy_extract(_regval));
}

static inline uint8_t rtl8029as_rsr_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rsr_dis_rdf(__DN(t) *_dev)
{
    rtl8029as_rsr_t _regval = __DN(page0_read_8)(_dev, 0xc);
    return(rtl8029as_rsr_dis_extract(_regval));
}

static inline uint8_t rtl8029as_rsr_dfr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rsr_dfr_rdf(__DN(t) *_dev)
{
    rtl8029as_rsr_t _regval = __DN(page0_read_8)(_dev, 0xc);
    return(rtl8029as_rsr_dfr_extract(_regval));
}

/*
 * Register clda: Current Local DMA
 * Type: rtl8029as.uint16 (primitive type)
 */
static inline uint16_t rtl8029as_clda_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t rtl8029as_clda_rawrd(__DN(t) *_dev)
{
    return(__DN(page0_read_16)(_dev, 0x1));
}

static inline uint16_t rtl8029as_clda_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t rtl8029as_clda_rd(__DN(t) *_dev)
{
    return(__DN(page0_read_16)(_dev, 0x1));
}

static inline void rtl8029as_clda_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_clda_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    __DN(page0_write_16)(_dev, 0x1, _regval);
}

// Register clda is not writeable
static inline int rtl8029as_clda_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_clda_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = __DN(page0_read_16)(_dev, 0x1);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register clda (Current Local DMA): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register pstart: Page Start
 * Type: rtl8029as.uint8 (primitive type)
 */
static inline uint8_t rtl8029as_pstart_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_pstart_rawrd(__DN(t) *_dev)
{
    return(__DN(p2p0_read_8)(_dev, 0x1));
}

static inline uint8_t rtl8029as_pstart_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_pstart_rd(__DN(t) *_dev)
{
    return(__DN(p2p0_read_8)(_dev, 0x1));
}

static inline void rtl8029as_pstart_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_pstart_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    __DN(p2p0_write_8)(_dev, 0x1, _regval);
}

static inline void rtl8029as_pstart_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_pstart_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(p2p0_write_8)(_dev, 0x1, _regval);
}

static inline int rtl8029as_pstart_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_pstart_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = __DN(p2p0_read_8)(_dev, 0x1);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pstart (Page Start): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register pstop: Page Stop
 * Type: rtl8029as.uint8 (primitive type)
 */
static inline uint8_t rtl8029as_pstop_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_pstop_rawrd(__DN(t) *_dev)
{
    return(__DN(p2p0_read_8)(_dev, 0x2));
}

static inline uint8_t rtl8029as_pstop_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_pstop_rd(__DN(t) *_dev)
{
    return(__DN(p2p0_read_8)(_dev, 0x2));
}

static inline void rtl8029as_pstop_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_pstop_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    __DN(p2p0_write_8)(_dev, 0x2, _regval);
}

static inline void rtl8029as_pstop_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_pstop_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(p2p0_write_8)(_dev, 0x2, _regval);
}

static inline int rtl8029as_pstop_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_pstop_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = __DN(p2p0_read_8)(_dev, 0x2);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pstop (Page Stop): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register bnry: Boundary
 * Type: rtl8029as.uint8 (primitive type)
 */
static inline uint8_t rtl8029as_bnry_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_bnry_rawrd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0x3));
}

static inline uint8_t rtl8029as_bnry_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_bnry_rd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0x3));
}

static inline void rtl8029as_bnry_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_bnry_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    __DN(page0_write_8)(_dev, 0x3, _regval);
}

static inline void rtl8029as_bnry_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_bnry_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(page0_write_8)(_dev, 0x3, _regval);
}

static inline int rtl8029as_bnry_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_bnry_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = __DN(page0_read_8)(_dev, 0x3);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register bnry (Boundary): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register tpsr: Transmit Page Start
 * Type: rtl8029as.uint8 (primitive type)
 */
static inline uint8_t rtl8029as_tpsr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tpsr_rawrd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0x4));
}

static inline uint8_t rtl8029as_tpsr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_tpsr_rd(__DN(t) *_dev)
{
    return(_dev->tpsr_shadow);
}

static inline void rtl8029as_tpsr_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_tpsr_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    __DN(page0_write_8)(_dev, 0x4, _regval);
}

static inline void rtl8029as_tpsr_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_tpsr_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(page0_write_8)(_dev, 0x4, _regval);
}

static inline int rtl8029as_tpsr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_tpsr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = _dev->tpsr_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tpsr (Transmit Page Start): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 " (SHADOW copy)\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register tbcr: Transmit Byte Count
 * Type: rtl8029as.uint16 (primitive type)
 */
static inline uint16_t rtl8029as_tbcr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t rtl8029as_tbcr_rawrd(__DN(t) *_dev)
{
    return(__DN(page0_read_16)(_dev, 0x5));
}

static inline uint16_t rtl8029as_tbcr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t rtl8029as_tbcr_rd(__DN(t) *_dev)
{
    return(_dev->tbcr_shadow);
}

static inline void rtl8029as_tbcr_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_tbcr_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    __DN(page0_write_16)(_dev, 0x5, _regval);
}

static inline void rtl8029as_tbcr_wr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_tbcr_wr(__DN(t) *_dev, uint16_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(page0_write_16)(_dev, 0x5, _regval);
}

static inline int rtl8029as_tbcr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_tbcr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = _dev->tbcr_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tbcr (Transmit Byte Count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 " (SHADOW copy)\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ncr: Number of Collisions
 * Type: rtl8029as.uint8 (primitive type)
 */
static inline uint8_t rtl8029as_ncr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_ncr_rawrd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0x5));
}

static inline uint8_t rtl8029as_ncr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_ncr_rd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0x5));
}

static inline void rtl8029as_ncr_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_ncr_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    __DN(page0_write_8)(_dev, 0x5, _regval);
}

// Register ncr is not writeable
static inline int rtl8029as_ncr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_ncr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = __DN(page0_read_8)(_dev, 0x5);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ncr (Number of Collisions): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register fifo: FIFO
 * Type: rtl8029as.uint8 (primitive type)
 */
static inline uint8_t rtl8029as_fifo_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_fifo_rawrd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0x6));
}

static inline uint8_t rtl8029as_fifo_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_fifo_rd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0x6));
}

static inline void rtl8029as_fifo_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_fifo_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    __DN(page0_write_8)(_dev, 0x6, _regval);
}

// Register fifo is not writeable
static inline int rtl8029as_fifo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_fifo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = __DN(page0_read_8)(_dev, 0x6);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fifo (FIFO): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register crda: Current Remote DMA Address
 * Type: rtl8029as.uint16 (primitive type)
 */
static inline uint16_t rtl8029as_crda_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t rtl8029as_crda_rawrd(__DN(t) *_dev)
{
    return(__DN(page0_read_16)(_dev, 0x8));
}

static inline uint16_t rtl8029as_crda_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t rtl8029as_crda_rd(__DN(t) *_dev)
{
    return(__DN(page0_read_16)(_dev, 0x8));
}

static inline void rtl8029as_crda_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_crda_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    __DN(page0_write_16)(_dev, 0x8, _regval);
}

// Register crda is not writeable
static inline int rtl8029as_crda_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_crda_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = __DN(page0_read_16)(_dev, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register crda (Current Remote DMA Address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rsar: Remote Start Address
 * Type: rtl8029as.uint16 (primitive type)
 */
static inline uint16_t rtl8029as_rsar_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t rtl8029as_rsar_rawrd(__DN(t) *_dev)
{
    return(__DN(page0_read_16)(_dev, 0x8));
}

static inline uint16_t rtl8029as_rsar_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t rtl8029as_rsar_rd(__DN(t) *_dev)
{
    return(_dev->rsar_shadow);
}

static inline void rtl8029as_rsar_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_rsar_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    __DN(page0_write_16)(_dev, 0x8, _regval);
}

static inline void rtl8029as_rsar_wr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_rsar_wr(__DN(t) *_dev, uint16_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(page0_write_16)(_dev, 0x8, _regval);
}

static inline int rtl8029as_rsar_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_rsar_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = _dev->rsar_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rsar (Remote Start Address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 " (SHADOW copy)\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rbcr: Remote Byte Count
 * Type: rtl8029as.uint16 (primitive type)
 */
static inline uint16_t rtl8029as_rbcr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t rtl8029as_rbcr_rawrd(__DN(t) *_dev)
{
    return(__DN(page0_read_16)(_dev, 0xa));
}

static inline uint16_t rtl8029as_rbcr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t rtl8029as_rbcr_rd(__DN(t) *_dev)
{
    return(_dev->rbcr_shadow);
}

static inline void rtl8029as_rbcr_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_rbcr_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    __DN(page0_write_16)(_dev, 0xa, _regval);
}

static inline void rtl8029as_rbcr_wr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_rbcr_wr(__DN(t) *_dev, uint16_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(page0_write_16)(_dev, 0xa, _regval);
}

static inline int rtl8029as_rbcr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_rbcr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = _dev->rbcr_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rbcr (Remote Byte Count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 " (SHADOW copy)\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register cntr0: Frame Alignment Error Tally Counter
 * Type: rtl8029as.uint8 (primitive type)
 */
static inline uint8_t rtl8029as_cntr0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cntr0_rawrd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0xd));
}

static inline uint8_t rtl8029as_cntr0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cntr0_rd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0xd));
}

static inline void rtl8029as_cntr0_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_cntr0_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    __DN(page0_write_8)(_dev, 0xd, _regval);
}

// Register cntr0 is not writeable
static inline int rtl8029as_cntr0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_cntr0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = __DN(page0_read_8)(_dev, 0xd);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cntr0 (Frame Alignment Error Tally Counter): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register cntr1: CRC Error Tally Counter
 * Type: rtl8029as.uint8 (primitive type)
 */
static inline uint8_t rtl8029as_cntr1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cntr1_rawrd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0xe));
}

static inline uint8_t rtl8029as_cntr1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cntr1_rd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0xe));
}

static inline void rtl8029as_cntr1_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_cntr1_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    __DN(page0_write_8)(_dev, 0xe, _regval);
}

// Register cntr1 is not writeable
static inline int rtl8029as_cntr1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_cntr1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = __DN(page0_read_8)(_dev, 0xe);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cntr1 (CRC Error Tally Counter): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register cntr2: Missed Packet Tally Counter
 * Type: rtl8029as.uint8 (primitive type)
 */
static inline uint8_t rtl8029as_cntr2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cntr2_rawrd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0xf));
}

static inline uint8_t rtl8029as_cntr2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cntr2_rd(__DN(t) *_dev)
{
    return(__DN(page0_read_8)(_dev, 0xf));
}

static inline void rtl8029as_cntr2_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_cntr2_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    __DN(page0_write_8)(_dev, 0xf, _regval);
}

// Register cntr2 is not writeable
static inline int rtl8029as_cntr2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_cntr2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = __DN(page0_read_8)(_dev, 0xf);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cntr2 (Missed Packet Tally Counter): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register array par: Physical Address
 * Type: rtl8029as.uint8 (primitive type)
 */
static const size_t rtl8029as_par_length = 6;
static inline uint8_t rtl8029as_par_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_par_rawrd(__DN(t) *_dev, int _i)
{
    return(__DN(page1_read_8)(_dev, 0x1 + (_i * (8 / 8))));
}

static inline uint8_t rtl8029as_par_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_par_rd(__DN(t) *_dev, int _i)
{
    return(__DN(page1_read_8)(_dev, 0x1 + (_i * (8 / 8))));
}

static inline void rtl8029as_par_rawwr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_par_rawwr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    __DN(page1_write_8)(_dev, 0x1 + (_i * (8 / 8)), _regval);
}

static inline void rtl8029as_par_wr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_par_wr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(page1_write_8)(_dev, 0x1 + (_i * (8 / 8)), _regval);
}

static inline int rtl8029as_par_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int rtl8029as_par_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = __DN(page1_read_8)(_dev, 0x1 + (_i * (8 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "par", _i, "Physical Address");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int rtl8029as_par_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_par_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 6; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = rtl8029as_par_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register curr: Current Page
 * Type: rtl8029as.uint8 (primitive type)
 */
static inline uint8_t rtl8029as_curr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_curr_rawrd(__DN(t) *_dev)
{
    return(__DN(page1_read_8)(_dev, 0x7));
}

static inline uint8_t rtl8029as_curr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_curr_rd(__DN(t) *_dev)
{
    return(__DN(page1_read_8)(_dev, 0x7));
}

static inline void rtl8029as_curr_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_curr_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    __DN(page1_write_8)(_dev, 0x7, _regval);
}

static inline void rtl8029as_curr_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_curr_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(page1_write_8)(_dev, 0x7, _regval);
}

static inline int rtl8029as_curr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_curr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = __DN(page1_read_8)(_dev, 0x7);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register curr (Current Page): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register array mar: Multicast Address
 * Type: rtl8029as.uint8 (primitive type)
 */
static const size_t rtl8029as_mar_length = 8;
static inline uint8_t rtl8029as_mar_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_mar_rawrd(__DN(t) *_dev, int _i)
{
    return(__DN(page1_read_8)(_dev, 0x8 + (_i * (8 / 8))));
}

static inline uint8_t rtl8029as_mar_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_mar_rd(__DN(t) *_dev, int _i)
{
    return(__DN(page1_read_8)(_dev, 0x8 + (_i * (8 / 8))));
}

static inline void rtl8029as_mar_rawwr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_mar_rawwr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    __DN(page1_write_8)(_dev, 0x8 + (_i * (8 / 8)), _regval);
}

static inline void rtl8029as_mar_wr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_mar_wr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(page1_write_8)(_dev, 0x8 + (_i * (8 / 8)), _regval);
}

static inline int rtl8029as_mar_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int rtl8029as_mar_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = __DN(page1_read_8)(_dev, 0x8 + (_i * (8 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "mar", _i, "Multicast Address");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int rtl8029as_mar_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_mar_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = rtl8029as_mar_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array chipid: RTL8029AS Chip ID
 * Type: rtl8029as.uint8 (primitive type)
 */
static const size_t rtl8029as_chipid_length = 2;
static inline uint8_t rtl8029as_chipid_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_chipid_rawrd(__DN(t) *_dev, int _i)
{
    return(__DN(page0_read_8)(_dev, 0xa + (_i * (8 / 8))));
}

static inline uint8_t rtl8029as_chipid_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_chipid_rd(__DN(t) *_dev, int _i)
{
    return(__DN(page0_read_8)(_dev, 0xa + (_i * (8 / 8))));
}

static inline void rtl8029as_chipid_rawwr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_chipid_rawwr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    __DN(page0_write_8)(_dev, 0xa + (_i * (8 / 8)), _regval);
}

// Register chipid is not writeable
static inline int rtl8029as_chipid_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int rtl8029as_chipid_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = __DN(page0_read_8)(_dev, 0xa + (_i * (8 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "chipid", _i, "RTL8029AS Chip ID");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int rtl8029as_chipid_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_chipid_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = rtl8029as_chipid_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register cr9346: 9346 Command
 * Type: rtl8029as.cr9346 (Implicit type of 9346 Command register)
 *   eedo	(size 1, offset 0, init 0):	RW	eedo
 *   eedi	(size 1, offset 1, init 0):	RW	eedi
 *   eesk	(size 1, offset 2, init 0):	RW	eesk
 *   eecs	(size 1, offset 3, init 0):	RW	eecs
 *   _anon4	(size 2, offset 4, init 0):	RSVD	_
 *   eem	(size 2, offset 6, init 0):	RW	RTL8029AS operating mode
 */
static inline rtl8029as_cr9346_t rtl8029as_cr9346_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_cr9346_t rtl8029as_cr9346_rawrd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_8)(_dev, 0x1));
}

static inline rtl8029as_cr9346_t rtl8029as_cr9346_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_cr9346_t rtl8029as_cr9346_rd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_8)(_dev, 0x1));
}

static inline void rtl8029as_cr9346_rawwr(__DN(t) *_dev, rtl8029as_cr9346_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_cr9346_rawwr(__DN(t) *_dev, rtl8029as_cr9346_t _regval)
{
    __DN(rtlp_write_8)(_dev, 0x1, _regval);
}

static inline void rtl8029as_cr9346_wr(__DN(t) *_dev, rtl8029as_cr9346_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_cr9346_wr(__DN(t) *_dev, rtl8029as_cr9346_t _regval)
{
    _regval = (_regval & 0xcf);
    // No MB1 fields present
    _regval = (_regval | (0x30 & __DN(rtlp_read_8)(_dev, 0x1)));
    __DN(rtlp_write_8)(_dev, 0x1, _regval);
}

static inline int rtl8029as_cr9346_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_cr9346_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    rtl8029as_cr9346_t _regval = __DN(rtlp_read_8)(_dev, 0x1);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cr9346 (9346 Command): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eedo =\t%" PRIx8 "\t(eedo)\n", rtl8029as_cr9346_eedo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eedi =\t%" PRIx8 "\t(eedi)\n", rtl8029as_cr9346_eedi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eesk =\t%" PRIx8 "\t(eesk)\n", rtl8029as_cr9346_eesk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eecs =\t%" PRIx8 "\t(eecs)\n", rtl8029as_cr9346_eecs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eem =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_mode_prtval(_s + _r, _avail, rtl8029as_cr9346_eem_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(RTL8029AS operating mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t rtl8029as_cr9346_eedo_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cr9346_eedo_rdf(__DN(t) *_dev)
{
    rtl8029as_cr9346_t _regval = __DN(rtlp_read_8)(_dev, 0x1);
    return(rtl8029as_cr9346_eedo_extract(_regval));
}

static inline uint8_t rtl8029as_cr9346_eedi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cr9346_eedi_rdf(__DN(t) *_dev)
{
    rtl8029as_cr9346_t _regval = __DN(rtlp_read_8)(_dev, 0x1);
    return(rtl8029as_cr9346_eedi_extract(_regval));
}

static inline uint8_t rtl8029as_cr9346_eesk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cr9346_eesk_rdf(__DN(t) *_dev)
{
    rtl8029as_cr9346_t _regval = __DN(rtlp_read_8)(_dev, 0x1);
    return(rtl8029as_cr9346_eesk_extract(_regval));
}

static inline uint8_t rtl8029as_cr9346_eecs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_cr9346_eecs_rdf(__DN(t) *_dev)
{
    rtl8029as_cr9346_t _regval = __DN(rtlp_read_8)(_dev, 0x1);
    return(rtl8029as_cr9346_eecs_extract(_regval));
}

static inline rtl8029as_mode_t rtl8029as_cr9346_eem_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_mode_t rtl8029as_cr9346_eem_rdf(__DN(t) *_dev)
{
    rtl8029as_cr9346_t _regval = __DN(rtlp_read_8)(_dev, 0x1);
    return(rtl8029as_cr9346_eem_extract(_regval));
}

static inline void rtl8029as_cr9346_eedo_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_cr9346_eedo_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_cr9346_t _regval = 0x1 & (((rtl8029as_cr9346_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfe & __DN(rtlp_read_8)(_dev, 0x1)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(rtlp_write_8)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_cr9346_eedi_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_cr9346_eedi_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_cr9346_t _regval = 0x2 & (((rtl8029as_cr9346_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfd & __DN(rtlp_read_8)(_dev, 0x1)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(rtlp_write_8)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_cr9346_eesk_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_cr9346_eesk_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_cr9346_t _regval = 0x4 & (((rtl8029as_cr9346_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfb & __DN(rtlp_read_8)(_dev, 0x1)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(rtlp_write_8)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_cr9346_eecs_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_cr9346_eecs_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_cr9346_t _regval = 0x8 & (((rtl8029as_cr9346_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf7 & __DN(rtlp_read_8)(_dev, 0x1)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(rtlp_write_8)(_dev, 0x1, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_cr9346_eem_wrf(__DN(t) *_dev, rtl8029as_mode_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_cr9346_eem_wrf(__DN(t) *_dev, rtl8029as_mode_t _fieldval)
{
    rtl8029as_cr9346_t _regval = 0xc0 & (((rtl8029as_cr9346_t )(_fieldval)) << 6);
    _regval = (_regval | (0x3f & __DN(rtlp_read_8)(_dev, 0x1)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(rtlp_write_8)(_dev, 0x1, _regval);
    // No shadow register to write to
}

/*
 * Register config0: RTL8029AS Configuration 0
 * Type: rtl8029as.config0 (Implicit type of RTL8029AS Configuration 0 register)
 *   _anon0	(size 2, offset 0, init 0):	MBZ	_
 *   bnc	(size 1, offset 2, init 0):	RO	10Base2 thin cable connected
 *   _anon3	(size 5, offset 3, init 0):	RSVD	_
 */
static inline rtl8029as_config0_t rtl8029as_config0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_config0_t rtl8029as_config0_rawrd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_8)(_dev, 0x3));
}

static inline rtl8029as_config0_t rtl8029as_config0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_config0_t rtl8029as_config0_rd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_8)(_dev, 0x3));
}

static inline void rtl8029as_config0_rawwr(__DN(t) *_dev, rtl8029as_config0_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_config0_rawwr(__DN(t) *_dev, rtl8029as_config0_t _regval)
{
    __DN(rtlp_write_8)(_dev, 0x3, _regval);
}

// Register config0 is not writeable
static inline int rtl8029as_config0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_config0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    rtl8029as_config0_t _regval = __DN(rtlp_read_8)(_dev, 0x3);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register config0 (RTL8029AS Configuration 0): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bnc =\t%" PRIx8 "\t(10Base2 thin cable connected)\n", rtl8029as_config0_bnc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t rtl8029as_config0_bnc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_config0_bnc_rdf(__DN(t) *_dev)
{
    rtl8029as_config0_t _regval = __DN(rtlp_read_8)(_dev, 0x3);
    return(rtl8029as_config0_bnc_extract(_regval));
}

/*
 * Register config2: RTL8029AS Configuration 2
 * Type: rtl8029as.config2 (Implicit type of RTL8029AS Configuration 2 register)
 *   bs	(size 2, offset 0, init 0):	RO	Boot ROM size
 *   _anon2	(size 2, offset 2, init 0):	RSVD	_
 *   pf	(size 1, offset 4, init 0):	RO	Pause flag
 *   fce	(size 1, offset 5, init 0):	RW	Flow control enable
 *   pl	(size 2, offset 6, init 0):	RW	Network medium select
 */
static inline rtl8029as_config2_t rtl8029as_config2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_config2_t rtl8029as_config2_rawrd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_8)(_dev, 0x5));
}

static inline rtl8029as_config2_t rtl8029as_config2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_config2_t rtl8029as_config2_rd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_8)(_dev, 0x5));
}

static inline void rtl8029as_config2_rawwr(__DN(t) *_dev, rtl8029as_config2_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_config2_rawwr(__DN(t) *_dev, rtl8029as_config2_t _regval)
{
    __DN(rtlp_write_8)(_dev, 0x5, _regval);
}

static inline void rtl8029as_config2_wr(__DN(t) *_dev, rtl8029as_config2_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_config2_wr(__DN(t) *_dev, rtl8029as_config2_t _regval)
{
    _regval = (_regval & 0xf3);
    // No MB1 fields present
    _regval = (_regval | (0xc & __DN(rtlp_read_8)(_dev, 0x5)));
    __DN(rtlp_write_8)(_dev, 0x5, _regval);
}

static inline int rtl8029as_config2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_config2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    rtl8029as_config2_t _regval = __DN(rtlp_read_8)(_dev, 0x5);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register config2 (RTL8029AS Configuration 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bs =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_bromsize_prtval(_s + _r, _avail, rtl8029as_config2_bs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Boot ROM size)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pf =\t%" PRIx8 "\t(Pause flag)\n", rtl8029as_config2_pf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fce =\t%" PRIx8 "\t(Flow control enable)\n", rtl8029as_config2_fce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pl =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_medium_prtval(_s + _r, _avail, rtl8029as_config2_pl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Network medium select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline rtl8029as_bromsize_t rtl8029as_config2_bs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_bromsize_t rtl8029as_config2_bs_rdf(__DN(t) *_dev)
{
    rtl8029as_config2_t _regval = __DN(rtlp_read_8)(_dev, 0x5);
    return(rtl8029as_config2_bs_extract(_regval));
}

static inline uint8_t rtl8029as_config2_pf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_config2_pf_rdf(__DN(t) *_dev)
{
    rtl8029as_config2_t _regval = __DN(rtlp_read_8)(_dev, 0x5);
    return(rtl8029as_config2_pf_extract(_regval));
}

static inline uint8_t rtl8029as_config2_fce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_config2_fce_rdf(__DN(t) *_dev)
{
    rtl8029as_config2_t _regval = __DN(rtlp_read_8)(_dev, 0x5);
    return(rtl8029as_config2_fce_extract(_regval));
}

static inline rtl8029as_medium_t rtl8029as_config2_pl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_medium_t rtl8029as_config2_pl_rdf(__DN(t) *_dev)
{
    rtl8029as_config2_t _regval = __DN(rtlp_read_8)(_dev, 0x5);
    return(rtl8029as_config2_pl_extract(_regval));
}

static inline void rtl8029as_config2_fce_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_config2_fce_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_config2_t _regval = 0x20 & (((rtl8029as_config2_t )(_fieldval)) << 5);
    _regval = (_regval | (0xcc & __DN(rtlp_read_8)(_dev, 0x5)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(rtlp_write_8)(_dev, 0x5, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_config2_pl_wrf(__DN(t) *_dev, rtl8029as_medium_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_config2_pl_wrf(__DN(t) *_dev, rtl8029as_medium_t _fieldval)
{
    rtl8029as_config2_t _regval = 0xc0 & (((rtl8029as_config2_t )(_fieldval)) << 6);
    _regval = (_regval | (0x2c & __DN(rtlp_read_8)(_dev, 0x5)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    __DN(rtlp_write_8)(_dev, 0x5, _regval);
    // No shadow register to write to
}

/*
 * Register config3: RTL8029AS Configuration 3
 * Type: rtl8029as.config3 (Implicit type of RTL8029AS Configuration 3 register)
 *   _anon0	(size 1, offset 0, init 0):	RSVD	_
 *   pwrdn	(size 1, offset 1, init 0):	RW	Power down mode
 *   sleep	(size 1, offset 2, init 0):	RW	Sleep mode
 *   _anon3	(size 1, offset 3, init 0):	MBZ	_
 *   leds	(size 2, offset 4, init 0):	RW	LED control
 *   fudup	(size 1, offset 6, init 0):	RW	Full-duplex mode
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 */
static inline rtl8029as_config3_t rtl8029as_config3_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_config3_t rtl8029as_config3_rawrd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_8)(_dev, 0x6));
}

static inline rtl8029as_config3_t rtl8029as_config3_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_config3_t rtl8029as_config3_rd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_8)(_dev, 0x6));
}

static inline void rtl8029as_config3_rawwr(__DN(t) *_dev, rtl8029as_config3_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_config3_rawwr(__DN(t) *_dev, rtl8029as_config3_t _regval)
{
    __DN(rtlp_write_8)(_dev, 0x6, _regval);
}

static inline void rtl8029as_config3_wr(__DN(t) *_dev, rtl8029as_config3_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_config3_wr(__DN(t) *_dev, rtl8029as_config3_t _regval)
{
    _regval = (_regval & 0x76);
    // No MB1 fields present
    _regval = (_regval | (0x81 & __DN(rtlp_read_8)(_dev, 0x6)));
    __DN(rtlp_write_8)(_dev, 0x6, _regval);
}

static inline int rtl8029as_config3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_config3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    rtl8029as_config3_t _regval = __DN(rtlp_read_8)(_dev, 0x6);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register config3 (RTL8029AS Configuration 3): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pwrdn =\t%" PRIx8 "\t(Power down mode)\n", rtl8029as_config3_pwrdn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sleep =\t%" PRIx8 "\t(Sleep mode)\n", rtl8029as_config3_sleep_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " leds =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_leds_prtval(_s + _r, _avail, rtl8029as_config3_leds_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fudup =\t%" PRIx8 "\t(Full-duplex mode)\n", rtl8029as_config3_fudup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    return(_r);
}

static inline uint8_t rtl8029as_config3_pwrdn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_config3_pwrdn_rdf(__DN(t) *_dev)
{
    rtl8029as_config3_t _regval = __DN(rtlp_read_8)(_dev, 0x6);
    return(rtl8029as_config3_pwrdn_extract(_regval));
}

static inline uint8_t rtl8029as_config3_sleep_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_config3_sleep_rdf(__DN(t) *_dev)
{
    rtl8029as_config3_t _regval = __DN(rtlp_read_8)(_dev, 0x6);
    return(rtl8029as_config3_sleep_extract(_regval));
}

static inline rtl8029as_leds_t rtl8029as_config3_leds_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline rtl8029as_leds_t rtl8029as_config3_leds_rdf(__DN(t) *_dev)
{
    rtl8029as_config3_t _regval = __DN(rtlp_read_8)(_dev, 0x6);
    return(rtl8029as_config3_leds_extract(_regval));
}

static inline uint8_t rtl8029as_config3_fudup_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_config3_fudup_rdf(__DN(t) *_dev)
{
    rtl8029as_config3_t _regval = __DN(rtlp_read_8)(_dev, 0x6);
    return(rtl8029as_config3_fudup_extract(_regval));
}

static inline void rtl8029as_config3_pwrdn_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_config3_pwrdn_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_config3_t _regval = 0x2 & (((rtl8029as_config3_t )(_fieldval)) << 1);
    _regval = (_regval | (0xf5 & __DN(rtlp_read_8)(_dev, 0x6)));
    // No read of register shadow required
    _regval = (_regval & 0xf7);
    // No MB1 fields present
    __DN(rtlp_write_8)(_dev, 0x6, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_config3_sleep_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_config3_sleep_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_config3_t _regval = 0x4 & (((rtl8029as_config3_t )(_fieldval)) << 2);
    _regval = (_regval | (0xf3 & __DN(rtlp_read_8)(_dev, 0x6)));
    // No read of register shadow required
    _regval = (_regval & 0xf7);
    // No MB1 fields present
    __DN(rtlp_write_8)(_dev, 0x6, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_config3_leds_wrf(__DN(t) *_dev, rtl8029as_leds_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_config3_leds_wrf(__DN(t) *_dev, rtl8029as_leds_t _fieldval)
{
    rtl8029as_config3_t _regval = 0x30 & (((rtl8029as_config3_t )(_fieldval)) << 4);
    _regval = (_regval | (0xc7 & __DN(rtlp_read_8)(_dev, 0x6)));
    // No read of register shadow required
    _regval = (_regval & 0xf7);
    // No MB1 fields present
    __DN(rtlp_write_8)(_dev, 0x6, _regval);
    // No shadow register to write to
}

static inline void rtl8029as_config3_fudup_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void rtl8029as_config3_fudup_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    rtl8029as_config3_t _regval = 0x40 & (((rtl8029as_config3_t )(_fieldval)) << 6);
    _regval = (_regval | (0xb7 & __DN(rtlp_read_8)(_dev, 0x6)));
    // No read of register shadow required
    _regval = (_regval & 0xf7);
    // No MB1 fields present
    __DN(rtlp_write_8)(_dev, 0x6, _regval);
    // No shadow register to write to
}

/*
 * Register hltclk: Halt Clock
 * Type: rtl8029as.uint8 (primitive type)
 */
static inline uint8_t rtl8029as_hltclk_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_hltclk_rawrd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_8)(_dev, 0x9));
}

static inline uint8_t rtl8029as_hltclk_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_hltclk_rd(__DN(t) *_dev)
{
    return(_dev->hltclk_shadow);
}

static inline void rtl8029as_hltclk_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_hltclk_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    __DN(rtlp_write_8)(_dev, 0x9, _regval);
}

static inline void rtl8029as_hltclk_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_hltclk_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(rtlp_write_8)(_dev, 0x9, _regval);
}

static inline int rtl8029as_hltclk_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_hltclk_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = _dev->hltclk_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hltclk (Halt Clock): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 " (SHADOW copy)\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register asid: 8029AS ID
 * Type: rtl8029as.uint16 (primitive type)
 */
static inline uint16_t rtl8029as_asid_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t rtl8029as_asid_rawrd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_16)(_dev, 0xe));
}

static inline uint16_t rtl8029as_asid_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t rtl8029as_asid_rd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_16)(_dev, 0xe));
}

static inline void rtl8029as_asid_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_asid_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    __DN(rtlp_write_16)(_dev, 0xe, _regval);
}

// Register asid is not writeable
static inline int rtl8029as_asid_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_asid_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = __DN(rtlp_read_16)(_dev, 0xe);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register asid (8029AS ID): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rdma32: Remote DMA 32-bit
 * Type: rtl8029as.uint32 (primitive type)
 */
static inline uint32_t rtl8029as_rdma32_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t rtl8029as_rdma32_rawrd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_32)(_dev, 0x10));
}

static inline uint32_t rtl8029as_rdma32_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t rtl8029as_rdma32_rd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_32)(_dev, 0x10));
}

static inline void rtl8029as_rdma32_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_rdma32_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    __DN(rtlp_write_32)(_dev, 0x10, _regval);
}

static inline void rtl8029as_rdma32_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_rdma32_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(rtlp_write_32)(_dev, 0x10, _regval);
}

static inline int rtl8029as_rdma32_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_rdma32_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = __DN(rtlp_read_32)(_dev, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rdma32 (Remote DMA 32-bit): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rdma16: Remote DMA 16-bit
 * Type: rtl8029as.uint16 (primitive type)
 */
static inline uint16_t rtl8029as_rdma16_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t rtl8029as_rdma16_rawrd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_16)(_dev, 0x10));
}

static inline uint16_t rtl8029as_rdma16_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t rtl8029as_rdma16_rd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_16)(_dev, 0x10));
}

static inline void rtl8029as_rdma16_rawwr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_rdma16_rawwr(__DN(t) *_dev, uint16_t _regval)
{
    __DN(rtlp_write_16)(_dev, 0x10, _regval);
}

static inline void rtl8029as_rdma16_wr(__DN(t) *_dev, uint16_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_rdma16_wr(__DN(t) *_dev, uint16_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(rtlp_write_16)(_dev, 0x10, _regval);
}

static inline int rtl8029as_rdma16_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_rdma16_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint16_t _regval = __DN(rtlp_read_16)(_dev, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rdma16 (Remote DMA 16-bit): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx16 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rdma8: Remote DMA 8-bit
 * Type: rtl8029as.uint8 (primitive type)
 */
static inline uint8_t rtl8029as_rdma8_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rdma8_rawrd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_8)(_dev, 0x10));
}

static inline uint8_t rtl8029as_rdma8_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_rdma8_rd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_8)(_dev, 0x10));
}

static inline void rtl8029as_rdma8_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_rdma8_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    __DN(rtlp_write_8)(_dev, 0x10, _regval);
}

static inline void rtl8029as_rdma8_wr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_rdma8_wr(__DN(t) *_dev, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    __DN(rtlp_write_8)(_dev, 0x10, _regval);
}

static inline int rtl8029as_rdma8_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_rdma8_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = __DN(rtlp_read_8)(_dev, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rdma8 (Remote DMA 8-bit): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register reset: Reset
 * Type: rtl8029as.uint8 (primitive type)
 */
static inline uint8_t rtl8029as_reset_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_reset_rawrd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_8)(_dev, 0x1f));
}

static inline uint8_t rtl8029as_reset_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t rtl8029as_reset_rd(__DN(t) *_dev)
{
    return(__DN(rtlp_read_8)(_dev, 0x1f));
}

static inline void rtl8029as_reset_rawwr(__DN(t) *_dev, uint8_t _regval) __attribute__ ((always_inline));
static inline void rtl8029as_reset_rawwr(__DN(t) *_dev, uint8_t _regval)
{
    __DN(rtlp_write_8)(_dev, 0x1f, _regval);
}

// Register reset is not writeable
static inline int rtl8029as_reset_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_reset_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = __DN(rtlp_read_8)(_dev, 0x1f);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register reset (Reset): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int rtl8029as_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int rtl8029as_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device rtl8029as (RTL8029AS Ethernet Controller):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_cr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_isr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_imr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_dcr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_tcr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_tsr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_rcr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_rsr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_clda_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_pstart_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_pstop_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_bnry_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_tpsr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_tbcr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_ncr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_fifo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_crda_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_rsar_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_rbcr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_cntr0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_cntr1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_cntr2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_par_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_curr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_mar_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_chipid_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_cr9346_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_config0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_config2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_config3_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_hltclk_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_asid_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_rdma32_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_rdma16_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_rdma8_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = rtl8029as_reset_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device rtl8029as\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __rtl8029as_DEV_H
